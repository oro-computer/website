{
  "generatedAt": "2026-02-18T18:36:05+00:00",
  "kind": "docs",
  "count": 33,
  "items": [
    {
      "id": "start",
      "title": "Oro Runtime Docs",
      "section": "overview",
      "summary": "Oro Runtime is a cross-platform runtime for building native applications as web applications: HTML/CSS for UI, JavaScript for behavior, and a small native core for OS integration.",
      "text": "Oro Runtime Docs Oro Runtime is a cross-platform runtime for building native applications as web applications: HTML/CSS for UI, JavaScript for behavior, and a small native core for OS integration. Your app runs inside the platform WebView. When you need native capabilities, you import them explicitly as ES modules under the oro: namespace. This documentation is organized into: Guides \u2014 the programming model, \u201chello world\u201d, and common workflows. CLI \u2014 oroc commands, flags, and environment variables. Configuration \u2014 oro.toml, .ororc, and copymap. JavaScript APIs \u2014 oro: modules like oro:application, oro:window, and oro:hooks. A minimal \u201chello world\u201d Project layout: hello/ oro.toml copy-map.toml web/ index.html main.js oro.toml: [meta] bundleidentifier = \"com.example.hello\" version = \"0.1.0\" [build] name = \"hello\" copymap = \"copy-map.toml\" copy-map.toml: \"./web/index.html\" = \"index.html\" \"./web/main.js\" = \"main.js\" web/index.html: <!doctype html> <html lang=\"en\"> <meta charset=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> <title>Hello \u00b7 Oro Runtime</title> <main> <h1>Hello</h1> <p id=\"status\">Starting\u2026</p> </main> <script type=\"module\" src=\"./main.js\"></script> </html> web/main.js: import application from 'oro:application' const status = document.getElementById('status') status.textContent = isOroRuntime: ${globalThis.isOroRuntime === true} application.getScreenSize().then(({ width, height }) => { status.textContent += \u00b7 screen: ${width}\u00d7${height} }) Run it: oroc run . Build an installable bundle/package: oroc build . Recommended reading path 1. Guides: Hello world 2. Guides: Project layout 3. Guides: Build and package 4. CLI: oroc \u2192 run \u2192 build \u2192 update 5. Config: Overview \u2192 copymap \u2192 reference 6. JavaScript APIs: Overview \u2192 module index \u2192 all module specifiers \u2192 application \u2192 window \u2192 hooks"
    },
    {
      "id": "guides/hello-world",
      "title": "Hello world",
      "section": "guides",
      "summary": "This guide builds a minimal Oro Runtime app: a web folder + an `oro.toml`, then runs it with `oroc`.",
      "text": "Hello world This guide builds a minimal Oro Runtime app: a web folder + an oro.toml, then runs it with oroc. 1) Create the files Create this layout: hello/ oro.toml copy-map.toml web/ index.html main.js 2) Add oro.toml oro.toml is the project configuration file. [meta] bundleidentifier = \"com.example.hello\" version = \"0.1.0\" [build] name = \"hello\" copymap = \"copy-map.toml\" 3) Add a copy-map Copy-maps define what files become part of your app bundle: \"./web/index.html\" = \"index.html\" \"./web/main.js\" = \"main.js\" See: copymap. 4) Add a page and a module web/index.html: <!doctype html> <html lang=\"en\"> <meta charset=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> <title>Hello \u00b7 Oro Runtime</title> <main> <h1>Hello</h1> <p id=\"status\">Starting\u2026</p> </main> <script type=\"module\" src=\"./main.js\"></script> </html> web/main.js: import application from 'oro:application' const status = document.getElementById('status') status.textContent = isOroRuntime: ${globalThis.isOroRuntime === true} application.getScreenSize().then(({ width, height }) => { status.textContent += \u00b7 screen: ${width}\u00d7${height} }) 5) Run it From the project directory: oroc run . 6) Build it oroc build . Optional: run a single HTML file For quick experiments, oroc can infer a minimal configuration when no oro.toml is present: oroc run web/index.html Next CLI: oroc run \u00b7 oroc build Config: Overview JavaScript APIs: Overview \u00b7 oro:application"
    },
    {
      "id": "guides/project-layout",
      "title": "Project layout",
      "section": "guides",
      "summary": "An Oro Runtime project is a directory with:",
      "text": "Project layout An Oro Runtime project is a directory with: an app configuration (oro.toml) a copy-map (copymap) that defines what gets bundled one or more web roots (HTML/CSS/JS that the WebView loads) optional backend code for platform work or long-running tasks A common layout: my-app/ oro.toml copy-map.toml web/ index.html main.js backend/ backend.js oro.toml at a glance You\u2019ll most commonly touch these sections: [meta] \u2014 identity and versioning (for example bundleidentifier, title, version) [build] \u2014 bundling inputs/outputs (name, copymap, output, script, env, headless) [webview] \u2014 routing and dev workflow (defaultindex, allowanyroute, watch) [window] \u2014 default window sizing and chrome [permissions] \u2014 runtime permission gates (for example notifications, clipboard, service workers) platform overrides: [mac], [linux], [win], [android], [ios] See: Config overview and Config reference. Copy-maps: bundle exactly what you ship Copy-maps are small TOML/INI files mapping inputs to outputs inside your bundle. They\u2019re designed to make builds reproducible (and to keep \u201cmystery files\u201d out of your app). See: copymap. Local overrides with .ororc Some values are machine-local or secret (signing identities, provisioning profiles, simulator device names, tokens). Put those in .ororc in the project root. It\u2019s an override file that oroc merges with oro.toml. See: Config overview. Next Guides: Hello world \u00b7 Windows and messaging CLI: oroc"
    },
    {
      "id": "guides/build-and-package",
      "title": "Build and package",
      "section": "guides",
      "summary": "This guide summarizes the workflows downstream app developers use most:",
      "text": "Build and package This guide summarizes the workflows downstream app developers use most: run an app locally during development bundle and package an app for distribution install onto a device/target prepare update artifacts and serve them 1) Install toolchain dependencies For host builds, oroc setup with no --platform installs dependencies for your host OS. To target a platform: oroc setup --platform=android oroc setup --platform=ios See: oroc setup. 2) Development loop From your project directory: oroc run . Common knobs: D/--debug or ORODEBUG=1 for debug mode V/--verbose or OROVERBOSE=1 for verbose logging log-file=... to mirror logs to a JSON file If you want file watching during development, use webview.watch / webview.watchreload in oro.toml. See: oroc run and Configuration reference. 3) Bundle inputs with copymap Copy-maps define exactly what files are included in your app bundle. \"./web/index.html\" = \"index.html\" \"./web/main.js\" = \"main.js\" See: copymap. 4) Add a web build step (optional, common) Many apps run a web build step (Vite, Rollup, etc.) and then map the generated output into the runtime bundle. Use build.script to run your web build before the copy phase: [build] script = \"./scripts/build-web.sh\" copymap = \"copy-map.toml\" 5) Production build + packaging For a production build: oroc build . --prod --package Packaging is platform-specific (for example Linux deb/rpm, macOS zip/pkg, Windows appx). See: oroc build Configuration reference 6) Install onto a device/target List devices: oroc list-devices --platform=ios oroc list-devices --platform=android Install: oroc install-app --platform=ios --device <identifier> oroc install-app --platform=android --device <identifier> See: oroc list-devices and oroc install-app. 7) Build update artifacts (optional) Update tooling can: scaffold and validate update manifests bundle app artifacts as tar files sign and verify manifests run an update server (HTTP/TCP/UDP) See: oroc update."
    },
    {
      "id": "guides/windows-and-messaging",
      "title": "Windows and messaging",
      "section": "guides",
      "summary": "Oro Runtime apps can create multiple windows. Windows are identified by a numeric index.",
      "text": "Windows and messaging Oro Runtime apps can create multiple windows. Windows are identified by a numeric index. Create a second window Create a new window using oro:application: import application from 'oro:application' await application.createWindow({ index: 1, path: 'peer.html', title: 'Peer window', }) The path must resolve inside your bundled resources, so make sure it\u2019s included in your copymap. Find existing windows import application from 'oro:application' const peer = await application.getWindow(1) const all = await application.getWindows() Send a message to another window ApplicationWindow.postMessage(...) is the simplest way to send a message to a specific window: import application from 'oro:application' const peer = await application.getWindow(1, { max: false }) await peer.postMessage({ type: 'ping', at: Date.now() }) Receive messages in any window: globalThis.addEventListener('message', (event) => { const payload = event.detail ?? event.data console.log('message:', payload) }) Send structured events (advanced) ApplicationWindow.send(...) lets you set an explicit event name: import application from 'oro:application' const current = await application.getCurrentWindow() await current.send({ window: 1, event: 'message', value: { hello: 'world' } }) Next JavaScript APIs: oro:application \u00b7 oro:window"
    },
    {
      "id": "cli/oroc",
      "title": "`oroc`",
      "section": "cli",
      "summary": "`oroc` is the Oro Runtime command line tool. It builds, runs, packages, and inspects Oro Runtime projects.",
      "text": "oroc oroc is the Oro Runtime command line tool. It builds, runs, packages, and inspects Oro Runtime projects. Usage oroc [SUBCOMMAND] [options] [<project-dir>] oroc [SUBCOMMAND] -h Subcommands build \u2014 Build run \u2014 Run init \u2014 Create a project setup \u2014 Install toolchain dependencies install-app \u2014 Install to a device/target list-devices \u2014 List connected devices print-build-dir \u2014 Print build output path config \u2014 Inspect config values env \u2014 Print relevant environment variables mcp \u2014 Run an MCP server version \u2014 Inspect or bump project version versions \u2014 Print CLI/runtime dependency versions update \u2014 Update tooling Global options h, --help print help prefix print install path v, --version print program version q, --quiet hint for less log output V, --verbose verbose output (can be global) D, --debug debug output (can be global) no-color disable colored log output json structured JSON logs on stdout log-file=<path> mirror logs to a JSON file Logging and debug environment ORODEBUG enable debug mode (like -D) OROVERBOSE enable verbose logs (like -V) OROLOGNOCOLOR disable colored log output OROLOGJSON enable structured JSON logs on stdout OROLOGFILE mirror logs to a JSON file OROALLOWEXEC allow external exec during builds OROENABLESANITIZERS enable ASan/UBSan on desktop builds Config discovery (project vs source) Most commands accept a project directory. build and run can also take a single HTML file or JavaScript module. When no oro.toml is found, oroc infers a minimal configuration automatically. See: Config overview."
    },
    {
      "id": "cli/run",
      "title": "`oroc run`",
      "section": "cli",
      "summary": "Run an Oro Runtime application.",
      "text": "oroc run Run an Oro Runtime application. You can provide a project directory, HTML file, or JavaScript module. When no oro.toml is found, oroc can infer a minimal configuration automatically. Usage oroc run [options] [<project-or-source>] Options headless run without a visible window platform=<platform> android android-emulator ios ios-simulator (default: host) config=<path> use an explicit oro.toml/oro.ini file host=<host> load index.html from host (default: 80 when port omitted) port=<port> load index.html from port (default: localhost when host omitted) prod production build (disables inspector/debugging) test[=path] test mode (optionally import a test file) D, --debug debug mode E, --env add environment variables V, --verbose verbose output allow-exec allow external command execution during builds tls-keylog=<path> write TLS key log lines (OpenSSL provider) log-file=<path> mirror logs to a JSON file Environment ORODEBUG enable debug mode (like -D) OROVERBOSE enable verbose logs (like -V) Common errors CI/Linux headless: install xvfb-run or set a custom headless runner in your config. Use --test=path to run tests bundled with your app."
    },
    {
      "id": "cli/build",
      "title": "`oroc build`",
      "section": "cli",
      "summary": "Build an Oro Runtime application.",
      "text": "oroc build Build an Oro Runtime application. You can provide a project directory, HTML file, or JavaScript module. When no oro.toml is found, oroc can infer a minimal configuration automatically. Usage oroc build [options] [<project-or-source>] Options platform=<platform> android android-emulator ios ios-simulator (default: host) config=<path> use an explicit oro.toml/oro.ini file copy=<source:dest> extra copy mapping (like [build] copy; can be repeated) host=<host> load index.html from host (default: 80 when port omitted) port=<port> load index.html from port (default: localhost when host omitted) test[=path] test mode (optionally import a test file) headless build to run without a visible window prod production build (disables inspector/debugging) D, --debug debug mode E, --env add environment variables o, --only-build only run the build step p, --package package the app for distribution r, --run run after building w, --watch watch for changes to rerun build allow-exec allow external command execution during builds sanitizers enable ASan/UBSan on desktop core builds tls-keylog=<path> write TLS key log lines (OpenSSL provider) log-file=<path> mirror logs to a JSON file Environment OROALLOWEXEC allow external exec during builds OROENABLESANITIZERS enable ASan/UBSan on desktop builds Common errors Android builds: run oroc setup --platform=android and accept SDK licenses. macOS/iOS signing: set ios.provisioningprofile (or platform-specific signing keys) in your config. \u201cexternal command execution is disabled\u201d: pass --allow-exec or set OROALLOWEXEC=1. Platform-specific options Linux f, --package-format=<format> deb rpm zip aur (default: deb) sign sign Linux packages with GPG (writes .asc next to the artifact) sign-key=<id> optional GPG key ID/fingerprint for --sign Dependencies: deb packaging requires dpkg and fakeroot (example: sudo apt-get install dpkg-dev fakeroot) rpm packaging requires rpmbuild (example: sudo dnf install rpm-build) macOS c, --codesign code sign the app with codesign n, --notarize notarize with notarytool f, --package-format=<format> zip (default) pkg Dependencies: Xcode and Command Line Tools are required (xcode-select --install) For Gradle/JDK, install via Homebrew (brew install gradle openjdk) or SDKMAN iOS c, --codesign code sign during xcodebuild (requires ios.provisioningprofile in config) Windows f, --package-format=<format> appx (default) Dependencies: Windows 10/11 SDK and Visual Studio Build Tools are recommended Ensure signtool.exe is available (set SIGNTOOL or add SDK bin to PATH) Next Run: oroc run Config: copymap \u00b7 reference"
    },
    {
      "id": "cli/setup",
      "title": "`oroc setup`",
      "section": "cli",
      "summary": "Setup build tools for the host or a target platform.",
      "text": "oroc setup Setup build tools for the host or a target platform. Usage oroc setup [options] [--platform=<platform>] [-y --yes] Options platform=<platform> android ios linux windows (default: host) q, --quiet hint for less log output y, --yes answer yes to prompts Notes Without --platform, setup defaults to the host. Verify with oroc env."
    },
    {
      "id": "cli/init",
      "title": "`oroc init`",
      "section": "cli",
      "summary": "Create a new project. If the path is not provided, the new project is created in the current directory.",
      "text": "oroc init Create a new project. If the path is not provided, the new project is created in the current directory. Usage oroc init [<project-dir>] Options C, --config only create the config file n, --name project name"
    },
    {
      "id": "cli/config",
      "title": "`oroc config`",
      "section": "cli",
      "summary": "Inspect configuration values.",
      "text": "oroc config Inspect configuration values. Usage oroc config [options] [<key-or-path>] Options config=<path> use an explicit oro.toml/oro.ini file list list known configuration keys with current and default values key=<name> print the current value for a specific key describe=<name> print help and metadata for a specific key f, --format=<format> print the full configuration as toml ini json strict treat unknown or unset keys as errors (non-zero exit) Notes Keys may be provided in flattened form (for example filesystemsandboxenabled) or TOML-style paths (for example filesystem.sandboxenabled). A bare argument after config is treated as a key query (for example oroc config filesystem.sandboxenabled). Unknown keys are printed when present in the active configuration but are marked as undocumented. See: Config overview and Config reference."
    },
    {
      "id": "cli/env",
      "title": "`oroc env`",
      "section": "cli",
      "summary": "Print environment variables relevant to the Oro CLI and build configuration.",
      "text": "oroc env Print environment variables relevant to the Oro CLI and build configuration. Usage oroc env Notes Prints a curated set of CLI, runtime, toolchain, and platform variables (for example ORODEBUG, JAVAHOME, ANDROIDHOME, SIGNTOOL). Merges [env] / env entries from the active configuration and local .ororc files when present. Filters out unset variables; each line prints as KEY=VALUE."
    },
    {
      "id": "cli/install-app",
      "title": "`oroc install-app`",
      "section": "cli",
      "summary": "Install the app to the device or host target.",
      "text": "oroc install-app Install the app to the device or host target. Usage oroc install-app [--platform=<platform>] [--device=<identifier>] [options] Options D, --debug debug output device[=identifier] device identifier (ECID/UDID/ID) platform=<platform> android ios (default: host) prod install production build V, --verbose verbose output macOS only: target=<target> install into '$target/Applications' (default: /) Common errors Android: list devices with adb devices or pass --device. iOS/macOS: list devices with oroc list-devices --platform=ios and pass --device."
    },
    {
      "id": "cli/list-devices",
      "title": "`oroc list-devices`",
      "section": "cli",
      "summary": "Get the list of connected devices.",
      "text": "oroc list-devices Get the list of connected devices. Usage oroc list-devices [options] --platform=<platform> Options platform=<platform> android ios ecid show device ECID (iOS only) udid show device UDID (iOS only) only print only the first device identifier (iOS only)"
    },
    {
      "id": "cli/mcp",
      "title": "`oroc mcp`",
      "section": "cli",
      "summary": "Run a Model Context Protocol (MCP) server for agent tooling.",
      "text": "oroc mcp Run a Model Context Protocol (MCP) server for agent tooling. By default this subcommand speaks JSON-RPC over stdio (stdout is reserved for MCP messages). Use --http to run an HTTP/SSE transport. Usage oroc mcp [options] [<workspace-dir>] Options stdio stdio transport (default) http HTTP/SSE transport host=<host> bind host (default: 127.0.0.1) port=<port> bind port (default: 0 for ephemeral) endpoint=<path> endpoint path (default: /mcp) token=<token> require bearer token (default varies) no-auth disable token auth (loopback only) workspace=<path> workspace root (default: CWD or <workspace-dir>) config=<path> oro.toml path relative to workspace (default: oro.toml) read-workspace-only restrict filesystem reads to workspace root allow-read-outside-workspace allow reading files outside workspace (default) replace-sse-stream allow a new SSE connection to replace an existing one Notes Stdio mode disables JSON logs and suppresses INFO output so stdout remains valid MCP JSON-RPC. HTTP mode implements MCP Streamable HTTP (2025-06-18). Clients must call initialize and then include Mcp-Session-Id on subsequent requests. See also: oro:mcp."
    },
    {
      "id": "cli/print-build-dir",
      "title": "`oroc print-build-dir`",
      "section": "cli",
      "summary": "Print the build directory path.",
      "text": "oroc print-build-dir Print the build directory path. Usage oroc print-build-dir [--platform=<platform>] [--prod] [--root] [<project-dir>] Options platform=<platform> android android-emulator ios ios-simulator (default: host) prod use production build directory root print only the root build directory"
    },
    {
      "id": "cli/update",
      "title": "`oroc update`",
      "section": "cli",
      "summary": "Update tooling for manifests, signatures, and bundles.",
      "text": "oroc update Update tooling for manifests, signatures, and bundles. Usage oroc update <subcommand> [options] Common workflow 1) Scaffold a manifest oroc update init 2) Generate a signing keypair oroc update keygen > key.json 3) Build an update bundle (tar) and record it in the manifest oroc update bundle --manifest manifest.json 4) Sign and verify the manifest oroc update sign --keys key.json --manifest manifest.json oroc update verify --keys key.json --manifest manifest.json Notes All subcommands support --log-file=<path> to mirror logs to a JSON file. Advanced: set OROUPDATEMANIFESTFILENAME or pass --manifest-name to override the default manifest.json filename. Subcommands init Scaffold a minimal update manifest JSON file. oroc update init [options] Options: config=<path> use an explicit oro.toml/oro.ini when deriving defaults manifest-name=<name> filename for the manifest JSON (default: manifest.json or OROUPDATEMANIFESTFILENAME) log-file=<path> mirror logs to a JSON file Notes: This command creates a basic manifest with: schemaVersion = 1 appId derived from your oro.toml (meta.bundleidentifier, falling back to \"com.example.app\") generatedAt = current UTC timestamp channels = [updatechannel or \"stable\"] updates = a single entry for the current version/channel (with an empty targets array) Edit the generated file to add real targets, artifact metadata, or additional updates. Examples: oroc update init create ./manifest.json using oro.toml metadata oroc update init --manifest-name app-updates.json create ./app-updates.json instead of manifest.json keygen Generate an Ed25519 keypair for signing update manifests. oroc update keygen [options] Options: out=<path> write keypair JSON to a file instead of stdout key-id=<id> optional key identifier (default: pk-1) log-file=<path> mirror logs to a JSON file Notes: The generated JSON includes keyId, publicKey, and privateKey fields (hex-encoded). Keep the private key secret; distribute only the public key with your application. Examples: oroc update keygen > key.json generate a default keypair and save it to key.json oroc update keygen --key-id pk-prod --out prod-key.json generate a named keypair for production use sign Sign an update manifest and emit a detached manifest.sig file. oroc update sign [--manifest=<path>] (--keys=<file> --private-key=<hex>) [options] Options: manifest=<path> path to the manifest JSON file to sign manifest-name=<name> manifest filename to use when --manifest is not provided keys=<file> JSON file containing a signing key (\"privateKey\" or \"secretKey\" field) private-key=<hex> Ed25519 private key as a hex string key-id=<id> optional key identifier to embed in manifest.sig (default: pk-1) out=<path> output path for manifest.sig (default: <manifest-without-extension>.sig) log-file=<path> mirror logs to a JSON file Notes: The signature file is JSON containing schemaVersion, algorithm, keyId, and signature fields. Clients verify manifest bytes against manifest.sig and the configured public key(s). Advanced: set OROUPDATEMANIFESTFILENAME or pass --manifest-name to change the default manifest filename. Examples: oroc update sign --keys key.json --manifest manifest.json sign manifest.json using the private key in key.json oroc update sign --private-key <hex-private-key> --manifest manifest.json --out manifest.sig sign a manifest using a raw hex private key verify Verify a manifest + signature pair using an Ed25519 public key. oroc update verify [--manifest=<path>] [--signature=<path>] (--keys=<file> --public-key=<hex>) [options] Options: manifest=<path> path to the manifest JSON file manifest-name=<name> manifest filename to use when --manifest is not provided signature=<path> path to the manifest.sig JSON file (default: <manifest>.sig) keys=<file> JSON file containing a public key (\"publicKey\" or \"key\" field) public-key=<hex> Ed25519 public key as a hex string log-file=<path> mirror logs to a JSON file Notes: Exits with status 0 when the signature is valid for the manifest and public key; non-zero otherwise. Advanced: set OROUPDATEMANIFESTFILENAME or pass --manifest-name to change the default manifest filename (the default signature path is derived as <manifest-without-extension>.sig, e.g. manifest.json -> manifest.sig). Examples: oroc update verify --keys key.json --manifest manifest.json verify manifest.json against manifest.sig using the public key in key.json oroc update verify --public-key <hex-public-key> --manifest manifest.json --signature manifest.sig verify using an explicit hex-encoded public key and signature file validate Validate an update manifest against the expected schema shape. oroc update validate [--manifest=<path>] [options] Options: manifest=<path> path to the manifest JSON file manifest-name=<name> manifest filename to use when --manifest is not provided strict enable additional consistency checks (channels vs updates, artifactUrl shape) json print a machine-readable JSON result object (for CI) log-file=<path> mirror logs to a JSON file Notes: This command parses the manifest and performs lightweight structural validation aligned with schemas/update-manifest.schema.json (required fields, types, and key relationships). It does not attempt full JSON Schema validation, but is suitable for fast local checks and CI. When --strict is provided, additional consistency rules are enforced. Examples: oroc update validate --manifest manifest.json run basic structural checks against manifest.json oroc update validate --manifest manifest.json --strict enable stricter consistency rules in addition to structural checks bundle Build a tar archive containing the contents of a directory for use as an update artifact. oroc update bundle [--input=<dir>] [--output=<bundle.tar>] [options] Options: input=<dir> directory whose contents will be archived (default: project directory) output=<bundle.tar> path to the tar archive to write (default: <buildname>-<version>.tar) manifest=<path> optional manifest path to update with a new target for this bundle manifest-name=<name> manifest filename to use when --manifest is not provided channel=<name> update channel to associate with this bundle (default: updatechannel or \"stable\") update-id=<id> update id to associate with this bundle (default: <channel>-<version>) platform=<id> platform identifier for the bundle target (default: source) arch=<id> architecture identifier for the bundle target (default: any) artifact-url=<url-or-path> artifactUrl to record in the manifest target (default: bundle filename) hash-algorithm=<sha256 sha1> hash algorithm to use (default: sha256 when libsodium is available, otherwise sha1) log-file=<path> mirror logs to a JSON file Notes: The archive is a plain tar file (no compression) built using the runtime\u2019s native tar implementation. Directory layout and basic metadata (mode bits, mtime) are preserved. When omitted: input defaults to the project directory (app source) output defaults to <buildname>-<version>.tar derived from your oro.toml metadata When --manifest or --manifest-name (or OROUPDATEMANIFESTFILENAME) is provided, the manifest is updated with a new target entry describing this bundle (including length and hash). Examples: oroc update bundle bundle the current project source into <buildname>-<version>.tar oroc update bundle --manifest manifest.json bundle the project and record the artifact in manifest.json oroc update bundle --input dist --output app-1.2.3.tar --manifest manifest.json --channel beta bundle a custom directory and attach it as a beta update in the manifest extract Extract an update tar archive produced by update bundle. oroc update extract --bundle=<bundle.tar> --dest=<dir> [options] Options: bundle=<bundle.tar> path to the tar archive to extract dest=<dir> destination directory (created if missing) log-file=<path> mirror logs to a JSON file Notes: The extractor rejects absolute paths and any paths containing .. or : to avoid directory traversal. Special tar entries (symlinks, devices, etc.) are ignored; regular files and directories are restored. Examples: oroc update extract --bundle app-1.0.0.tar --dest ./update-staging extract the contents of app-1.0.0.tar into ./update-staging server Run an update server over HTTP/TCP/UDP. oroc update server [options] Options: root=<dir> directory containing manifest trees and artifacts to serve host=<host> interface to bind (default: 0.0.0.0) port=<port> port to bind (default: 8080) manifest-name=<name> manifest filename to look up under each appId tcp run in TCP mode (binary OUP CHECK/RESPONSE) udp run in UDP mode (binary OUP CHECK/RESPONSE) log-file=<path> mirror logs to a JSON file Notes: Default mode is HTTP; the server exposes: GET /health \u2014 readiness metadata POST /check \u2014 accepts a CHECK JSON payload with appId and responds with a RESPONSE JSON whose manifestUrl points at /<appId>/<manifest-name> when present GET /<path> \u2014 serves files rooted under --root, including <appId>/<manifest-name> and <appId>/<manifest-name>.sig HTTP mode is designed to be run behind a load balancer or reverse proxy in production. TCP and UDP modes implement the same CHECK/RESPONSE selection semantics using the binary OUP framing. Examples: oroc update server --root ./updates serve manifests and bundles over HTTP on port 8080 oroc update server --root ./updates --tcp --port 9090 run a TCP OUP server on port 9090 oroc update server --root ./updates --udp --port 9090 run a UDP OUP server on port 9090 info Query update servers or static manifests over HTTP/TCP/UDP. oroc update info [--transport=<http tcp udp>] [options] Options: transport=<http tcp udp> transport to use (default: http) http shorthand for --transport=http tcp shorthand for --transport=tcp udp shorthand for --transport=udp follow-manifest when contacting servers, follow manifestUrl in the RESPONSE and fetch/validate the manifest over HTTP(S) timeout-ms=<ms> optional timeout for TCP/UDP CHECK requests (0 = no timeout) manifest-url=<url> HTTP(S) URL of a statically hosted manifest.json signature-url=<url> optional signature URL (default: derived from --manifest-url) keys=<file> JSON file containing a public key (\"publicKey\" or \"key\" field) public-key=<hex> Ed25519 public key as a hex string host=<host> host for HTTP/TCP/UDP update servers (default: 127.0.0.1) port=<port> port for HTTP/TCP/UDP update servers (default: 8080) app-id=<id> application identifier to send in CHECK messages (default: oro.toml meta.bundleidentifier) channel=<name> update channel hint (default: updatechannel or \"stable\") current-version=<version> current app version hint (default: meta.version) runtime-version=<version> runtime version hint advertised in CHECK (optional) platform=<id> platform hint advertised in CHECK (optional) arch=<id> architecture hint advertised in CHECK (optional) log-file=<path> mirror logs to a JSON file Notes: With --manifest-url, this command fetches and pretty-prints a manifest JSON and reports whether a signature file is reachable. When --keys or --public-key is provided and libsodium is available, it also verifies the manifest signature before printing. With HTTP/TCP/UDP transports and no --manifest-url, it sends a CHECK message to an update server and pretty-prints the RESPONSE JSON. With --follow-manifest, if the RESPONSE includes a manifestUrl, it will fetch, validate, and optionally verify that manifest as well. When --app-id is provided, the fetched manifest must have a matching appId or the command exits with an error. When using TCP/UDP, --timeout-ms can be used to bound how long the client waits for a response. http, --tcp, and --udp are shorthands for --transport=http, --transport=tcp, and --transport=udp. Examples: oroc update info --manifest-url https://cdn.example.com/app/manifest.json inspect a statically hosted manifest oroc update info --manifest-url https://cdn.example.com/app/manifest.json --keys app-pubkey.json fetch and verify a statically hosted manifest + signature oroc update info --http --host 127.0.0.1 --port 8080 --app-id com.example.app --follow-manifest query an HTTP update server and then fetch the referenced manifest oroc update info --tcp --host 127.0.0.1 --port 9000 --app-id com.example.app --follow-manifest query a TCP update server using the binary OUP protocol"
    },
    {
      "id": "cli/version",
      "title": "`oroc version`",
      "section": "cli",
      "summary": "Inspect or bump the project version defined in your configuration file.",
      "text": "oroc version Inspect or bump the project version defined in your configuration file. Usage oroc version [options] oroc version <new-version release> [options] Options config=<path> explicit oro.toml/oro.ini to update preid=<id> pre-release tag for pre bumps (default: rc) V, --verbose verbose output log-file=<path> mirror logs to a JSON file Examples oroc version oroc version minor oroc version prepatch --preid beta oroc version 1.2.3 Notes With no arguments, version prints the current semantic version from [meta]. With a <new-version> argument, it sets the version to that exact SemVer 2.0.0 value. With a release type, it bumps the version using SemVer rules (major/minor/patch, pre variants). The command updates only your app configuration file; it does not call git or create tags."
    },
    {
      "id": "cli/versions",
      "title": "`oroc versions`",
      "section": "cli",
      "summary": "Print Oro CLI/runtime and dependency versions.",
      "text": "oroc versions Print Oro CLI/runtime and dependency versions. Usage oroc versions [options] [<dependency>] Options f, --format=<format> text json (default: text) V, --verbose verbose output log-file=<path> mirror logs to a JSON file Examples oroc versions oroc versions -f json oroc versions sqlite"
    },
    {
      "id": "config/overview",
      "title": "Configuration overview",
      "section": "config",
      "summary": "Oro Runtime projects are configured with a file named `oro.toml` (TOML) in the project root.",
      "text": "Configuration overview Oro Runtime projects are configured with a file named oro.toml (TOML) in the project root. The CLI also supports oro.ini when oro.toml is absent. This is mainly for compatibility with older projects. How configuration is composed At build/run time, oroc computes an effective configuration from multiple sources: 1. Project config: oro.toml (preferred) or oro.ini 2. RC overrides: .ororc files (global \u2192 user \u2192 local) 3. CLI flags: oroc run/build/... options To see what you\u2019re actually running with, use: oroc config --format toml Local overrides: .ororc Some values are machine-local or secret (signing identities, provisioning profiles, simulator device names, tokens). Put those in .ororc so you don\u2019t have to commit them. oroc will read .ororc from several locations (system, user, and project). The project-local .ororc has the highest precedence. To override values from oro.toml, use a settings. section. For example: [settings.ios] simulatordevice = \"iPhone 15\" codesignidentity = \"iPhone Developer: Jane Doe (XXXXXXXXXX)\" provisioningprofile = \"jane.mobileprovision\" No ~ expansion ~ does not expand to your home directory in config files. Use an absolute path or $HOME. Next Reference: Config keys Bundling inputs: copymap CLI: oroc config"
    },
    {
      "id": "config/reference",
      "title": "Configuration reference",
      "section": "config",
      "summary": "This page documents the most commonly used `oro.toml` sections and keys.",
      "text": "Configuration reference This page documents the most commonly used oro.toml sections and keys. For the full set of keys the CLI knows how to list and describe, use: oroc config --list oroc config --describe build.copymap Common keys TOML key Default What it does - - - meta.bundleidentifier (required) Reverse-DNS identifier (used by platforms and for runtime origin). meta.title \u2014 Human-readable app title used in OS metadata and window chrome. meta.version 1.0.0 Semantic version string for the application bundle. meta.description \u2014 Short description used in metadata and packaging. meta.lang en-US Primary BCP-47 language tag. build.name (required) Short name used for bundle names and packaging. build.output build Output directory for build artifacts. build.copymap \u2014 Copy-map file that defines bundle inputs. build.script \u2014 Script to run before the copy phase (common for web build steps). build.headless false Start the application in headless mode (no visible window). build.allowexec false Allow external command execution during builds (Gradle, NDK, scripts). webview.defaultindex /index.html Default index path for navigation. webview.allowanyroute false SPA-style fallback: unmatched routes resolve to defaultindex. webview.watch false Watch files in development (emits change events). webview.watchreload true Reload the page when a file change event is emitted. window.width 80% Default window width (percentage or pixels). window.height 80% Default window height (percentage or pixels). window.resizable true Whether the main window is resizable (desktop). filesystem.sandboxenabled true Enable the filesystem sandbox (non-Apple platforms). filesystem.nofollowsymlinks true Disallow following symlinks for resource paths. Sections you\u2019ll commonly see [meta] \u2014 app identity and versioning [build] \u2014 bundling, packaging, toolchain options [webview] \u2014 navigation, routing, service worker mode, dev watch/reload [window] \u2014 default window sizing and appearance [permissions] \u2014 runtime permission gates [mcp] \u2014 defaults for oroc mcp (host/port/token) [ai] \u2014 defaults for embedded AI features (when enabled) Permissions The runtime\u2019s permission gates live under [permissions]. Common examples: permissions.allownotifications \u2014 system notifications permissions.allowgeolocation \u2014 location APIs permissions.allowclipboard \u2014 clipboard read/write permissions.allowserviceworker \u2014 service worker APIs (set to false to disable) Use oroc config --list to discover all available permission keys for your runtime build."
    },
    {
      "id": "config/copy-map",
      "title": "`copy_map`",
      "section": "config",
      "summary": "Copy-maps let you explicitly map build inputs into your app bundle. They are referenced from `oro.toml`:",
      "text": "copymap Copy-maps let you explicitly map build inputs into your app bundle. They are referenced from oro.toml: [build] copymap = \"copy-map.toml\" A copy-map file can be TOML or INI. It must contain only top-level key/value pairs: key: source path (relative to the copy-map file\u2019s directory, unless absolute) value: destination path inside the bundle (relative to the bundle resource root) Minimal example \"./web/index.html\" = \"index.html\" \"./web/main.js\" = \"main.js\" \"./web/styles.css\" = \"styles.css\" If the destination value is empty, the source is copied into the resource root (advanced; typically avoid this and spell out the destination). Conditional entries (platform + build mode) Copy-map keys may be prefixed to include entries only on certain platforms or modes: win..., mac..., ios..., linux..., android... debug... prod... / production... Example: \"./web/index.html\" = \"index.html\" \"debug./web/dev-tools.js\" = \"dev-tools.js\" \"prod./web/dev-tools.js\" = \"\" \"mac./icons/app.icns\" = \"icon.icns\" \"win./icons/app.ico\" = \"icon.ico\" Common pitfalls The build warns when a copy-map entry source path doesn\u2019t exist. Copy-map TOML must be a single table (no nested tables). Prefer paths relative to your project; avoid .. in build inputs."
    },
    {
      "id": "javascript/overview",
      "title": "JavaScript APIs overview",
      "section": "javascript",
      "summary": "Oro Runtime apps run inside the platform WebView. You use standard web APIs (DOM, ES modules, `fetch`, URLs, WebCrypto, WebAssembly) and import Oro-specific native capabilities as explicit ES modules under the `oro:*` namespace.",
      "text": "JavaScript APIs overview Oro Runtime apps run inside the platform WebView. You use standard web APIs (DOM, ES modules, fetch, URLs, WebCrypto, WebAssembly) and import Oro-specific native capabilities as explicit ES modules under the oro: namespace. Importing oro: modules Modules are standard ES modules: import application from 'oro:application' import { onReady } from 'oro:hooks' import as secureStorage from 'oro:secure-storage' See: Module index. If you need an exhaustive list of every oro: specifier (including subpaths), see: All module specifiers. Runtime detection Inside Oro Runtime, globalThis.isOroRuntime === true. Configuration in JavaScript oro:application exposes the effective application configuration as application.config. Config keys are flattened (for example metabundleidentifier, buildoutput) rather than nested tables. import application from 'oro:application' console.log(application.config.metabundleidentifier) console.log(application.runtimeVersion) If you\u2019re looking for the TOML keys and defaults, see: Configuration. Next Core modules: oro:application \u00b7 oro:window \u00b7 oro:hooks Integrations: oro:mcp \u00b7 oro:ai Security: oro:secure-storage \u00b7 oro:fs"
    },
    {
      "id": "javascript/module-index",
      "title": "Module index",
      "section": "javascript",
      "summary": "Oro Runtime exposes native capabilities as explicit ES modules under the `oro:*` namespace.",
      "text": "Module index Oro Runtime exposes native capabilities as explicit ES modules under the oro: namespace. Core modules (start here) oro:application \u2014 app/window management, menus, runtime metadata oro:window \u2014 ApplicationWindow instances and per-window operations oro:hooks \u2014 lifecycle and runtime event subscriptions oro:secure-storage \u2014 origin-scoped secret storage oro:notification \u2014 notifications and permissions oro:fs \u2014 filesystem APIs (Node/POSIX-style) oro:mcp \u2014 register tools/resources and start the embedded MCP bridge oro:ai \u2014 local AI helpers (LLM + chat) See also: All module specifiers. Top-level module specifiers Many modules also have subpath imports (for example oro:fs/promises, oro:url/index, oro:test/). Top-level oro: modules: oro:ai oro:application oro:asn1 oro:assert oro:async oro:asynchooks oro:background oro:bootstrap oro:buffer oro:cdp oro:childprocess oro:clipboard oro:commonjs oro:conduit oro:console oro:constants oro:cookies oro:crypto oro:dbus oro:dgram oro:diagnostics oro:did oro:dns oro:enumeration oro:errno oro:errors oro:events oro:extension oro:external oro:fetch oro:fs oro:gc oro:hci oro:hooks oro:http oro:https oro:i18n oro:internal oro:ip oro:ipc oro:ipfs oro:iroh oro:language oro:latica oro:location oro:mcp oro:mime oro:module oro:navigation oro:net oro:network oro:node oro:node-esm-loader oro:notification oro:npm oro:os oro:path oro:process oro:protocol-handlers oro:querystring oro:secure-storage oro:semver oro:service-worker oro:shared-worker oro:signal oro:sqlite oro:stream oro:stringdecoder oro:tar oro:tcp oro:test oro:timers oro:tls oro:toml oro:tty oro:url oro:util oro:vm oro:window oro:worker oro:workerthreads oro:xpc oro:zlib"
    },
    {
      "id": "javascript/all-modules",
      "title": "All module specifiers",
      "section": "javascript",
      "summary": "This page lists every ES module specifier that Oro Runtime publishes under the `oro:*` namespace.",
      "text": "All module specifiers This page lists every ES module specifier that Oro Runtime publishes under the oro: namespace. If you\u2019re new, start with the curated Module index and the core modules it links to. Notes Most apps should stick to the modules documented in this docs set (for example oro:application, oro:window, oro:hooks, oro:secure-storage). This list also includes compatibility modules and advanced/internal modules used by the runtime and tooling. The authoritative surface is the runtime\u2019s published TypeScript declarations; this list is derived from those declarations. All oro: module specifiers oro:ai oro:ai/ann oro:ai/chat oro:ai/llm oro:ai/whisper oro:application oro:application/client oro:application/menu oro:application/update oro:asn1 oro:assert oro:async oro:async/context oro:async/deferred oro:async/hooks oro:asynchooks oro:async/resource oro:async/storage oro:async/wrap oro:background oro:bootstrap oro:buffer oro:cdp oro:childprocess oro:childprocess/worker oro:clipboard oro:commonjs oro:commonjs/builtins oro:commonjs/cache oro:commonjs/loader oro:commonjs/module oro:commonjs/package oro:commonjs/require oro:conduit oro:console oro:constants oro:cookies oro:crypto oro:crypto/sodium oro:dbus oro:dgram oro:diagnostics oro:diagnostics/channels oro:diagnostics/index oro:diagnostics/metric oro:diagnostics/runtime oro:diagnostics/window oro:did oro:did/index oro:dns oro:dns/constants oro:dns/index oro:dns/promises oro:dns/utils oro:enumeration oro:errno oro:errors oro:events oro:extension oro:external/libsodium/index oro:fetch oro:fetch/fetch oro:fetch/index oro:fs oro:fs/bookmarks oro:fs/constants oro:fs/dir oro:fs/fds oro:fs/flags oro:fs/handle oro:fs/index oro:fs/promises oro:fs/stats oro:fs/stream oro:fs/watcher oro:fs/web oro:gc oro:hci oro:hooks oro:http oro:http/adapters oro:https oro:i18n oro:internal/async/hooks oro:internal/bluetooth-web oro:internal/callsite oro:internal/credentials oro:internal/database oro:internal/direct-sockets-policy oro:internal/error oro:internal/events oro:internal/geolocation oro:internal/globals oro:internal/hid-web oro:internal/init oro:internal/iterator oro:internal/permissions oro:internal/pickers oro:internal/post-message oro:internal/primitives oro:internal/promise oro:internal/runtime-schemes oro:internal/scheduler oro:internal/serialize oro:internal/service-worker oro:internal/shared-array-buffer oro:internal/streams oro:internal/streams/web oro:internal/symbols oro:internal/tcp-server-socket oro:internal/tcp-socket oro:internal/timers oro:internal/udp-socket oro:internal/usb-web oro:internal/webassembly oro:internal/web-share oro:internal/worker oro:ip oro:ipc oro:ipfs oro:iroh oro:language oro:latica oro:latica/api oro:latica/cache oro:latica/encryption oro:latica/index oro:latica/nat oro:latica/packets oro:latica/proxy oro:latica/worker oro:location oro:mcp oro:mcp/index oro:mime oro:mime/index oro:mime/params oro:mime/type oro:module oro:navigation oro:navigation/navigation oro:net oro:network oro:node-esm-loader oro:node/index oro:notification oro:npm/module oro:npm/service-worker oro:os oro:os/constants oro:path oro:path/index oro:path/mounts oro:path/path oro:path/posix oro:path/well-known oro:path/win32 oro:process oro:process/signal oro:protocol-handlers oro:querystring oro:secure-storage oro:semver oro:service-worker oro:service-worker/clients oro:service-worker/container oro:service-worker/context oro:service-worker/debug oro:service-worker/env oro:service-worker/events oro:service-worker/global oro:service-worker/init oro:service-worker/instance oro:service-worker/notification oro:service-worker/registration oro:service-worker/state oro:service-worker/storage oro:service-worker/worker oro:shared-worker oro:shared-worker/debug oro:shared-worker/global oro:shared-worker/index oro:shared-worker/init oro:shared-worker/state oro:shared-worker/worker oro:signal oro:sqlite oro:stream oro:stream/web oro:stringdecoder oro:tar oro:tcp oro:test oro:test/context oro:test/dom-helpers oro:test/fast-deep-equal oro:test/harness oro:test/index oro:timers oro:timers/index oro:timers/platform oro:timers/promises oro:timers/scheduler oro:timers/timer oro:tls oro:toml oro:tty oro:url oro:url/index oro:url/urlpattern/urlpattern oro:url/url/url oro:util oro:util/types oro:vm oro:vm/init oro:vm/world oro:window oro:window/constants oro:window/hotkey oro:worker oro:workerthreads oro:workerthreads/init oro:xpc oro:zlib"
    },
    {
      "id": "javascript/application",
      "title": "`oro:application`",
      "section": "javascript",
      "summary": "`oro:application` exposes application-level APIs: creating windows, querying windows, menus, and runtime metadata.",
      "text": "oro:application oro:application exposes application-level APIs: creating windows, querying windows, menus, and runtime metadata. Import import application from 'oro:application' import { createWindow } from 'oro:application' Window indices Windows are addressed by numeric indices. The main window is typically index 0. import application from 'oro:application' console.log(application.getCurrentWindowIndex()) Creating a window import application from 'oro:application' await application.createWindow({ index: 1, path: 'peer.html', title: 'Peer', }) Querying windows import application from 'oro:application' const current = await application.getCurrentWindow() const peer = await application.getWindow(1, { max: false }) const all = await application.getWindows() Screen size import application from 'oro:application' const { width, height } = await application.getScreenSize() Menus setSystemMenu(...) sets a native application menu using a simple DSL: import application from 'oro:application' await application.setSystemMenu({ index: 0, value: App: About: ; Quit: q + Meta; , }) Runtime metadata import application from 'oro:application' console.log(application.runtimeVersion) console.log(application.debug) console.log(application.config.metabundleidentifier) Backend process control import application from 'oro:application' await application.backend.open() // ... await application.backend.close()"
    },
    {
      "id": "javascript/window",
      "title": "`oro:window`",
      "section": "javascript",
      "summary": "`oro:window` provides the `ApplicationWindow` class and window-specific methods.",
      "text": "oro:window oro:window provides the ApplicationWindow class and window-specific methods. You typically do not import this module directly\u2014get window instances via oro:application: import application from 'oro:application' const current = await application.getCurrentWindow() Common operations const win = await application.getCurrentWindow() await win.setTitle('Hello') await win.setSize({ width: '80%', height: '80%' }) await win.navigate('index.html') Messaging Send a message to another window: const peer = await application.getWindow(1, { max: false }) await peer.postMessage({ type: 'ping' }) Receive messages: globalThis.addEventListener('message', (event) => { const payload = event.detail ?? event.data console.log(payload) }) File pickers ApplicationWindow exposes native file pickers: const win = await application.getCurrentWindow() const paths = await win.showOpenFilePicker({ multiple: true }) console.log(paths)"
    },
    {
      "id": "javascript/hooks",
      "title": "`oro:hooks`",
      "section": "javascript",
      "summary": "`oro:hooks` provides a consistent way to subscribe to runtime-delivered lifecycle and system events.",
      "text": "oro:hooks oro:hooks provides a consistent way to subscribe to runtime-delivered lifecycle and system events. Most hooks: register a callback return a disposer function you can call to unsubscribe Common hooks import { onInit, onLoad, onReady, onError, onMessage, onOnline, onOffline, onApplicationURL, onApplicationPause, onApplicationResume, } from 'oro:hooks' onInit(() => { // runtime initialized (once) }) onReady(() => { // Window + Document + Runtime are ready (once) }) onError((event) => { console.error('global error:', event) }) onMessage((event) => { console.log('message:', event.data) }) Deep links: onApplicationURL When the OS opens your app via a registered URL protocol, handle it with onApplicationURL. import { onApplicationURL } from 'oro:hooks' onApplicationURL((event) => { if (!event.isValid) return console.log('opened:', event.url.href) }) The URL parser uses your configured meta.applicationprotocol when normalizing scheme URLs. Waiting for a single hook event wait(...) returns a Promise that resolves when a hook event occurs: import { wait } from 'oro:hooks' await wait('runtimeready')"
    },
    {
      "id": "javascript/filesystem",
      "title": "`oro:fs`",
      "section": "javascript",
      "summary": "`oro:fs` provides filesystem APIs modeled on POSIX and Node.js.",
      "text": "oro:fs oro:fs provides filesystem APIs modeled on POSIX and Node.js. Import The sync/callback surface: import as fs from 'oro:fs' Promises: import as fs from 'oro:fs/promises' Basic example import as fs from 'oro:fs/promises' await fs.mkdir('./data', { recursive: true }) await fs.writeFile('./data/hello.txt', 'hello', 'utf8') const text = await fs.readFile('./data/hello.txt', 'utf8') console.log(text) Sandboxing The runtime can restrict filesystem access via configuration. Common keys: filesystem.sandboxenabled filesystem.nofollowsymlinks See: Config reference."
    },
    {
      "id": "javascript/secure-storage",
      "title": "`oro:secure-storage`",
      "section": "javascript",
      "summary": "`oro:secure-storage` stores secrets scoped by origin (for example tokens, credentials, API keys).",
      "text": "oro:secure-storage oro:secure-storage stores secrets scoped by origin (for example tokens, credentials, API keys). Import import as secureStorage from 'oro:secure-storage' Store and retrieve a token import as secureStorage from 'oro:secure-storage' await secureStorage.setItem('authToken', 'secret-token-value') const token = await secureStorage.getItem('authToken') Scopes By default, secure storage uses location.origin as the scope (when available). You can override the scope explicitly: await secureStorage.setItem('key', 'value', { scope: 'https://example.com' }) Encodings and binary values For strings, encoding may be utf8 (default), base64, or hex. For binary values, pass a Uint8Array, ArrayBuffer, or Buffer. When reading binary values, use encoding: 'buffer' to get a Uint8Array back. const bytes = new Uint8Array([1, 2, 3]) await secureStorage.setItem('blob', bytes) const restored = await secureStorage.getItem('blob', { encoding: 'buffer' })"
    },
    {
      "id": "javascript/notification",
      "title": "`oro:notification`",
      "section": "javascript",
      "summary": "`oro:notification` provides an API to display desktop and mobile notifications and request permission to use them.",
      "text": "oro:notification oro:notification provides an API to display desktop and mobile notifications and request permission to use them. Import import Notification, { showNotification } from 'oro:notification' Permissions const state = await Notification.requestPermission() console.log(state) // 'granted' 'default' 'denied' On macOS/iOS you can pass options like alert, sound, and badge. Show a notification await showNotification('Hello', { body: 'From Oro Runtime' }) Observe notification events The runtime also emits global notification events through oro:hooks: import { onNotificationPresented, onNotificationResponse } from 'oro:hooks' onNotificationPresented((event) => { console.log('presented:', event) }) onNotificationResponse((event) => { console.log('response:', event) })"
    },
    {
      "id": "javascript/mcp",
      "title": "`oro:mcp`",
      "section": "javascript",
      "summary": "`oro:mcp` provides runtime MCP helpers for registering tools/resources and controlling the embedded HTTP/SSE bridge.",
      "text": "oro:mcp oro:mcp provides runtime MCP helpers for registering tools/resources and controlling the embedded HTTP/SSE bridge. If you want the CLI-hosted server for a workspace, see: oroc mcp. Register a tool import as mcp from 'oro:mcp' await mcp.registerTool({ name: 'echo', description: 'Echo the input.', inputSchema: { type: 'object', properties: { text: { type: 'string' } }, required: ['text'], }, handler: ({ arguments: args }) => ({ text: args.text }), }) Register a resource import as mcp from 'oro:mcp' await mcp.registerResource({ uri: 'oro://runtime/version', name: 'Runtime version', handler: async () => ({ contents: [{ type: 'text', text: 'ok' }] }), }) Start the embedded server const status = await mcp.startServer({ host: '127.0.0.1', port: 0 }) console.log(status)"
    },
    {
      "id": "javascript/ai",
      "title": "`oro:ai`",
      "section": "javascript",
      "summary": "`oro:ai` exposes local AI helpers. It currently exports two modules:",
      "text": "oro:ai oro:ai exposes local AI helpers. It currently exports two modules: llm \u2014 model/context management chat \u2014 a chat/session helper that streams tokens as events Import import ai from 'oro:ai' Minimal chat session import ai from 'oro:ai' const chat = new ai.chat.Chat({ model: 'my-model-name', prompt: 'You are a helpful assistant.', }) await chat.load() chat.addEventListener('message', (event) => { // event is a MessageEvent with an additional finished flag console.log(event.data?.toString?.() ?? event.data) }) await chat.message({ prompt: 'Hello!' }) await chat.generate({ prompt: 'Tell me a joke.' })"
    }
  ]
}

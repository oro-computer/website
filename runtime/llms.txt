Oro Runtime · LLMS Pack
======================

This file concatenates the full Oro Runtime documentation hosted on this website,
so an LLM can answer questions using the same source of truth as readers.

Generated: 2026-02-18T18:36:08+00:00

How to link:
- Docs: /runtime/docs/?p=<id>

Table of contents
-----------------

Runtime Docs
- Start
  - start — Oro Runtime Docs — /runtime/docs/?p=start
- Guides
  - guides/hello-world — Hello world — /runtime/docs/?p=guides/hello-world
  - guides/project-layout — Project layout — /runtime/docs/?p=guides/project-layout
  - guides/build-and-package — Build and package — /runtime/docs/?p=guides/build-and-package
  - guides/windows-and-messaging — Windows and messaging — /runtime/docs/?p=guides/windows-and-messaging
- CLI
  - cli/oroc — `oroc` — /runtime/docs/?p=cli/oroc
  - cli/run — `oroc run` — /runtime/docs/?p=cli/run
  - cli/build — `oroc build` — /runtime/docs/?p=cli/build
  - cli/setup — `oroc setup` — /runtime/docs/?p=cli/setup
  - cli/init — `oroc init` — /runtime/docs/?p=cli/init
  - cli/config — `oroc config` — /runtime/docs/?p=cli/config
  - cli/env — `oroc env` — /runtime/docs/?p=cli/env
  - cli/install-app — `oroc install-app` — /runtime/docs/?p=cli/install-app
  - cli/list-devices — `oroc list-devices` — /runtime/docs/?p=cli/list-devices
  - cli/mcp — `oroc mcp` — /runtime/docs/?p=cli/mcp
  - cli/print-build-dir — `oroc print-build-dir` — /runtime/docs/?p=cli/print-build-dir
  - cli/update — `oroc update` — /runtime/docs/?p=cli/update
  - cli/version — `oroc version` — /runtime/docs/?p=cli/version
  - cli/versions — `oroc versions` — /runtime/docs/?p=cli/versions
- Configuration
  - config/overview — Configuration overview — /runtime/docs/?p=config/overview
  - config/reference — Configuration reference — /runtime/docs/?p=config/reference
  - config/copy-map — `copy_map` — /runtime/docs/?p=config/copy-map
- JavaScript APIs
  - javascript/overview — JavaScript APIs overview — /runtime/docs/?p=javascript/overview
  - javascript/module-index — Module index — /runtime/docs/?p=javascript/module-index
  - javascript/all-modules — All module specifiers — /runtime/docs/?p=javascript/all-modules
  - javascript/application — `oro:application` — /runtime/docs/?p=javascript/application
  - javascript/window — `oro:window` — /runtime/docs/?p=javascript/window
  - javascript/hooks — `oro:hooks` — /runtime/docs/?p=javascript/hooks
  - javascript/filesystem — `oro:fs` — /runtime/docs/?p=javascript/filesystem
  - javascript/secure-storage — `oro:secure-storage` — /runtime/docs/?p=javascript/secure-storage
  - javascript/notification — `oro:notification` — /runtime/docs/?p=javascript/notification
  - javascript/mcp — `oro:mcp` — /runtime/docs/?p=javascript/mcp
  - javascript/ai — `oro:ai` — /runtime/docs/?p=javascript/ai

==============================================================================
DOCS: Oro Runtime Docs (start)
URL: /runtime/docs/?p=start
==============================================================================

# Oro Runtime Docs

Oro Runtime is a cross-platform runtime for building native applications as web applications: HTML/CSS for UI, JavaScript
for behavior, and a small native core for OS integration.

Your app runs inside the platform WebView. When you need native capabilities, you import them explicitly as ES modules
under the `oro:*` namespace.

This documentation is organized into:

- **Guides** — the programming model, “hello world”, and common workflows.
- **CLI** — `oroc` commands, flags, and environment variables.
- **Configuration** — `oro.toml`, `.ororc`, and `copy_map`.
- **JavaScript APIs** — `oro:*` modules like `oro:application`, `oro:window`, and `oro:hooks`.

## A minimal “hello world”

Project layout:

```text
hello/
  oro.toml
  copy-map.toml
  web/
    index.html
    main.js
```

`oro.toml`:

```toml
[meta]
bundle_identifier = "com.example.hello"
version = "0.1.0"

[build]
name = "hello"
copy_map = "copy-map.toml"
```

`copy-map.toml`:

```toml
"./web/index.html" = "index.html"
"./web/main.js" = "main.js"
```

`web/index.html`:

```html
<!doctype html>
<html lang="en">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hello · Oro Runtime</title>

  <main>
    <h1>Hello</h1>
    <p id="status">Starting…</p>
  </main>

  <script type="module" src="./main.js"></script>
</html>
```

`web/main.js`:

```js
import application from 'oro:application'

const status = document.getElementById('status')
status.textContent = `isOroRuntime: ${globalThis.isOroRuntime === true}`

application.getScreenSize().then(({ width, height }) => {
  status.textContent += ` · screen: ${width}×${height}`
})
```

Run it:

```bash
oroc run .
```

Build an installable bundle/package:

```bash
oroc build .
```

## Recommended reading path

1. Guides: [Hello world](?p=guides/hello-world)
2. Guides: [Project layout](?p=guides/project-layout)
3. Guides: [Build and package](?p=guides/build-and-package)
4. CLI: [oroc](?p=cli/oroc) → [run](?p=cli/run) → [build](?p=cli/build) → [update](?p=cli/update)
5. Config: [Overview](?p=config/overview) → [copy_map](?p=config/copy-map) → [reference](?p=config/reference)
6. JavaScript APIs: [Overview](?p=javascript/overview) → [module index](?p=javascript/module-index) → [all module specifiers](?p=javascript/all-modules) → [application](?p=javascript/application) → [window](?p=javascript/window) → [hooks](?p=javascript/hooks)

==============================================================================
DOCS: Hello world (guides/hello-world)
URL: /runtime/docs/?p=guides/hello-world
==============================================================================

# Hello world

This guide builds a minimal Oro Runtime app: a web folder + an `oro.toml`, then runs it with `oroc`.

## 1) Create the files

Create this layout:

```text
hello/
  oro.toml
  copy-map.toml
  web/
    index.html
    main.js
```

## 2) Add `oro.toml`

`oro.toml` is the project configuration file.

```toml
[meta]
bundle_identifier = "com.example.hello"
version = "0.1.0"

[build]
name = "hello"
copy_map = "copy-map.toml"
```

## 3) Add a copy-map

Copy-maps define what files become part of your app bundle:

```toml
"./web/index.html" = "index.html"
"./web/main.js" = "main.js"
```

See: [copy_map](?p=config/copy-map).

## 4) Add a page and a module

`web/index.html`:

```html
<!doctype html>
<html lang="en">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hello · Oro Runtime</title>

  <main>
    <h1>Hello</h1>
    <p id="status">Starting…</p>
  </main>

  <script type="module" src="./main.js"></script>
</html>
```

`web/main.js`:

```js
import application from 'oro:application'

const status = document.getElementById('status')
status.textContent = `isOroRuntime: ${globalThis.isOroRuntime === true}`

application.getScreenSize().then(({ width, height }) => {
  status.textContent += ` · screen: ${width}×${height}`
})
```

## 5) Run it

From the project directory:

```bash
oroc run .
```

## 6) Build it

```bash
oroc build .
```

## Optional: run a single HTML file

For quick experiments, `oroc` can infer a minimal configuration when no `oro.toml` is present:

```bash
oroc run web/index.html
```

## Next

- CLI: [oroc run](?p=cli/run) · [oroc build](?p=cli/build)
- Config: [Overview](?p=config/overview)
- JavaScript APIs: [Overview](?p=javascript/overview) · [`oro:application`](?p=javascript/application)

==============================================================================
DOCS: Project layout (guides/project-layout)
URL: /runtime/docs/?p=guides/project-layout
==============================================================================

# Project layout

An Oro Runtime project is a directory with:

- an app configuration (`oro.toml`)
- a copy-map (`copy_map`) that defines what gets bundled
- one or more web roots (HTML/CSS/JS that the WebView loads)
- optional backend code for platform work or long-running tasks

A common layout:

```text
my-app/
  oro.toml
  copy-map.toml
  web/
    index.html
    main.js
  backend/
    backend.js
```

## `oro.toml` at a glance

You’ll most commonly touch these sections:

- `[meta]` — identity and versioning (for example `bundle_identifier`, `title`, `version`)
- `[build]` — bundling inputs/outputs (`name`, `copy_map`, `output`, `script`, `env`, `headless`)
- `[webview]` — routing and dev workflow (`default_index`, `allow_any_route`, `watch`)
- `[window]` — default window sizing and chrome
- `[permissions]` — runtime permission gates (for example notifications, clipboard, service workers)
- platform overrides: `[mac]`, `[linux]`, `[win]`, `[android]`, `[ios]`

See: [Config overview](?p=config/overview) and [Config reference](?p=config/reference).

## Copy-maps: bundle exactly what you ship

Copy-maps are small TOML/INI files mapping inputs to outputs inside your bundle. They’re designed to make builds
reproducible (and to keep “mystery files” out of your app).

See: [copy_map](?p=config/copy-map).

## Local overrides with `.ororc`

Some values are machine-local or secret (signing identities, provisioning profiles, simulator device names, tokens).
Put those in `.ororc` in the project root. It’s an override file that `oroc` merges with `oro.toml`.

See: [Config overview](?p=config/overview).

## Next

- Guides: [Hello world](?p=guides/hello-world) · [Windows and messaging](?p=guides/windows-and-messaging)
- CLI: [oroc](?p=cli/oroc)

==============================================================================
DOCS: Build and package (guides/build-and-package)
URL: /runtime/docs/?p=guides/build-and-package
==============================================================================

# Build and package

This guide summarizes the workflows downstream app developers use most:

- run an app locally during development
- bundle and package an app for distribution
- install onto a device/target
- prepare update artifacts and serve them

## 1) Install toolchain dependencies

For host builds, `oroc setup` with no `--platform` installs dependencies for your host OS. To target a platform:

```bash
oroc setup --platform=android
oroc setup --platform=ios
```

See: [`oroc setup`](?p=cli/setup).

## 2) Development loop

From your project directory:

```bash
oroc run .
```

Common knobs:

- `-D/--debug` or `ORO_DEBUG=1` for debug mode
- `-V/--verbose` or `ORO_VERBOSE=1` for verbose logging
- `--log-file=...` to mirror logs to a JSON file

If you want file watching during development, use `webview.watch` / `webview.watch_reload` in `oro.toml`.

See: [`oroc run`](?p=cli/run) and [Configuration reference](?p=config/reference).

## 3) Bundle inputs with `copy_map`

Copy-maps define exactly what files are included in your app bundle.

```toml
"./web/index.html" = "index.html"
"./web/main.js" = "main.js"
```

See: [`copy_map`](?p=config/copy-map).

## 4) Add a web build step (optional, common)

Many apps run a web build step (Vite, Rollup, etc.) and then map the generated output into the runtime bundle.

Use `build.script` to run your web build before the copy phase:

```toml
[build]
script = "./scripts/build-web.sh"
copy_map = "copy-map.toml"
```

## 5) Production build + packaging

For a production build:

```bash
oroc build . --prod --package
```

Packaging is platform-specific (for example Linux deb/rpm, macOS zip/pkg, Windows appx). See:

- [`oroc build`](?p=cli/build)
- [Configuration reference](?p=config/reference)

## 6) Install onto a device/target

List devices:

```bash
oroc list-devices --platform=ios
oroc list-devices --platform=android
```

Install:

```bash
oroc install-app --platform=ios --device <identifier>
oroc install-app --platform=android --device <identifier>
```

See: [`oroc list-devices`](?p=cli/list-devices) and [`oroc install-app`](?p=cli/install-app).

## 7) Build update artifacts (optional)

Update tooling can:

- scaffold and validate update manifests
- bundle app artifacts as tar files
- sign and verify manifests
- run an update server (HTTP/TCP/UDP)

See: [`oroc update`](?p=cli/update).

==============================================================================
DOCS: Windows and messaging (guides/windows-and-messaging)
URL: /runtime/docs/?p=guides/windows-and-messaging
==============================================================================

# Windows and messaging

Oro Runtime apps can create multiple windows. Windows are identified by a numeric index.

## Create a second window

Create a new window using `oro:application`:

```js
import application from 'oro:application'

await application.createWindow({
  index: 1,
  path: 'peer.html',
  title: 'Peer window',
})
```

The `path` must resolve inside your bundled resources, so make sure it’s included in your `copy_map`.

## Find existing windows

```js
import application from 'oro:application'

const peer = await application.getWindow(1)
const all = await application.getWindows()
```

## Send a message to another window

`ApplicationWindow.postMessage(...)` is the simplest way to send a message to a specific window:

```js
import application from 'oro:application'

const peer = await application.getWindow(1, { max: false })
await peer.postMessage({ type: 'ping', at: Date.now() })
```

Receive messages in any window:

```js
globalThis.addEventListener('message', (event) => {
  const payload = event.detail ?? event.data
  console.log('message:', payload)
})
```

## Send structured events (advanced)

`ApplicationWindow.send(...)` lets you set an explicit event name:

```js
import application from 'oro:application'

const current = await application.getCurrentWindow()
await current.send({ window: 1, event: 'message', value: { hello: 'world' } })
```

## Next

- JavaScript APIs: [`oro:application`](?p=javascript/application) · [`oro:window`](?p=javascript/window)

==============================================================================
DOCS: `oroc` (cli/oroc)
URL: /runtime/docs/?p=cli/oroc
==============================================================================

# `oroc`

`oroc` is the Oro Runtime command line tool. It builds, runs, packages, and inspects Oro Runtime projects.

## Usage

```bash
oroc [SUBCOMMAND] [options] [<project-dir>]
oroc [SUBCOMMAND] -h
```

## Subcommands

- `build` — [Build](?p=cli/build)
- `run` — [Run](?p=cli/run)
- `init` — [Create a project](?p=cli/init)
- `setup` — [Install toolchain dependencies](?p=cli/setup)
- `install-app` — [Install to a device/target](?p=cli/install-app)
- `list-devices` — [List connected devices](?p=cli/list-devices)
- `print-build-dir` — [Print build output path](?p=cli/print-build-dir)
- `config` — [Inspect config values](?p=cli/config)
- `env` — [Print relevant environment variables](?p=cli/env)
- `mcp` — [Run an MCP server](?p=cli/mcp)
- `version` — [Inspect or bump project version](?p=cli/version)
- `versions` — [Print CLI/runtime dependency versions](?p=cli/versions)
- `update` — [Update tooling](?p=cli/update)

## Global options

```text
-h, --help            print help
--prefix              print install path
-v, --version         print program version
-q, --quiet           hint for less log output
-V, --verbose         verbose output (can be global)
-D, --debug           debug output (can be global)
--no-color            disable colored log output
--json                structured JSON logs on stdout
--log-file=<path>     mirror logs to a JSON file
```

## Logging and debug environment

```text
ORO_DEBUG             enable debug mode (like -D)
ORO_VERBOSE           enable verbose logs (like -V)
ORO_LOG_NO_COLOR      disable colored log output
ORO_LOG_JSON          enable structured JSON logs on stdout
ORO_LOG_FILE          mirror logs to a JSON file
ORO_ALLOW_EXEC        allow external exec during builds
ORO_ENABLE_SANITIZERS enable ASan/UBSan on desktop builds
```

## Config discovery (project vs source)

Most commands accept a project directory. `build` and `run` can also take a single HTML file or JavaScript module.
When no `oro.toml` is found, `oroc` infers a minimal configuration automatically.

See: [Config overview](?p=config/overview).

==============================================================================
DOCS: `oroc run` (cli/run)
URL: /runtime/docs/?p=cli/run
==============================================================================

# `oroc run`

Run an Oro Runtime application.

You can provide a project directory, HTML file, or JavaScript module. When no `oro.toml` is found, `oroc` can infer a
minimal configuration automatically.

## Usage

```bash
oroc run [options] [<project-or-source>]
```

## Options

```text
--headless              run without a visible window
--platform=<platform>   android | android-emulator | ios | ios-simulator (default: host)
--config=<path>         use an explicit oro.toml/oro.ini file
--host=<host>           load index.html from host (default: 80 when port omitted)
--port=<port>           load index.html from port (default: localhost when host omitted)
--prod                  production build (disables inspector/debugging)
--test[=path]           test mode (optionally import a test file)
-D, --debug             debug mode
-E, --env               add environment variables
-V, --verbose           verbose output
--allow-exec            allow external command execution during builds
--tls-keylog=<path>     write TLS key log lines (OpenSSL provider)
--log-file=<path>       mirror logs to a JSON file
```

## Environment

```text
ORO_DEBUG               enable debug mode (like -D)
ORO_VERBOSE             enable verbose logs (like -V)
```

## Common errors

- CI/Linux headless: install `xvfb-run` or set a custom headless runner in your config.
- Use `--test=path` to run tests bundled with your app.

==============================================================================
DOCS: `oroc build` (cli/build)
URL: /runtime/docs/?p=cli/build
==============================================================================

# `oroc build`

Build an Oro Runtime application.

You can provide a project directory, HTML file, or JavaScript module. When no `oro.toml` is found, `oroc` can infer a
minimal configuration automatically.

## Usage

```bash
oroc build [options] [<project-or-source>]
```

## Options

```text
--platform=<platform>   android | android-emulator | ios | ios-simulator (default: host)
--config=<path>         use an explicit oro.toml/oro.ini file
--copy=<source:dest>    extra copy mapping (like [build] copy; can be repeated)
--host=<host>           load index.html from host (default: 80 when port omitted)
--port=<port>           load index.html from port (default: localhost when host omitted)
--test[=path]           test mode (optionally import a test file)
--headless              build to run without a visible window
--prod                  production build (disables inspector/debugging)
-D, --debug             debug mode
-E, --env               add environment variables
-o, --only-build        only run the build step
-p, --package           package the app for distribution
-r, --run               run after building
-w, --watch             watch for changes to rerun build
--allow-exec            allow external command execution during builds
--sanitizers            enable ASan/UBSan on desktop core builds
--tls-keylog=<path>     write TLS key log lines (OpenSSL provider)
--log-file=<path>       mirror logs to a JSON file
```

## Environment

```text
ORO_ALLOW_EXEC          allow external exec during builds
ORO_ENABLE_SANITIZERS   enable ASan/UBSan on desktop builds
```

## Common errors

- Android builds: run `oroc setup --platform=android` and accept SDK licenses.
- macOS/iOS signing: set `ios.provisioning_profile` (or platform-specific signing keys) in your config.
- “external command execution is disabled”: pass `--allow-exec` or set `ORO_ALLOW_EXEC=1`.

## Platform-specific options

### Linux

```text
-f, --package-format=<format>   deb | rpm | zip | aur (default: deb)
--sign                          sign Linux packages with GPG (writes .asc next to the artifact)
--sign-key=<id>                 optional GPG key ID/fingerprint for --sign
```

Dependencies:

- deb packaging requires `dpkg` and `fakeroot` (example: `sudo apt-get install dpkg-dev fakeroot`)
- rpm packaging requires `rpmbuild` (example: `sudo dnf install rpm-build`)

### macOS

```text
-c, --codesign                  code sign the app with codesign
-n, --notarize                  notarize with notarytool
-f, --package-format=<format>   zip (default) | pkg
```

Dependencies:

- Xcode and Command Line Tools are required (`xcode-select --install`)
- For Gradle/JDK, install via Homebrew (`brew install gradle openjdk`) or SDKMAN

### iOS

```text
-c, --codesign                  code sign during xcodebuild (requires ios.provisioning_profile in config)
```

### Windows

```text
-f, --package-format=<format>   appx (default)
```

Dependencies:

- Windows 10/11 SDK and Visual Studio Build Tools are recommended
- Ensure `signtool.exe` is available (set `SIGNTOOL` or add SDK bin to `PATH`)

## Next

- Run: [`oroc run`](?p=cli/run)
- Config: [copy_map](?p=config/copy-map) · [reference](?p=config/reference)

==============================================================================
DOCS: `oroc setup` (cli/setup)
URL: /runtime/docs/?p=cli/setup
==============================================================================

# `oroc setup`

Setup build tools for the host or a target platform.

## Usage

```bash
oroc setup [options] [--platform=<platform>] [-y|--yes]
```

## Options

```text
--platform=<platform>   android | ios | linux | windows (default: host)
-q, --quiet             hint for less log output
-y, --yes               answer yes to prompts
```

## Notes

Without `--platform`, setup defaults to the host. Verify with `oroc env`.

==============================================================================
DOCS: `oroc init` (cli/init)
URL: /runtime/docs/?p=cli/init
==============================================================================

# `oroc init`

Create a new project. If the path is not provided, the new project is created in the current directory.

## Usage

```bash
oroc init [<project-dir>]
```

## Options

```text
-C, --config    only create the config file
-n, --name      project name
```

==============================================================================
DOCS: `oroc config` (cli/config)
URL: /runtime/docs/?p=cli/config
==============================================================================

# `oroc config`

Inspect configuration values.

## Usage

```bash
oroc config [options] [<key-or-path>]
```

## Options

```text
--config=<path>         use an explicit oro.toml/oro.ini file
--list                  list known configuration keys with current and default values
--key=<name>            print the current value for a specific key
--describe=<name>       print help and metadata for a specific key
-f, --format=<format>   print the full configuration as toml | ini | json
--strict                treat unknown or unset keys as errors (non-zero exit)
```

## Notes

- Keys may be provided in flattened form (for example `filesystem_sandbox_enabled`) or TOML-style paths (for example `filesystem.sandbox_enabled`).
- A bare argument after `config` is treated as a key query (for example `oroc config filesystem.sandbox_enabled`).
- Unknown keys are printed when present in the active configuration but are marked as undocumented.

See: [Config overview](?p=config/overview) and [Config reference](?p=config/reference).

==============================================================================
DOCS: `oroc env` (cli/env)
URL: /runtime/docs/?p=cli/env
==============================================================================

# `oroc env`

Print environment variables relevant to the Oro CLI and build configuration.

## Usage

```bash
oroc env
```

## Notes

- Prints a curated set of CLI, runtime, toolchain, and platform variables (for example `ORO_DEBUG`, `JAVA_HOME`, `ANDROID_HOME`, `SIGNTOOL`).
- Merges `[env]` / `env_*` entries from the active configuration and local `.ororc` files when present.
- Filters out unset variables; each line prints as `KEY=VALUE`.

==============================================================================
DOCS: `oroc install-app` (cli/install-app)
URL: /runtime/docs/?p=cli/install-app
==============================================================================

# `oroc install-app`

Install the app to the device or host target.

## Usage

```bash
oroc install-app [--platform=<platform>] [--device=<identifier>] [options]
```

## Options

```text
-D, --debug             debug output
--device[=identifier]   device identifier (ECID/UDID/ID)
--platform=<platform>   android | ios (default: host)
--prod                  install production build
-V, --verbose           verbose output
```

macOS only:

```text
--target=<target>       install into '$target/Applications' (default: /)
```

## Common errors

- Android: list devices with `adb devices` or pass `--device`.
- iOS/macOS: list devices with `oroc list-devices --platform=ios` and pass `--device`.

==============================================================================
DOCS: `oroc list-devices` (cli/list-devices)
URL: /runtime/docs/?p=cli/list-devices
==============================================================================

# `oroc list-devices`

Get the list of connected devices.

## Usage

```bash
oroc list-devices [options] --platform=<platform>
```

## Options

```text
--platform=<platform>   android | ios
--ecid                  show device ECID (iOS only)
--udid                  show device UDID (iOS only)
--only                  print only the first device identifier (iOS only)
```

==============================================================================
DOCS: `oroc mcp` (cli/mcp)
URL: /runtime/docs/?p=cli/mcp
==============================================================================

# `oroc mcp`

Run a Model Context Protocol (MCP) server for agent tooling.

By default this subcommand speaks JSON-RPC over stdio (stdout is reserved for MCP messages). Use `--http` to run an
HTTP/SSE transport.

## Usage

```bash
oroc mcp [options] [<workspace-dir>]
```

## Options

```text
--stdio                        stdio transport (default)
--http                         HTTP/SSE transport
--host=<host>                  bind host (default: 127.0.0.1)
--port=<port>                  bind port (default: 0 for ephemeral)
--endpoint=<path>              endpoint path (default: /mcp)
--token=<token>                require bearer token (default varies)
--no-auth                      disable token auth (loopback only)
--workspace=<path>             workspace root (default: CWD or <workspace-dir>)
--config=<path>                oro.toml path relative to workspace (default: oro.toml)
--read-workspace-only          restrict filesystem reads to workspace root
--allow-read-outside-workspace allow reading files outside workspace (default)
--replace-sse-stream           allow a new SSE connection to replace an existing one
```

## Notes

- Stdio mode disables JSON logs and suppresses INFO output so stdout remains valid MCP JSON-RPC.
- HTTP mode implements MCP Streamable HTTP (2025-06-18). Clients must call `initialize` and then include `Mcp-Session-Id`
  on subsequent requests.

See also: [`oro:mcp`](?p=javascript/mcp).

==============================================================================
DOCS: `oroc print-build-dir` (cli/print-build-dir)
URL: /runtime/docs/?p=cli/print-build-dir
==============================================================================

# `oroc print-build-dir`

Print the build directory path.

## Usage

```bash
oroc print-build-dir [--platform=<platform>] [--prod] [--root] [<project-dir>]
```

## Options

```text
--platform=<platform>   android | android-emulator | ios | ios-simulator (default: host)
--prod                  use production build directory
--root                  print only the root build directory
```

==============================================================================
DOCS: `oroc update` (cli/update)
URL: /runtime/docs/?p=cli/update
==============================================================================

# `oroc update`

Update tooling for manifests, signatures, and bundles.

## Usage

```bash
oroc update <subcommand> [options]
```

## Common workflow

```bash
# 1) Scaffold a manifest
oroc update init

# 2) Generate a signing keypair
oroc update keygen > key.json

# 3) Build an update bundle (tar) and record it in the manifest
oroc update bundle --manifest manifest.json

# 4) Sign and verify the manifest
oroc update sign --keys key.json --manifest manifest.json
oroc update verify --keys key.json --manifest manifest.json
```

## Notes

- All subcommands support `--log-file=<path>` to mirror logs to a JSON file.
- Advanced: set `ORO_UPDATE_MANIFEST_FILENAME` or pass `--manifest-name` to override the default `manifest.json` filename.

## Subcommands

### `init`

Scaffold a minimal update manifest JSON file.

```bash
oroc update init [options]
```

Options:

```text
--config=<path>         use an explicit oro.toml/oro.ini when deriving defaults
--manifest-name=<name>  filename for the manifest JSON (default: manifest.json or ORO_UPDATE_MANIFEST_FILENAME)
--log-file=<path>       mirror logs to a JSON file
```

Notes:

This command creates a basic manifest with:

- `schemaVersion = 1`
- `appId` derived from your `oro.toml` (`meta.bundle_identifier`, falling back to `"com.example.app"`)
- `generatedAt =` current UTC timestamp
- `channels = [update_channel or "stable"]`
- `updates =` a single entry for the current version/channel (with an empty `targets` array)

Edit the generated file to add real targets, artifact metadata, or additional updates.

Examples:

```bash
oroc update init
# create ./manifest.json using oro.toml metadata

oroc update init --manifest-name app-updates.json
# create ./app-updates.json instead of manifest.json
```

### `keygen`

Generate an Ed25519 keypair for signing update manifests.

```bash
oroc update keygen [options]
```

Options:

```text
--out=<path>       write keypair JSON to a file instead of stdout
--key-id=<id>      optional key identifier (default: pk-1)
--log-file=<path>  mirror logs to a JSON file
```

Notes:

The generated JSON includes `keyId`, `publicKey`, and `privateKey` fields (hex-encoded).
Keep the private key secret; distribute only the public key with your application.

Examples:

```bash
oroc update keygen > key.json
# generate a default keypair and save it to key.json

oroc update keygen --key-id pk-prod --out prod-key.json
# generate a named keypair for production use
```

### `sign`

Sign an update manifest and emit a detached `manifest.sig` file.

```bash
oroc update sign [--manifest=<path>] (--keys=<file> | --private-key=<hex>) [options]
```

Options:

```text
--manifest=<path>       path to the manifest JSON file to sign
--manifest-name=<name>  manifest filename to use when --manifest is not provided
--keys=<file>           JSON file containing a signing key ("privateKey" or "secretKey" field)
--private-key=<hex>     Ed25519 private key as a hex string
--key-id=<id>           optional key identifier to embed in manifest.sig (default: pk-1)
--out=<path>            output path for manifest.sig (default: <manifest-without-extension>.sig)
--log-file=<path>       mirror logs to a JSON file
```

Notes:

The signature file is JSON containing `schemaVersion`, `algorithm`, `keyId`, and `signature` fields.
Clients verify manifest bytes against `manifest.sig` and the configured public key(s).

Advanced: set `ORO_UPDATE_MANIFEST_FILENAME` or pass `--manifest-name` to change the default manifest filename.

Examples:

```bash
oroc update sign --keys key.json --manifest manifest.json
# sign manifest.json using the private key in key.json

oroc update sign --private-key <hex-private-key> --manifest manifest.json --out manifest.sig
# sign a manifest using a raw hex private key
```

### `verify`

Verify a manifest + signature pair using an Ed25519 public key.

```bash
oroc update verify [--manifest=<path>] [--signature=<path>] (--keys=<file> | --public-key=<hex>) [options]
```

Options:

```text
--manifest=<path>       path to the manifest JSON file
--manifest-name=<name>  manifest filename to use when --manifest is not provided
--signature=<path>      path to the manifest.sig JSON file (default: <manifest>.sig)
--keys=<file>           JSON file containing a public key ("publicKey" or "key" field)
--public-key=<hex>      Ed25519 public key as a hex string
--log-file=<path>       mirror logs to a JSON file
```

Notes:

Exits with status `0` when the signature is valid for the manifest and public key; non-zero otherwise.

Advanced: set `ORO_UPDATE_MANIFEST_FILENAME` or pass `--manifest-name` to change the default manifest filename
(the default signature path is derived as `<manifest-without-extension>.sig`, e.g. `manifest.json -> manifest.sig`).

Examples:

```bash
oroc update verify --keys key.json --manifest manifest.json
# verify manifest.json against manifest.sig using the public key in key.json

oroc update verify --public-key <hex-public-key> --manifest manifest.json --signature manifest.sig
# verify using an explicit hex-encoded public key and signature file
```

### `validate`

Validate an update manifest against the expected schema shape.

```bash
oroc update validate [--manifest=<path>] [options]
```

Options:

```text
--manifest=<path>       path to the manifest JSON file
--manifest-name=<name>  manifest filename to use when --manifest is not provided
--strict                enable additional consistency checks (channels vs updates, artifactUrl shape)
--json                  print a machine-readable JSON result object (for CI)
--log-file=<path>       mirror logs to a JSON file
```

Notes:

This command parses the manifest and performs lightweight structural validation aligned with
`schemas/update-manifest.schema.json` (required fields, types, and key relationships).
It does not attempt full JSON Schema validation, but is suitable for fast local checks and CI.

When `--strict` is provided, additional consistency rules are enforced.

Examples:

```bash
oroc update validate --manifest manifest.json
# run basic structural checks against manifest.json

oroc update validate --manifest manifest.json --strict
# enable stricter consistency rules in addition to structural checks
```

### `bundle`

Build a tar archive containing the contents of a directory for use as an update artifact.

```bash
oroc update bundle [--input=<dir>] [--output=<bundle.tar>] [options]
```

Options:

```text
--input=<dir>                  directory whose contents will be archived (default: project directory)
--output=<bundle.tar>          path to the tar archive to write (default: <build_name>-<version>.tar)
--manifest=<path>              optional manifest path to update with a new target for this bundle
--manifest-name=<name>         manifest filename to use when --manifest is not provided
--channel=<name>               update channel to associate with this bundle (default: update_channel or "stable")
--update-id=<id>               update id to associate with this bundle (default: <channel>-<version>)
--platform=<id>                platform identifier for the bundle target (default: source)
--arch=<id>                    architecture identifier for the bundle target (default: any)
--artifact-url=<url-or-path>   artifactUrl to record in the manifest target (default: bundle filename)
--hash-algorithm=<sha256|sha1> hash algorithm to use (default: sha256 when libsodium is available, otherwise sha1)
--log-file=<path>              mirror logs to a JSON file
```

Notes:

The archive is a plain tar file (no compression) built using the runtime’s native tar implementation.
Directory layout and basic metadata (mode bits, mtime) are preserved.

When omitted:

- `--input` defaults to the project directory (app source)
- `--output` defaults to `<build_name>-<version>.tar` derived from your `oro.toml` metadata

When `--manifest` or `--manifest-name` (or `ORO_UPDATE_MANIFEST_FILENAME`) is provided, the manifest is updated
with a new target entry describing this bundle (including length and hash).

Examples:

```bash
oroc update bundle
# bundle the current project source into <build_name>-<version>.tar

oroc update bundle --manifest manifest.json
# bundle the project and record the artifact in manifest.json

oroc update bundle --input dist --output app-1.2.3.tar --manifest manifest.json --channel beta
# bundle a custom directory and attach it as a beta update in the manifest
```

### `extract`

Extract an update tar archive produced by `update bundle`.

```bash
oroc update extract --bundle=<bundle.tar> --dest=<dir> [options]
```

Options:

```text
--bundle=<bundle.tar>  path to the tar archive to extract
--dest=<dir>           destination directory (created if missing)
--log-file=<path>      mirror logs to a JSON file
```

Notes:

The extractor rejects absolute paths and any paths containing `..` or `:` to avoid directory traversal.
Special tar entries (symlinks, devices, etc.) are ignored; regular files and directories are restored.

Examples:

```bash
oroc update extract --bundle app-1.0.0.tar --dest ./update-staging
# extract the contents of app-1.0.0.tar into ./update-staging
```

### `server`

Run an update server over HTTP/TCP/UDP.

```bash
oroc update server [options]
```

Options:

```text
--root=<dir>           directory containing manifest trees and artifacts to serve
--host=<host>          interface to bind (default: 0.0.0.0)
--port=<port>          port to bind (default: 8080)
--manifest-name=<name> manifest filename to look up under each appId
--tcp                  run in TCP mode (binary OUP CHECK/RESPONSE)
--udp                  run in UDP mode (binary OUP CHECK/RESPONSE)
--log-file=<path>      mirror logs to a JSON file
```

Notes:

Default mode is HTTP; the server exposes:

- `GET /health` — readiness metadata
- `POST /check` — accepts a CHECK JSON payload with `appId` and responds with a RESPONSE JSON whose `manifestUrl`
  points at `/<appId>/<manifest-name>` when present
- `GET /<path>` — serves files rooted under `--root`, including `<appId>/<manifest-name>` and `<appId>/<manifest-name>.sig`

HTTP mode is designed to be run behind a load balancer or reverse proxy in production.
TCP and UDP modes implement the same CHECK/RESPONSE selection semantics using the binary OUP framing.

Examples:

```bash
oroc update server --root ./updates
# serve manifests and bundles over HTTP on port 8080

oroc update server --root ./updates --tcp --port 9090
# run a TCP OUP server on port 9090

oroc update server --root ./updates --udp --port 9090
# run a UDP OUP server on port 9090
```

### `info`

Query update servers or static manifests over HTTP/TCP/UDP.

```bash
oroc update info [--transport=<http|tcp|udp>] [options]
```

Options:

```text
--transport=<http|tcp|udp>  transport to use (default: http)
--http                      shorthand for --transport=http
--tcp                       shorthand for --transport=tcp
--udp                       shorthand for --transport=udp
--follow-manifest           when contacting servers, follow manifestUrl in the RESPONSE and fetch/validate the manifest over HTTP(S)
--timeout-ms=<ms>           optional timeout for TCP/UDP CHECK requests (0 = no timeout)
--manifest-url=<url>        HTTP(S) URL of a statically hosted manifest.json
--signature-url=<url>       optional signature URL (default: derived from --manifest-url)
--keys=<file>               JSON file containing a public key ("publicKey" or "key" field)
--public-key=<hex>          Ed25519 public key as a hex string
--host=<host>               host for HTTP/TCP/UDP update servers (default: 127.0.0.1)
--port=<port>               port for HTTP/TCP/UDP update servers (default: 8080)
--app-id=<id>               application identifier to send in CHECK messages (default: oro.toml meta.bundle_identifier)
--channel=<name>            update channel hint (default: update_channel or "stable")
--current-version=<version> current app version hint (default: meta.version)
--runtime-version=<version> runtime version hint advertised in CHECK (optional)
--platform=<id>             platform hint advertised in CHECK (optional)
--arch=<id>                 architecture hint advertised in CHECK (optional)
--log-file=<path>           mirror logs to a JSON file
```

Notes:

- With `--manifest-url`, this command fetches and pretty-prints a manifest JSON and reports whether a signature file is
  reachable. When `--keys` or `--public-key` is provided and libsodium is available, it also verifies the manifest
  signature before printing.
- With HTTP/TCP/UDP transports and no `--manifest-url`, it sends a CHECK message to an update server and pretty-prints the
  RESPONSE JSON. With `--follow-manifest`, if the RESPONSE includes a `manifestUrl`, it will fetch, validate, and
  optionally verify that manifest as well. When `--app-id` is provided, the fetched manifest must have a matching `appId`
  or the command exits with an error.
- When using TCP/UDP, `--timeout-ms` can be used to bound how long the client waits for a response.
- `--http`, `--tcp`, and `--udp` are shorthands for `--transport=http`, `--transport=tcp`, and `--transport=udp`.

Examples:

```bash
oroc update info --manifest-url https://cdn.example.com/app/manifest.json
# inspect a statically hosted manifest

oroc update info --manifest-url https://cdn.example.com/app/manifest.json --keys app-pubkey.json
# fetch and verify a statically hosted manifest + signature

oroc update info --http --host 127.0.0.1 --port 8080 --app-id com.example.app --follow-manifest
# query an HTTP update server and then fetch the referenced manifest

oroc update info --tcp --host 127.0.0.1 --port 9000 --app-id com.example.app --follow-manifest
# query a TCP update server using the binary OUP protocol
```

==============================================================================
DOCS: `oroc version` (cli/version)
URL: /runtime/docs/?p=cli/version
==============================================================================

# `oroc version`

Inspect or bump the project version defined in your configuration file.

## Usage

```bash
oroc version [options]
oroc version <new-version | release> [options]
```

## Options

```text
--config=<path>         explicit oro.toml/oro.ini to update
--preid=<id>            pre-release tag for pre* bumps (default: rc)
-V, --verbose           verbose output
--log-file=<path>       mirror logs to a JSON file
```

## Examples

```bash
oroc version
oroc version minor
oroc version prepatch --preid beta
oroc version 1.2.3
```

## Notes

- With no arguments, `version` prints the current semantic version from `[meta]`.
- With a `<new-version>` argument, it sets the version to that exact SemVer 2.0.0 value.
- With a release type, it bumps the version using SemVer rules (major/minor/patch, pre* variants).
- The command updates only your app configuration file; it does not call git or create tags.

==============================================================================
DOCS: `oroc versions` (cli/versions)
URL: /runtime/docs/?p=cli/versions
==============================================================================

# `oroc versions`

Print Oro CLI/runtime and dependency versions.

## Usage

```bash
oroc versions [options] [<dependency>]
```

## Options

```text
-f, --format=<format>   text | json (default: text)
-V, --verbose           verbose output
--log-file=<path>       mirror logs to a JSON file
```

## Examples

```bash
oroc versions
oroc versions -f json
oroc versions sqlite
```

==============================================================================
DOCS: Configuration overview (config/overview)
URL: /runtime/docs/?p=config/overview
==============================================================================

# Configuration overview

Oro Runtime projects are configured with a file named `oro.toml` (TOML) in the project root.

The CLI also supports `oro.ini` when `oro.toml` is absent. This is mainly for compatibility with older projects.

## How configuration is composed

At build/run time, `oroc` computes an effective configuration from multiple sources:

1. **Project config**: `oro.toml` (preferred) or `oro.ini`
2. **RC overrides**: `.ororc` files (global → user → local)
3. **CLI flags**: `oroc run/build/...` options

To see what you’re actually running with, use:

```bash
oroc config --format toml
```

## Local overrides: `.ororc`

Some values are machine-local or secret (signing identities, provisioning profiles, simulator device names, tokens).
Put those in `.ororc` so you don’t have to commit them.

`oroc` will read `.ororc` from several locations (system, user, and project). The project-local `.ororc` has the
highest precedence.

To override values from `oro.toml`, use a `settings.*` section. For example:

```ini
[settings.ios]
simulator_device = "iPhone 15"
codesign_identity = "iPhone Developer: Jane Doe (XXXXXXXXXX)"
provisioning_profile = "jane.mobileprovision"
```

## No `~` expansion

`~` does not expand to your home directory in config files. Use an absolute path or `$HOME`.

## Next

- Reference: [Config keys](?p=config/reference)
- Bundling inputs: [copy_map](?p=config/copy-map)
- CLI: [`oroc config`](?p=cli/config)

==============================================================================
DOCS: Configuration reference (config/reference)
URL: /runtime/docs/?p=config/reference
==============================================================================

# Configuration reference

This page documents the most commonly used `oro.toml` sections and keys.

For the full set of keys the CLI knows how to list and describe, use:

```bash
oroc config --list
oroc config --describe build.copy_map
```

## Common keys

| TOML key | Default | What it does |
| - | - | - |
| `meta.bundle_identifier` | (required) | Reverse-DNS identifier (used by platforms and for runtime origin). |
| `meta.title` | — | Human-readable app title used in OS metadata and window chrome. |
| `meta.version` | `1.0.0` | Semantic version string for the application bundle. |
| `meta.description` | — | Short description used in metadata and packaging. |
| `meta.lang` | `en-US` | Primary BCP-47 language tag. |
| `build.name` | (required) | Short name used for bundle names and packaging. |
| `build.output` | `build` | Output directory for build artifacts. |
| `build.copy_map` | — | Copy-map file that defines bundle inputs. |
| `build.script` | — | Script to run before the copy phase (common for web build steps). |
| `build.headless` | `false` | Start the application in headless mode (no visible window). |
| `build.allow_exec` | `false` | Allow external command execution during builds (Gradle, NDK, scripts). |
| `webview.default_index` | `/index.html` | Default index path for navigation. |
| `webview.allow_any_route` | `false` | SPA-style fallback: unmatched routes resolve to `default_index`. |
| `webview.watch` | `false` | Watch files in development (emits change events). |
| `webview.watch_reload` | `true` | Reload the page when a file change event is emitted. |
| `window.width` | `80%` | Default window width (percentage or pixels). |
| `window.height` | `80%` | Default window height (percentage or pixels). |
| `window.resizable` | `true` | Whether the main window is resizable (desktop). |
| `filesystem.sandbox_enabled` | `true` | Enable the filesystem sandbox (non-Apple platforms). |
| `filesystem.no_follow_symlinks` | `true` | Disallow following symlinks for resource paths. |

## Sections you’ll commonly see

- `[meta]` — app identity and versioning
- `[build]` — bundling, packaging, toolchain options
- `[webview]` — navigation, routing, service worker mode, dev watch/reload
- `[window]` — default window sizing and appearance
- `[permissions]` — runtime permission gates
- `[mcp]` — defaults for `oroc mcp` (host/port/token)
- `[ai]` — defaults for embedded AI features (when enabled)

## Permissions

The runtime’s permission gates live under `[permissions]`. Common examples:

- `permissions.allow_notifications` — system notifications
- `permissions.allow_geolocation` — location APIs
- `permissions.allow_clipboard` — clipboard read/write
- `permissions.allow_service_worker` — service worker APIs (set to `false` to disable)

Use `oroc config --list` to discover all available permission keys for your runtime build.

==============================================================================
DOCS: `copy_map` (config/copy-map)
URL: /runtime/docs/?p=config/copy-map
==============================================================================

# `copy_map`

Copy-maps let you explicitly map build inputs into your app bundle. They are referenced from `oro.toml`:

```toml
[build]
copy_map = "copy-map.toml"
```

A copy-map file can be TOML or INI. It must contain only top-level key/value pairs:

- **key**: source path (relative to the copy-map file’s directory, unless absolute)
- **value**: destination path inside the bundle (relative to the bundle resource root)

## Minimal example

```toml
"./web/index.html" = "index.html"
"./web/main.js" = "main.js"
"./web/styles.css" = "styles.css"
```

If the destination value is empty, the source is copied into the resource root (advanced; typically avoid this and spell
out the destination).

## Conditional entries (platform + build mode)

Copy-map keys may be prefixed to include entries only on certain platforms or modes:

- `win_...`, `mac_...`, `ios_...`, `linux_...`, `android_...`
- `debug_...`
- `prod_...` / `production_...`

Example:

```toml
"./web/index.html" = "index.html"

"debug_./web/dev-tools.js" = "dev-tools.js"
"prod_./web/dev-tools.js" = ""

"mac_./icons/app.icns" = "icon.icns"
"win_./icons/app.ico" = "icon.ico"
```

## Common pitfalls

- The build warns when a copy-map entry source path doesn’t exist.
- Copy-map TOML must be a single table (no nested tables).
- Prefer paths relative to your project; avoid `..` in build inputs.

==============================================================================
DOCS: JavaScript APIs overview (javascript/overview)
URL: /runtime/docs/?p=javascript/overview
==============================================================================

# JavaScript APIs overview

Oro Runtime apps run inside the platform WebView. You use standard web APIs (DOM, ES modules, `fetch`, URLs, WebCrypto,
WebAssembly) and import Oro-specific native capabilities as explicit ES modules under the `oro:*` namespace.

## Importing `oro:*` modules

Modules are standard ES modules:

```js
import application from 'oro:application'
import { onReady } from 'oro:hooks'
import * as secureStorage from 'oro:secure-storage'
```

See: [Module index](?p=javascript/module-index).

If you need an exhaustive list of every `oro:*` specifier (including subpaths), see: [All module specifiers](?p=javascript/all-modules).

## Runtime detection

Inside Oro Runtime, `globalThis.isOroRuntime === true`.

## Configuration in JavaScript

`oro:application` exposes the effective application configuration as `application.config`.

Config keys are flattened (for example `meta_bundle_identifier`, `build_output`) rather than nested tables.

```js
import application from 'oro:application'

console.log(application.config.meta_bundle_identifier)
console.log(application.runtimeVersion)
```

If you’re looking for the TOML keys and defaults, see: [Configuration](?p=config/overview).

## Next

- Core modules: [`oro:application`](?p=javascript/application) · [`oro:window`](?p=javascript/window) · [`oro:hooks`](?p=javascript/hooks)
- Integrations: [`oro:mcp`](?p=javascript/mcp) · [`oro:ai`](?p=javascript/ai)
- Security: [`oro:secure-storage`](?p=javascript/secure-storage) · [`oro:fs`](?p=javascript/filesystem)

==============================================================================
DOCS: Module index (javascript/module-index)
URL: /runtime/docs/?p=javascript/module-index
==============================================================================

# Module index

Oro Runtime exposes native capabilities as explicit ES modules under the `oro:*` namespace.

## Core modules (start here)

- [`oro:application`](?p=javascript/application) — app/window management, menus, runtime metadata
- [`oro:window`](?p=javascript/window) — `ApplicationWindow` instances and per-window operations
- [`oro:hooks`](?p=javascript/hooks) — lifecycle and runtime event subscriptions
- [`oro:secure-storage`](?p=javascript/secure-storage) — origin-scoped secret storage
- [`oro:notification`](?p=javascript/notification) — notifications and permissions
- [`oro:fs`](?p=javascript/filesystem) — filesystem APIs (Node/POSIX-style)
- [`oro:mcp`](?p=javascript/mcp) — register tools/resources and start the embedded MCP bridge
- [`oro:ai`](?p=javascript/ai) — local AI helpers (LLM + chat)

See also: [All module specifiers](?p=javascript/all-modules).

## Top-level module specifiers

Many modules also have subpath imports (for example `oro:fs/promises`, `oro:url/index`, `oro:test/*`).

Top-level `oro:*` modules:

```text
oro:ai
oro:application
oro:asn1
oro:assert
oro:async
oro:async_hooks
oro:background
oro:bootstrap
oro:buffer
oro:cdp
oro:child_process
oro:clipboard
oro:commonjs
oro:conduit
oro:console
oro:constants
oro:cookies
oro:crypto
oro:dbus
oro:dgram
oro:diagnostics
oro:did
oro:dns
oro:enumeration
oro:errno
oro:errors
oro:events
oro:extension
oro:external
oro:fetch
oro:fs
oro:gc
oro:hci
oro:hooks
oro:http
oro:https
oro:i18n
oro:internal
oro:ip
oro:ipc
oro:ipfs
oro:iroh
oro:language
oro:latica
oro:location
oro:mcp
oro:mime
oro:module
oro:navigation
oro:net
oro:network
oro:node
oro:node-esm-loader
oro:notification
oro:npm
oro:os
oro:path
oro:process
oro:protocol-handlers
oro:querystring
oro:secure-storage
oro:semver
oro:service-worker
oro:shared-worker
oro:signal
oro:sqlite
oro:stream
oro:string_decoder
oro:tar
oro:tcp
oro:test
oro:timers
oro:tls
oro:toml
oro:tty
oro:url
oro:util
oro:vm
oro:window
oro:worker
oro:worker_threads
oro:xpc
oro:zlib
```

==============================================================================
DOCS: All module specifiers (javascript/all-modules)
URL: /runtime/docs/?p=javascript/all-modules
==============================================================================

# All module specifiers

This page lists every ES module specifier that Oro Runtime publishes under the `oro:*` namespace.

If you’re new, start with the curated [Module index](?p=javascript/module-index) and the core modules it links to.

## Notes

- Most apps should stick to the modules documented in this docs set (for example `oro:application`, `oro:window`,
  `oro:hooks`, `oro:secure-storage`).
- This list also includes compatibility modules and advanced/internal modules used by the runtime and tooling.
- The authoritative surface is the runtime’s published TypeScript declarations; this list is derived from those
  declarations.

## All `oro:*` module specifiers

```text
oro:ai
oro:ai/ann
oro:ai/chat
oro:ai/llm
oro:ai/whisper
oro:application
oro:application/client
oro:application/menu
oro:application/update
oro:asn1
oro:assert
oro:async
oro:async/context
oro:async/deferred
oro:async/hooks
oro:async_hooks
oro:async/resource
oro:async/storage
oro:async/wrap
oro:background
oro:bootstrap
oro:buffer
oro:cdp
oro:child_process
oro:child_process/worker
oro:clipboard
oro:commonjs
oro:commonjs/builtins
oro:commonjs/cache
oro:commonjs/loader
oro:commonjs/module
oro:commonjs/package
oro:commonjs/require
oro:conduit
oro:console
oro:constants
oro:cookies
oro:crypto
oro:crypto/sodium
oro:dbus
oro:dgram
oro:diagnostics
oro:diagnostics/channels
oro:diagnostics/index
oro:diagnostics/metric
oro:diagnostics/runtime
oro:diagnostics/window
oro:did
oro:did/index
oro:dns
oro:dns/constants
oro:dns/index
oro:dns/promises
oro:dns/utils
oro:enumeration
oro:errno
oro:errors
oro:events
oro:extension
oro:external/libsodium/index
oro:fetch
oro:fetch/fetch
oro:fetch/index
oro:fs
oro:fs/bookmarks
oro:fs/constants
oro:fs/dir
oro:fs/fds
oro:fs/flags
oro:fs/handle
oro:fs/index
oro:fs/promises
oro:fs/stats
oro:fs/stream
oro:fs/watcher
oro:fs/web
oro:gc
oro:hci
oro:hooks
oro:http
oro:http/adapters
oro:https
oro:i18n
oro:internal/async/hooks
oro:internal/bluetooth-web
oro:internal/callsite
oro:internal/credentials
oro:internal/database
oro:internal/direct-sockets-policy
oro:internal/error
oro:internal/events
oro:internal/geolocation
oro:internal/globals
oro:internal/hid-web
oro:internal/init
oro:internal/iterator
oro:internal/permissions
oro:internal/pickers
oro:internal/post-message
oro:internal/primitives
oro:internal/promise
oro:internal/runtime-schemes
oro:internal/scheduler
oro:internal/serialize
oro:internal/service-worker
oro:internal/shared-array-buffer
oro:internal/streams
oro:internal/streams/web
oro:internal/symbols
oro:internal/tcp-server-socket
oro:internal/tcp-socket
oro:internal/timers
oro:internal/udp-socket
oro:internal/usb-web
oro:internal/webassembly
oro:internal/web-share
oro:internal/worker
oro:ip
oro:ipc
oro:ipfs
oro:iroh
oro:language
oro:latica
oro:latica/api
oro:latica/cache
oro:latica/encryption
oro:latica/index
oro:latica/nat
oro:latica/packets
oro:latica/proxy
oro:latica/worker
oro:location
oro:mcp
oro:mcp/index
oro:mime
oro:mime/index
oro:mime/params
oro:mime/type
oro:module
oro:navigation
oro:navigation/navigation
oro:net
oro:network
oro:node-esm-loader
oro:node/index
oro:notification
oro:npm/module
oro:npm/service-worker
oro:os
oro:os/constants
oro:path
oro:path/index
oro:path/mounts
oro:path/path
oro:path/posix
oro:path/well-known
oro:path/win32
oro:process
oro:process/signal
oro:protocol-handlers
oro:querystring
oro:secure-storage
oro:semver
oro:service-worker
oro:service-worker/clients
oro:service-worker/container
oro:service-worker/context
oro:service-worker/debug
oro:service-worker/env
oro:service-worker/events
oro:service-worker/global
oro:service-worker/init
oro:service-worker/instance
oro:service-worker/notification
oro:service-worker/registration
oro:service-worker/state
oro:service-worker/storage
oro:service-worker/worker
oro:shared-worker
oro:shared-worker/debug
oro:shared-worker/global
oro:shared-worker/index
oro:shared-worker/init
oro:shared-worker/state
oro:shared-worker/worker
oro:signal
oro:sqlite
oro:stream
oro:stream/web
oro:string_decoder
oro:tar
oro:tcp
oro:test
oro:test/context
oro:test/dom-helpers
oro:test/fast-deep-equal
oro:test/harness
oro:test/index
oro:timers
oro:timers/index
oro:timers/platform
oro:timers/promises
oro:timers/scheduler
oro:timers/timer
oro:tls
oro:toml
oro:tty
oro:url
oro:url/index
oro:url/urlpattern/urlpattern
oro:url/url/url
oro:util
oro:util/types
oro:vm
oro:vm/init
oro:vm/world
oro:window
oro:window/constants
oro:window/hotkey
oro:worker
oro:worker_threads
oro:worker_threads/init
oro:xpc
oro:zlib
```

==============================================================================
DOCS: `oro:application` (javascript/application)
URL: /runtime/docs/?p=javascript/application
==============================================================================

# `oro:application`

`oro:application` exposes application-level APIs: creating windows, querying windows, menus, and runtime metadata.

## Import

```js
import application from 'oro:application'
import { createWindow } from 'oro:application'
```

## Window indices

Windows are addressed by numeric indices. The main window is typically index `0`.

```js
import application from 'oro:application'

console.log(application.getCurrentWindowIndex())
```

## Creating a window

```js
import application from 'oro:application'

await application.createWindow({
  index: 1,
  path: 'peer.html',
  title: 'Peer',
})
```

## Querying windows

```js
import application from 'oro:application'

const current = await application.getCurrentWindow()
const peer = await application.getWindow(1, { max: false })
const all = await application.getWindows()
```

## Screen size

```js
import application from 'oro:application'

const { width, height } = await application.getScreenSize()
```

## Menus

`setSystemMenu(...)` sets a native application menu using a simple DSL:

```js
import application from 'oro:application'

await application.setSystemMenu({
  index: 0,
  value: `
    App:
      About: _;
      Quit: q + Meta;
  `,
})
```

## Runtime metadata

```js
import application from 'oro:application'

console.log(application.runtimeVersion)
console.log(application.debug)
console.log(application.config.meta_bundle_identifier)
```

## Backend process control

```js
import application from 'oro:application'

await application.backend.open()
// ...
await application.backend.close()
```

==============================================================================
DOCS: `oro:window` (javascript/window)
URL: /runtime/docs/?p=javascript/window
==============================================================================

# `oro:window`

`oro:window` provides the `ApplicationWindow` class and window-specific methods.

You typically do not import this module directly—get window instances via `oro:application`:

```js
import application from 'oro:application'

const current = await application.getCurrentWindow()
```

## Common operations

```js
const win = await application.getCurrentWindow()

await win.setTitle('Hello')
await win.setSize({ width: '80%', height: '80%' })
await win.navigate('index.html')
```

## Messaging

Send a message to another window:

```js
const peer = await application.getWindow(1, { max: false })
await peer.postMessage({ type: 'ping' })
```

Receive messages:

```js
globalThis.addEventListener('message', (event) => {
  const payload = event.detail ?? event.data
  console.log(payload)
})
```

## File pickers

`ApplicationWindow` exposes native file pickers:

```js
const win = await application.getCurrentWindow()

const paths = await win.showOpenFilePicker({ multiple: true })
console.log(paths)
```

==============================================================================
DOCS: `oro:hooks` (javascript/hooks)
URL: /runtime/docs/?p=javascript/hooks
==============================================================================

# `oro:hooks`

`oro:hooks` provides a consistent way to subscribe to runtime-delivered lifecycle and system events.

Most hooks:

- register a callback
- return a disposer function you can call to unsubscribe

## Common hooks

```js
import {
  onInit,
  onLoad,
  onReady,
  onError,
  onMessage,
  onOnline,
  onOffline,
  onApplicationURL,
  onApplicationPause,
  onApplicationResume,
} from 'oro:hooks'

onInit(() => {
  // runtime initialized (once)
})

onReady(() => {
  // Window + Document + Runtime are ready (once)
})

onError((event) => {
  console.error('global error:', event)
})

onMessage((event) => {
  console.log('message:', event.data)
})
```

## Deep links: `onApplicationURL`

When the OS opens your app via a registered URL protocol, handle it with `onApplicationURL`.

```js
import { onApplicationURL } from 'oro:hooks'

onApplicationURL((event) => {
  if (!event.isValid) return
  console.log('opened:', event.url.href)
})
```

The URL parser uses your configured `meta.application_protocol` when normalizing scheme URLs.

## Waiting for a single hook event

`wait(...)` returns a Promise that resolves when a hook event occurs:

```js
import { wait } from 'oro:hooks'

await wait('__runtime_ready__')
```

==============================================================================
DOCS: `oro:fs` (javascript/filesystem)
URL: /runtime/docs/?p=javascript/filesystem
==============================================================================

# `oro:fs`

`oro:fs` provides filesystem APIs modeled on POSIX and Node.js.

## Import

The sync/callback surface:

```js
import * as fs from 'oro:fs'
```

Promises:

```js
import * as fs from 'oro:fs/promises'
```

## Basic example

```js
import * as fs from 'oro:fs/promises'

await fs.mkdir('./data', { recursive: true })
await fs.writeFile('./data/hello.txt', 'hello', 'utf8')
const text = await fs.readFile('./data/hello.txt', 'utf8')
console.log(text)
```

## Sandboxing

The runtime can restrict filesystem access via configuration. Common keys:

- `filesystem.sandbox_enabled`
- `filesystem.no_follow_symlinks`

See: [Config reference](?p=config/reference).

==============================================================================
DOCS: `oro:secure-storage` (javascript/secure-storage)
URL: /runtime/docs/?p=javascript/secure-storage
==============================================================================

# `oro:secure-storage`

`oro:secure-storage` stores secrets scoped by origin (for example tokens, credentials, API keys).

## Import

```js
import * as secureStorage from 'oro:secure-storage'
```

## Store and retrieve a token

```js
import * as secureStorage from 'oro:secure-storage'

await secureStorage.setItem('authToken', 'secret-token-value')
const token = await secureStorage.getItem('authToken')
```

## Scopes

By default, secure storage uses `location.origin` as the scope (when available). You can override the scope explicitly:

```js
await secureStorage.setItem('key', 'value', { scope: 'https://example.com' })
```

## Encodings and binary values

For strings, `encoding` may be `utf8` (default), `base64`, or `hex`.

For binary values, pass a `Uint8Array`, `ArrayBuffer`, or `Buffer`. When reading binary values, use `encoding: 'buffer'`
to get a `Uint8Array` back.

```js
const bytes = new Uint8Array([1, 2, 3])
await secureStorage.setItem('blob', bytes)

const restored = await secureStorage.getItem('blob', { encoding: 'buffer' })
```

==============================================================================
DOCS: `oro:notification` (javascript/notification)
URL: /runtime/docs/?p=javascript/notification
==============================================================================

# `oro:notification`

`oro:notification` provides an API to display desktop and mobile notifications and request permission to use them.

## Import

```js
import Notification, { showNotification } from 'oro:notification'
```

## Permissions

```js
const state = await Notification.requestPermission()
console.log(state) // 'granted' | 'default' | 'denied'
```

On macOS/iOS you can pass options like `alert`, `sound`, and `badge`.

## Show a notification

```js
await showNotification('Hello', { body: 'From Oro Runtime' })
```

## Observe notification events

The runtime also emits global notification events through `oro:hooks`:

```js
import { onNotificationPresented, onNotificationResponse } from 'oro:hooks'

onNotificationPresented((event) => {
  console.log('presented:', event)
})

onNotificationResponse((event) => {
  console.log('response:', event)
})
```

==============================================================================
DOCS: `oro:mcp` (javascript/mcp)
URL: /runtime/docs/?p=javascript/mcp
==============================================================================

# `oro:mcp`

`oro:mcp` provides runtime MCP helpers for registering tools/resources and controlling the embedded HTTP/SSE bridge.

If you want the CLI-hosted server for a workspace, see: [`oroc mcp`](?p=cli/mcp).

## Register a tool

```js
import * as mcp from 'oro:mcp'

await mcp.registerTool({
  name: 'echo',
  description: 'Echo the input.',
  inputSchema: {
    type: 'object',
    properties: { text: { type: 'string' } },
    required: ['text'],
  },
  handler: ({ arguments: args }) => ({ text: args.text }),
})
```

## Register a resource

```js
import * as mcp from 'oro:mcp'

await mcp.registerResource({
  uri: 'oro://runtime/version',
  name: 'Runtime version',
  handler: async () => ({ contents: [{ type: 'text', text: 'ok' }] }),
})
```

## Start the embedded server

```js
const status = await mcp.startServer({ host: '127.0.0.1', port: 0 })
console.log(status)
```

==============================================================================
DOCS: `oro:ai` (javascript/ai)
URL: /runtime/docs/?p=javascript/ai
==============================================================================

# `oro:ai`

`oro:ai` exposes local AI helpers. It currently exports two modules:

- `llm` — model/context management
- `chat` — a chat/session helper that streams tokens as events

## Import

```js
import ai from 'oro:ai'
```

## Minimal chat session

```js
import ai from 'oro:ai'

const chat = new ai.chat.Chat({
  model: 'my-model-name',
  prompt: 'You are a helpful assistant.',
})

await chat.load()

chat.addEventListener('message', (event) => {
  // event is a MessageEvent with an additional `finished` flag
  console.log(event.data?.toString?.() ?? event.data)
})

await chat.message({ prompt: 'Hello!' })
await chat.generate({ prompt: 'Tell me a joke.' })
```

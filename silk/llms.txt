Silk · LLMS Pack
================

This file concatenates the full Silk documentation hosted on this website,
so an LLM can answer questions using the same source of truth as readers.

Generated: 2026-02-06T22:39:19+00:00

How to link:
- Docs: /silk/docs/?p=<id>
- Wiki: /silk/wiki/?p=<id>

Table of contents
-----------------

Silk Docs
- Start
  - start — Silk Documentation — /silk/docs/?p=start
- Guides
  - guides/purpose — What Silk is for — /silk/docs/?p=guides/purpose
  - guides/hello-world — Hello world — /silk/docs/?p=guides/hello-world
  - guides/language-tour — Language tour — /silk/docs/?p=guides/language-tour
  - guides/modules-and-packages — Modules & packages — /silk/docs/?p=guides/modules-and-packages
  - guides/standard-library — Standard library — /silk/docs/?p=guides/standard-library
  - guides/cli — CLI and toolchain — /silk/docs/?p=guides/cli
  - guides/testing — Testing — /silk/docs/?p=guides/testing
  - guides/formal-silk — Formal Silk — /silk/docs/?p=guides/formal-silk
- Language
  - language/flow-break — `break` — /silk/docs/?p=language/flow-break
  - language/flow-continue — `continue` — /silk/docs/?p=language/flow-continue
  - language/duration-instant — `Duration` & `Instant` — /silk/docs/?p=language/duration-instant
  - language/enums — `enum` Types — /silk/docs/?p=language/enums
  - language/flow-for — `for` Loop — /silk/docs/?p=language/flow-for
  - language/flow-if-else — `if` / `else` — /silk/docs/?p=language/flow-if-else
  - language/flow-loop — `loop` Loop — /silk/docs/?p=language/flow-loop
  - language/flow-match — `match` Expression — /silk/docs/?p=language/flow-match
  - language/flow-return — `return` — /silk/docs/?p=language/flow-return
  - language/using — `using` (Aliases and Method Reuse) — /silk/docs/?p=language/using
  - language/flow-while — `while` Loop — /silk/docs/?p=language/flow-while
  - language/literals-aggregate — Aggregate Literals — /silk/docs/?p=language/literals-aggregate
  - language/arenas — Arenas — /silk/docs/?p=language/arenas
  - language/flow-blocks-statements — Blocks and Statement Composition — /silk/docs/?p=language/flow-blocks-statements
  - language/literals-boolean — Boolean Literals — /silk/docs/?p=language/literals-boolean
  - language/borrow-checker — Borrow Checking (Static Alias and Lifetime Safety) — /silk/docs/?p=language/borrow-checker
  - language/buffers — Buffers — /silk/docs/?p=language/buffers
  - language/build-metadata — Build Metadata (`BUILD_KIND`, `BUILD_MODE`, `BUILD_VERSION`) — /silk/docs/?p=language/build-metadata
  - language/literals-character — Character Literals — /silk/docs/?p=language/literals-character
  - language/concurrency — Concurrency — /silk/docs/?p=language/concurrency
  - language/const-functions — Const Functions (`const fn`) — /silk/docs/?p=language/const-functions
  - language/dependent-types — Dependent Types (Const Parameters and Type-Level Computation) — /silk/docs/?p=language/dependent-types
  - language/literals-duration — Duration Literals — /silk/docs/?p=language/literals-duration
  - language/errors — Errors — /silk/docs/?p=language/errors
  - language/flow-expression-statements — Expression Statements — /silk/docs/?p=language/flow-expression-statements
  - language/ext — External Declarations (`ext`) — /silk/docs/?p=language/ext
  - language/flow-overview — Flow Control Overview — /silk/docs/?p=language/flow-overview
  - language/grammar — Formal Grammar Spec — /silk/docs/?p=language/grammar
  - language/formal-verification — Formal Silk — /silk/docs/?p=language/formal-verification
  - language/function-disciplines — Function Disciplines (`pure`, `task`, `async`) — /silk/docs/?p=language/function-disciplines
  - language/generics — Generics (Monomorphized) — /silk/docs/?p=language/generics
  - language/interfaces — Interfaces — /silk/docs/?p=language/interfaces
  - language/cheat-sheet — Language Cheat Sheet — /silk/docs/?p=language/cheat-sheet
  - language/conventions — Language Spec Conventions — /silk/docs/?p=language/conventions
  - language/literals-overview — Literals Overview — /silk/docs/?p=language/literals-overview
  - language/memory-model — Memory Model (Stack, Heap, and Moves) — /silk/docs/?p=language/memory-model
  - language/mutability — Mutability — /silk/docs/?p=language/mutability
  - language/literals-numeric — Numeric Literals — /silk/docs/?p=language/literals-numeric
  - language/operators — Operators — /silk/docs/?p=language/operators
  - language/optional — Optional — /silk/docs/?p=language/optional
  - language/packages-imports-exports — Packages, Imports, and Exports — /silk/docs/?p=language/packages-imports-exports
  - language/refinement-types — Refinement Types — /silk/docs/?p=language/refinement-types
  - language/regions — Regions — /silk/docs/?p=language/regions
  - language/literals-regexp — Regular Expression Literals — /silk/docs/?p=language/literals-regexp
  - language/syntax-tour — Silk Syntax Tour (Soup to Nuts) — /silk/docs/?p=language/syntax-tour
  - language/doc-comments — Silkdoc (Documentation Comments) — /silk/docs/?p=language/doc-comments
  - language/literals-string — String Literals — /silk/docs/?p=language/literals-string
  - language/structs-impls-layout — Structs, Impl Blocks, and Memory Layout — /silk/docs/?p=language/structs-impls-layout
  - language/testing — Testing — /silk/docs/?p=language/testing
  - language/type-unions — Type Unions (`T1 | T2 | ...`) — /silk/docs/?p=language/type-unions
  - language/typed-errors — Typed Errors (`error`, `panic`, and `T | ErrorType...`) — /silk/docs/?p=language/typed-errors
  - language/types — Types — /silk/docs/?p=language/types
  - language/varargs — Varargs (Variable Arguments) — /silk/docs/?p=language/varargs
- Standard library
  - std/conventions — `std::` Conventions — /silk/docs/?p=std/conventions
  - std/package-structure — `std::` Module Structure — /silk/docs/?p=std/package-structure
  - std/algorithms — `std::algorithms` — /silk/docs/?p=std/algorithms
  - std/args — `std::args` — /silk/docs/?p=std/args
  - std/arrays — `std::arrays` — /silk/docs/?p=std/arrays
  - std/bits — `std::bits` — /silk/docs/?p=std/bits
  - std/buffer — `std::buffer` — /silk/docs/?p=std/buffer
  - std/crypto — `std::crypto` — /silk/docs/?p=std/crypto
  - std/env — `std::env` — /silk/docs/?p=std/env
  - std/flag — `std::flag` — /silk/docs/?p=std/flag
  - std/fmt — `std::fmt` — /silk/docs/?p=std/fmt
  - std/formal — `std::formal` — /silk/docs/?p=std/formal
  - std/filesystem — `std::fs` — /silk/docs/?p=std/filesystem
  - std/ggml — `std::ggml` — /silk/docs/?p=std/ggml
  - std/http — `std::http` — /silk/docs/?p=std/http
  - std/https — `std::https` — /silk/docs/?p=std/https
  - std/interfaces — `std::interfaces` — /silk/docs/?p=std/interfaces
  - std/io — `std::io` — /silk/docs/?p=std/io
  - std/json — `std::json` — /silk/docs/?p=std/json
  - std/limits — `std::limits` — /silk/docs/?p=std/limits
  - std/map — `std::map` — Maps and Dictionaries — /silk/docs/?p=std/map
  - std/math — `std::math` — /silk/docs/?p=std/math
  - std/memory — `std::memory` — /silk/docs/?p=std/memory
  - std/networking — `std::net` — /silk/docs/?p=std/networking
  - std/number — `std::number` — /silk/docs/?p=std/number
  - std/path — `std::path` — /silk/docs/?p=std/path
  - std/process — `std::process` — /silk/docs/?p=std/process
  - std/readline — `std::readline` — /silk/docs/?p=std/readline
  - std/regex — `std::regex` — /silk/docs/?p=std/regex
  - std/result — `std::result` — /silk/docs/?p=std/result
  - std/runtime — `std::runtime` — /silk/docs/?p=std/runtime
  - std/semver — `std::semver` — /silk/docs/?p=std/semver
  - std/set — `std::set` — Sets — /silk/docs/?p=std/set
  - std/sqlite — `std::sqlite` — /silk/docs/?p=std/sqlite
  - std/ssh2 — `std::ssh2` — /silk/docs/?p=std/ssh2
  - std/stream — `std::stream` — /silk/docs/?p=std/stream
  - std/strings — `std::strings` — /silk/docs/?p=std/strings
  - std/sync — `std::sync` — /silk/docs/?p=std/sync
  - std/task — `std::task` — /silk/docs/?p=std/task
  - std/temporal — `std::temporal` — /silk/docs/?p=std/temporal
  - std/test — `std::test` — /silk/docs/?p=std/test
  - std/tls — `std::tls` — /silk/docs/?p=std/tls
  - std/toml — `std::toml` — /silk/docs/?p=std/toml
  - std/unicode — `std::unicode` — /silk/docs/?p=std/unicode
  - std/url — `std::url` — /silk/docs/?p=std/url
  - std/uuid — `std::uuid` — /silk/docs/?p=std/uuid
  - std/vector — `std::vector` — /silk/docs/?p=std/vector
  - std/websocket — `std::websocket` — /silk/docs/?p=std/websocket
  - std/js-ecma — ECMAScript FFI (`std::js::ecma`) — /silk/docs/?p=std/js-ecma
  - std/overview — Standard Library Overview (`std::`) — /silk/docs/?p=std/overview
  - std/idl-web — Web IDL (`std::idl::web`) — /silk/docs/?p=std/idl-web
  - std/wasm — WebAssembly Runtime (`std::wasm`) — /silk/docs/?p=std/wasm
- Usage
  - usage/cli-examples — CLI usage examples — /silk/docs/?p=usage/cli-examples
  - usage/editor-coc-nvim — coc.nvim Integration for Silk — /silk/docs/?p=usage/editor-coc-nvim
  - usage/getting-started — Getting Started (Repo Workflow) — /silk/docs/?p=usage/getting-started
  - usage/github-linguist — GitHub Linguist Support — /silk/docs/?p=usage/github-linguist
  - usage/howto-run-wasi-node — How-To: Run `wasm32-wasi` Output in Node.js — /silk/docs/?p=usage/howto-run-wasi-node
  - usage/howto-custom-stdlib-root — How-To: Use a Custom Stdlib Root (and Runtime) — /silk/docs/?p=usage/howto-custom-stdlib-root
  - usage/editor-textmate — TextMate Grammar (tmLanguage) — /silk/docs/?p=usage/editor-textmate
  - usage/tutorials/01-first-program — Tutorial 1: your first program — /silk/docs/?p=usage/tutorials/01-first-program
  - usage/tutorials/02-structs-and-impls — Tutorial 2: structs and `impl` — /silk/docs/?p=usage/tutorials/02-structs-and-impls
  - usage/tutorials/03-arrays-and-slices — Tutorial 3: Arrays and Slices — /silk/docs/?p=usage/tutorials/03-arrays-and-slices
  - usage/tutorials/04-filesystem — Tutorial 4: filesystem basics (`std::fs`) — /silk/docs/?p=usage/tutorials/04-filesystem
  - usage/tutorials/05-concurrency — Tutorial 5: concurrency basics (`async`, `task`, `yield`, `await`) — /silk/docs/?p=usage/tutorials/05-concurrency
  - usage/editor-ctags — Universal Ctags Support — /silk/docs/?p=usage/editor-ctags
  - usage/editor-vim — Vim Integration for Silk — /silk/docs/?p=usage/editor-vim
- Compiler
  - compiler/cli-silk — `silk` CLI — /silk/docs/?p=compiler/cli-silk
  - compiler/build-scripts — Build Scripts (`build.silk`) — /silk/docs/?p=compiler/build-scripts
  - compiler/abi-libsilk — C99 ABI and `libsilk.a` — /silk/docs/?p=compiler/abi-libsilk
  - compiler/architecture — Compiler Architecture — /silk/docs/?p=compiler/architecture
  - compiler/diagnostics — Compiler Diagnostics — /silk/docs/?p=compiler/diagnostics
  - compiler/limits — Compiler Limits — /silk/docs/?p=compiler/limits
  - compiler/ir-overview — Intermediate Representation (IR) – Overview — /silk/docs/?p=compiler/ir-overview
  - compiler/package-manifests — Package Manifests (`silk.toml`) — /silk/docs/?p=compiler/package-manifests
  - compiler/lsp-silk — Silk Language Server (LSP) — /silk/docs/?p=compiler/lsp-silk
  - compiler/stdlib-integration — Standard Library Integration — /silk/docs/?p=compiler/stdlib-integration
  - compiler/testing-strategy — Testing Strategy (Zig + C99 + Silk) — /silk/docs/?p=compiler/testing-strategy
  - compiler/vendored-deps — Vendored Dependencies — /silk/docs/?p=compiler/vendored-deps
  - compiler/backend-wasm — WebAssembly Back-End (`wasm32` / `wasm64`) — /silk/docs/?p=compiler/backend-wasm
  - compiler/zig-api — Zig Embedding API (Programmatic Compilation) — /silk/docs/?p=compiler/zig-api
- Man
  - man/libsilk.7 — `libsilk` (7) — C99 ABI for the Silk Compiler — /silk/docs/?p=man/libsilk.7
  - man/silk-build.1 — `silk-build` (1) — Build Silk Artifacts — /silk/docs/?p=man/silk-build.1
  - man/silk-cc.1 — `silk-cc` (1) — C Compiler Wrapper for `libsilk` — /silk/docs/?p=man/silk-cc.1
  - man/silk-check.1 — `silk-check` (1) — Parse and Type-Check — /silk/docs/?p=man/silk-check.1
  - man/silk-doc.1 — `silk-doc` (1) — Generate Documentation (Markdown or Manpages) — /silk/docs/?p=man/silk-doc.1
  - man/silk-lsp.1 — `silk-lsp` (1) — Language Server Protocol (LSP) Server — /silk/docs/?p=man/silk-lsp.1
  - man/silk-man.1 — `silk-man` (1) — View Manpages Derived from Source Docs — /silk/docs/?p=man/silk-man.1
  - man/silk-test.1 — `silk-test` (1) — Run Language-Level Tests — /silk/docs/?p=man/silk-test.1
  - man/silk_abi_get_version.3 — `silk_abi_get_version` (3) — Query the `libsilk` ABI Version — /silk/docs/?p=man/silk_abi_get_version.3
  - man/silk_bytes.3 — `silk_bytes` (3) — Manage Owned Build Output Buffers — /silk/docs/?p=man/silk_bytes.3
  - man/silk_compiler.3 — `silk_compiler` (3) — Embed the Silk Compiler — /silk/docs/?p=man/silk_compiler.3
  - man/silk_error.3 — `silk_error` (3) — Retrieve and Format Compiler Errors — /silk/docs/?p=man/silk_error.3
  - man/silk.1 — `silk` (1) — Silk Language Compiler — /silk/docs/?p=man/silk.1
  - man/silk.7 — `silk` (7) — Silk Toolchain Overview — /silk/docs/?p=man/silk.7
  - man/slc.1 — `slc` (1) — Alias of `silk build` — /silk/docs/?p=man/slc.1
  - man/slcc.1 — `slcc` (1) — Alias of `silk cc` — /silk/docs/?p=man/slcc.1
- Spec
  - spec/2026 — Silk Specification (2026) — /silk/spec/2026/

Silk Wiki
- Start
  - start — Silk Wiki — /silk/wiki/?p=start
- Language
  - language/flow-break — `break` — /silk/wiki/?p=language/flow-break
  - language/flow-continue — `continue` — /silk/wiki/?p=language/flow-continue
  - language/duration-instant — `Duration` and `Instant` — /silk/wiki/?p=language/duration-instant
  - language/flow-for — `for` loops — /silk/wiki/?p=language/flow-for
  - language/flow-if-else — `if` / `else` — /silk/wiki/?p=language/flow-if-else
  - language/flow-loop — `loop` — /silk/wiki/?p=language/flow-loop
  - language/flow-match — `match` — /silk/wiki/?p=language/flow-match
  - language/flow-return — `return` — /silk/wiki/?p=language/flow-return
  - language/flow-while — `while` — /silk/wiki/?p=language/flow-while
  - language/literals-aggregate — Aggregate literals (arrays and structs) — /silk/wiki/?p=language/literals-aggregate
  - language/arenas — Arenas — /silk/wiki/?p=language/arenas
  - language/flow-blocks-statements — Blocks and statements — /silk/wiki/?p=language/flow-blocks-statements
  - language/literals-boolean — Boolean literals — /silk/wiki/?p=language/literals-boolean
  - language/borrow-checker — Borrow checker (design) — /silk/wiki/?p=language/borrow-checker
  - language/buffers — Buffers (`Buffer(T)`) (design) — /silk/wiki/?p=language/buffers
  - language/literals-character — Character literals — /silk/wiki/?p=language/literals-character
  - language/cheat-sheet — Cheat sheet — /silk/wiki/?p=language/cheat-sheet
  - language/concurrency — Concurrency (`async`, `task`, `await`, `yield`) — /silk/wiki/?p=language/concurrency
  - language/const-functions — Const Functions (`const fn`) — /silk/wiki/?p=language/const-functions
  - language/conventions — Conventions — /silk/wiki/?p=language/conventions
  - language/dependent-types — Dependent types (const parameters) (design) — /silk/wiki/?p=language/dependent-types
  - language/doc-comments — Doc comments — /silk/wiki/?p=language/doc-comments
  - language/literals-duration — Duration literals — /silk/wiki/?p=language/literals-duration
  - language/enums — Enums — /silk/wiki/?p=language/enums
  - language/errors — Errors and assertions — /silk/wiki/?p=language/errors
  - language/flow-expression-statements — Expression statements — /silk/wiki/?p=language/flow-expression-statements
  - language/ext — External declarations (`ext`) — /silk/wiki/?p=language/ext
  - language/flow-overview — Flow control overview — /silk/wiki/?p=language/flow-overview
  - language/formal-verification — Formal verification (Formal Silk) — /silk/wiki/?p=language/formal-verification
  - language/function-disciplines — Function disciplines (`pure`, `async`, `task`) — /silk/wiki/?p=language/function-disciplines
  - language/generics — Generics (monomorphized) — /silk/wiki/?p=language/generics
  - language/grammar — Grammar — /silk/wiki/?p=language/grammar
  - language/interfaces — Interfaces — /silk/wiki/?p=language/interfaces
  - language/literals-overview — Literals — /silk/wiki/?p=language/literals-overview
  - language/memory-model — Memory model — /silk/wiki/?p=language/memory-model
  - language/mutability — Mutability (`mut`) — /silk/wiki/?p=language/mutability
  - language/literals-numeric — Numeric literals — /silk/wiki/?p=language/literals-numeric
  - language/operators — Operators — /silk/wiki/?p=language/operators
  - language/optional — Optionals (`T?`) — /silk/wiki/?p=language/optional
  - language/packages-imports-exports — Packages, imports, and exports — /silk/wiki/?p=language/packages-imports-exports
  - language/refinement-types — Refinement types (design) — /silk/wiki/?p=language/refinement-types
  - language/regions — Regions (`with`) — /silk/wiki/?p=language/regions
  - language/literals-string — String literals — /silk/wiki/?p=language/literals-string
  - language/structs-impls-layout — Structs and `impl` — /silk/wiki/?p=language/structs-impls-layout
  - language/syntax-tour — Syntax tour — /silk/wiki/?p=language/syntax-tour
  - language/testing — Testing (`test`) — /silk/wiki/?p=language/testing
  - language/typed-errors — Typed errors (`error`, `panic`, and `T | ErrorType...`) — /silk/wiki/?p=language/typed-errors
  - language/types — Types — /silk/wiki/?p=language/types
  - language/varargs — Varargs (`...args`) — /silk/wiki/?p=language/varargs
- Standard library
  - std/conventions — `std::` conventions — /silk/wiki/?p=std/conventions
  - std/package-structure — `std::` package structure — /silk/wiki/?p=std/package-structure
  - std/algorithms — `std::algorithms` — /silk/wiki/?p=std/algorithms
  - std/args — `std::args` — /silk/wiki/?p=std/args
  - std/arrays — `std::arrays` — /silk/wiki/?p=std/arrays
  - std/bits — `std::bits` — /silk/wiki/?p=std/bits
  - std/buffer — `std::buffer` — /silk/wiki/?p=std/buffer
  - std/crypto — `std::crypto` — /silk/wiki/?p=std/crypto
  - std/env — `std::env` — /silk/wiki/?p=std/env
  - std/fmt — `std::fmt` — /silk/wiki/?p=std/fmt
  - std/formal — `std::formal` — /silk/wiki/?p=std/formal
  - std/filesystem — `std::fs` — /silk/wiki/?p=std/filesystem
  - std/interfaces — `std::interfaces` — /silk/wiki/?p=std/interfaces
  - std/io — `std::io` — /silk/wiki/?p=std/io
  - std/json — `std::json` — /silk/wiki/?p=std/json
  - std/map — `std::map` — /silk/wiki/?p=std/map
  - std/memory — `std::memory` — /silk/wiki/?p=std/memory
  - std/networking — `std::net` — /silk/wiki/?p=std/networking
  - std/path — `std::path` — /silk/wiki/?p=std/path
  - std/process — `std::process` — /silk/wiki/?p=std/process
  - std/result — `std::result` — /silk/wiki/?p=std/result
  - std/runtime — `std::runtime` — /silk/wiki/?p=std/runtime
  - std/semver — `std::semver` — /silk/wiki/?p=std/semver
  - std/set — `std::set` — /silk/wiki/?p=std/set
  - std/strings — `std::strings` — /silk/wiki/?p=std/strings
  - std/sync — `std::sync` — /silk/wiki/?p=std/sync
  - std/task — `std::task` — /silk/wiki/?p=std/task
  - std/temporal — `std::temporal` — /silk/wiki/?p=std/temporal
  - std/tls — `std::tls` — /silk/wiki/?p=std/tls
  - std/toml — `std::toml` — /silk/wiki/?p=std/toml
  - std/url — `std::url` — /silk/wiki/?p=std/url
  - std/uuid — `std::uuid` — /silk/wiki/?p=std/uuid
  - std/vector — `std::vector` — /silk/wiki/?p=std/vector
  - std/overview — Standard library overview (`std::`) — /silk/wiki/?p=std/overview

Content
-------

==============================================================================
DOCS: Silk Documentation (start)
URL: /silk/docs/?p=start
==============================================================================

# Silk Documentation

Silk is a spec-first programming language and compiler toolchain. The goal is a language you can *read* as well as you can
compile: predictable semantics, explicit module boundaries, and a standard library designed for systems work.

This documentation site is written for downstream users. It is organized into:

- **Guides** — purpose, mental model, hello worlds, and practical workflows.
- **Reference** — the detailed language, standard library, CLI, and ABI surfaces.

## A minimal “hello world”

Silk programs are ordinary `.slk` files. A small program can look like this:

```silk
import std::io::println;

fn main () -> int {
  println("hello from silk");
  return 0;
}
```

From here, you can:

- explore the guided path in **Guides**
- jump straight to a topic in **Reference** (language, `std::`, tooling)
- use search to find concepts by name

## Recommended reading path

If you’re new to Silk, this is a good order:

1. **What Silk is for**: design goals, spec-first workflow, and the mental model.
2. **Hello world**: the smallest working program and the `check → test → build` loop.
3. **Language tour**: the shape of real programs (types, functions, control flow, errors).
4. **Modules & packages**: how code is organized and how imports/exports create clean dependency boundaries.
5. **Standard library**: what lives in `std::` and the common patterns it uses.
7. **Testing**: language-level tests and TAP output for CI and tooling.
8. **Formal Silk**: opt-in proofs with Z3; how to write verified code with zero runtime cost.

Start here:

- Guides: [What Silk is for](?p=guides/purpose)
- Guides: [Hello world](?p=guides/hello-world) · [Language tour](?p=guides/language-tour) · [Modules & packages](?p=guides/modules-and-packages)
- Guides: [Standard library](?p=guides/standard-library) · [CLI and toolchain](?p=guides/cli)
- Guides: [Testing](?p=guides/testing) · [Formal Silk](?p=guides/formal-silk)
- Spec: [Silk Spec (2026)](../spec/2026/)

==============================================================================
DOCS: What Silk is for (guides/purpose)
URL: /silk/docs/?p=guides/purpose
==============================================================================

# What Silk is for

Silk is a **spec-first** programming language and toolchain: the design is written down as a readable, linkable reference,
and the compiler is built to match that contract.

This matters because it changes how the language evolves:

- The “meaning” of a construct lives in the docs, not in folklore.
- Tooling can rely on stable concepts (packages, imports, diagnostics, CLI shapes).
- The implementation can grow incrementally while staying predictable to users.

If you’re new to Silk, this page gives you the mental model: what you write, what you get, and why the design looks the way
it does.

## Design goals (practical)

Silk is designed around a handful of constraints that show up everywhere:

### Explicit structure

Real systems code is easier to maintain when it is obvious where names come from and how code is organized.

- Names are qualified with `::`.
- Files declare a `package` or `module` header at the top.
- Imports are explicit and live in a contiguous import block.

That gives you codebases where “what depends on what” is visible without special tooling.

### A language you can reason about

Silk pushes toward **predictable semantics**:

- Types matter most at boundaries (public APIs, FFI, storage formats). Silk keeps those boundaries explicit.
- Error handling is explicit and typed, so you can see what can fail and what must be handled.
- Verification is opt-in by syntax (Formal Silk): ordinary code stays ordinary.

### A toolchain you can embed

Silk is not only “a compiler binary”. It is also designed to be integrated as a library:

- a C99 embedding ABI (`libsilk`) for host applications and build systems
- a Zig embedding wrapper for Zig-native integrations

This is useful when you want compilation as a component inside another program (editors, language servers, build
orchestrators, analysis tools).

## The basic programming model

### Files form a module set

When you run the compiler, you compile a **module set**: a set of `.slk` files that are type-checked together.

You can provide that set explicitly (a list of files), or you can ask `silk` to load it from a package manifest
(`silk.toml`). Either way, the idea is the same: *“these files form a unit.”*

### Packages and imports keep boundaries obvious

A simple file often begins like this:

```silk
package app;

import std::io::println;
```

That header tells you the namespace (`app`) and the dependencies (here: `std::io::println`) before you read the rest of the
file.

### Programs are ordinary code

Executables use a conventional entry point: `fn main () -> int` (exit code).

```silk
import std::io::println;

fn main () -> int {
  println("hello from silk");
  return 0;
}
```

Silk is designed so that “the smallest program” uses the same constructs you use at scale: packages, imports, types,
functions, and explicit boundaries.

## Where Silk fits well

Silk is aimed at code where clarity and correctness matter:

- tools and developer infrastructure
- network services and protocol code
- parsers, encoders, and data plumbing
- libraries that need a stable ABI boundary
- systems components that benefit from local verification (Formal Silk)

If you want a language that is both *low-level enough* to express systems concerns and *structured enough* to keep large
projects readable, Silk is built for that space.

## How to use this documentation

This site is organized into two layers:

- **Guides**: reading order, “how to think”, and realistic examples.
- **Reference**: precise language rules, standard library modules, and CLI/ABI details.

The recommended flow:

1. [Hello world](?p=guides/hello-world)
2. [Language tour](?p=guides/language-tour)
3. [Modules & packages](?p=guides/modules-and-packages)
4. [Standard library](?p=guides/standard-library)
5. [CLI and toolchain](?p=guides/cli)
6. [Testing](?p=guides/testing)
7. [Formal Silk](?p=guides/formal-silk)

If you already know what you’re looking for, use search and the sidebar reference sections.

==============================================================================
DOCS: Hello world (guides/hello-world)
URL: /silk/docs/?p=guides/hello-world
==============================================================================

# Hello world

This page teaches the Silk “shape of a program”: explicit imports, a normal `main`, and a workflow that makes it cheap to
iterate.

Assumption: you have a `silk` binary available on your PATH.

## The smallest program

Create a file named `hello.slk`:

```silk
import std::io::println;

fn main () -> int {
  println("hello from silk");
  return 0;
}
```

### Why this looks the way it does

- **Imports are explicit.** If you want `println`, you import it. This keeps dependencies obvious and makes refactors
  safer.
- **`main` is a normal function.** Executables use a conventional entrypoint. There isn’t a special “program block” that
  behaves differently from the rest of the language.
- **The return type is explicit.** `-> int` is the process exit code on hosted platforms. A successful run returns `0`.

## Iteration loop: check → test → build

Most Silk workflows are intentionally simple:

```bash
silk check hello.slk
silk test hello.slk
silk build hello.slk -o build/hello
```

- `silk check` answers: “does this module set parse and type-check?”
- `silk test` discovers and runs `test "name" { ... }` blocks and emits TAP output.
- `silk build` compiles and produces an artifact. When you omit `--kind`, you’re building an executable.

The important term is **module set**: each command operates on a set of `.slk` files compiled together. Even in small
programs, thinking in module sets scales well to larger codebases.

Next: [CLI and toolchain](?p=guides/cli)

## A slightly richer example

This adds a helper function and shows how “real” Silk code stays ordinary:

```silk
import std::io::println;

fn greet (name: string) -> void {
  println("hello {s}", name);
}

fn main () -> int {
  greet("silk");
  return 0;
}
```

## A practical hello: reading arguments

On hosted targets, Silk can also accept a conventional `(argc, argv)` entrypoint shape. The standard library includes a
small `std::args` helper so you can treat raw `argv` pointers as `string` views.

```silk
import std::args;
import std::io::println;

fn main (argc: int, argv: u64) -> int {
  let a = std::args::Args.init(argc, argv);
  if a.count() < 2 {
    println("usage: hello <name>");
    return 2;
  }

  println("hello {s}", a.get(1));
  return 0;
}
```

This example is intentionally small, but it demonstrates the “systems” posture of Silk: when a boundary is low-level
(process arguments are ultimately raw pointers), the language and stdlib make that boundary explicit rather than hiding it
behind magic.

## Where to go next

- [Language tour](?p=guides/language-tour)
- [Modules & packages](?p=guides/modules-and-packages)
- Reference: packages/imports/exports (`Packages, imports, exports` in the sidebar under “Language”)

==============================================================================
DOCS: Language tour (guides/language-tour)
URL: /silk/docs/?p=guides/language-tour
==============================================================================

# Language tour

This is a guided walkthrough of the core ideas you’ll use in real Silk programs: explicit structure, readable types,
predictable control flow, and clear boundaries.

Silk is designed for explicit structure:

- Programs are organized into **packages** and **modules** with clear boundaries.
- Types are **spelled out** when they matter (especially at public boundaries).
- The standard library is under **`std::`** and is designed to be usable for systems programming.

This guide is intentionally example-heavy. For the precise rules, use the reference pages in the sidebar.

## Program structure: packages and imports

At the top of a file you declare your package and then import dependencies:

```silk
package my_app::core;

import std::io::println;
```

This header ordering is intentional: it keeps dependency structure tooling-friendly and prevents “imports halfway down the
file” patterns.

If you omit a `package` declaration, the file belongs to a default package for that build. In real projects, declaring the
package explicitly keeps codebases easier to navigate.

## Values: `let`, `mut`, and explicit types

Silk uses `let` bindings for local values.

```silk
fn main () -> int {
  let port: int = 8080;
  let enabled: bool = true;
  let name: string = "silk";
  return 0;
}
```

Use `mut` when a binding needs to change:

```silk
fn main () -> int {
  let mut sum: int = 0;
  sum = sum + 1;
  return sum;
}
```

The “why” is simple: mutability is a property you can see at the binding site.

## Functions: ordinary code, explicit boundaries

Functions are declared with `fn`, and you write return types explicitly at boundaries:

```silk
fn add (a: int, b: int) -> int {
  return a + b;
}
```

Executables use `fn main () -> int` by convention.

## Exports: a deliberate public surface

Bindings are explicit and can be exported as part of a package’s public surface:

```silk
export let build_name: string = "my_app";

export fn add (a: int, b: int) -> int {
  return a + b;
}
```

Exports matter because they define what other packages can depend on. A large part of Silk’s “readability” comes from being
able to see a package’s public surface without reading every file.

## Structs and methods

Silk uses `struct` for concrete data with well-defined layout. Methods live in `impl` blocks:

```silk
struct Packet {
  seq: u32;
  size: u16;
}

impl Packet {
  fn bytes (self: &Packet) -> u32 {
    return self.size as u32;
  }
}
```

The important idea is not the syntax — it’s that data and behavior stay grouped without turning “types” into magical objects.

## Enums and `match`

Enums model “one of several shapes” and are commonly used with `match`.

```silk
enum Mode {
  Debug,
  Release,
}

fn code_for (m: Mode) -> int {
  return match (m) {
    Mode::Debug => 1,
    Mode::Release => 2,
  };
}
```

`match` is also the natural way to handle results and typed errors (next sections).

## Interfaces (practical contracts)

Interfaces describe required method signatures for a contract. In user code, these are often used to define “protocols”
such as readers, writers, serializers, or log sinks.

```silk
import std::io;

interface LogSink {
  fn write(line: string) -> void;
}

struct StdoutSink {}

impl StdoutSink as LogSink {
  fn write (self: &StdoutSink, line: string) -> void {
    std::io::println("{s}", line);
  }
}
```

The key idea: interfaces are about *meaningful program structure*, not about web-specific types.

## Control flow

Silk uses familiar control flow constructs:

```silk
fn clamp (x: int, lo: int, hi: int) -> int {
  if x < lo { return lo; }
  if x > hi { return hi; }
  return x;
}
```

## Optionals: `T?` and “absence”

Optionals (`T?`) represent an optional value (`Some(...)` or `None`).

```silk
fn parse_flag (s: string) -> bool? {
  if s == "on" { return Some(true); }
  if s == "off" { return Some(false); }
  return None;
}
```

Use optionals when “missing” is a normal outcome and you don’t need structured error details.

## Results: `std::result::Result(T, E)`

When you want a standard “success or error” return shape, use `Result(T, E)`:

```silk
import std::result;

type IntOrMessage = std::result::Result(int, string);

fn div (a: int, b: int) -> IntOrMessage {
  if b == 0 { return Err("division by zero"); }
  return Ok(a / b);
}
```

Callers typically handle results with `match`:

```silk
fn main () -> int {
  match (div(10, 2)) {
    Ok(v) => { return v; },
    Err(_) => { return 1; },
  }
}
```

## Typed errors: structured failures

Silk also supports typed errors directly. You define an error type and return `T | ErrorType`:

```silk
error ParseFailed {
  message: string
}

fn parse_port (s: string) -> int | ParseFailed {
  if s == "" { return ParseFailed{ message: "empty" }; }
  return 8080;
}
```

Then handle it explicitly with `match`:

```silk
fn main () -> int {
  match (parse_port("8080")) {
    port => { return port; },
    _: ParseFailed => { return 2; },
  }
}
```

The value-add is clarity: you can see *what can fail* and *how to handle it* without conventions or exceptions.

## Testing (language-level)

Silk provides language-level tests (`test "name" { ... }`). Tests live next to the code they exercise and are run with
`silk test`.

```silk
import std::test::expect_equal;

fn add (a: int, b: int) -> int { return a + b; }

test "add returns the sum" {
  expect_equal(3, add(1, 2));
}
```

## Next

Next: [Modules & packages](?p=guides/modules-and-packages) · [Standard library](?p=guides/standard-library) ·
[Testing](?p=guides/testing)

==============================================================================
DOCS: Modules & packages (guides/modules-and-packages)
URL: /silk/docs/?p=guides/modules-and-packages
==============================================================================

# Modules & packages

Silk uses `::`-qualified names to organize code. The goal is not novelty — it’s **clarity**:

- you can see where names come from,
- you can see what depends on what,
- and builds stay deterministic because the compiler always knows what the module set is.

This page focuses on the practical model you’ll use in real code.

## Packages

A **package** is a named collection of source files that share a namespace. A file can declare its package at the top:

```silk
package my_app::core;
```

Package names are `::`-qualified paths. The standard library lives under `std::...` (for example `std::io`, `std::fs`,
`std::strings`).

### Importing packages

When you import a package, you are declaring a dependency on that package’s public surface:

```silk
import std::strings;
```

Exports are explicit (`export fn`, `export let`, and named re-exports). This keeps public API surfaces intentional.

### A tiny multi-file example

`util.slk`:

```silk
package app::util;

export fn add (a: int, b: int) -> int { return a + b; }
```

`main.slk`:

```silk
package app;

import app::util;
import std::io::println;

fn main () -> int {
  println("sum={d}", app::util::add(20, 22));
  return 0;
}
```

The important thing is how *obvious* this is: `main` depends on `app::util` and `std::io::println`, and nothing else is
implicitly pulled in.

## Modules

A **module** declaration is a compile-time-only namespace value. It lets you write code that is “about” a module, including
module-level conformance checks.

```silk
module my_app::logger;
```

Modules are useful when you want a named namespace in a single file without necessarily treating it as “a package you import
from other files”.

In addition to header-form modules, you can define inline modules for nested namespaces:

```silk
package my_app;

export module math {
  export fn add (a: int, b: int) -> int { return a + b; }
}
```

## Imports: whole packages vs individual symbols

Silk supports a small set of import forms that cover most real programs:

- **package imports** for cohesive namespaces
- **symbol imports** when you want a single dependency in scope
- **module-specifier imports** (for relative files, `std/` file paths, or package specifiers)

```silk
import std::io::println;
import std::strings;
```

Use package imports when you want a cohesive namespace; use symbol imports when you want explicit local dependencies.

## Exports: keeping APIs deliberate

Exports define what other packages can depend on.

Common forms:

```silk
export let version: string = "0.1.0";

export fn parse (s: string) -> int? {
  return None;
}

export { parse as parse_port };
```

This “explicit exports” rule is a major readability win in larger codebases: public surfaces stay curated.

## The CLI view: module sets and package manifests

The compiler always operates on a **module set**: the set of `.slk` files compiled together for that command.

You can define the module set explicitly (a list of files), or you can load it from a package manifest (`silk.toml`) using
`--package`.

Why this matters for packages/modules:

- Package imports only resolve to packages that exist in the module set.
- Tooling can answer questions like “what packages exist?” without executing code.
- Builds become reproducible because “what was compiled” is not a hidden global.

If you want the user-facing toolchain model, read: [CLI and toolchain](?p=guides/cli).

## Why this structure matters

The language design is intentionally strict about where these declarations live (package/module headers first, then a
contiguous import block). The payoff is large in practice:

- tools can parse dependency structure without executing code
- refactors are safer because imports and exports are explicit
- builds can be reproducible because module sets are well-defined

## Next

- [Standard library](?p=guides/standard-library)
- [Testing](?p=guides/testing)

==============================================================================
DOCS: Standard library (guides/standard-library)
URL: /silk/docs/?p=guides/standard-library
==============================================================================

# Standard library

Silk’s standard library lives under the reserved `std::` namespace. This is where “practical systems programming” shows up:
I/O, filesystem, networking, parsing, collections, time, and the shared conventions that make those modules compose.

This page is not a full reference (the sidebar is). It’s a guide to the **shape** of `std::`, how to use it, and what
patterns to expect.

## Importing `std::` modules

You can import an entire package, or import a single symbol:

```silk
import std::io;                 // package import (use as std::io::println, ...)
import std::io::println;        // symbol import (use as println(...))
import std::fs;                 // filesystem
import std::result::Result;     // common return shape
```

Use symbol imports when you want the dependency to be explicit at the call site (especially in small programs). Use package
imports when you want a cohesive namespace (common for larger modules).

## The three common “return shapes”

`std::` APIs intentionally reuse a small set of patterns so code stays readable.

### 1) Optionals: `T?`

`T?` means “a `T` or no value” (`Some(...)` / `None`).

Use this when “absence” is expected and you don’t need rich error information.

```silk
fn parse_port (s: string) -> int? {
  // Example sketch: a real parser would validate digits.
  if s == "" { return None; }
  return Some(8080);
}
```

### 2) Results: `std::result::Result(T, E)`

`Result(T, E)` is the standard “success or error” type used across `std::`.

```silk
import std::result;

type IntOrMessage = std::result::Result(int, string);

fn div (a: int, b: int) -> IntOrMessage {
  if b == 0 { return Err("division by zero"); }
  return Ok(a / b);
}
```

In real code you typically `match` on a result so success and failure paths stay explicit.

### 3) Typed errors: `T | E`

Silk supports typed errors directly in the language: a value is either a success type `T` or an error type `E`.

This is a good fit when:

- the error has structure (fields), and
- callers are expected to handle distinct failure reasons.

You’ll see both `T | E` and `Result(T, E)` in the ecosystem; `std::` uses `Result` heavily because it composes cleanly and
is easy to pattern-match.

## A quick tour of key modules

### `std::io` — printing and stream I/O

`std::io` covers console I/O and basic stream patterns.

```silk
import std::io::println;

fn main () -> int {
  println("hello {s} answer={d}", "world", 42);
  return 0;
}
```

When you need lower-level I/O, `std::io` also exposes byte-oriented read/write primitives and stable error kinds.

Reference: `std::io` (see the sidebar under “Standard library”).

### `std::fs` — filesystem operations

`std::fs` provides file and directory helpers and a low-level `File` handle.

Whole-file helpers are intentionally common:

```silk
import std::fs;
import std::io::println;

fn main () -> int {
  match (std::fs::read_file_string("message.txt")) {
    Ok(s) => {
      println("{s}", s.as_string());
      return 0;
    },
    Err(e) => {
      // A real program would format/inspect `e.kind()` and report it.
      println("read failed");
      return 1;
    },
  }
}
```

Reference: `std::fs`, `std::path`.

### `std::strings` — owned strings and utilities

Silk has a built-in `string` type (an immutable view over UTF‑8 bytes). The standard library adds an owning `String` for
when you need to build or retain dynamic strings.

Reference: `std::strings`, `std::unicode`.

### `std::json` and `std::toml` — configuration and structured data

Silk includes parsers for data formats used in real programs:

- `std::toml` for configuration (including `silk.toml` manifests)
- `std::json` for interoperability and structured data exchange

Reference: `std::toml`, `std::json`.

### `std::task`, `std::sync`, `std::temporal`

For concurrent and time-aware programs, `std::` provides:

- `std::task` (tasks, scheduling primitives)
- `std::sync` (mutexes/locks and synchronization)
- `std::temporal` (time types like `Duration`/`Instant`)

Reference: `std::task`, `std::sync`, `std::temporal`.

## How to keep `std::` code readable

Two patterns pay off quickly:

1. **Use small local aliases for verbose types.** For example, alias a `Result` instantiation to a short name.
2. **Prefer `match` at boundaries.** Convert errors into your own types at module boundaries, so the rest of your program
   doesn’t become a chain of “plumbing”.

## Next

- [CLI and toolchain](?p=guides/cli)
- [Testing](?p=guides/testing)

==============================================================================
DOCS: CLI and toolchain (guides/cli)
URL: /silk/docs/?p=guides/cli
==============================================================================

# CLI and toolchain

Silk’s CLI is designed to make the “normal loop” cheap:

1. **check** — parse + type-check
2. **test** — run language-level tests
3. **build** — produce artifacts (executables and libraries)

binary.

This guide focuses on the **user-facing model**: what the commands mean and how they fit together.

## The key idea: a module set

Every invocation operates on a **module set**: the set of `.slk` files compiled together.

You can define that set in two ways:

- **Explicit files:** `silk check a.slk b.slk`
- **A package manifest:** `silk check --package .` (loads `silk.toml`)

The module set determines:

- what packages exist
- how `import` resolves
- what gets type-checked together

This is why the CLI feels deterministic: you always know what the compiler is looking at.

## `silk check`: fast feedback

Use `silk check` when you want a quick, cheap answer:

```bash
silk check src/main.slk
```

Common patterns:

- Check a whole package:
  ```bash
  silk check --package .
  ```
- Check with a custom stdlib root:
  ```bash
  silk check --std-root ./path/to/std src/main.slk
  ```

Why it’s valuable:

- it makes “does this program make sense?” a first-class operation
- editors and CI can run it constantly without building outputs

## `silk build`: artifacts and build targets

`silk build` compiles and produces an output artifact. The output **kind** is explicit:

```bash
# Executable (default kind is executable)
silk build src/main.slk -o build/app

# Object file (useful for embedding into other build systems)
silk build src/lib.slk --kind object -o build/lib.o

# Static / shared libraries
silk build src/lib.slk --kind static -o build/libfoo.a
silk build src/lib.slk --kind shared -o build/libfoo.so
```

Build targets matter because they change how you structure code:

- **executables** center around `main`
- **libraries** emphasize exported functions and stable boundaries (often with a C header via `--c-header`)

### Target selection

When you need to select a target explicitly:

```bash
silk build src/main.slk --target x86_64-linux-gnu -o build/app
silk build src/main.slk --arch wasm32 --kind executable -o build/app.wasm
```

The CLI also exposes knobs for linking metadata (`--needed`, `--runpath`, `--soname`) when producing executables or shared
libraries.

## `silk test`: language-level tests (TAP)

Silk tests are authored in the language and live next to the code they exercise:

```silk
import std::test::expect_equal;

fn add (a: int, b: int) -> int { return a + b; }

test "add returns the sum" {
  expect_equal(3, add(1, 2));
}
```

Run them with:

```bash
silk test src/main.slk
silk test --package .          # run package tests
silk test --filter add         # run only matching tests
```

The runner emits TAP v13 output so it drops into existing tooling without special adapters.

## `silk doc` and `silk man`: documentation as part of the toolchain

Silk treats documentation as something the compiler can *extract* and *render*:

- `silk doc` generates Markdown from doc comments
- `silk man` renders a manpage view for a symbol/module/concept

This is a practical way to keep “what this code means” close to the codebase without inventing a separate doc pipeline.

## `silk cc` and embedding (C99 ABI)

Silk includes a stable embedding interface (`libsilk`) for host applications.

If you’re integrating Silk into an existing C build:

- use `silk build --kind object|static|shared` for artifacts
- emit headers with `--c-header`
- link against `libsilk` when embedding the compiler itself

For deep embedding details, see:

- C ABI: `libsilk` (sidebar → compiler/ABI)
- Zig embedding: `Zig Embedding API` (sidebar → compiler)

## Diagnostics

When a command fails, the compiler prints a diagnostic with a stable error code. These codes are designed to be:

- human readable (good in terminals)
- machine consumable (good in CI and tooling)

Reference: `Diagnostics` (sidebar → compiler).

## Next

- [Testing](?p=guides/testing)
- [Formal Silk](?p=guides/formal-silk)

==============================================================================
DOCS: Testing (guides/testing)
URL: /silk/docs/?p=guides/testing
==============================================================================

# Testing

Silk testing is **language-level**: tests live next to the code they exercise. The compiler discovers them, runs them with
`silk test`, and emits TAP output (TAP v13) so results are easy to consume in CI and existing tooling.

The goal is a workflow where “write code + write tests” is the default, not a separate phase.

## A basic test

```silk
import std::test::expect_equal;

test "addition" {
  expect_equal(3, 1 + 2);
}
```

Run it:

```bash
silk test hello.slk
```

## Nested tests

Tests can be nested to share setup and group behavior:

```silk
import std::test::expect_equal;

fn add (a: int, b: int) -> int { return a + b; }

test "math" {
  test "addition" {
    expect_equal(4, add(2, 2));
  }

  test "associativity (small sample)" {
    expect_equal(add(add(1, 2), 3), add(1, add(2, 3)));
  }
}
```

Nested tests execute inline (in source order) as part of the enclosing test, which makes them a natural fit for
hierarchical grouping and shared setup.

## Assertions and failures

Inside `silk test` builds, failed assertions **record failures** instead of aborting the entire run. That means one test run
can report multiple failures, which is valuable when you’re iterating.

You have two complementary tools:

- `assert <cond>;` — built-in assertion syntax
- `std::test` helpers — ergonomic test-only helpers (`expect`, `expect_equal`, `expect_error`)

Example:

```silk
import std::test;

test "example" {
  test::expect(1 + 1 == 2, Some("basic arithmetic"));
}
```

## TAP output (tooling-friendly)

The runner emits TAP v13:

- `TAP version 13`
- `1..N`
- `ok <n> - <name>`
- `not ok <n> - <name>`

This makes Silk tests easy to integrate with existing CI systems and TAP consumers.

## Filtering tests

When you have a larger suite, you can run a subset:

```bash
silk test src/main.slk --filter addition
```

The filter matches test names (substring match), which keeps it practical for “run the one I’m working on” loops.

## What makes Silk testing valuable

Silk’s testing model has a few strong properties:

- **Co-location:** tests live with the code they validate.
- **Good failure reporting:** failures are recorded and execution continues, so you see more than the first failure.
- **Tooling-friendly output:** TAP output integrates with existing test tooling.
- **Language integration:** the compiler understands tests as part of the language, not as an external framework.

## Next

- [Formal Silk](?p=guides/formal-silk)

==============================================================================
DOCS: Formal Silk (guides/formal-silk)
URL: /silk/docs/?p=guides/formal-silk
==============================================================================

# Formal Silk

Formal Silk is Silk’s compile-time formal verification language. It lets you write *machine-checked* specifications next to
ordinary code, and have the compiler prove those specifications using the Z3 SMT solver.

Two properties make this practical:

- **Zero runtime cost.** Verification directives do not exist at runtime; they don’t slow down your program.
- **Opt-in by syntax.** Normal code stays normal. Proofs are required only where you write verification syntax.

The key design choice is **opt-in by syntax**:

- normal code stays normal, and
- proofs are required only when verification syntax is present.

Formal Silk is meant to be used the way you actually write systems code: small, local assertions around the parts that are
easy to get subtly wrong (boundary checks, invariants, protocol rules, and “this must never happen” assumptions).

## The basic pieces

Formal Silk uses a small vocabulary of directives:

- `#require` — preconditions (what must be true before a function runs)
- `#assure` — postconditions (what must be true when a function returns)
- `#assert` — a proof obligation at a specific point in a block
- `#invariant` — a property that must hold before/after loop iterations
- `#variant` — a measure used for termination reasoning (it must decrease)
- `#const` — a compile-time-only binding used inside specifications
- `theory` / `#theory` — reusable proof obligations

You’ll see these used in three places: function boundaries, inside blocks, and around loops.

## Function contracts: `#require` and `#assure`

You can attach preconditions and postconditions to a function:

```silk
#require x >= 0;
#assure result > x;
fn inc (x: int) -> int {
  return x + 1;
}
```

This gives you a mechanically checked contract with zero runtime cost.

### A more realistic example: `clamp`

`clamp` is simple, but it’s exactly the kind of function where off-by-one and boundary mistakes show up:

```silk
#require lo <= hi;
#assure result >= lo;
#assure result <= hi;
fn clamp (x: int, lo: int, hi: int) -> int {
  if x < lo { return lo; }
  if x > hi { return hi; }
  return x;
}
```

The postconditions say what callers actually care about: the result is within range.

## Loop invariants and termination

Formal Silk can express loop invariants (`#invariant`) and termination measures (`#variant`) to prove properties that span
iterations.

Invariants are “always true” properties around the loop. Variants are how you justify termination: the variant must move in
the right direction each iteration (usually decreasing toward a bound).

Example: counting up to a limit while remembering what the original limit was:

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  while i < limit {
    i = i + 1;
  }
  return 0;
}
```

This is a small example, but it illustrates a common pattern: use `#const` to name the “before” value you want to talk
about in specifications.

## Block-local proof obligations

Use `#assert` to create a proof obligation at a specific point in a block:

```silk
fn demo (x: int) -> int {
  #assert x == x;
  return x;
}
```

In practice, `#assert` is most useful for:

- documenting an assumption you want the compiler to enforce (not just a comment)
- breaking a large proof into smaller checkpoints
- expressing a local fact that helps downstream invariants

## Reusable proofs: theories

When you have a property that should hold in many places, you can write it as a `theory` and attach it where needed.

The idea is to keep verification **modular**: small reusable statements instead of one giant proof block.

## Why it’s valuable

Formal verification is most useful where bugs are expensive:

- memory safety boundaries
- cryptographic and security-sensitive logic
- protocol parsers and encoders
- concurrency invariants

Silk’s approach keeps verification lightweight and local: you opt in where it buys you confidence.

## Debugging failed proofs

When a proof fails, the compiler reports a normal diagnostic at the annotation site.

For deeper debugging, run with `--debug` so the verifier can emit additional information and (when available) write an
SMT‑LIB reproduction script you can replay with an external Z3 binary.

The workflow is intentionally pragmatic: when a proof fails, you should be able to iterate the same way you iterate on type
errors — with good diagnostics and small edits.

==============================================================================
DOCS: `break` (language/flow-break)
URL: /silk/docs/?p=language/flow-break
==============================================================================

# `break`

`break` exits the nearest enclosing loop.

## Surface Syntax

```silk
break;
```

Notes:

- `break` is a statement, terminated by a semicolon.
- `break` does not carry a value in the current language design; there is no
  `break <expr>` form.

## Semantics

When executed, `break;`:

- terminates the innermost enclosing loop (`loop`, `while`, or `for`), and
- continues execution at the statement immediately following that loop.

In nested loops, `break` only exits the nearest loop:

```silk
fn main () -> int {
  while true {
    while true {
      break; // exits the inner loop only
    }
    break; // exits the outer loop
  }
  return 0;
}
```

`break` does not exit the current function. Use `return` for that.

## Type Checking Rules

- `break` is only permitted inside a loop body.
  `E2007`).

## Common Pitfalls

- Forgetting the semicolon (`break` is a statement).
- Expecting `break` to return a value (not supported).
- Using `break` outside a loop (rejected, `E2007`).

==============================================================================
DOCS: `continue` (language/flow-continue)
URL: /silk/docs/?p=language/flow-continue
==============================================================================

# `continue`

`continue` skips the remainder of the current loop iteration and jumps to the
next iteration of the nearest enclosing loop.

## Surface Syntax

```silk
continue;
```

Notes:

- `continue` is a statement, terminated by a semicolon.

## Semantics

When executed inside a loop body, `continue;`:

- stops executing the remainder of the current iteration’s body, and
- transfers control to the loop’s “next iteration” point:
  - for `loop`, this means jumping to the start of the loop body.
  - for `while`, this means re-evaluating the loop condition.
  - for `for`, this means advancing to the next iteration (and for C-style `for`
    loops, executing the loop step before re-checking the loop condition).

Example:

```silk
fn main () -> int {
  let mut i: int = 0;
  while i < 10 {
    i += 1;
    if i == 5 {
      continue; // skips the return below for i == 5
    }
    // More work could happen here.
  }
  return 0;
}
```

In nested loops, `continue` applies to the nearest loop:

```silk
fn main () -> int {
  while true {
    while true {
      continue; // continues the inner loop
    }
  }
  return 0;
}
```

## Type Checking Rules

- `continue` is only permitted inside a loop body.
  `E2008`).

## Common Pitfalls

- Forgetting the semicolon (`continue` is a statement).
- Expecting `continue` to exit the loop (it does not; use `break`).
- Using `continue` outside a loop (rejected, `E2008`).

==============================================================================
DOCS: `Duration` & `Instant` (language/duration-instant)
URL: /silk/docs/?p=language/duration-instant
==============================================================================

# `Duration` & `Instant`

`Duration` and `Instant` are time-related types with special literal and operator support.

Key ideas:

- `Duration` represents a signed time span.
- `Instant` represents a signed point-in-time on a monotonic timeline (an opaque
  epoch chosen by the runtime).
- Duration literals represent time spans with unit suffixes and are converted into
  integral ticks.
- Operators cover arithmetic, comparisons, and construction from scalars.

## Representation

In Silk:

- `Duration` is represented as a signed 64-bit integer count of **nanoseconds**.
- `Instant` is represented as a signed 64-bit integer count of **nanoseconds**
  since a monotonic, runtime-defined origin.

These are distinct Silk types in the type system, but share the same underlying
scalar representation (`i64`) at the IR and native ABI layers.

## Operators

The current implementation supports the following operator subset:

- `Duration + Duration -> Duration`
- `Duration - Duration -> Duration`
- `-Duration -> Duration`

- `Instant + Duration -> Instant`
- `Duration + Instant -> Instant`
- `Instant - Duration -> Instant`
- `Instant - Instant -> Duration`

- Comparisons (`==`, `!=`, `<`, `<=`, `>`, `>=`) are supported for:
  - `Duration` vs `Duration`
  - `Instant` vs `Instant`

Other arithmetic (`*`, `/`, `%`) and bitwise operators are not defined for time
types in the current implementation.

## Overflow

Arithmetic uses the same deterministic wrapping behavior as the underlying
`i64` operations in the current back-end subset (two’s complement wraparound).

## Future Work

At maturity, this document will be expanded to fully specify:

- duration/instant division semantics and rounding rules,
- checked/saturating variants exposed by the standard library,
- the precise relationship between `Instant` and the platform clock APIs,
- and FFI-safe conversions and APIs in `std::temporal`.

Compiler requirements:

- Implement type-checking and lowering for the operator subset above.
- Integrate with `std::temporal` in the standard library.

==============================================================================
DOCS: `enum` Types (language/enums)
URL: /silk/docs/?p=language/enums
==============================================================================

# `enum` Types

An `enum` defines a *tagged union* type: a value that is exactly one of several
named variants, optionally carrying a payload.

Use enums to model:

- finite state machines (connection state, parser state),
- protocol messages and events,
- and any API where “exactly one of these cases” is the core invariant.

If your goal is “a function can fail with one of several error shapes”, prefer

## Surface Syntax

Enum declarations introduce a nominal type and its variants:

```silk
enum RecvJob {
  Msg(Job),
  Cancelled,
  Timeout,
}
```

Rules:

- Variant names are identifiers and must be unique within the enum.
- Variant names may not be the reserved optional constructors `Some` / `None`.
- An enum must declare at least one variant.
- A variant is either:
  - a **unit** variant (no payload): `Cancelled`,
  - or a **tuple** variant with one or more payload element types: `Msg(Job)`,
    `Pair(int, int)`.
- A trailing comma after the last variant is permitted.

## Construction

### Unit variants

Unit variants are constructed as values using `Enum::Variant` (or, in
type-directed contexts, just `Variant`):

```silk
enum E {
  A,
  B,
}

fn main () -> int {
  let x: E = E::A;
  let y: E = A;
  return 0;
}
```

Notes:

- `E::A()` and `A()` are invalid in Silk (unit variants are not callable).

### Tuple variants

Tuple variants are constructed using `Enum::Variant(<args...>)` where the
argument count and types match the variant’s declared payload element types:

```silk
enum E {
  Data(int),
  Pair(int, int),
  Empty,
}

fn main () -> int {
  let a: E = E::Data(7);
  let b: E = Data(7);
  let b: E = E::Pair(1, 2);
  let c: E = E::Empty;
  return 0;
}
```

Notes:

- `E::Data` by itself is not a value in Silk (tuple variants must
  be constructed with `(...)`).
- If a tuple-variant constructor argument has the wrong type, you get `E2001`.
- If the argument count does not match the variant definition, the compiler
  currently rejects the construct with `E2002`.

### Generic enums (instantiation via alias)

When an enum is generic, callers typically alias an instantiation and then use
that alias as the qualifier for constructors:

```silk
enum Result(T, E) {
  Ok(T),
  Err(E),
}

type R = Result(int, int);

fn main () -> int {
  let x: R = R::Ok(123);
  return match x {
    R::Ok(v) => v,
    R::Err(_) => 0,
  };
}
```

### Namespaced enums (packages)

Across packages, enums and variants may be referenced with `::` qualification.
For example, if `util` defines `enum Mode { Inc, Dec }`, an importer can write:

- `util::Mode` as the type name, and
- `util::Mode::Inc` / `util::Mode::Dec` as the constructors and patterns.

package imports seed qualified type names.

## Matching

Enum values are typically consumed via `match` expressions. The `match`
focuses on the enum-specific subset.

### Patterns

Enum patterns are variant patterns:

- Unit variant: `E::A`
- Tuple variant: `E::Data(x)`, `E::Pair(a, b)`
- Tuple binder omission: `E::Pair(_, b)` (underscore binder ignores that element)

Shorthand:

- When the scrutinee type is the enum `E`, the qualifier may be omitted:
  - Unit variant: `A`
  - Tuple variant: `Data(x)`, `Pair(a, b)`

For instantiated generic enums, the qualifier `E` may be a type alias (for
example `type R = Result(int, string);` then `R::Ok(v)` / `R::Err(e)`).

Binders:

- introduce a name scoped to that arm only, and
- shadow outer bindings of the same name (because they create a new binding in
  the arm’s environment).

### Exhaustiveness ()

In Silk, enum matches must be exhaustive:

- There must be exactly one arm per enum variant.
- Each variant must appear exactly once.
- Wildcard arms (`_ => ...`) are not supported for enum matches yet.

If a match is not exhaustive, the compiler currently reports `E2002` rather than
a dedicated “missing match arm” diagnostic.

### Example: unit enum match

```silk
enum E {
  A,
  B,
}

fn main () -> int {
  let v: E = E::A;

  let x: int = match v {
    E::A => 10,
    E::B => 20,
  };

  if x != 10 {
    return 1;
  }
  return 0;
}
```

### Example: tuple enum match (payload binders)

```silk
enum E {
  Pair(int, int),
  Empty,
}

fn main () -> int {
  let v: E = E::Pair(1, 2);

  let x: int = match v {
    E::Pair(a, _) => a,
    E::Empty => 0,
  };

  if x != 1 {
    return 1;
  }
  return 0;
}
```

### Example: struct payload enum match

```silk
struct Job {
  id: int,
}

enum RecvJob {
  Msg(Job),
  Cancelled,
}

fn main () -> int {
  let j: Job = Job{ id: 5 };
  let evt: RecvJob = RecvJob::Msg(j);

  let rc: int = match evt {
    RecvJob::Msg(job) => job.id,
    RecvJob::Cancelled => 0,
  };

  if rc != 5 {
    return 1;
  }
  return 0;
}
```

## Representation

Enums are values. In the current IR-backed lowering, an enum value is lowered to
scalar slots as:

1. a `u64` **tag** (variant index in declaration order, starting at `0`), and
2. a **payload region** that includes a distinct slot range for each variant’s
   payload elements, in variant declaration order.

Conceptually:

```text
(u64 tag,
 payload slots for variant 0,
 payload slots for variant 1,
 ...)
```

Only the active variant’s payload region is meaningful for a given value; other
payload regions are unspecified.

This representation is an implementation detail and is expected to evolve (for
example, toward a tag + max-payload “union-style” layout) as the compiler and
ABI mature.

## Common Pitfalls

- **Forgetting parentheses**: `E::Data(7)` is valid, but `E::Data` is not a value
  In Silk (error `E2002`).
- **Calling a unit variant**: `E::A` is a value; `E::A()` is rejected (`E2002`).
- **Wrong binder count**: `E::Pair(a)` does not match `Pair(int, int)` (`E2002`).
- **Non-exhaustive matches**: you must list every variant (error `E2002` in the
  ).
- **Assuming enum equality is defined**: use `match` to inspect the tag/payload;
  the backend does not define `==`/`!=` over enums yet.

## Related Documents


## Relevant Tests

- Enum matches (end-to-end):
- Namespaced enum references (module-set build):

==============================================================================
DOCS: `for` Loop (language/flow-for)
URL: /silk/docs/?p=language/flow-for
==============================================================================

# `for` Loop

The `for` loop iterates over a range or iterable and executes a block once per
element.

`start..=end`), array/slice iteration (`for x in xs { ... }` for `T[N]` and
`T[]`), iterator iteration (`for x in it { ... }` when `it.next() -> T?`), and
C-style `for (init; condition; step) { ... }` loops.

## Goals

- Provide a readable, structured loop construct for iteration.
- Avoid “off-by-one” patterns by making range boundaries explicit.
- Integrate with `break` / `continue`.
- Integrate with future iteration protocols (interfaces/generics) without
  introducing hidden allocation.

## Surface Syntax ()

Supported surface forms:

```silk
for <pattern> in <iterable> {
  ...
}
```

```silk
for (<init>; <condition>; <step>) {
  ...
}
```

Notes:

- `<pattern>` is intended to be a pattern binder. In early implementations it
  is restricted to a single identifier (and `_`). It will be expanded alongside
  pattern matching.
- `<iterable>` is an expression.
- `<init>` is a local binding (`let` / `var` / `const`) with an initializer.
- `<condition>` is a boolean expression.
- `<step>` is a statement-like expression (the same restricted subset as

## Semantics

General rules:

- The iterable expression is evaluated once to produce an iteration source.
- The loop body executes once per produced element.
- `break` exits the loop; `continue` advances to the next element.

### Range iteration

When the iterable is a range expression (for example `start..end` or
`start..=end`), the loop iterates over integer values.

Design intent:

- `start..end` iterates `start, start+1, ..., end-1` (end-exclusive).
- `start..=end` iterates `start, start+1, ..., end` (end-inclusive).

Notes: 

- The range bounds are evaluated once, left-to-right (`start` then `end`).
- If the start bound is greater than or equal to the end bound (`start >= end`)
  for an end-exclusive range, the loop executes zero times.
- If the start bound is greater than the end bound (`start > end`) for an
  end-inclusive range, the loop executes zero times.
- `continue` advances to the next element (it performs the increment step, then
  re-checks the range condition).
- The loop binder is in scope only inside the loop body block.
- The binder is immutable in Silk (it behaves like a `let`
  binding that is updated by the loop machinery; user code cannot assign to it).

Type checking:

- Both range bounds must have integer type (`int`, `i8`/`u8`, `i16`/`u16`,
  `i32`/`u32`, `i64`/`u64`).
- The two bound types must match, except that an integer literal bound may be
  coerced to the other bound’s integer type (for example `for i in 0..n_u32`).
- The loop binder (when not `_`) has the bound’s integer type.

Example:

```silk
fn main () -> int {
  let mut sum: int = 0;

  for i in 0..3 {
    // i takes values 0, 1, 2
    sum += i;
  }

  // 0 + 1 + 2 = 3
  return sum;
}
```

### Array and slice iteration

In Silk, `for` also supports iterating over builtin
array and slice types:

- fixed arrays `T[N]`,
- slices `T[]`.

Semantics:

- The iterable expression is evaluated once.
- The loop executes in increasing index order, starting at index `0`.
- The loop binder (when not `_`) is bound to the element value (a copy) for the
  current iteration.
- The binder is in scope only inside the loop body block.
- `break` exits the loop; `continue` advances to the next element.

Limitations:

- Element types are limited to the currently-supported array/slice element
  subset (types that lower to a fixed scalar slot sequence in the current
  back-end, such as primitive scalars, `string`, and supported non-opaque
  structs).
- Iteration is by value; to mutate an element, use indexing (`xs[i] = ...`).

Example:

```silk
fn main () -> int {
  let xs: int[3] = [1, 2, 3];
  let mut sum: int = 0;
  for x in xs {
    sum += x;
  }
  return sum;
}
```

### Iterator protocol

In addition to builtin arrays and slices, `for` supports iterating over a
stateful iterator value.

An expression `it` is treated as an iterator when it has a `next() -> T?`
instance method (typically by implementing `std::interfaces::Iterator(T)`).

Semantics:

- The iterable expression is evaluated once to produce the iterator value.
- The loop repeatedly calls `(mut it).next()`.
  - When the result is `None`, the loop exits.
  - When the result is `Some(value)`, the binder (when not `_`) is bound to
    `value` (a copy) for that iteration and the body executes.
- `continue` advances by calling `next()` again; `break` exits the loop.

## C-style `for` loops

Silk also supports the traditional “C-style” `for` loop:

```silk
fn main () -> int {
  let len: int = 10;
  let mut sum: int = 0;

  for (let i = 0; i < len; ++i) {
    sum += i;
  }

  return sum;
}
```

Semantics:

- `<init>` executes exactly once before the first condition check.
- `<condition>` is checked before each iteration; if it is `false`, the loop
  exits.
- The loop body executes once per iteration when `<condition>` is `true`.
- After the body executes normally, `<step>` executes, then the loop re-checks
  `<condition>`.
- `continue;` skips the remainder of the loop body and jumps to `<step>` (then
  re-checks `<condition>`).
- `break;` exits the loop immediately without executing `<step>` for that
  iteration.
- The init binding’s name is in scope within the entire loop (condition, step,
  and body) but is not visible after the loop.

Init binding mutability:

- For ergonomics, `for (let i = 0; ...; ++i)` is accepted and the init binding
  is treated as mutable (equivalent to `var`) within the loop.
  - `const` init bindings remain immutable.

## Guidance

In Silk, `for` supports integer ranges and builtin
array/slice iteration. To write other loops today, use `while`:

```silk
fn main () -> int {
  let mut i: int = 0;
  while i < 3 {
    std::io::println("i = {}", i);
    i += 1;
  }
  return 0;
}
```

## Compiler Requirements

- Recognize `for` loop syntax.
- Resolve iteration targets (ranges, collections) according to the language’s
  iteration model.
- Lower `for` into explicit control flow, with correct semantics for `break`
  and `continue`.

Compiler requirements:

- Recognize `for` loop syntax.
- Resolve iteration targets (ranges, collections) according to the language’s iteration model.

==============================================================================
DOCS: `if` / `else` (language/flow-if-else)
URL: /silk/docs/?p=language/flow-if-else
==============================================================================

# `if` / `else`

The `if` / `else` construct provides branching based on a boolean condition.

In Silk, `if` is a **statement** that selects which
block of statements executes. The broader language design also includes
expression-oriented forms; those are documented as planned where relevant.

## Surface Syntax

Minimal form:

```silk
if <condition> {
  ...
}
```

With an `else`:

```silk
if <condition> {
  ...
} else {
  ...
}
```

Notes:

- `<condition>` is an expression; parentheses are optional because the normal
  expression grammar already includes parenthesized expressions.
- Bodies are blocks. `else` may be followed by either:
  - a block (`else { ... }`), or
  - another `if` (`else if ... { ... }`) to form an “else-if” chain.

## Surface Syntax (Expression Form)

Silk also supports `if` / `else` as an **expression** form that yields a value:

```silk
let v: int = if cond { 123 } else { 456 };
```

Notes:

- `if` expressions require an `else` branch so the expression yields a value on
  all paths.
- The `else if ...` chain form is supported in expression position:

  ```silk
  let v: int = if a { 1 } else if b { 2 } else { 3 };
  ```

- Current compiler subset restriction: the `{ ... }` bodies of `if` expressions
  contain a single expression (not a full statement block).

## Semantics

- The condition expression is evaluated exactly once.
- If the condition is `true`, the `if` block executes and the `else` block (if
  present) does not execute.
- If the condition is `false`, the `else` block executes if present; otherwise
  the `if` statement does nothing.

Blocks create scopes:

- Declarations inside the `if` body are not visible outside that body.
- Declarations inside the `else` body are not visible outside that body.

## Type Checking Rules

- The condition must have type `bool`. If it does not, the checker reports a

For `if` expressions:

- The `then` and `else` branches must produce compatible value types.
- The expression’s result type is the shared branch type (or the expected type
  when the expression is type-directed).

## `else if` Chains

The language supports chained conditions (“else-if chains”). The compiler
parses `else if` as sugar for nesting an `if` inside the `else` block:

```silk
fn main () -> int {
  let x: int = 1;

  if x == 0 {
    return 0;
  } else {
    if x == 1 {
      return 1;
    } else {
      return 2;
    }
  }
}
```

The equivalent direct surface form is:

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  } else if x == 1 {
    return 1;
  } else {
    return 2;
  }
}
```

## Examples

### Minimal `if` / `else`

```silk
fn main () -> int {
  if true {
    return 0;
  } else {
    return 1;
  }
}
```

### Boolean expressions in conditions

```silk
fn main () -> int {
  let x: int = 1;
  let y: int = 2;

  if x < y && y < 10 {
    return 3;
  } else {
    return 4;
  }
}
```

### Control flow inside branches

```silk
fn main () -> int {
  let x: int = 1;
  let y: int = 2;

  if x < y {
    while false {
      continue;
    }
    return 3;
  } else {
    return 4;
  }
}
```

==============================================================================
DOCS: `loop` Loop (language/flow-loop)
URL: /silk/docs/?p=language/flow-loop
==============================================================================

# `loop` Loop

The `loop` statement executes a block repeatedly until it is terminated by a
`break` or `return`.

`task loop { ... }`.

## Surface Syntax

```silk
loop {
  // ...
}
```

```silk
async loop {
  // ...
}
```

```silk
task loop {
  // ...
}
```

Notes:

- `async loop` and `task loop` are still loop statements: they do not end with
  `;`.
- In Silk, `async loop` / `task loop` follow the same
  async-context restriction as `async { ... }` / `task { ... }`:
  they are only allowed inside functions declared with `async`

## Semantics

- The body block executes repeatedly.
- `break;` exits the nearest enclosing loop and continues execution at the
- `continue;` skips the remainder of the current iteration’s body and begins the

## Type Checking Rules

- The loop body is checked in a loop context so `break` / `continue` are valid.

==============================================================================
DOCS: `match` Expression (language/flow-match)
URL: /silk/docs/?p=language/flow-match
==============================================================================

# `match` Expression

The `match` expression provides structured pattern matching.

Key ideas:

- A `match` selects one of several branches based on a scrutinee expression.
- `match` is an expression; all arms must be compatible in type.

The compiler must:

- Enforce exhaustiveness rules (where specified).
- Type check each arm and compute a consistent result type.

## Surface Syntax

The full language design includes rich pattern matching, guards, and matching
over many scrutinee types. The current compiler implementation supports only a
narrow, explicitly documented subset so we can validate end-to-end lowering and
code generation.

In the current implementation, `match` is accepted as an *expression* of the
form:

```silk
match <scrutinee> {
  <pattern> => <expr>,
  <pattern> => <expr>,
}
```

Notes:

- Arms are separated by commas; a trailing comma is permitted.
- Arm bodies are expressions (not blocks) in the current implementation.

### Optional Matching (`T?`)

The currently implemented pattern subset is limited to optionals:

- The scrutinee expression must have optional type `T?` (`Option(T)`), where `T`
  is a payload type supported by the backend.
- Patterns are restricted to:
  - `None`
  - `Some(<name>)`
  - `Some(_)`
- No guards (`if ...`) are implemented yet.
- Matches must be exhaustive for the optional scrutinee: there must be exactly
  one `None` arm and exactly one `Some(...)` arm (order is not significant).

Example:

```silk
fn main () -> int {
  let x: int? = Some(7);
  let y: int = match x {
    None => 5,
    Some(v) => v,
  };
  return y;
}
```

### Enum Matching (`enum`)

The language design supports matching over user-defined `enum` types

Defined initial subset:

- The scrutinee expression must have an enum type `E` (including an
  instantiated generic enum in module-set builds).
- Patterns are restricted to enum variants:
  - unit variants: `E::Cancelled` or `Cancelled`
  - tuple variants: `E::Msg(x)` / `Msg(x)` / `E::Pair(a, b)` / `Pair(a, b)` (binders may be identifiers or `_`)
- For instantiated generic enums, the qualifier `E` in patterns may be a type
  alias for the instantiation (for example `type R = Result(int, string);` then
  `R::Ok(v)` / `R::Err(e)`), or patterns may omit the qualifier and use the
  variant name directly.
- No guards (`if ...`) are implemented yet.
- Matches must be exhaustive for the enum scrutinee in the initial subset:
  there must be exactly one arm for each enum variant (order is not
  significant).

### Type Union Matching (`T1 | T2 | ...`)


Defined initial subset:

- The scrutinee expression must have a union type `T1 | ... | Tn`.
- Patterns are restricted to typed binders:
  - `name: Ti` (binds the payload as `Ti`), or
  - `_: Ti` (matches and ignores the payload),
  where `Ti` is one of the union member types.
- No guards (`if ...`) are implemented yet.
- Matches must be exhaustive: there must be exactly one arm per union member
  type (order is not significant).

## Semantics (Initial Subset)

- The scrutinee expression is evaluated exactly once.
- The selected arm is chosen based on the scrutinee value; non-selected arms
  are not evaluated.
- For `Some(v) => ...`, the binder `v` is in scope only within that arm and has
  type `T` (the inner payload type of the scrutinee `T?`).
- The result type of a `match` expression is the common type of its arms; all
  arms must type-check to the same result type in the current implementation.

## `match` Statement (Typed Errors)

The language design also includes a statement form of `match` used for

Surface form:

```silk
match (expr) {
  pattern => { ... },
  err: SomeError => { std::abort(); }
}
```

Key semantic rule (Terminal Arm Rule):

- If `expr` is an error-producing expression (its signature includes `T | ErrorType...`),
  then any arm that matches an `error` type must end in a terminal statement.


- The compiler currently implements `match` as an expression for:
  - the optional subset (`T?`), and
  - exhaustive `enum` matches (no guards) for the current CFG IR backend subset.
- The statement form required for typed errors is implemented as part of the

Note: the compiler also allows the `match` statement form to destructure
recoverable `Result`-style values. This form does not trigger the Terminal Arm
Rule because it is not a `T | ...` typed-error expression.

### Result Matching (`Ok(...)` / `Err(...)`)

The `match` expression also supports a small subset for
recoverable “success or error” values. In the current implementation this
includes:

- `std::result::Result(T, E)` (an `enum` with `Ok(T)` and `Err(E)` variants), and
- “Result-like” structs of the form `{ value: T?, err: E? }`.

For the struct form, the runtime invariant is: exactly one of `value` and `err`
is `Some(...)`. If this invariant is broken at runtime, execution traps.

Patterns:

- `Ok(name)` / `Ok(_)`
- `Err(name)` / `Err(_)`

Rules ():

- Enum form:
  - The scrutinee expression must have an enum type with variants `Ok` and `Err`.
  - `Ok(...)` / `Err(...)` patterns are shorthand for `R::Ok(...)` / `R::Err(...)` where `R`
    is the scrutinee enum type, and may appear alongside other enum variant patterns.
  - Exhaustiveness follows the enum rules: there must be exactly one arm per enum variant.
- Struct form:
  - The scrutinee expression must have a nominal struct type that contains
    `value: T?` and `err: E?`.
- Matches must be exhaustive:
  - for enum scrutinees, follow the enum rules (one arm per variant),
  - for struct scrutinees, there must be exactly one `Ok(...)` arm and exactly one `Err(...)` arm.
- In `Ok(v) => ...`, the binder `v` has type `T`.
- In `Err(e) => ...`, the binder `e` has type `E`.

Example:

```silk
import std::result;
import std::strings::String;

fn main () -> int {
  let s: String = match String.from_string("hello") {
    Ok(v) => v,
    Err(_) => String.empty(),
  };
  return s.len as int;
}
```

## Relevant Tests

- Optional `match` expressions:
- Enum `match` expressions:
- Union `match` expressions:
- Result-like `match` expressions:
- Typed error-handling `match` statements:

==============================================================================
DOCS: `return` (language/flow-return)
URL: /silk/docs/?p=language/flow-return
==============================================================================

# `return`

The `return` statement exits a function, optionally with a value.

## Surface Syntax

Return a value:

```silk
return <expr>;
```

Return from a `void` function:

```silk
return;
```

## Semantics

When a `return` statement executes:

- the current function terminates immediately, and
- control transfers back to the caller,
- carrying a return value if the function’s result type is non-`void`.

No statements after a `return` in the same control-flow path are executed.

## Type Checking Rules

The checker enforces:

- `return` is only valid inside a function body (otherwise `E2009`).
- In a function with non-`void` result type `R`, `return` must provide an
  expression whose type is `R` (otherwise `E2009`).
- In a `void` function, `return;` is permitted and `return <expr>;` is rejected
  (`E2009`).
- In a function with non-`void` result, falling off the end of the function

## Examples

### Returning from `main`

```silk
fn main () -> int {
  return 0;
}
```

### Early return

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  }
  return 1;
}
```

### `return;` in a `void` function

```silk
struct Counter {
  value: int,
}

impl Counter {
  fn inc (mut self: &Counter) -> void {
    self.value += 1;
    return;
  }
}
```

==============================================================================
DOCS: `using` (Aliases and Method Reuse) (language/using)
URL: /silk/docs/?p=language/using
==============================================================================

# `using` (Aliases and Method Reuse)

`using` introduces a local alias to an existing symbol, and (in `interface` /
`impl` bodies) can import method signatures/implementations under a new name.

This feature is intended to make large module trees ergonomic (short local
names) and to enable explicit, audited method reuse across types.

## Syntax

At any supported scope, `using` has two surface forms:

```silk
using Alias = QualifiedName;
using QualifiedName;
using QualifiedName as Alias;
```

Where `QualifiedName` uses the normal `::`-separated name syntax (including the
global-prefix form `::name`).

## Module / Package Scope

At module scope, `using` introduces a local alias for an in-scope symbol:

- types (`struct` / `enum` / `error` / `interface` / `type` aliases),
- functions (`fn` and `ext` function bindings),
- Formal Silk theories (`theory`).

The alias is transparent: using `Alias` is equivalent to using the target
symbol directly.

Name conflicts are errors, except when the alias already refers to the same
symbol as the target (a redundant alias). In that case the `using` declaration
is accepted as a no-op.

## `interface` Scope

Inside an `interface { ... }` body, `using` may import method **signatures**
from another interface:

```silk
interface Read {
  fn read() -> u8;
}

interface ReadAndPeek {
  using Read::read;
  fn peek() -> u8;
}
```

- `using Other::name;` is equivalent to copying the corresponding `fn name(...);`
  signature from `Other`.
- `using Other::name as alias;` imports it under the new name `alias`.
- Name conflicts (including conflicts with inherited `extends` members) are
  errors.

Note: interface method signatures omit the receiver parameter. The receiver is

## `impl` Scope

Inside an `impl Type { ... }` body, `using` may import a method implementation
from another impl:

```silk
impl Foo {
  fn id(self: &Foo) -> int { return 1; }
}

impl Bar {
  using Foo::id;
}
```

This makes the imported method available as if it were declared in the target
impl, including as a candidate for interface conformance checking.

### Visibility

Imported methods inherit the source method’s visibility:

- importing a `public fn` method produces a `public` method in the target impl,
- importing a private method produces a private method in the target impl.

Since `using` does not accept visibility modifiers in Silk, this
inheritance rule is the only way to control whether an imported method is
callable outside the target `impl { ... }` block.

### `Self` and Layout Compatibility

When the imported method’s signature depends on `Self` (for example
`self: &Self`, parameters of type `Self`, or returning `Self`), importing it
across distinct struct types requires that the underlying layouts are
compatible.

In Silk, a pair of non-opaque, non-`error` structs are
considered compatible when they have the same number of fields and the same
field types in the same order (field names do not matter).

If the source and target struct layouts are not compatible, the `using`
declaration is rejected.

##  Limitations

- `using` does not accept `public` / `private` modifiers yet (imported methods
  inherit the source method’s visibility).
- Imported methods whose `Self`-dependent parameters require a mutable borrow
  (`mut` `&Self`) are rejected in Silk.
- Constructor reuse (`constructor`) via `using` is not supported yet.

==============================================================================
DOCS: `while` Loop (language/flow-while)
URL: /silk/docs/?p=language/flow-while
==============================================================================

# `while` Loop

The `while` loop repeatedly executes a block while a boolean condition holds.

## Surface Syntax

Minimal form:

```silk
while <condition> {
  // body
}
```

`<condition>` is an expression. Parentheses are optional because the condition
is parsed using the normal expression grammar:

```silk
while (x < y && y < 10) {
  ...
}
```

### Loop Specifications (`#invariant` / `#variant` / `#monovariant`)

The language supports attaching loop specifications immediately before a
When Formal Silk syntax is present, the compiler proves these obligations with
Z3 at compile time.

```silk
#invariant <expr>;
#variant <expr>;
#monovariant <expr>;
while <condition> {
  ...
}
```

## Semantics

Evaluation rules:

- The condition is evaluated before each iteration.
- If the condition evaluates to `true`, the body block executes.
- After the body completes normally, control returns to the condition.
- If the condition evaluates to `false`, the loop terminates and execution
  continues after the loop statement.

Control-flow statements inside the body follow their own definitions:


Blocks create scopes. A `let` declared inside the body is not visible outside
the loop’s body block.

## Type Checking Rules

The checker enforces:

- The loop condition must have type `bool` (otherwise `E2001`).
- Each `#invariant` expression must have type `bool` (otherwise `E2001`).
- If present, the `#variant` expression must have an integer type (`int` or a
  fixed-width integer; otherwise `E2001`).
- Each `#monovariant` expression must have an integer type (`int` or a
  fixed-width integer; otherwise `E2001`).

`#invariant`, `#variant`, and `#monovariant` expressions are compile-time-only
(erased from runtime code). When Formal Silk verification is enabled by syntax,
they are proved with Z3 during compilation.

## Examples

### Minimal loop with `break`

```silk
fn main () -> int {
  while true {
    break;
  }
  return 0;
}
```

### Loop with invariants and a variant

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  while i < limit {
    i = i + 1;
  }

  return 0;
}
```

==============================================================================
DOCS: Aggregate Literals (language/literals-aggregate)
URL: /silk/docs/?p=language/literals-aggregate
==============================================================================

# Aggregate Literals

Aggregate literals cover arrays and structs.

## Array Literals

Array literals construct fixed-size array values from a list of elements.

### Surface Syntax

An array literal is written using square brackets:

```silk
let xs = [1, 2, 3];
let ys = [1, 2, 3,]; // trailing comma allowed
```

Empty array literals are permitted only when an expected array type is
available from context (so the compiler knows the element type and, for
fixed-size arrays, the required length):

```silk
let empty: i32[0] = [];
let empty_slice: i32[] = [];
```

### Typing

- A non-empty array literal has type `T[N]` where `N` is the number of
  elements and `T` is inferred from the elements (or from an expected type
  when present).
- When an expected type is present and it is `T[N]`, the literal must contain
  exactly `N` elements.
- When an expected type is present and it is `T[]`, the literal’s elements are
  type-checked against `T` and the resulting value has type `T[]`.
  - In Silk, this slice form is lowered as a non-owning
    view over a compiler-generated backing array.
  - The current implementation does not yet enforce lifetime rules for such
    slices; do not allow a slice derived from a stack-backed array literal to
    outlive the scope where it was created.

Compiler requirements:

- Infer element type when possible, or require explicit annotation where
  ambiguity exists.
- Validate that all elements are convertible to the target element type.
- Enforce current-subset restrictions on which element types are supported for

## Struct Literals

Struct literals construct values of `struct` types by specifying field names and values.

### Surface Syntax

A struct literal may be written in two forms:

- An **explicit** struct literal begins with a struct type name followed by a
  brace-enclosed field initializer list.
- A **contextual (inferred)** struct literal omits the type name and consists
  only of the brace-enclosed field initializer list. This form is only valid
  when an expected struct type is available from context (for example a
  function argument position or an explicit type annotation).

An explicit struct literal looks like:

```silk
struct Pair {
  a: int,
  b: int,
}

fn make () -> Pair {
  return Pair { a: 1, b: 2 };
}
```

An inferred struct literal looks like:

```silk
struct User {
  name: string,
}

fn print_user (user: User) -> void {
  std::println("user.name = {}", user.name);
}

fn main () -> int {
  // Equivalent to: `print_user(User{ name: "user name" });`
  print_user({ name: "user name" });
  return 0;
}
```

Initializers are written as either:

- `field_name: <expr>` (explicit initializer), or
- `field_name` (shorthand initializer, equivalent to `field_name: field_name`).

Initializers are separated by commas and an optional trailing comma is
permitted.

Example (shorthand):

```silk
struct User {
  name: string,
}

fn main () -> int {
  let name: string = "alice";
  let user = User{ name }; // equivalent to `User{ name: name }`
  if (user.name != "alice") { return 1; }
  return 0;
}
```

### Field defaults (struct declarations)

A `struct` field declaration may include a default value expression:

```silk
struct Beep {
  value: string = "boop",
}
```

When a struct literal omits a field, the compiler uses the field default
expression when present; otherwise it falls back to zero-initialization in the
current backend subset. This means the empty literal form is useful when all
fields have defaults:

```silk
let b = Beep {};
```

Important notes:

- Inferred struct literals are a **value** construction mechanism. They do not
  imply heap allocation. The compiler will not infer `&T` from `{ ... }`; use
  `new` for heap allocation explicitly.
- The parser only treats `{ ... }` as an inferred struct literal when it
  contains a struct-style initializer list (or is `{}`); blocks (`{ Stmt* }`)
  remain statement syntax (there is no general “block expression” in the current
  subset).

Compiler requirements:

- Enforce that field names are valid and that each field is initialized at most once.
- Define the behavior for omitted fields (in Silk, omitted fields
  are default-initialized).
- Respect struct lowering/layout rules from `structs-impls-layout.md`.

### Details

The current compiler implementation supports struct literals only for the
limited struct subset described in `structs-impls-layout.md`:

- structs with 0+ fields of supported value types (scalar primitives, `string`,
  nested structs, and supported optionals),
- literals may omit fields:
  - omitted fields that have a field default (`field: T = <expr>`) use that
    default expression,
  - otherwise, omitted fields are **zero-initialized** in the current backend
    subset,
- no duplicate field initializers are permitted,
- field order is not semantically significant.

==============================================================================
DOCS: Arenas (language/arenas)
URL: /silk/docs/?p=language/arenas
==============================================================================

# Arenas

Arenas are not part of the language surface. Use **regions** instead.

==============================================================================
DOCS: Blocks and Statement Composition (language/flow-blocks-statements)
URL: /silk/docs/?p=language/flow-blocks-statements
==============================================================================

# Blocks and Statement Composition

Blocks group statements, establish lexical scopes, and provide the “body” form
for structured control-flow constructs like `if`, `while`, and the `match`
statement used for typed errors.

## Surface Syntax

A block is a sequence of zero or more statements delimited by braces:

```silk
{
  stmt0;
  stmt1;
  ...
}
```

The empty block `{}` is permitted.

## Statements

the compiler supports these statement forms (see

- Local bindings:
  - `const` (compile-time constant binding; initializer must be const-evaluable),
  - `let` and `let mut` (and `var` as an alias for `let mut`).
- Specification-only declarations: `#const` (Formal Silk; not usable in runtime expressions).
- Expression statements: limited to calls, assignments, and increment/decrement
- Flow control:
  - `if` / `else` statements,
  - `while` loops,
  - `break`, `continue`,
  - `return`,
  - `assert`,
  - `panic` (typed errors),

## Semantics

### Sequencing

Statements in a block execute in source order. If a statement transfers control
out of the current block (`return`, `panic`, `break`/`continue` inside loops),
the remainder of the block is not executed on that path.

### Scope

A block introduces a lexical scope:

- Names declared by `const`/`let`/`var` are visible only after their
  declaration within the same block, and within any nested blocks.
- Inner blocks may shadow outer bindings by reusing a name (this is a normal
  lexical-shadowing rule; the checker should reject only when a specific
  feature imposes stricter rules).
- The special name `_` is a discard binding:
  - `let _ = expr;` and `let _: T = expr;` evaluate the initializer but do not
    introduce a binding into scope.
  - `_` may be used repeatedly in the same scope without conflicts.
  - Any produced runtime value is cleaned up at end-of-statement (not at scope
    exit).

Destructuring `let` bindings bind multiple locals from a
single struct value:

- Positional (field order):

  ```silk
  struct User { id: u64, name: string }
  let (id, name) = User{ id: 123, name: "alice" };
  ```

- Named (by field name, order-independent), with aliasing:

  ```silk
  struct Record { id: u64, data: string }
  let { data, id } = Record{ id: 123, data: "a record" };
  let { data as d, id as i } = Record{ id: 456, data: "other record" };
  ```

Array destructuring binds multiple locals from a single array/slice value:

```silk
struct Record { id: u64, data: string }

let records: Record[] = [{ id: 123, data: "a" }, { id: 456, data: "b" }];
let [a, b] = records;
```

Rules ():

- Only flat patterns are supported (no nested destructuring).
- The initializer is required.
- The initializer must have a non-opaque `struct` value type.
- The pattern must account for every field exactly once:
  - positional patterns must have exactly one binder per declared field (in
    field order),
  - named patterns must list each field exactly once (in any order),
  - use `_` to discard a field (`let (_, name) = ...;` or `let { data as _ } = ...;`).

For array/slice destructuring:

- The initializer must have an array type (`T[N]`) or slice type (`T[]`).
- Each binder is positional (index order).
- The pattern binds exactly the number of listed binders:
  - fixed arrays require an exact arity match (`[a, b]` requires `T[2]`),
  - slices trap at runtime if too short (as if indexing each element).

Enum destructuring binds payload elements from a single enum variant:

```silk
import std::result;

error Oops { code: int }

fn foo (oops: bool) -> std::result::Result(int, Oops) {
  if (oops) {
    return Err(Oops{ code: 123 });
  }
  return Ok(7);
}

fn main () -> int {
  // Destructure `Ok(...)` and bind its payload.
  // If the value is `Err(...)`, the program traps.
  let Ok(value) = foo(false);
  return value;
}
```

Rules ():

- The initializer is required.
- The initializer must have an enum type `E` (including a monomorphized generic enum).
- The initializer value is consumed (moved); the original binding may not be
  used after destructuring.
- The pattern must be an enum variant pattern:
  - `Variant(...)` (shorthand), or
  - `E::Variant(...)` / `pkg::E::Variant(...)` / `::pkg::E::Variant(...)`.
- Binder arity must match the variant payload arity (use `_` to discard payload elements).
- If the runtime value is not the matched variant, execution traps.

`const` bindings are compile-time constants:

- their initializer expression must be compile-time evaluable (otherwise the
  compiler reports an error),
- the binding is immutable (there is no `const mut`),
- a `const` binding is a normal runtime value (unlike `#const`), but its value
  is computed by the compiler at compile time and does not incur runtime
  computation cost in Silk.

In Silk, compile-time evaluation for runtime `const`
bindings is restricted to:

- scalar primitive types (`bool`, integer/float scalars, `char`, `Instant`, `Duration`), and
- pure scalar expressions composed of:
  - literals,
  - other `const` bindings,
  - calls to `const fn` functions where all arguments are themselves compile-time evaluable, and
  - `as` casts between supported scalar types, and
  - a small operator subset (notably `+`, `-`, `*`, bitwise ops, shifts; `/` and `%` are currently rejected for `const`).

- `string` bindings whose initializer is either:
  - a string literal (`"..."` or `` `...` ``), or
  - another `const` string binding.

Formal Silk declarations (`#const`) are compile-time-only names intended for specifications
(`#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`). They must not be referenced

### Blocks as Expressions

The broader language design includes expression-oriented flow constructs (for
example `match` expressions today and `if` expressions).

In Silk:

- a block is not an expression and does not produce a value; it is purely a
  statement list used as the body of constructs.

The `if` expression form is a special-case expression-oriented construct; it
does not make `{ ... }` a general expression form.

If/when general block expressions are introduced, the spec will define:

- which contexts accept them (and how ambiguity with `{ ... }` struct literals
  is resolved), and
- how their result values are computed.

## Examples

### Nested scope

```silk
fn main () -> int {
  let x: int = 1;
  {
    let y: int = 2;
    if x < y {
      return 0;
    }
  }
  return 1;
}
```

### Formal Silk declarations for loop specifications

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  while i < limit {
    i = i + 1;
  }

  return 0;
}
```

==============================================================================
DOCS: Boolean Literals (language/literals-boolean)
URL: /silk/docs/?p=language/literals-boolean
==============================================================================

# Boolean Literals

Boolean literals are the two built-in logical values:

- `true`
- `false`


## Examples

### Basic control flow

```silk
fn main () -> int {
  let ready: bool = true;
  if ready {
    return 0;
  } else {
    return 1;
  }
}
```

### Short-circuit evaluation

```silk
fn returns_false () -> bool {
  return false;
}

fn main () -> int {
  // Because the left operand is `true`, the right operand is evaluated.
  let a: bool = true && returns_false();
  if a {
    return 1;
  }

  // Because the left operand is `false`, the right operand is not evaluated.
  let b: bool = false && returns_false();
  if b {
    return 2;
  }

  return 0;
}
```

## Common Pitfalls

- **Assuming “truthy” values**: `bool` is a distinct type. Use comparisons to
  produce a `bool` (for example `x != 0`) rather than writing `if x { ... }`.
- **Forgetting short-circuiting**: `&&` and `||` may skip evaluating the right
  operand; do not rely on side effects in the skipped operand.

## Related Documents


## Relevant Tests

- Boolean control flow:
- Short-circuit semantics:
- Unary `!`:

==============================================================================
DOCS: Borrow Checking (Static Alias and Lifetime Safety) (language/borrow-checker)
URL: /silk/docs/?p=language/borrow-checker
==============================================================================

# Borrow Checking (Static Alias and Lifetime Safety)

This document specifies Silk’s intended borrow-checking model for references.


- call-scoped alias checks for mutable borrows (including slice range borrows),
- lexical lifetime checks for slice and reference borrows (no escaping borrows
  of stack locals),
- and a small explicit ownership-transfer form (`move`) used by the checker and
  lowering to prevent accidental double-drops in the safe subset.

## Goals

- Prevent use-after-free and data races in safe code.
- Make mutation explicit and intentional.
- Reject invalid borrows at compile time (no runtime borrow errors required for
  safe code).
- Keep diagnostics actionable (highlight the borrow origin, conflicting use,
  and suggest a fix).

## Details

Today, the language subset implemented by the compiler supports only:

- call-scoped borrow alias checks for:
  - borrowed reference parameters (`&T`, `mut p: &T`), and
  - slice parameters (`T[]`, `mut s: T[]`) and slice range borrows
    (`&base[start..end]`, `mut &base[start..end]`).
- first-class borrowed `&Struct` values created from borrowable lvalues:
  - `&expr` (borrow operator) for borrowable lvalues, and
  - implicit borrow coercions in contexts that expect `&T`
    (for example `let r: &Pair = pair;`).

Additionally, the subset implements **lexical lifetime checks** for both slice
borrows and borrowed `&T` values so obvious use-after-scope cases are rejected
(for example returning a slice borrowed from a local fixed array, or returning
`&T` borrowed from a local struct binding).

## Lexical Lifetimes

Slices (`T[]`) are non-owning views. Slice range borrows create slices that
point into existing storage:

- `&base[start..end]` creates a slice view whose lifetime is tied to `base`.
- When borrowing a range from an existing slice binding `s: T[]`, the borrow’s
  underlying origin is `s`’s origin (sub-slicing does not extend lifetime).

Lexical lifetime rules enforced by the compiler:

- A slice value that ultimately borrows from a **local fixed array binding**
  (`T[N]`) may not escape that binding’s lexical scope.
  - Returning such a slice from a function is rejected.
  - Assigning such a slice into outer-scope storage is rejected (including via
    field assignment and via mutable reference parameters).
- Returning a slice is permitted when the returned slice ultimately borrows
  from a **function parameter** (for example returning a sub-slice of a `T[]`
  parameter).

These rules are intentionally conservative and are expected to be generalized
to a richer lifetime model as more borrow forms become first-class.

## Lexical Reference Lifetimes

Borrowed `&T` values that ultimately reference **stack storage** may not escape
that storage’s lexical scope. This includes:

- returning a borrowed `&T` that points to a local struct binding,
- and assigning such a borrowed reference into outer-scope storage.

Returning a reference is permitted when the returned `&T` ultimately refers to
an input reference parameter (that is, storage owned by the caller), and not to
stack locals.

## Ownership Transfer (`move`)

Silk’s safe subset includes a small explicit ownership-transfer form:

- `move <name>`

This expression:

- consumes the binding `<name>` when its type requires ownership tracking
  (for example values that are dropped on scope exit),
- and makes `<name>` unavailable for further use until it is reinitialized
  (for `var`) or permanently (for `let`).

This enables moving values into other values (for example as call arguments or
as the payload of `Some(...)`) without accidentally copying a resource-owning
value and dropping it twice.

In Silk, ownership transfer is intentionally conservative:

- A binding may not be moved while it has any live borrows (reference or slice
  views) in scope, including borrows stored in struct fields.
- A by-value call argument that requires ownership tracking is treated as a
  move, and is rejected when the same binding is also borrowed in that call.

## Planned Expansion

As the language grows, borrow checking is expected to expand to cover:

- borrowed references as first-class values (`&expr` producing `&T` values),
- references and borrows in more positions (locals, fields, returns),
- lifetime/region inference across control flow,
- explicit disambiguation when multiple input references exist (for example a
  label syntax like `as A` to tie a return reference to a specific input),
- restrictions around suspension points in `async`/`await`,
- and well-defined rules for passing references across FFI boundaries.

document before implementation lands, and must be reflected in diagnostics

==============================================================================
DOCS: Buffers (language/buffers)
URL: /silk/docs/?p=language/buffers
==============================================================================

# Buffers

`Buffer(T)` is an intrinsic type providing low-level access to a contiguous block of memory. It is intentionally unsafe and used as a foundation for higher-level collections and strings.

Key points:

- `Buffer(T)` is a “fat pointer” with:
  - a raw pointer to the start of the memory block,
  - a capacity (number of elements that can be stored).
- `Buffer(T)` does **not** track the number of initialized elements (length).
- The intrinsic API includes operations such as:
  - `std::buffer::alloc`
  - `std::buffer::write`
  - `std::buffer::read`
  - `std::buffer::capacity`
  - `std::buffer::drop`
  - `std::buffer::view`
  - `std::buffer::slice`
- The safety model is layered:
  - Layer 1: unsafe `Buffer(T)` primitive.
  - Layer 2: compile-time safety via the verifier.
  - Layer 3: provable safety via refinement types.

Compiler requirements:

- Treat `Buffer(T)` as an intrinsic type with special semantics.
- Ensure the verifier has enough information to reason about buffer safety.
- Coordinate with the standard library so that safe collections are built on top of `Buffer(T)`.

==============================================================================
DOCS: Build Metadata (`BUILD_KIND`, `BUILD_MODE`, `BUILD_VERSION`) (language/build-metadata)
URL: /silk/docs/?p=language/build-metadata
==============================================================================

# Build Metadata (`BUILD_KIND`, `BUILD_MODE`, `BUILD_VERSION`)

Silk exposes a small set of compiler-provided **build metadata** values to both
runtime code and Formal Silk (compile-time verification) so programs can adapt
to build configuration and so theories can express “this code is only valid in
test builds”, “this feature requires a minimum version”, and similar policies.

## Built-In Constants

The compiler provides the following built-in constants in every module:

- `BUILD_KIND: string`
- `BUILD_MODE: string`
- `BUILD_VERSION: string`
- `BUILD_VERSION_MAJOR: u64`
- `BUILD_VERSION_MINOR: u64`
- `BUILD_VERSION_PATCH: u64`

These behave like normal `const` string values:

- They do not require an import.
- They may be used anywhere a `string` expression is allowed.
- They are compile-time constants (their values are fixed at compile time and
  are embedded into the output artifact).

### `BUILD_KIND`

The output kind currently being built:

- `"executable"`
- `"object"`
- `"static"`
- `"shared"`

### `BUILD_MODE`

The build mode currently being built:

- `"debug"`
- `"release"`
- `"test"`

Notes:

- `"test"` is the mode used by `silk test`.
- Debug stack traces and debug assertion behavior are controlled separately by

### `BUILD_VERSION`

The semantic version of the current package when building from a manifest.

- When building from a package manifest (`silk.toml`), `BUILD_VERSION` is the
  manifest `version`.
- When not building from a manifest, `BUILD_VERSION` is `"0.0.0"`.

### `BUILD_VERSION_MAJOR` / `BUILD_VERSION_MINOR` / `BUILD_VERSION_PATCH`

The SemVer **core triplet** (`major.minor.patch`) of `BUILD_VERSION` exposed as
`u64` values for convenient comparisons (especially in Formal Silk).

Rules:

- These parse the `major.minor.patch` prefix of `BUILD_VERSION`.
- Any trailing `-prerelease` or `+build` suffix is ignored.
- On parse failure, all three values default to `0`.

## Relationship to `std::runtime::build`

The standard library provides `std::runtime::build` functions that return the
same metadata:

- `std::runtime::build::kind() -> string`
- `std::runtime::build::mode() -> string`
- `std::runtime::build::version() -> string`

Use `std::runtime::build` when you prefer explicit namespacing or when writing
code intended to run under alternate stdlib roots.

## Examples

### Build-mode gated behavior

```silk
fn main () -> int {
  if BUILD_MODE == "test" {
    // Test-only behavior.
    return 0;
  }
  return 0;
}
```

### Version-gated behavior

For semver parsing and comparison, use `std::semver` at runtime or reuse the

==============================================================================
DOCS: Character Literals (language/literals-character)
URL: /silk/docs/?p=language/literals-character
==============================================================================

# Character Literals

Character literals represent Unicode scalar values (code points) and have type

Use `char` for:

- single-character markers and delimiters (e.g. `','`, `':'`),
- working with code points when interfacing with parsing/lexing logic,
- representing control characters (`'\n'`, `'\t'`, `'\0'`).


## Surface Syntax

Character literals are delimited by single quotes:

```silk
let a: char = 'x';
```

Rules:

- The contents must represent **exactly one Unicode scalar value**.
- A character literal must not span multiple lines.
- The source file is interpreted as UTF-8.

## Escapes

Inside a character literal, `\` introduces an escape sequence.

Supported escapes in the current implementation:

- `\n` — U+000A (line feed)
- `\r` — U+000D (carriage return)
- `\t` — U+0009 (tab)
- `\0` — U+0000 (NUL)
- `\\` — backslash
- `\'` — single quote
- `\"` — double quote
- `\xNN` — a code point given as exactly two hex digits
- `\u{...}` — a code point given as 1–6 hex digits

Unicode rules:

- The decoded code point must be a Unicode scalar value:
  - range `0x0000..=0x10FFFF`, excluding the surrogate range
    `0xD800..=0xDFFF`.
- For `\u{...}`, values outside that range are rejected.

## Semantics

Evaluating a character literal produces a `char` value whose numeric value is
the decoded Unicode code point.

In Silk, that code point is carried as a `u32` scalar.
This is an implementation detail; the language-level rule is “a `char` is a
Unicode scalar value”.

## Examples

### ASCII and punctuation

```silk
fn main () -> int {
  let comma: char = ',';
  if comma == ',' {
    return 0;
  }
  return 1;
}
```

### Unicode: literal UTF-8 vs `\u{...}`

```silk
fn main () -> int {
  let a: char = 'é';
  let b: char = '\u{00E9}';
  if a == b {
    return 0;
  }
  return 1;
}
```

### Escape sequences

```silk
fn main () -> int {
  if '\n' != '\x0A' { return 1; }
  if '\r' != '\x0D' { return 2; }
  if '\t' != '\x09' { return 3; }
  if '\0' != '\x00' { return 4; }
  if '\\' != '\u{005C}' { return 5; }
  if '\'' != '\x27' { return 6; }
  if '\"' != '"' { return 7; }
  return 0;
}
```

## Common Pitfalls

- **Using double quotes**: `"x"` is a `string`, not a `char`. Use `'x'`.
- **Writing more than one character**: `'ab'` is invalid; use `"ab"`.
- **Source encoding surprises**: prefer `\u{...}` for non-ASCII characters when
  you want the source spelling to be stable across editors/fonts.
- **Confusing `\xNN` between `char` and `string`**:
  - for `char`, `\xNN` denotes a code point value,

## Related Documents


## Relevant Tests

- Unicode char equality and `\u{...}` escape:
- Returning and comparing `char` values:
- Escape coverage:

==============================================================================
DOCS: Concurrency (language/concurrency)
URL: /silk/docs/?p=language/concurrency
==============================================================================

# Concurrency

Concurrency in Silk is built around two orthogonal function modifiers:

- `async` — marks a function as pausable/awaitable (concurrency),
- `task` — marks a function as safe to execute on a worker pool (parallelism),

plus structured concurrency blocks (`async { ... }` and `task { ... }`)
intended to provide **structured concurrency**.

- The runtime manages a thread pool to execute tasks.
- The compiler is intended to enforce task-safety rules when values cross task
  boundaries (Send/Sync-like constraints).

## Core Keywords: `async` and `task`

### `async`

- Marks a function as **awaitable** (pausable).
- Primary domain (design): I/O-bound concurrency on an event loop/executor.

### `task`

- Marks a function as **task-safe** and eligible to be executed as a parallel
  task on a worker pool.
- Primary domain (design): CPU-bound parallelism and offloading blocking work.
- In the intended design, *calling a `task fn` is non-blocking* and produces a
  task handle.

### `await`

`await <expr>` is the surface syntax for unwrapping a `Promise(T)` handle.

In Silk:

- `await Promise(T)` unwraps the completed promise and yields `T`.
- `await Promise(Task(T))` yields `Task(T)` (which can then be consumed via `yield` / `yield *`).
- `await Task(T)` is rejected; use `yield` / `yield *` for task values.

#### Task/Promise Handle Ownership ()

In Silk, `Task(T)` and `Promise(T)` are **single-use
handles**:

- A `Promise(T)` handle may be **awaited at most once**. `await` consumes the handle.
- A `Task(T)` handle may be **drained/joined at most once** via `yield *`
  (and `yield` on a temporary task expression drains/joins as well).
- Handles are **non-copyable**: you may not copy a handle into another binding
  or use it as a normal value expression.
- A consumed handle may not be used again (including attempting to `await` it a
  second time, or attempting to `yield *` it a second time).
- Consuming a handle that was created outside the current loop body is rejected
  In Silk (a loop may iterate multiple times).

These rules are enforced at compile time and exist to prevent double-free and
use-after-free bugs in the current runtime lowering, where `await` frees the
underlying handle storage after join/unwrap.

#### Handle Lifetime and Cleanup ()

In Silk, `Task(T)` and `Promise(T)` handles are stored in
heap-allocated handle memory:

- `await` unwraps a promise and then frees the promise handle storage.
- `yield *` drains/joins a task and then frees the task handle storage.
- If a handle is **not consumed** (`await`/`yield *`), the compiler inserts
  automatic cleanup when the handle binding is overwritten or goes out of scope:
  - `Task(T)` cleanup joins the worker thread and then frees the handle storage.
  - `Promise(T)` cleanup frees the handle storage.

Because the current runtime subset uses OS threads (no coroutine transform or
event loop), this automatic cleanup can block the current OS thread when it
joins a task.

### `yield`

`yield` is the task-side counterpart to `await`.

In the intended model for tasks:

- A `task fn ... -> T` produces a `Task(T)` handle when called.
- Inside the task body, `yield <expr>;` sends a value (convertible to `T`) to
  the task’s receiver and continues execution.
- `return <expr>;` sends the final task value (of type `T`) and terminates the
  task.
- Outside the task, `yield <task_handle>` blocks until the task produces its
  next value and yields it.
- `yield * <task_handle>` drains all remaining task values and then joins the
  worker thread for cleanup, yielding a collected `T[]` in value position.
- `yield * <task_handle>;` as a statement forwards all remaining values from the
  right-hand task to the enclosing task’s receiver and then joins/cleans up the
  drained task.

In Silk:

- `yield` is a blocking OS-thread operation (like the rest of the current
  concurrency runtime).
- `yield` is permitted only inside `task fn` / `async task fn` bodies and inside
  `task { ... }` / `task loop { ... }` blocks.
- The statement forms (`yield <value>;` and `yield * <task_handle>;` forwarding)
  require an enclosing task function (`task fn` / `async task fn`), since they
  send values to the task’s receiver.

#### Collected Array Ownership ()

In Silk, `yield *` and `await *` produce a heap-allocated
collection of values (`T[]`) for convenience. This is a current behavior:

- the compiler inserts deterministic cleanup for these collections when their
  bindings are overwritten or go out of scope,
- the returned `T[]` value must not be copied, and must not escape its defining
  scope until a stable owning collection type is specified.

### Structured Concurrency Blocks and Loops

`async { ... }`, `task { ... }`, `async loop { ... }`, and `task loop { ... }`
introduce structured regions intended for scheduler-backed concurrency and
ensure all work started in the region completes before exit.

In Silk, these forms parse and type-check, but they do
not yet introduce any runtime scheduling; they currently behave like a normal
lexical block.

## Future Work: Runtime and Safety

The long-term design is to provide:

- a well-defined `Task(T)` handle type,
- scheduler-backed lowering of `task` calls into non-blocking spawns,
- `await` that unwraps promises and propagates errors/contracts,
- `yield` / `yield *` that receive/drain tasks without blocking the OS thread,
- structured blocks (`async { ... }` / `task { ... }`) that provide well-delimited lifetimes,
- static rules for data-race prevention and safe sharing across tasks.

==============================================================================
DOCS: Const Functions (`const fn`) (language/const-functions)
URL: /silk/docs/?p=language/const-functions
==============================================================================

# Const Functions (`const fn`)

## Summary

Silk supports compile-time evaluation of certain expressions to produce
compile-time constants. `const fn` (and `const pure fn`) declarations opt a
function into this compile-time evaluation system so that it can be called from
compile-time contexts (for example, a `const` binding initializer).

## Syntax

`const` is a function modifier:

```silk
const fn add (a: int, b: int) -> int {
  return a + b;
}

const pure fn add2 (a: int, b: int) -> int {
  return a + b;
}
```

Notes:

- `const pure fn` is simply a `const fn` that also opts into the `pure` rules
  (see `function-disciplines.md`).
- `const fn` is a **compile-time-only** function:
  - it may be called only from compile-time contexts (for example `const`
    initializers and Formal Silk specifications),
  - it is not emitted as a runtime/linkable symbol in executable, object, or
    library outputs.

## Compile-Time Values ()

In this document, a “compile-time value” is a value that the compiler can
produce and manipulate during compile-time evaluation.

 (initial implementation target):

- scalar primitives:
  - `bool`
  - fixed-width integers (`i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`)
  - `int`
  - `f32`, `f64`
  - `char`
  - `Instant`, `Duration`

Planned (not yet supported for `const fn` in Silk):

- `string` values (string literals are supported directly in `const` bindings),
- aggregate values (struct/enum/optional/slice/array) as return values,
- function values as compile-time values (for higher-order const evaluation).

## Rules ()

The  defines a deliberately small “const-eval VM” surface. A
`const fn` must fit within this surface.

### Signature rules

In Silk, a `const fn`:

- must not be `task` or `async`,
- must not declare a typed-error contract (`-> T | ErrorType...`),
- must have a non-`void` return type that is a compile-time value type,
- must have parameters whose types are compile-time value types.

### Body rules

In Silk, a `const fn`:

- must not allocate (`new`) and must not use regions/`with`,
- must not contain `panic` statements,
- must not declare `const` local bindings,
- may call only other `const fn` declarations,
- is restricted to a small expression subset over scalar values:
  - literals and local names (parameters and `let` bindings; no global `const` reads in Silk),
  - `as` casts between supported scalar types,
  - unary operators: `-`, `~`, `!`,
  - binary operators:
    - arithmetic: `+`, `-`, `*` (division/modulo are not part of the const-eval subset),
    - bitwise: `&`, `|`, `^`, `<<`, `>>`,
    - comparisons: `==`, `!=`, `<`, `<=`, `>`, `>=`,
  - `if` expressions (`if cond { a } else { b }`).
  - assignments to local names: `=`, `+=`, `-=`, `*=`, plus `++`/`--`.

Control flow is limited to:

- `if` / `else` statements,
- `while` loops with boolean conditions,
- `break` / `continue`,
- `return` statements.

## Calling Const Functions

The initial intended compile-time use site is `const` bindings:

```silk
const fn add (a: int, b: int) -> int {
  return a + b;
}

const answer: int = add(20, 22);

fn main () -> int {
  return answer;
}
```

Const functions may also be imported/exported across modules/packages like
runtime declarations, but they are still compile-time-only: importing a `const
fn` does not make it callable from runtime code.

## “No Static Storage” Rule

Const functions do not create new static storage. In particular:

- compile-time execution may compute scalar values and fold them into constants,
- compile-time execution must not allocate heap memory,
- compile-time execution must not synthesize new global read-only data (for
  example, it cannot build a new string at compile time in Silk).

String literals are still backed by read-only static storage, but they are
introduced by the literal syntax itself (see `literals-string.md`), not by the
`const fn` evaluator.

## Evaluation Limits

Compile-time evaluation must terminate. The current implementation enforces an
instruction budget and a call-depth budget when executing `const fn` bodies at
compile time; evaluation that exceeds these budgets is rejected as not
compile-time evaluable.

==============================================================================
DOCS: Dependent Types (Const Parameters and Type-Level Computation) (language/dependent-types)
URL: /silk/docs/?p=language/dependent-types
==============================================================================

# Dependent Types (Const Parameters and Type-Level Computation)

This document specifies Silk’s intended support for “dependent-type-like”
patterns where types mention compile-time values (most notably integers).


- declaration parameter lists on `struct`, `impl`, and `fn`,
- type application in type positions (for example `VectorN(int, 1024)`),

but the compiler does not yet implement constraint checking, inference, or
monomorphization/code generation for parameterized declarations. In the current
compiler subset, generic parameter lists and applied types are rejected during

## Const Parameters

Const parameters are compile-time values that appear in parameter lists with a
type annotation:

```silk
struct VectorN(T, N: int) { /* ... */ }
```

Where:

- `T` is a type parameter, and
- `N: int` is a const parameter whose value must be known at compile time.

The initial supported const-argument form in type application is integer
literals (for example `VectorN(int, 1024)`).

## Type-Level Computation

The language intends to allow certain expressions over const parameters in type
positions (design-only):

```silk
fn concat(T, M: int, N: int; a: VectorN(T, M), b: VectorN(T, N)) -> VectorN(T, M + N) {
  // ...
}
```

This requires:

- a notion of const expressions at the type level,
- evaluation rules (and overflow behavior) for those expressions,
- and a compilation strategy (typically monomorphization) that produces concrete
  layouts and code for each instantiated type.

## Function Parameter Lists (CT/RT Split)

Generic functions use a single parameter list split by a top-level `;` inside
the parentheses:

```silk
fn id(T; x: T) -> T { return x; }
fn g(T;) -> T { /* CT-only, rare */ }
fn h(x: int) -> int { return x; } // RT-only
```

This split is parsed and preserved by the front-end, but generic functions are
rejected by the current checker until monomorphization is implemented

## Relationship to Arrays and Collections

Const parameters are intended to power:

- fixed-size arrays (`T[N]`),
- dependent-length collections (for example `VectorN(T, N)`),
- and compile-time-checked indexing/slicing APIs.

These features require additional language and runtime support beyond the
current compiler subset.

==============================================================================
DOCS: Duration Literals (language/literals-duration)
URL: /silk/docs/?p=language/literals-duration
==============================================================================

# Duration Literals

The `Duration` and `Instant` types have specialized literal support.

## Syntax

Duration literals are written as a decimal integer or decimal float immediately
followed by a unit suffix:

- Examples:
  - `10ns`
  - `250us`
  - `5ms`
  - `1s`
  - `1.5s`
  - `2min`
  - `1h`

The unit suffix is part of the literal token; the lexer must not split it into
an integer token followed by an identifier.

## Units

The current implementation recognizes the following suffixes:

- `ns` — nanoseconds
- `us` — microseconds
- `ms` — milliseconds
- `s` — seconds
- `min` — minutes
- `h` — hours
- `d` — days

## Semantics

Duration literals evaluate to a `Duration` value represented as an `i64`
nanosecond count.

- For integer forms (e.g. `5ms`), the value is scaled exactly.
- For floating-point forms (e.g. `1.5s`), the value is scaled and then rounded
  toward zero to an integral nanosecond count.

If the scaled value does not fit in `i64`, compilation fails.

Compiler requirements:

- Implement lexing rules that distinguish unit suffixes from identifiers.
- Map duration literals to the `Duration` type with correct unit scaling.
- Ensure constant-evaluation behavior (rounding, overflow) matches the spec.

==============================================================================
DOCS: Errors (language/errors)
URL: /silk/docs/?p=language/errors
==============================================================================

# Errors


For unrecoverable logic bugs and contract violations, Silk uses **typed
errors** (`error`, `panic`, and `T | ErrorType...`), specified in

## Design Goals

- Error signaling is explicit and typed (no hidden global error state).
- Error paths are part of normal control flow, not out-of-band exceptions.
- The verifier can reason about both success and error paths symmetrically.
- The C99 ABI must be able to represent error outcomes in a stable, documented way.

## Recoverable Errors (Recommended Pattern)

Silk distinguishes between:

- **Recoverable errors** (invalid user input, I/O failures, parse failures): model
  these as normal values, typically using `std::result::Result(T, E)` or an
  optional (`T?`).
- **Typed errors** (`T | ErrorType...` + `panic`): reserved for unrecoverable
  contract violations and logic bugs that should not be silently ignored (see

### Example: Recovering from URL parse errors

`std::url` exposes a recoverable parsing API (`std::url::parse`) that returns a
tagged result (`std::url::URLResult`), so callers can report an error and keep
going without aborting.

A runnable example that wraps `URLResult` into `std::result::Result` and parses
all command-line arguments is in:

- `examples/feature_errors_recoverable_url_parse.slk`

## Error Representation

From the overall language design:

- Silk favors explicit types such as:
  - optionals (`T?` / `Option(T)`) for “may be present / may be absent” values.
  - domain-specific error types (enums or structs) for richer error reporting.
- Functions that can fail should surface that in their type signatures:
  - either by returning a value that encodes both success and error (e.g. an optional or a nominal error-aware type),
  - or by returning an error-only type where success is absence of error.

The naming and shapes of error-carrying types are defined by this language spec and by standard library APIs, but the compiler must:

- treat them as regular, first-class types,
- enforce that callers handle them appropriately (e.g. via pattern matching, explicit checks).

## Interaction with Control Flow

Error-aware types integrate with control flow constructs:

- `if` / `match` can be used to branch on error vs. success cases.
- Pattern matching can destructure enum-based error types, exposing error codes or payloads.
- Optionals (`T?`) can be used where “absence” is a common error shape; they compose with `?.` and `??` to keep code concise while still explicit.

The compiler must:

- ensure that branches that depend on error conditions are type-checked,
- support exhaustiveness checks when matching on error enums/types.

## Verification and Errors

Formal Silk constructs (`#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`) apply equally to:

- success paths (e.g. postconditions describing the returned value),
- error paths (e.g. guarantees about when and how certain errors can occur).

The verifier should be able to:

- treat error-carrying types as ordinary values with invariants,
- prove that certain errors cannot happen given preconditions,
- or, conversely, require explicit handling of error cases when the proof cannot eliminate them.

## ABI and FFI Considerations

On the C99 side:

- For external functions declared via `ext`, any error behavior must be captured in the Silk-side function type and corresponding C signature (e.g. error-return codes, nullable pointers, or explicit error structs).

The compiler must:

- preserve error-related information across the FFI boundary,
- avoid implicit, hidden error channels (such as untracked global error codes) in favor of explicit parameters or return values.

## Assertions (`assert`)

`assert` is a debugging/safety construct intended to catch programmer mistakes.
It is **not** part of Silk’s typed error model and is not a replacement for
returning optionals or `Result(...)`.

Syntax (initial):

- `assert <Expr>;`
- `assert (<Expr>, <message>?);`

Rules:

- The condition expression must type-check as `bool`.
- The optional message, when present, must type-check as `string`.

Runtime behavior (current compiler subset):

- By default (release builds), if the condition evaluates to `false`, execution
  traps immediately (a panic-like abort). In the current `linux/x86_64` backend
  this is implemented as an invalid-instruction trap.
- In debug builds (`silk build --debug` / `-g`) on `linux/x86_64`, a failed
  assertion prints a panic header, the optional message (when present), and a
  stack trace to stderr when available (via glibc `backtrace_symbols_fd`)
  before aborting.

Notes:

- Failed assertions are currently isolated by the `silk test` runner (each
  test runs in its own process). Future work may allow reporting failed
  assertions without process isolation (for example by lowering `assert` to a
  typed error in test contexts).

==============================================================================
DOCS: Expression Statements (language/flow-expression-statements)
URL: /silk/docs/?p=language/flow-expression-statements
==============================================================================

# Expression Statements

Expression statements allow expressions to be used for their side effects.

## Syntax

An expression statement is an expression followed by a semicolon:

```
expr;
```

## Semantics

- The expression is evaluated exactly once.
- The result value (if any) is discarded.

## Current implementation restrictions

For the compiler, an expression statement is only valid when
the expression is either:

- a call expression (a function call), or
- an assignment / compound assignment expression.
- an increment/decrement expression (`++x`, `x++`, `--x`, `x--`).

All other expression statements are rejected.

This restriction will be relaxed as more of the expression language is lowered
and code-generated.

Examples (accepted in Silk):

```silk
fn main () -> int {
  std::io::println("hello");

  let mut x: int = 0;
  x = 1;
  x += 2;
  x++;

  return 0;
}
```

Examples (rejected in Silk):

```silk
fn main () -> int {
  1 + 2; // rejected: non-call/non-assignment expression statement (E2002)
  return 0;
}
```

## Guidance

If you computed a value and you want to keep it, bind it:

```silk
fn main () -> int {
  let x: int = 1 + 2;
  return x;
}
```

If you want a value for control flow, prefer an expression form that produces a

## Compiler requirements

The compiler must:

- Distinguish between expressions that can appear as statements and those that cannot (if the spec imposes restrictions).
- Preserve evaluation order consistent with the language’s semantics.

==============================================================================
DOCS: External Declarations (`ext`) (language/ext)
URL: /silk/docs/?p=language/ext
==============================================================================

# External Declarations (`ext`)

Silk’s external declaration feature lets Silk code call foreign functions and
access foreign variables.

- The core construct is the `ext` definition, which declares:
  - external C functions and their Silk function types, or
  - external C variables and their Silk types.
- The compiler and runtime perform marshalling between Silk’s internal representations and the C ABI, following a documented mapping.

## Declaring an External Binding

Example:

```silk
ext foo = fn (string) -> void;
ext bar = u32;
```

Here:

- `foo` is a C function named `foo` with the given Silk function type.
- `bar` is a C variable of type `u32`.

## Binding a Different External Symbol Name

Sometimes you want the Silk binding name to differ from the linked external
symbol name (for example, when writing wrapper modules that want to expose
stable public API names without colliding with imported libc names).

Syntax:

```silk
// The binding name is `c_malloc`, but the linked symbol is `malloc`.
ext c_malloc "malloc" = fn (i64) -> u64;
ext c_free "free" = fn (u64) -> void;
```

Rules:

- The identifier after `ext` is the **Silk binding name** (used for imports and
  calls from Silk code).
- The optional string literal is the **external symbol name** used for linking
  (native) or as the import name (wasm).
- If the string literal is omitted, the external symbol name is the same as the
  binding name.

## Avoiding Shadowing (Global `::...`)

If an `ext` binding is declared in the global namespace (a module with no
`package ...;` or header-form `module ...;` declaration) and a local declaration
shadows it (for example, a wrapper function named `malloc`), use the global-name
prefix to force lookup of the global binding:

```silk
return ::malloc(bytes);
```

The global-name prefix is not limited to `ext`: it also applies to type names
and enum variant paths in expression and type positions (for example, `::Foo`,
`::Foo{...}`, or `::E::Variant`), always forcing resolution in the global
(unnamed) package.

## Verification and `ext` (Silk rule)

External declarations have no body available to the verifier.

Therefore:

- It is a compile-time error to attempt to verify an `ext` declaration.
- It is a compile-time error for verified code (code whose compilation requires
  proofs) to call an `ext` function or read an `ext` variable.

This intentionally limits verification across the `ext` boundary.

## Opaque Struct Handles

Opaque structs are intended for representing foreign pointers/handles safely.
They strengthen type safety at the language boundary by preventing accidental
mixups between different handle types and by disallowing invalid operations in
Silk.

Declare an opaque handle type with a fieldless `struct` declaration:

```silk
// runtime.slk
struct StringBuilder;

ext sb_new = fn () -> &StringBuilder;
ext sb_append = fn (&StringBuilder, string) -> void;
ext sb_destroy = fn (&StringBuilder) -> void;
```

Use the handle by importing the type name and the `ext` functions:

```silk
import { StringBuilder, sb_new, sb_append, sb_destroy } from "./runtime.slk";

fn main () -> int {
  let sb: &StringBuilder = sb_new();
  sb_append(sb, "hello");
  sb_destroy(sb);

  // Using `sb` after destroy is UNDEFINED BEHAVIOR (dangling foreign pointer).
  return 0;
}
```

Rules:

- The handle type must be used behind `&` (`&StringBuilder`), not by value.
- Opaque structs cannot be instantiated and do not support member access.

Safety:

- You are responsible for managing the lifetime of foreign handles. Most C APIs
  provide explicit create/destroy functions; always call the destruction
  function when you are done.
- Using a handle after destruction is undefined behavior; the compiler does not
  currently enforce this at compile time.

Notes on executable `ext` calls (current linux/x86_64 implementation):

- When an executable uses `ext` calls or `ext` variable reads, the compiler
  emits a **dynamically-linked** ELF64 executable (PIE-style `ET_DYN` with
  `PT_INTERP`, `.dynamic`, `.rela.dyn`, and a `.got`).
- External symbols are resolved by the platform dynamic loader. Dependencies
  can be declared via the CLI (`silk build --needed <soname> ...`) or via the
  C99 embedding API (`silk_compiler_add_needed_library`), and runtime search
  paths can be declared via `--runpath` / `silk_compiler_add_runpath`.

## ABI Contract (Overview)

The language defines two closely related views of the ABI:

- A “fat pointer” internal representation for `string` and `regexp`:
  - conceptually: `struct string { ptr: ptr, len: i64 }` where `ptr` is a UTF‑8 pointer.
  - conceptually: `struct regexp { ptr: ptr, len: i64 }` where `ptr` is an engine-owned bytecode pointer.
- A C ABI contract (e.g. via `silk.h`) using an explicit struct:

  ```c
  typedef struct {
      char   *ptr;
      int64_t len;
  } SilkString;
  ```

- A mapping to an LLVM type used internally by the compiler:

  ```llvm
  %silk.string = type { i8*, i64 }
  ```

When calling conventional C APIs, the compiler may pass a `const char *` derived from this structure, with the guarantee that the underlying data is null‑terminated. This distinction is important:

- Internal/runtime ABI: operates on `{ ptr, len }` structs (`SilkString`).
- Compatibility calls to typical C libraries: may expose `const char *` for parameters declared as `string` in Silk `ext` declarations, with the compiler extracting the `ptr`.


## Primitive Type Mapping

The spec includes a table mapping Silk primitive types to C types, for example:

- `i8`, `u8` → `int8_t`, `uint8_t`
- `i16`, `u16` → `int16_t`, `uint16_t`
- `i32`, `u32` → `int32_t`, `uint32_t`
- `i64`, `u64` → `int64_t`, `uint64_t`
- `int` → `int64_t` (current `linux/x86_64` baseline; do not assume C `int`)
- `f32` → `float`
- `f64` → `double`
- `bool` → `bool` (or `_Bool`)
- `char` → `uint32_t` (UTF‑32)
- `string` → `SilkString` (`{ char *ptr; int64_t len; }`)
- `regexp` → `SilkString` (`{ char *ptr; int64_t len; }`, opaque bytecode view)
- `void` → `void`

Notes:

- For FFI with APIs that use a C `int` (for example many POSIX syscalls),
  prefer `i32`/`u32` in your `ext` declarations rather than `int`.
- The stable C99 ABI does **not** use compiler-specific `__int128` or
  `__float128` types for these primitives; it uses explicit `{ lo, hi }`
  structs so the ABI is portable and can be expressed in strict C99.

These mappings must be reflected exactly in the C99 ABI.

## Strings and Passing Convention

For strings, the spec makes the following points:

- Silk’s `string` is represented internally as a `{ ptr, len }` pair.
- For `ext` calls to typical C APIs:
  - the compiler can extract `ptr` and pass it as a `const char *`,
  - the data is guaranteed to be null‑terminated so standard C string functions are safe.

For regex bytecode values (`regexp`):

- Silk’s `regexp` is represented internally as a `{ ptr, len }` pair with the
  same slot layout as `string`, but the bytes are *not text* and are not
  required to be null‑terminated.
- At ABI boundaries, `regexp` uses the same C shape as `SilkString`, but C code
  must treat it as an opaque `(ptr, len)` byte span (not a C string).

For the embedding ABI (`libsilk.a`):

- We treat `SilkString` (`{ char *ptr; int64_t len; }`) as the primary C representation of Silk `string` values.
- Functions exported by `libsilk.a` will use `SilkString` in their signatures wherever strings cross the boundary.

This layered design allows:

- idiomatic FFI to existing C libraries using `const char *`,
- a precise, length‑carrying ABI (`SilkString`) for embedding the compiler/runtime.

## Safety & Ownership

The external interface rules must ensure:

- No C code can violate Silk’s invariants about ownership and lifetimes.
- Any shared data representation (strings, structs, arrays, closures) is documented and stable.

## Typed Errors and the `ext` boundary

Typed errors (`error`, `panic`, and `T | ErrorType...`) must not cross the `ext`
boundary.

Rules:

- `ext` function types must not use `|` in their return types.
- Silk-to-C ABI surfaces must not expose `|` in exported function signatures.
  Shims should convert typed errors into explicit error codes, optionals, or
  domain-specific error types, or terminate in a platform-appropriate way.


- The current compiler rejects `ext` declarations that include `|`, and rejects
  exporting error-producing functions to C ABI outputs.

The spec also includes a “Structs, Arrays, and Closures (Complex Types)” subsection for FFI. As the implementation proceeds, this document must be extended to:

- describe how user‑defined structs map to C structs (respecting the layout rules in `structs-impls-layout.md`),
- define how arrays and slices are represented across the boundary,
- document any stable closure representation, if exposed in the C ABI.

## Structs (Initial ABI Subset)

The full language design includes rich user-defined structs and nested
aggregates. The current compiler implementation supports only a small subset of
structs in code generation:

- structs with 0+ fields of supported value types (scalar primitives, `string`,
  nested structs, and supported optionals) in function bodies and internal helper calls,
- on `linux/x86_64`, passing and returning these structs by value at ABI boundaries
  using a scalar-slot lowering model:
  - a struct value lowers to N scalar “eightbyte” slots in field order, and
    each slot is classified as INTEGER (integer-like scalars such as `int`,
    fixed-width integers, `bool`, `char`, `Instant`, `Duration`) or SSE (`f32`/`f64`),
  - exported function *parameters* accept these slots as separate parameters;
    for 1–2 slot structs this is ABI-compatible with a by-value C struct
    parameter for the 8-byte-field subset, while for packed structs with
    smaller fields ABI compatibility with an equivalent C struct layout is not
    yet implemented/validated; for 3+ slot structs downstream C callers should
    declare separate parameters for the slots,
  - exported function *returns* support 1+ slot structs; 1–2 slot results
    return in `rax`/`rdx` and/or `xmm0`/`xmm1` accordingly, while 3+ slot
    results return indirectly via a hidden sret pointer.

This subset is intended as a stepping stone toward fully general struct layout
and SysV ABI classification (including packed layout for smaller fields such
as `f32` and small integers, nested structs, and larger aggregates returned via
hidden sret pointers).

## Optionals (Initial ABI Subset)

The full language design includes rich optional patterns (`?.`, `match`, nested
optionals, etc.). The current compiler implementation supports only a limited
optional subset in code generation:

- optionals whose payload type is a supported scalar, `string`, or a supported
  ABI-safe `struct` (i.e. after slot-flattening, all scalar slots are `i64`/`u64`/`f64`),
- construction via `None` and `Some(value)`,
- unwrapping via `??` with short-circuit fallback evaluation,
- and nested optionals (`T??`) for the same supported payload subset, including
  unwrapping `T??` to `T?` via `??`.

At ABI boundaries in the current `linux/x86_64` subset, optionals are lowered
as a `Bool` tag followed by the payload scalar slots in order:

- `(tag, payload)` for scalar payload optionals,
- `(tag, ptr, len)` for `string?`,
- `(tag, slot0, slot1, ...)` for `struct?` where the payload lowers to N scalar slots.

For nested optionals (`T??`) in this subset, the payload slots are the full
inner optional representation (for example `int??` lowers as
`(tag0, tag1, i64 payload)`).

For exported functions, these slots consume the normal scalar argument and
result locations (registers then stack), and 3+ scalar results return via a
hidden sret pointer.

Compiler requirements:

- Implement `ext` declarations as specified.
- Map Silk types to C types per the ABI document.
- Enforce the documented passing conventions and ownership rules for external-call strings and other bridged types.

==============================================================================
DOCS: Flow Control Overview (language/flow-overview)
URL: /silk/docs/?p=language/flow-overview
==============================================================================

# Flow Control Overview

Flow control describes how Silk programs sequence work, branch, loop, and exit.
This concept spans several surface constructs and their static rules (typing,
scoping, and diagnostics).

## Core Constructs

- `if` / `else`
- `loop` loops
- `while` loops
- `for` loops
- `match` expressions
- `return`
- `break`
- `continue`
- blocks and statement composition
- expression statements

Each construct has defined syntax, typing, and evaluation semantics which the
compiler must implement.

## Principles

These rules help keep control flow explicit and statically checkable:

- Conditions are boolean: `if` and `while` require a `bool` condition (no
  integer “truthiness”).
- Bodies are blocks: flow constructs use `{ ... }` blocks as their bodies.
- Statements are terminated: most statement forms end with `;` (for example
  `let`, `return`, `break`, `continue`, `panic`, `assert`, and expression
  statements).

## Quick Examples

Branching:

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  } else {
    return 1;
  }
}
```

Looping:

```silk
fn main () -> int {
  let mut i: int = 0;
  while i < 3 {
    i += 1;
  }
  return 0;
}
```

Matching:

```silk
fn main () -> int {
  let x: int? = Some(7);
  let y: int = match x {
    None => 0,
    Some(v) => v,
  };
  return y;
}
```

See the dedicated documents:

- `flow-if-else.md`
- `flow-loop.md`
- `flow-while.md`
- `flow-for.md`
- `flow-match.md`
- `flow-return.md`
- `flow-break.md`
- `flow-continue.md`
- `flow-blocks-statements.md`
- `flow-expression-statements.md`

==============================================================================
DOCS: Formal Grammar Spec (language/grammar)
URL: /silk/docs/?p=language/grammar
==============================================================================

# Formal Grammar Spec

This document contains the formal grammar and lexical specification for Silk as used by the compiler implementation.

## Lexical Structure (Overview)

The lexer operates over:

- Whitespace and comments (trivia):
  - spaces, tabs, newlines;
  - line comments starting with `//` and continuing to the end of the line;
    doc line comments start with `///` and follow the same lexical rules;
  - block comments starting with `/*` and ending with the next `*/` (non‑nesting);
    doc block comments start with `/**` and also end at the next `*/`.

    Both doc-comment forms are still **trivia** for the parser (they do not
    affect the syntax tree), but tooling may preserve and parse their text for
- Identifiers:
  - sequences of Unicode letters, digits, and `_`, with language-specific rules for leading characters.
  - Keywords:
  - packages and imports: `package`, `module`, `import`,
    file imports: `from`,
  - control flow: `if`, `else`, `loop`, `while`, `for`, `in`, `match`, `return`, `panic`, `break`, `continue`, `assert`, `await`, `yield`,
  - declarations and mutability: `export`, `public`, `private`, `default`, `const`, `let`, `var`, `mut`, `fn`, `test`, `theory`, `type`,
  - types and declarations: `struct`, `enum`, `error`, `interface`, `impl`, `as`, `raw`, `extends`, `pure`, `task`, `async`,
  - memory and regions: `move`, `region`, `with`, `new`,
  - other operators: `sizeof`, `alignof`, `offsetof`, `typename`,
  - optionals and literals: `None`/`none`, `Some`, `true`, `false`, `null`,
  - verification and external declarations: `ext`, and Formal Silk directives `#const`, `#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`, `#theory`,
  - other keywords as listed in the spec.

  Keywords are lexed as distinct tokens, but in name positions (for example
  qualified-name segments like `std::test`, function/method names, and member
  access like `value.test`) the parser accepts keywords anywhere an
  identifier is expected.

  The `#require` / `#assure` / `#assert` / `#invariant` / `#variant` / `#monovariant` / `#const` / `#theory` forms are
  **not** comments; they are first-class lexical tokens that participate in the
  normal expression grammar and are handled by the verifier. A directive token
  begins with `#` followed by optional horizontal whitespace and the directive
  name (so `#require` and `#  require` are equivalent spellings). When these
  sequences appear inside a `//` line comment or anywhere inside a `/* ... */`
  block comment, the surrounding comment is treated as trivia and the directive
  spellings are ignored by the lexer.
- Literals:
  - numeric, duration, boolean, character, string, regexp, aggregate (see `*literals-*.md`).
  - String literals have two surface forms:
    - `"..."` (escape sequences),
    - `` `...` `` (raw/no-escape).
  - Regular expression literals have a JavaScript-style surface form:
    - Disambiguation is context-sensitive (like JavaScript): the parser only
      recognizes a regex literal in expression-start positions where a
      `Primary` expression may begin; otherwise `/` is parsed as the division
      operator.
    - Because `//` starts a line comment, an empty regex literal `//` is not a
      valid token sequence; use `/(?:)/` for an explicit empty pattern.
- Operators and delimiters:

The lexer must implement longest-token rules for ambiguous prefixes (e.g. `...` vs `..=` vs `..`).

### Lexical Grammar for Whitespace and Comments

For the purposes of the grammar, whitespace and comments are treated as **trivia**
that may appear between any two tokens and are ignored by the parser:

- `Trivia       ::= (Whitespace | LineComment | BlockComment)+`
- `Whitespace   ::= ' ' | '\t' | '\r' | '\n'`
- `LineComment  ::= '//' LineCommentChar* Newline?`
- `LineCommentChar ::= any character except '\n'`
- `Newline      ::= '\n'`
- `BlockComment ::= '/*' BlockCommentChar* '*/'`
- `BlockCommentChar ::= any character except the end of input`

Block comments are **not nesting**: a `/*` sequence inside an existing
`BlockComment` has no special meaning and is treated as part of the comment
text until the first following `*/`. Doc-style comments such as `/** ... */`
are just syntactic sugar for `BlockComment` at the lexical level.

## High-Level Grammar Skeleton

At a high level, the language can be structured as:

- Compilation unit:

  - `Module ::= (PackageDecl | ModuleDecl)? ImportDecl* TopLevelDecl*`

- Top-level declarations:

  - `TopLevelDecl ::= PackageDecl | ModuleDecl | ImportDecl | InlineModuleDecl | UsingDecl | ReExportDecl | DefaultExportDecl | ExportableDecl | TestDecl`
  - `ExportableDecl ::= FnDecl | LetDecl | TypeDecl | StructDecl | EnumDecl | InterfaceDecl | ImplDecl | ExtDecl | ...`

- Packages and imports:

  The surface syntax for packages, imports, and exports is specified in detail in
  the currently implemented subset:

  - `PackageDecl ::= 'package' PackagePath ';'`
  - `ModuleDecl ::= 'module' PackagePath ModuleAsOpt ';'`
  - `InlineModuleDecl ::= ExportModifier 'module' NameToken '{' InlineModuleItem* '}'`
  - `InlineModuleItem ::= InlineModuleDecl | UsingDecl | ExportableDecl`
  - `NameToken ::= Identifier | Keyword`
  - `PackagePath ::= NameToken ('::' NameToken)*`
  - `ModuleAsOpt ::= ('as' QualifiedName TypeArgListOpt) | ε`

  - `ImportDecl ::= 'import' ImportSpec ';'`
  - `ImportSpec ::= ImportPath | FileImportSpec | FileDefaultImportSpec | AmbientFileImportSpec`
  - `ImportPath ::= ('::')? NameToken ('::' NameToken)*`
  - `ImportFrom ::= StringLiteral | PackagePath`
  - `AmbientFileImportSpec ::= StringLiteral`
  - `FileImportSpec ::= '{' ImportBindingListOpt '}' 'from' ImportFrom`
  - `FileDefaultImportSpec ::= NameToken 'from' ImportFrom`
  - `ImportBindingListOpt ::= ImportBindingList | ε`
  - `ImportBindingList ::= ImportBinding (',' ImportBinding)* ','?`
  - `ImportBinding ::= NameToken ('as' NameToken)?`

  - `ReExportDecl ::= 'export' '{' ReExportBindingListOpt '}' ';'`
  - `ReExportBindingListOpt ::= ReExportBindingList | ε`
  - `ReExportBindingList ::= ReExportBinding (',' ReExportBinding)* ','?`
  - `ReExportBinding ::= NameToken ('as' NameToken)?`

  - `DefaultExportDecl ::= 'export' 'default' NameToken ';'`

  - `UsingDecl ::= 'using' Identifier '=' QualifiedName ';' | 'using' QualifiedName UsingAsOpt ';'`
  - `UsingAsOpt ::= ('as' Identifier) | ε`

  - `ExportModifier ::= 'export'?`
  - `FnExportModifier ::= ('export' ('default')?)?`

  For top-level declarations that can be exported, the `ExportModifier`
  appears before the declaration keyword (currently `fn`, `let`, `ext`, `type`,
  `struct`, `enum`, `theory`, `error`, and `interface`):

  - `FnDecl ::= FnSpecs FnExportModifier FnModifierOpt 'fn' FnGenericParamListOpt FnNameOpt FnSignature FnBody`
  - `FnBody ::= Block | ';'`
  - `FnModifierOpt ::= FnModifier*`
  - `FnModifier ::= 'const' | 'pure' | 'task' | 'async'`
  - `FnGenericParamListOpt ::= GenericParamList | ε`
  - `FnNameOpt ::= NameToken | ε`
  - `FnSpecs ::= (FnPrecondition | FnPostcondition | FnContractTheory)*`
  - `FnPrecondition ::= '#require' Expr ';'`
  - `FnPostcondition ::= '#assure' Expr ';'`
  - `FnContractTheory ::= '#theory' Identifier '(' ArgListOpt ')' ';'`

  Formal Silk theories may be declared either at top level (exportable) or
  inline inside blocks (non-exportable):

  - `TheoryDecl ::= TheorySpecs ExportModifier 'theory' Identifier '(' TheoryParamsOpt ')' '{' TheoryBodyItem* '}'`
  - `TheorySpecs ::= (TheoryPrecondition | TheoryPostcondition)*`
  - `TheoryPrecondition ::= '#require' Expr ';'`
  - `TheoryPostcondition ::= '#assure' Expr ';'`
  - `TheoryParamsOpt ::= TheoryParams | ε`
  - `TheoryParams ::= TheoryParam (',' TheoryParam)* ','?`
  - `TheoryParam ::= Identifier ':' Type`
  - `TheoryBodyItem ::= SpecConstStmt | SpecTheoryStmt | TheoryRequires | TheoryInvariant | TheoryEnsures | TheoryVariant`
  - `TheoryRequires ::= '#require' Expr ';'`
  - `TheoryInvariant ::= '#invariant' Expr ';'`
  - `TheoryEnsures ::= '#assure' Expr ';'`
  - `TheoryVariant ::= '#variant' Expr ';'`

  - `FnSignature ::= '(' FnParamsOpt ')' ResultTypeOpt`
  - `FnParamsOpt ::= FnParams | ε`
  - `FnParams ::= GenericParamSectionOpt ';' ParamListOpt | ParamList`
  - `GenericParamSectionOpt ::= GenericParamSection | ε`
  - `GenericParamSection ::= GenericParam (',' GenericParam)* ','?`
  - `ParamListOpt ::= ParamList | ε`
  - `ParamList ::= Param (',' Param)*`
  - `Param ::= VarArgsOpt MutOpt Identifier TypeAnnotationOpt DefaultArgOpt`
  - `VarArgsOpt ::= '...' | ε`
  - `DefaultArgOpt ::= ('=' Expr) | ε`
  - `ResultTypeOpt ::= ('->' TypeNoPipe TypedErrorTypesOpt)?`
  - `TypedErrorTypesOpt ::= ('|' TypeNoPipe)+ | ε`

  Notes:

  - When a top-level `;` appears inside the function parameter list, it splits
    **compile-time** parameters (type/const parameters) from **run-time** value
    parameters.
  - The compile-time side uses `GenericParam` syntax (`T` and `N: int`) and does
    not permit `mut`.
  - `FnNameOpt` is currently permitted only for default-exported functions
    (`export default fn (...) { ... }`). For non-default functions, the `fn`
    identifier is required.
  - Default export statements (`export default Name;`) always name an existing
    symbol; they do not permit anonymous exports.
  - The run-time side uses ordinary `Param` syntax (`mut x: T` or `x: T`, with
    the type annotation optional in Silk).
  - If there is no `;`, the entire list is treated as run-time parameters.
  - Default arguments are supported in function parameter lists:
    - any parameter may provide a default expression (`x: int = 1`),
    - defaulted parameters must be **trailing** (once a parameter has a
      default, all subsequent parameters must also have defaults) because
      call syntax is positional-only in the current language subset,
    - and in the current implementation, default expressions are restricted to
      a constant/literal expression subset (no name references), so they can be
      inlined at call sites during lowering.
    - a parameter declared as `T?` with a default has two effective behaviors
      in the current implementation subset:
      - if the default expression has type `T`, the parameter has effective
        type `T` (the argument may be omitted at call sites, but the callee
        sees a non‑optional value),
      - if the default expression is `None`/`Null`, the parameter remains `T?`
        (the argument may be omitted, and callers may still pass optional
        values explicitly).

  - Varargs parameters are supported:
    - a varargs parameter is declared by prefixing the final parameter with
      `...` (for example `fn f(x: int, ...rest: int) { ... }`),
    - only one varargs parameter is permitted per function and it must be
      **final**,
    - In Silk, varargs parameters:
      - must have an explicit type annotation,
      - may not be `mut`,
      - and may not have a default expression.

  - The `from` string literal is a *module specifier* (either `"..."` or `` `...` ``):
    - strings starting with `./`, `../`, or an absolute path are treated as
      file specifiers and resolve to a module by file path,
    - strings starting with `std/` are treated as std-root file specifiers and
      resolve to a module by file path under the configured stdlib root,
    - other strings are treated as package specifiers and resolve to a package

  - `BindingDecl ::= ('const' | 'let' MutOpt | 'var') Identifier TypeAnnotationOpt InitializerOpt ';'`
  - `LetDecl ::= ExportModifier BindingDecl`
  - `TypeAnnotationOpt ::= (':' Type)?`
  - `InitializerOpt ::= ('=' Expr)?`

  Type aliases are supported:

  - `TypeDecl ::= ExportModifier 'type' TypeDeclKindOpt Identifier '=' Type ';'`
  - `TypeDeclKindOpt ::= TypeDeclKind | ε`
  - `TypeDeclKind ::= 'struct' | 'enum' | 'error' | 'interface' | 'fn' | 'pure' 'fn'`

  `test` declarations are supported as Zig-inspired top-level test blocks:

  - `TestDecl ::= 'test' StringLiteral? Block`

  FFI declarations are also part of the language grammar:

  - `ExtDecl ::= ExportModifier 'ext' NameToken ExtExternNameOpt '=' Type ';'`
  - `ExtExternNameOpt ::= StringLiteral | ε`

  When `ExtExternNameOpt` is present, it sets the linked external symbol name.
  This allows Silk code to bind a local name that differs from the C/FFI symbol
  name (for example to avoid name collisions in wrapper modules).

  The current compiler implementation supports external declarations (`ext`) whose type
  is either:

  - a `FunctionType` (external functions, callable from Silk), or
  - a supported scalar type (external variables, readable as values in Silk).

  the compiler **requires an initializer** for runtime bindings
  (`let`/`var`) and for compile-time constant bindings (`const`). Uninitialized
  declarations like `let x: int;` / `const x: int;` are parsed but rejected by

  Additionally, `const` initializers must be compile-time evaluable; otherwise

  In practice, prefer:

  - `let x: int = 0;` for a zero value, or
  - `let x: T? = None;` for an “empty” optional.

  Struct declarations are also accepted by the current parser:

  - `StructDecl ::= ExportModifier 'struct' Identifier GenericParamListOpt StructExtendsOpt ';' | ExportModifier 'struct' Identifier GenericParamListOpt StructExtendsOpt '{' StructFieldListOpt '}'`
  - `StructExtendsOpt ::= ('extends' QualifiedName) | ε`
  - `GenericParamListOpt ::= GenericParamList | ε`
  - `GenericParamList ::= '(' GenericParamListInnerOpt ')'`
  - `GenericParamListInnerOpt ::= GenericParamListInner | ε`
  - `GenericParamListInner ::= GenericParam (',' GenericParam)* ','?`
  - `GenericParam ::= Identifier (':' Type)? ('=' Type)?`
  - `StructFieldListOpt ::= StructFieldList | ε`
  - `StructFieldList ::= StructField (',' StructField)* ','?`
  - `StructField ::= Identifier ':' Type StructFieldDefaultOpt`
  - `StructFieldDefaultOpt ::= ('=' Expr) | ε`

  Enum declarations are part of the core language design. They are specified in

  - `EnumDecl ::= ExportModifier 'enum' Identifier GenericParamListOpt '{' EnumVariantListOpt '}'`
  - `EnumVariantListOpt ::= EnumVariantList | ε`
  - `EnumVariantList ::= EnumVariant (',' EnumVariant)* ','?`
  - `EnumVariant ::= Identifier EnumVariantPayloadOpt`
  - `EnumVariantPayloadOpt ::= ('(' TypeListOpt ')') | ε`

  Interface and impl declarations are part of the language design and are
  parsed by the front-end as the syntax is implemented:

  - `InterfaceDecl ::= ExportModifier 'interface' Identifier GenericParamListOpt InterfaceExtendsOpt '{' InterfaceItem* '}'`
  - `InterfaceExtendsOpt ::= ('extends' QualifiedName) | ε`
  - `InterfaceMethodDecl ::= 'fn' NameToken FnSignature ';'`
  - `InterfaceItem ::= InterfaceMethodDecl | UsingDecl`

  - `ImplDecl ::= 'impl' QualifiedName GenericParamListOpt ImplAsOpt '{' ImplMemberDecl* '}'`
  - `ImplAsOpt ::= ('as' QualifiedName TypeArgListOpt) | ε`
  - `ImplMemberDecl ::= FnDecl | UsingDecl` (within an `impl` block, `export` is
    reserved for static members with no `self` receiver; instance method
    visibility uses `public`/`private`)

  Note: const-parameter-style generics (`N: int` parameters and integer literal
  type arguments like `Foo(u8, 1024)`) remain tracked work; the front-end parses
  these surface forms but the current implementation focuses on type parameters
  and monomorphization for type arguments.

  Exception: the nominal optional form `Option(T)` is recognized as sugar for
  `T?` and is accepted in Silk.

- Types:

  - `Type ::= UnionType`
  - `UnionType ::= TypeNoPipe ('|' TypeNoPipe)*`
  - `TypeNoPipe ::= BaseType TypeSuffix`
  - `TypeSuffix ::= TypeSuffixElem TypeSuffix | ε`
  - `TypeSuffixElem ::= OptionalTypeSuffix | ArrayTypeSuffix`
  - `OptionalTypeSuffix ::= '?' | '??'`
  - `ArrayTypeSuffix ::= '[' ']' | '[' ArrayLen ']'`
  - `ArrayLen ::= IntLiteral | Identifier`
  - `BaseType ::= ReferenceType | FunctionType | '(' Type ')' | SimpleType`
  - `ReferenceType ::= '&' BaseType`
  - `FunctionType ::= 'fn' '(' TypeListOpt ')' ResultTypeOpt`
  - `TypeListOpt ::= TypeList | ε`
  - `TypeList ::= Type (',' Type)*`
  - `SimpleType ::= PrimitiveType | NamedType`
  - `PrimitiveType ::= 'bool' | 'i8' | 'u8' | 'i16' | 'u16' | 'i32' | 'u32' | 'i64' | 'u64' | 'i128' | 'u128' | 'int' | 'f32' | 'f64' | 'f128' | 'char' | 'string' | 'void' | 'Instant' | 'Duration'`
  - `NamedType ::= QualifiedName TypeArgListOpt`
  - `TypeArgListOpt ::= ('(' TypeArgListInnerOpt ')') | ε`
  - `TypeArgListInnerOpt ::= TypeArgListInner | ε`
  - `TypeArgListInner ::= TypeArg (',' TypeArg)* ','?`
  - `TypeArg ::= Type | IntLiteral`

  This means that type annotations such as `string?` or `int??` are parsed
  into nested optional types. For simple nominal optionals, the parser also
  recognizes `Option(T)` and desugars it to the same internal representation
  as `T?`. Borrowed reference types (`&T`) are now parsed in type annotations.
  Array/slice types (`T[]`, `T[N]`) are
  parsed and type-checked in Silk (with element-type
  restrictions), and are part of the implemented expression grammar via array
  literals (`[a, b, c]`) and indexing (`xs[i]`). Function types
  (`fn (T, ...) -> R`) are parsed as part of the `Type` grammar, and function
  values are supported in the current lowering subset (including capturing

- Statements:

  - `Stmt ::= LetStmt | SpecConstStmt | SpecAssertStmt | SpecTheoryDeclStmt | SpecTheoryStmt | AsyncBlockStmt | TaskBlockStmt | ExprStmt | IfStmt | LoopStmt | WhileStmt | ForStmt | MatchStmt | ReturnStmt | PanicStmt | AssertStmt | BreakStmt | ContinueStmt`

  - `LetStmt ::= ('const' | 'let' MutOpt | 'var') LetBinder TypeAnnotationOpt InitializerOpt ';'`
  - `LetBinder ::= Identifier | '_' | LetTupleBinder | LetStructBinder | LetArrayBinder | LetEnumBinder`
  - `LetTupleBinder ::= '(' LetTupleBinderItemsOpt ')'`
  - `LetTupleBinderItemsOpt ::= LetTupleBinderItem (',' LetTupleBinderItem)* ','? | ε`
  - `LetTupleBinderItem ::= Identifier | '_'`
  - `LetStructBinder ::= '{' LetStructBinderItemsOpt '}'`
  - `LetStructBinderItemsOpt ::= LetStructBinderItem (',' LetStructBinderItem)* ','? | ε`
  - `LetStructBinderItem ::= Identifier ('as' (Identifier | '_'))?`
  - `LetArrayBinder ::= '[' LetArrayBinderItemsOpt ']'`
  - `LetArrayBinderItemsOpt ::= LetArrayBinderItem (',' LetArrayBinderItem)* ','? | ε`
  - `LetArrayBinderItem ::= Identifier | '_'`
  - `LetEnumBinder ::= QualifiedName '(' LetEnumBinderItemsOpt ')'`
  - `LetEnumBinderItemsOpt ::= LetEnumBinderItem (',' LetEnumBinderItem)* ','? | ε`
  - `LetEnumBinderItem ::= Identifier | '_'`
  - `SpecConstStmt ::= '#const' Identifier '=' Expr ';'`
  - `SpecAssertStmt ::= '#assert' Expr ';'`
  - `SpecTheoryDeclStmt ::= '#theory' Identifier '(' TheoryParamsOpt ')' '{' TheoryBodyItem* '}'`
  - `SpecTheoryStmt ::= '#theory' Identifier '(' ArgListOpt ')' ';'`
  - `AsyncBlockStmt ::= 'async' Block`
  - `TaskBlockStmt ::= 'task' Block`
  - `MutOpt ::= 'mut' | ε`
  - `ExprStmt ::= Expr ';'`
  - `IfStmt ::= 'if' Expr Block ('else' (IfStmt | Block))?`
  - `LoopStmt ::= LoopPrefixOpt 'loop' Block`
  - `LoopPrefixOpt ::= 'async' | 'task' | ε`
  - `WhileStmt ::= WhileSpecs 'while' Expr Block`
  - `WhileSpecs ::= (LoopInvariant | LoopVariant | LoopMonovariant)*`
  - `LoopInvariant ::= '#invariant' Expr ';'`
  - `LoopVariant ::= '#variant' Expr ';'`
  - `LoopMonovariant ::= '#monovariant' Expr ';'`
  - `ForStmt ::= ForInStmt | ForCStmt`
  - `ForInStmt ::= 'for' ForBinder 'in' Expr (RangeOp Expr)? Block`
  - `ForCStmt ::= 'for' '(' ForInit ';' Expr ';' Expr ')' Block`
  - `ForInit ::= ('const' | 'let' MutOpt | 'var') Identifier TypeAnnotationOpt '=' Expr`
  - `ForBinder ::= Identifier | '_'`
  - `RangeOp ::= '..' | '..='`
  - `BlockStmt ::= Block`
  - `Block ::= '{' Stmt* '}'`
  - `ReturnStmt ::= 'return' ExprOpt ';'`
  - `ExprOpt ::= Expr?`
  - `PanicStmt ::= 'panic' QualifiedName StructLiteralSuffixOpt ';'`
  - `AssertStmt ::= 'assert' Expr ';' | 'assert' '(' Expr (',' Expr)? ')' ';'`
  - `BreakStmt ::= 'break' ';'`
  - `ContinueStmt ::= 'continue' ';'`
  - `WithStmt ::= 'with' Identifier Block
                | 'with' WithBytes Block
                | 'with' WithBytes 'from' Identifier WithFromSliceOpt Block`
  - `WithBytes ::= IntLiteral | '(' IntLiteral ')'`
  - `WithFromSliceOpt ::= '[' IntLiteral '..' IntLiteralOpt ']' | ε`
  - `IntLiteralOpt ::= IntLiteral | ε`
  - `MatchStmt ::= 'match' Expr '{' MatchStmtArmListOpt '}'`
  - `MatchStmtArmListOpt ::= MatchStmtArmList | ε`
  - `MatchStmtArmList ::= MatchStmtArm (',' MatchStmtArm)* ','?`
  - `MatchStmtArm ::= MatchStmtPattern '=>' Block`
  - `OptionalPattern ::= 'None'
                      | 'Some' '(' (Identifier | '_') ')'`

  - `MatchStmtPattern ::= OptionalPattern
                        | '_'
                        | Identifier
                        | (Identifier | '_') ':' QualifiedName`
  - `StructLiteralSuffixOpt ::= StructLiteralSuffix | ε`


  `match` is implemented in two separate forms:

  - `match` as an expression (arms are expressions; see `MatchExpr` below),
  - `match` as a statement (arms are blocks), used for typed errors as

  In the current implementation, the `match` statement form is restricted to a
  call-expression scrutinee and the patterns listed above.

- Expressions:

  Expressions follow a conventional precedence hierarchy, as implemented in
  `src/parser.zig`:

  - `Expr ::= Assign`
  - `Assign ::= Coalesce (AssignOp Assign)?`
  - `AssignOp ::= '=' | '+=' | '-=' | '*=' | '/='`
  - `Coalesce ::= LogicalOr ('??' Coalesce)?`
  - `LogicalOr ::= LogicalAnd ('||' LogicalAnd)*`
  - `LogicalAnd ::= BitOr ('&&' BitOr)*`
  - `BitOr ::= BitXor ('|' BitXor)*`
  - `BitXor ::= BitAnd ('^' BitAnd)*`
  - `BitAnd ::= Equality ('&' Equality)*`
  - `Equality ::= TypeTest (('==' | '!=') TypeTest)*`
  - `TypeTest ::= Relational ('is' Type)?`
  - `Relational ::= Shift (('<' | '<=' | '>' | '>=') Shift)*`
  - `Shift ::= AddSub (('<<' | '>>') AddSub)*`
  - `AddSub ::= MulDiv (('+' | '-') MulDiv)*`
  - `MulDiv ::= Unary (('*' | '/' | '%') Unary)*`
  - `Unary ::= ('!' | '~' | '-' | 'mut' | 'move' | 'new' | 'await' | 'yield' | 'sizeof' | 'alignof' | 'offsetof' | 'typename' | '&' | '*' | '++' | '--') Unary | Postfix`
  - `Postfix ::= Primary PostfixSuffix*`
  - `PostfixSuffix ::= CallSuffix | FieldSuffix | OptionalFieldSuffix | StructLiteralSuffix | IndexSuffix | SliceSuffix | CastSuffix | TrySuffix | IncDecSuffix`
  - `CallSuffix ::= '(' CallArgsOpt ')'`
  - `FieldSuffix ::= '.' NameToken`
  - `OptionalFieldSuffix ::= '?.' NameToken`
  - `StructLiteralSuffix ::= '{' StructInitListOpt '}'`
  - `IndexSuffix ::= '[' Expr ']'`
  - `SliceSuffix ::= '[' SliceBoundOpt '..' SliceBoundOpt ']'`
  - `SliceBoundOpt ::= Expr | ε`
  - `CastSuffix ::= 'as' RawOpt Type CastSliceLenOpt`
  - `CastSliceLenOpt ::= '(' Expr ')' | ε`
  - `RawOpt ::= 'raw' | ε`
  - `TrySuffix ::= '?'`
  - `IncDecSuffix ::= '++' | '--'`
  - `StructInitListOpt ::= StructInitList | ε`
  - `StructInitList ::= StructInit (',' StructInit)* ','?`
  - `StructInit ::= NameToken (':' Expr)?`

  - `CallArgsOpt ::= CallArgs | ε`
  - `CallArgs ::= GenericArgListOpt ';' ArgListOpt | ArgList`
  - `GenericArgListOpt ::= GenericArgList | ε`
  - `GenericArgList ::= GenericArg (',' GenericArg)* ','?`
  - `GenericArg ::= Type | IntLiteral`

  - `ArgListOpt ::= ArgList | ε`
  - `ArgList ::= Expr (',' Expr)*`

  Note: the parser treats `mut <expr>`, `new <expr>`, `await <expr>`, `await * <expr>`,
  `yield <expr>`, `yield * <expr>`, `sizeof <expr>`, `alignof <expr>`, `offsetof(Type, field_path)`,
  `typename <expr>`, and prefix `++<expr>` / `--<expr>` as unary expressions.

  Note: `CastSliceLenOpt` is permitted only when `Type` is a slice type (`T[]`)
  and `RawOpt` is `ε` (it is used by unsafe pointer→slice casts like
  `ptr as u8[](len)`).

  - The type checker currently permits `mut <expr>` only in call arguments (and
    method receivers) when the corresponding parameter is declared `mut` and is:
    - a borrowed reference type (`mut r: &T`), or
    - a slice type (`mut s: T[]`).
  - The `move <expr>` unary form is used for explicit ownership transfer; in the
     it is restricted to `move <name>` where `<name>` is a local
    binding.
  - The type checker currently permits `new <expr>` only when it can determine a
    concrete reference result type of the form `&Struct`. In the current
    implementation this happens either:
    - from an expected `&Struct` type context (for example `let x: &Packet = new
      Packet{ ... };` or as a call argument whose parameter type is `&Struct`)
    - from the operand itself when it names the struct type (for example `let x
      = new Packet{ ... };` or `let x = new Packet(...);`)
    `new` is supported only in function bodies (not in top-level `let`
    initializers).

  - `Primary ::= IntegerLiteral
               | DurationLiteral
               | FloatLiteral
               | StringLiteral
               | RegexpLiteral
               | CharLiteral
               | 'true'
               | 'false'
               | 'None'
               | 'null'
               | 'Some' '(' Expr ')'
               | ArrayLiteral
               | IfExpr
               | MatchExpr
               | FnExpr
               | '(' Expr ')'
               | InferredStructLiteral
               | QualifiedName`

  - `RegexpLiteral ::= '/' RegexpBody '/' RegexpFlagsOpt`
  - `RegexpFlagsOpt ::= Identifier | ε`

  Notes:
  - `RegexpBody` is scanned by the parser (not the lexer): it is the byte span
    between the opening and closing `/`, where the closing delimiter is the
    first unescaped `/` that is not inside a character class (`[...]`).

  - `ArrayLiteral ::= '[' ExprListOpt ']'`
  - `ExprListOpt ::= ExprList | ε`
  - `ExprList ::= Expr (',' Expr)* ','?`

  - `QualifiedName ::= GlobalPrefixOpt NameToken ('::' NameToken)*`
  - `GlobalPrefixOpt ::= '::' | ε`

  - `InferredStructLiteral ::= '{' StructInitListOpt '}'`

  - `FnExpr ::= 'fn' '(' LambdaParamListOpt ')' '->' LambdaBody`
  - `LambdaParamListOpt ::= LambdaParamList | ε`
  - `LambdaParamList ::= LambdaParam (',' LambdaParam)* ','?`
  - `LambdaParam ::= Identifier ':' Type`
  - `LambdaBody ::= Type Block | Expr`

  Disambiguation rule (current parser):

  - `fn (...) -> Type Block` is treated as the block-body form only when the
    return type is followed immediately by `{` (starting the block).
  - Otherwise, `fn (...) -> Expr` is treated as an expression-body function
    expression and its result type is inferred by the checker.

  Notes:

  - `InferredStructLiteral` has the same token-level shape as
    `StructLiteralSuffix` (used for `Type{ ... }`), but appears as a `Primary`
    expression with **no explicit type name**. The type checker requires an
    expected struct type context to resolve the literal’s target type.
  - To avoid ambiguity with statement blocks, the parser only recognizes
    `InferredStructLiteral` when the `{ ... }` contents look like a struct
    initializer list (or are `{}`): either the first token after `{` is `}` or
    it is an `Identifier` followed by `:` (explicit initializer) or followed by
    `,` / `}` (shorthand initializer).

  - `MatchExpr ::= 'match' Expr '{' MatchArmListOpt '}'`
  - `MatchArmListOpt ::= MatchArmList | ε`
  - `MatchArmList ::= MatchArm (',' MatchArm)* ','?`
  - `MatchArm ::= MatchExprPattern '=>' Expr`
  - `MatchExprPattern ::= OptionalPattern | EnumVariantPattern | ResultPattern`

  - `IfExpr ::= 'if' Expr IfExprBlock 'else' (IfExpr | IfExprBlock)`
  - `IfExprBlock ::= '{' Expr '}'`

  - `ResultPattern ::= ('Ok' | 'Err') '(' (Identifier | '_') ')'`

  - `EnumVariantPattern ::= EnumVariantName EnumVariantBinderListOpt`
  - `EnumVariantName ::= ('::')? Identifier '::' Identifier ('::' Identifier)*`
  - `EnumVariantBinderListOpt ::= ('(' EnumVariantBinderListInnerOpt ')') | ε`
  - `EnumVariantBinderListInnerOpt ::= EnumVariantBinderList | ε`
  - `EnumVariantBinderList ::= EnumVariantBinder (',' EnumVariantBinder)* ','?`
  - `EnumVariantBinder ::= Identifier | '_'`

- Declarations:

  - `Decl ::= ... | ErrorDecl`
  - `ErrorDecl ::= ExportModifier 'error' Identifier '{' StructFieldListOpt '}'`

  This matches the current AST and checker:

  - `Primary` constructs `Literal` or `Name` expressions (or a parenthesized `Expr`),
  - unary expressions are represented as `UnaryExpr` with a token kind indicating the
    operator,
  - binary expressions are represented as `BinaryExpr` with a token kind indicating
    the operator,
  - identifiers and qualified names are stored as `NameExpr` with the full
    slice of source text (e.g. `util::answer`),
  - simple function calls such as `helper()` or `util::helper(1, 2)` are
    parsed as call expressions using the `Postfix`/`CallSuffix` productions;
    the current implementation supports calls to named functions, but the type checker
    and back-end currently restrict which value types can appear at call boundaries;

Further expression forms (ranges, etc.) are described in other
parser now accepts `?.` optional field access (`opt?.field`) and the initial
`match` expression form as part of the implemented optional subset, but other
expression forms will be added here as they are implemented.

## Role of This File

This document serves as the reference for:

- lexer implementation (token categories and reserved words),
- parser implementation (production rules and precedence),
- pretty-printer or formatter behavior.

As the parser and lexer are implemented, this file must be updated with:

- the exact grammar that the compiler accepts (including any temporary limitations),
- clarifications or corrections discovered during implementation (recorded here so this file remains canonical),
- notes about desugaring and how surface constructs map into the internal AST,
- clear indication of which productions are implemented today vs. planned
  future work, so that downstream users can see both the full language
  design and the currently supported subset.

==============================================================================
DOCS: Formal Silk (language/formal-verification)
URL: /silk/docs/?p=language/formal-verification
==============================================================================

# Formal Silk

Formal Silk is Silk’s compile-time formal verification language. It is written
using syntax that does not exist at runtime and is discharged at compile time
using the Z3 SMT solver.


When Formal Silk syntax is present, compilation generates verification
conditions (VCs), proves them with Z3, and fails the build if any VC cannot be
proven. This behavior applies to:

- the `silk` CLI (`silk check`, `silk test`, `silk build`), and
- the C ABI build entrypoints (`silk_compiler_build`, `silk_compiler_build_to_bytes`).

## Proof requirements are opt-in by syntax

Silk requires proofs only when verification syntax is present in the compiled
module set:

- any use of `#...` directives (`#require`, `#assure`, `#assert`, `#invariant`,
  `#variant`, `#monovariant`, `#const`), and/or
- any use of `where` predicates (for example refinement-type binders).

Note: `where` predicates are not implemented yet. When they land, they will
also be treated as verification syntax.

When verification syntax is present, compilation MUST:

1. generate VCs,
2. prove them using Z3, and
3. fail compilation with clear diagnostics if any VC cannot be proven.

When verification syntax is not present, compilation does not require proofs.

## Z3 linkage and overrides

On `linux/x86_64`, Silk always links the vendored Z3 static library
(`vendor/lib/x64-linux/libz3.a`) and its headers (`vendor/include`).

To override the Z3 library at runtime (for example to test against a different
Z3 build), provide a dynamic library path:

- CLI: pass `--z3-lib <path>`, or
- CLI/ABI: set `SILK_Z3_LIB` in the environment.

When `--z3-lib` is provided, it overrides `SILK_Z3_LIB`.

## Debugging proofs with Z3 (`--debug`)

When a verification condition fails, the compiler reports a normal diagnostic
at the failing annotation site.

When `--debug` is passed to `silk build` or `silk test`, the verifier also emits
additional Z3 debugging output to stderr and writes an SMT-LIB2 reproduction
script under `.silk/z3/` in the current working directory (or `$SILK_WORK_DIR/z3`):

- `.silk/z3/silk_z3_m<module>_<n>.smt2`

You can replay the query with an external Z3 binary:

```sh
z3 -smt2 .silk/z3/silk_z3_m0_0.smt2
```

## Z3 model ()

The current Formal Silk verifier maps Silk constructs directly to Z3:

- `bool` → Z3 Bool.
- `string` → Z3 String (: literals and equality/inequality comparisons).
- integer primitives → fixed-width Z3 bitvectors:
  - `i8`/`u8` → BV8
  - `i16`/`u16` → BV16
  - `i32`/`u32` → BV32
  - `i64`/`u64`/`int` → BV64

  Arithmetic is modular 2^N (wraparound). Ordered comparisons and `>>` use
  signed semantics for signed integers (`i*`/`int`) and unsigned semantics for
  unsigned integers (`u*`).

Supported operators in specification expressions ():

- boolean: `!`, `&&`, `||`, `==`, `!=`
- string: `==`, `!=`
- integer:
  - unary: `-`, `~`
  - arithmetic: `+`, `-`, `*`, `/`, `%`
  - bitwise: `&`, `|`, `^`, `<<`, `>>`
  - comparisons: `<`, `<=`, `>`, `>=`, `==`, `!=`
- size/layout queries: `sizeof`, `alignof`, `offsetof` (type operands and other statically-sized operands in Silk)

Other operators and expression forms are currently rejected in verified code
(see “Implementation Status” below).

## The `ext` boundary

External declarations (`ext`) have no body available to the verifier.

Therefore:

- The verifier cannot generate VCs about the behavior of `ext` bodies.
- In the current verifier subset, calls are supported only to functions that
  have Formal Silk contracts (see “Calls in verified code” below). `ext`
  declarations do not have Formal Silk contracts yet, so verified code cannot
  call `ext` functions.


The main constructs are:

- `#const` — formal Silk declarations used inside specifications.
- `#require` — precondition.
- `#assure` — postcondition.
- `#assert` — block-local proof obligation.
- `#invariant` — loop or state invariant.
- `#variant` — well-founded termination measure (ranking function).
- `#monovariant` — monotonic measure (non-decreasing or non-increasing).
- `theory` / `#theory` — reusable, parameterized proof obligations.

Key properties:

- These annotations appear before the function or loop they describe.
- They are used by the verifier only and incur no runtime cost.

### Formal Silk declarations (`#const`)

Formal Silk declarations let you name intermediate values for use in specifications.

Syntax:

```silk
#const name = <Expr>;
```

Rules:

- `#const` is a statement that may appear inside function bodies (inside blocks).
- The binding is **compile-time-only** and is not lowered into runtime code.
- A `#const` binding is visible only inside specification expressions:
  - function specs (`#require`, `#assure`),
  - loop specs (`#invariant`, `#variant`, `#monovariant`).
- Using a `#const` name in a runtime expression (e.g. in `while` conditions or normal
  `let` initializers) is a compile-time error. Use a normal `let` binding for
  runtime values, and (optionally) introduce a `#const` alias for specifications.

Example:

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  while i < limit {
    i = i + 1;
  }
  return 0;
}
```

### Function annotations (initial syntax)

For functions, the initial surface syntax is:

```silk
#require <Expr>;
#require <Expr2>;
#assure <Expr3>;
#theory TheoryName(args...);
fn name (params) -> ResultType {
  ...
}
```

- One or more `#require`, `#assure`, and contract-theory attachments
  (`#theory Name(args...);`) may appear, in any order, immediately before the
  `fn` declaration (and before any `export` modifier).
- Each annotation is terminated by a semicolon.
- The compiler front-end:
  - lexes these annotations as dedicated tokens,
  - parses the annotation expressions using the normal expression grammar,
  - type-checks each annotation expression as `bool` so obvious mistakes are
    rejected early (specifications are still compile-time-only metadata),
  - attaches them to the corresponding function in the AST as lists of
    preconditions, postconditions, and contract theories.

Loop specifications (`#invariant`, `#variant`, `#monovariant`) follow a similar
pattern for loops.

### Loop annotations (initial syntax)

For `while` loops, the initial surface syntax is:

```silk
#invariant <Expr>;
#variant <Expr2>;
#monovariant <Expr3>;
while condition {
  ...
}
```

Rules:

- One or more `#invariant` annotations, zero or more `#monovariant` annotations,
  and at most one `#variant` annotation may appear immediately before the
  `while` keyword.
- Each annotation is terminated by a semicolon.
- The compiler front-end:
  - lexes these annotations as directive tokens,
  - parses the annotation expressions using the normal expression grammar,
  - attaches them to the corresponding loop in the AST as invariants,
    monovariants, and a (single) variant expression.

The verifier will interpret:

- `#invariant` expressions (type `bool` in Silk) as properties that must hold:
  - before entering the loop,
  - after each iteration (assuming the body and condition do not diverge),
  - and at `break` exits (so proofs after the loop may rely on the invariant).
- `#variant` expressions as a well-founded measure that must decrease on each
  iteration (and be non-negative at the loop head), used for termination proofs.
- `#monovariant` expressions as measures that must be monotonic on each
  iteration (either non-decreasing or non-increasing, proved consistently across
  all continuation paths).

Compiler requirements:

- Parse and represent these annotations in the AST.
- Integrate with the verifier to check specifications.
- Ensure that, if verification fails, compilation fails with clear diagnostics.

### Block assertions (`#assert`)

Formal Silk also supports block-local proof obligations:

```silk
#assert <Expr>;
```

Rules:

- `#assert` is a statement that may appear inside function/test bodies (inside
  blocks).
- It is compile-time-only metadata and is not lowered into runtime code.
- The verifier must prove the assertion holds in the current symbolic state at
  the `#assert` site. If it cannot be proven, compilation fails.
- After a `#assert` succeeds, the asserted expression is assumed to hold for
  the remainder of the block (so later proofs may rely on it).

## Theories (`theory` / `#theory`)

A **theory** is a reusable, parameterized block of Formal Silk directives that
can be applied at points inside a function body to assert properties about the
current symbolic state.

### Syntax

Declaration form (top-level):

```silk
export theory a_custom_theory (x: int, y: int) {
  #const z = x + y;
  #invariant x != 0 && y != 0;
  #invariant z > 1;
}
```

An inline theory declaration may also appear as a statement inside a
function/test block:

```silk
fn main (x: int, y: int) -> int {
  #theory local_sum_nonzero (x: int, y: int) {
    #const z = x + y;
    #assure z != 0;
  }

  #theory local_sum_nonzero(x, y);
  return 0;
}
```

Use form (statement inside a function body, or inside another theory body):

```silk
fn main (x: int, y: int) -> int {
  #theory a_custom_theory(x, y);
  return 0;
}
```

Theories may apply other theories:

```silk
export theory nonzero (x: int) {
  #require x != 0;
}

export theory nonzero_sum (x: int, y: int) {
  #theory nonzero(x);
  #theory nonzero(y);
  #assure (x + y) != 0;
}
```

Notes:

- Top-level theory declarations use the `theory` keyword.
- Inline (block) theory declarations and theory use sites share the `#theory`
  token; the parser disambiguates by the token that follows the
  argument/parameter list:
  - `{ ... }` starts an inline theory declaration,
  - `;` terminates a theory use.
- A top-level theory declaration may be exported (`export theory ...`). Exported
  theories may be imported from other modules and reused.
- Inline theory declarations inside a block are not exportable/importable; they
  exist only in the containing block and may be applied via `#theory Name(...);`
  after they are declared.
- A theory body may contain `#theory Name(args);` statements. These are
  compile-time-only theory applications; they are checked by the verifier in the
  current symbolic state at the point they appear in the theory body.
- Theory recursion is rejected (direct or indirect cycles).
- Theories are not runtime functions. They can only be applied via `#theory` use
  statements; calling a theory with normal call syntax (`Name(...)`) is a
  compile-time error.

### Prefix `#require` / `#assure` on theories

For ergonomics, a `theory` declaration may be preceded by `#require` and/or
`#assure` directives:

```silk
#require x >= 0;
export theory ensure_nonnegative_x (x: int) {
  #assure x >= 0;
}
```

These prefix directives are treated as if they were written at the beginning of
the theory body.

### Theories as function contracts

A function may attach one or more theories as part of its Formal Silk contract
surface by placing `#theory Name(args...);` directives in the function-spec
prelude:

```silk
import { bounded_nonneg_add } from "./theories.slk";

#theory bounded_nonneg_add(x, y);
export fn add (x: int, y: int) -> int {
  return x + y;
}
```

Contract-theory attachments:

- are compile-time-only metadata (not runtime statements),
- contribute additional preconditions/postconditions to the function contract:
  - `#require` become additional function preconditions,
  - `#assure` and `#invariant` become additional function postconditions,
- are used by the verifier to enable contracted calls in verified code (see
  “Calls in verified code” above),
- are not permitted before a top-level `theory` declaration (only `#require` /
  `#assure` may prefix a theory declaration).

### Importing theories

Exported theories may be imported via JS-style named imports and then applied
via `#theory` use statements.

Example:

```silk
// theories.slk
export theory ensure_positive_x (x: int) {
  #assure x > 0;
}
```

```silk
// main.slk
import { ensure_positive_x as pos_x } from "./theories.slk";

fn main () -> int {
  let x: int = 1;
  #theory pos_x(x);
  return 0;
}
```

Rules:

- Only exported theories may be imported.
- A theory use (`#theory Name(args);`) resolves `Name` as either:
  - a local theory declared in the same module, or
  - an imported theory name from `import { ... } from "<specifier>";`.
- Namespace imports (`import ns from "<specifier>";`) do not currently provide
  theory access, because theory use sites do not accept qualified names
  (`ns::TheoryName`) yet.

### Semantics (initial subset)

When a theory is applied (`#theory Name(args);`):

- its parameters are bound to the provided argument expressions (as
  specification expressions),
- its `#const` formal declarations are evaluated and are visible only within the
  theory during checking,
- each `#require <Expr>;`, `#invariant <Expr>;`, and `#assure <Expr>;`
  directive in the theory body is treated as a compile-time proof obligation
  that must hold in the current symbolic state at the use site,
- each `#variant <Expr>;` directive in the theory body is treated as a
  non-negativity obligation (`Expr >= 0`) at the use site (the theory form does
  not model decrease across iterations).

Theory bodies are verifier-only:

- Theory argument expressions and theory directive expressions are **Formal Silk
  specification expressions** evaluated by the verifier.
- In Silk, specification expressions do not support function
  calls or value construction (for example `foo(x)`, `Type{...}`, arrays, or
  `new`). Such expressions are rejected as unsupported Formal Silk.

The theory form is compile-time-only and has no runtime semantics.

==============================================================================
DOCS: Function Disciplines (`pure`, `task`, `async`) (language/function-disciplines)
URL: /silk/docs/?p=language/function-disciplines
==============================================================================

# Function Disciplines (`pure`, `task`, `async`)

This document specifies Silk’s intended “function discipline” system: how
functions declare whether they are pure, asynchronous, or safe to run as
parallel tasks.

Const functions (`const fn`) are specified separately in
discipline system described here (a `const fn` may also be declared `pure`).

`pure fn` parsing and a strict purity checker. Concurrency disciplines (`task` /
`async`) are parsed and `Task(T)` / `Promise(T)` handles plus `yield` (task
values) and `await` (promise values) are implemented in Silk
(`await Task(T)` is rejected), but the compiler does not yet implement an async
event loop, coroutine lowering, or task-safety (`Send`/`Sync`) rules. See
status.

## Overview

The language design distinguishes:

- `fn` — normal function (may perform effects; blocking).
- `pure fn` — function with no observable side effects (referentially
  transparent).
- `task fn` — function safe to execute on a worker pool as a parallel task.
- `async fn` — function that may suspend at `await` points (returns an
  awaitable).
- `async task fn` — async function executed as a separate task (self-contained
  worker).

## Intended Call Rules (Design)

The checker is expected to enforce:

- `pure` code may call only `pure` code (and cannot perform I/O or mutation
  outside local, non-escaping temporaries).
- `task` code may call `task` and `pure` code, and must satisfy task-safety
  rules for captured/argument data.
- `async` code may `await` other async operations; it may call `pure` code and
  may offload blocking work via explicit adapters (planned intrinsics).

Crossing discipline boundaries is intended to be explicit and diagnostic-driven
(for example suggesting the correct adapter/intrinsic).

## Standard Intrinsics

The standard library is expected to provide typed adapters to cross boundaries
safely (names and exact signatures are design work):

- lifting sync work onto a task pool,
- presenting a task as an async operation,
- running blocking work from async without stalling the event loop,
- structured spawn/join primitives.

These APIs are not yet present in the in-tree `std/` implementation.

## Implementation Notes

Today:

- `pure fn` is parsed and checked ():
  - a `pure fn` may call only `pure` functions; `ext` is treated as impure,
  - the checker also supports purity inference (“auto-pure”) for ordinary `fn`
    declarations and `impl` methods:
    - when an unannotated function/method has an eligible signature and its
      body satisfies the purity rules, it is treated as `pure` for call
      checking, and may be called from `pure` code,
    - functions/methods with `&T` parameters are not eligible for inference
      (explicit `pure fn` remains supported for `&T` parameters in the current
      subset),
  - `pure` cannot be combined with `task` or `async` in Silk,
  - a `pure fn` may not have `mut` parameters,
  - a `pure fn` may not declare mutable locals (`var` or `let mut`) and may not
    perform mutation via assignment,
  - a `pure fn` may not allocate (`new`) in Silk,
  - a `pure fn` may not have a typed-error contract (`-> T | Error...`) and may
    not contain `panic` statements.
- `task fn`, `async fn`, and `async task fn` are parsed and preserved in the AST.
- Calls across disciplines are now reflected in expression types:
  - calling a `task fn` yields `Task(T)`,
  - calling an `async fn` yields `Promise(T)`,
  - calling an `async task fn` yields `Promise(Task(T))`,
  - `yield` sends task values (`yield v;`) and receives task values (`yield t`),
    and `yield * t` drains/collects remaining task values into `T[]`,
  - `await` unwraps `Promise(T)` and yields `T` (`await Task(T)` is rejected),
    and `await * ps` unwraps `Promise(T)[]` into `T[]`.
- `await <expr>` and `async { ... }` / `task { ... }` blocks are enforced as
  **async-only** constructs:
  - `await` is only permitted inside `async` functions (including `async task fn`),
  - `async { ... }` / `task { ... }` blocks are only permitted inside `async` functions.
- `yield <expr>` is enforced as a **task-only** construct:
  - `yield` is permitted only inside `task` functions (`task fn` / `async task fn`)
    and inside `task { ... }` / `task loop { ... }` blocks.
- Lowering/codegen implements `task` execution using OS threads on `linux/x86_64`
  and implements `yield`/`yield *` for task values plus `await` for promises.
  - There is not yet a coroutine transformation or event loop; awaiting a
    `Promise(T)` currently does not “park” the OS thread (it is still a
    synchronous unwrap in Silk).
  - `async { ... }` / `task { ... }` blocks are still lexical blocks in the
     (they do not yet introduce scheduler behavior).
- Function types are parsed in type positions (notably for `ext`).
- Function expressions are implemented as first-class function values:
  - `fn (x: int) -> x + 1` (expression body),
  - `fn (x: int) -> int { return x + 1; }` (block body).
  - Function expressions may not declare `&T` parameters.
  - Non-capturing function expressions are inferred as `pure` and are callable
    from `pure` code.
  - Capturing closures are supported as a subset:
    - a function expression may reference immutable locals/parameters from an
      enclosing scope,
    - captures are by-value copies into a heap environment (scalar-only in the
      ),
    - capturing closures are not `pure` and are rejected in `pure` code.
  - Function values (both non-capturing and capturing) are supported end-to-end:
    they may be passed, returned, stored, and called indirectly.

==============================================================================
DOCS: Generics (Monomorphized) (language/generics)
URL: /silk/docs/?p=language/generics
==============================================================================

# Generics (Monomorphized)

This document specifies Silk’s parameterized type and declaration syntax.

parameterized declarations are **monomorphized** into concrete, fully specified
types and functions at build time (there are no runtime type parameters).

Note: `Option(T)` is a special-case surface form that is treated as sugar for
accepted in Silk even as general-purpose type-parameter generics are
implemented.

## Overview

Silk supports parameterized declarations by allowing a parameter list on
`struct`, `interface`, `enum`, `impl`, and `fn` declarations.

In Silk:

- **Supported**: type parameters (`T`) and const parameters (`N: usize`) on
  `struct`/`interface`/`enum`/`impl`, type application in type positions
  (`Name(args...)`), and generic functions using a compile-time parameter
  section separated by `;` in the signature (`fn id(T; x: T) -> T`) (including
  generic methods in `impl` blocks).

## Declaration syntax

### Parameter lists

The parameter list uses parentheses:

```silk
struct Vector(T) {
  // ...
}
```

Rules:

- `T` is a type parameter.
- Type parameters may provide a default type argument using `=`:
  - `interface Serialize(S = string) { ... }`
  - defaults must be **trailing** (once a parameter has a default, all
    subsequent parameters must also have defaults).
- Const parameters are written with an explicit type annotation:
  - `N: usize`
  - const parameters are compile-time integer values and may be used in type
    positions such as array lengths (`T[N]`) and type applications.
- The parameter list may be empty (though it is uncommon): `struct Foo() { ... }`.

Supported declaration forms:

- `struct Name(T, ...) { ... }`
- `interface Name(T, ...) { ... }`
- `enum Name(T, ...) { ... }`
- `impl Name(T, ...) { ... }`
- `impl Name(T, ...) as InterfaceName(T, ...) { ... }`

### Applying parameters in types

Parameterized types are referenced using the same call-like syntax in type
positions:

```silk
Vector(int)
Mutex(Account)
Result(int, string)
```

## Generic enums (tagged unions)

Enums may be parameterized and are monomorphized like generic structs.

Because applied types are not used directly as expression qualifiers in the
current surface syntax, callers typically introduce a local alias for an
instantiation and then use that alias to construct and match variants:

```silk
enum Result(T, E) {
  Ok(T),
  Err(E),
}

type R = Result(int, string);

fn main () -> int {
  let x: R = R::Ok(123);
  return match x {
    R::Ok(v) => v,
    R::Err(_) => 0,
  };
}
```

Default type arguments:

- When a parameterized declaration provides default type arguments, a use site
  may omit **trailing** arguments that have defaults.
- If all parameters have defaults, the type may be referenced as `Name` or
  `Name()` (both are equivalent to applying the defaults).

Type arguments may be:

- types (e.g. `int`, `&Foo`, `Option(string)`).
- integer literals for const parameters (e.g. `Vector(u8, 1024)`).

Const arguments are compile-time integer literals and participate in
monomorphization identity.

## Interfaces and applied interface types

Interfaces may be generic:

```silk
interface Channel(T) {
  fn send(value: T) -> bool;
  fn recv() -> T?;
}
```

An `impl ... as ...` conformance may apply type arguments to the interface:

```silk
struct QueueU8 {
  // ...
}

impl QueueU8 as Channel(u8) {
  // ...
}
```

Rule: when a generic interface is referenced in a concrete `impl X as I(...)`,
all interface type arguments must be fully known at that conformance site. The
only exception is when the conformance itself is generic (type parameters are
in scope), for example:

```silk
struct Data(T) { /* ... */ }
interface DataInterface(T) { /* ... */ }

impl Data(T) as DataInterface(T) {
  // ...
}
```

## Impl blocks for generic structs

If a struct is declared with type parameters, its impl blocks must also declare
those parameters:

```silk
struct Data(T) { /* ... */ }

// OK:
impl Data(T) { /* ... */ }

// Error:
// impl Data { /* ... */ }
```

This rule keeps method receiver typing unambiguous and makes monomorphization
explicit.

## Functions (initial parsed surface form)

Generic functions require a way to declare type/const parameters distinct from
value parameters. The initial parsed surface form is:

```silk
fn get_first(T, N: usize; v: &T[N]) -> T {
  // ...
}
```

Where the `;` separates generic parameters from value parameters inside the
function’s parameter list.

### Alternate (Go-like) function declaration syntax

Silk also supports a Go-like generic header form:

```silk
fn (T, N: usize) get_first (v: &T[N]) -> T {
  // ...
}
```

This is sugar for the `;` form above; the compiler records the same generic
parameter list (`T, N: usize`) either way.

Rules:

- At most one generic parameter list may be provided:
  - either `fn name(T; ...)`,
  - or `fn (T) name (...)`.

### Call syntax for generic functions

Calls mirror the signature split:

```silk
let x: int = get_first(int, 4; &xs);
```

Rules:

- the `;` separates compile-time arguments from runtime value arguments,
- compile-time arguments are a comma-separated list of:
  - type arguments (`int`, `&Foo`, `Option(string)`),
  - and integer literals for const arguments,
- runtime arguments are ordinary expressions.
- the compile-time argument list may be empty when defaults supply all generic
  parameters, for example `id_default(; 1)` uses the default type argument for
  `T` in `fn id_default(T = int; x: T) -> T`.

### Call-site type inference (omitting `;`)

When a call does not include the generic separator (`;`), the compiler may
infer type and const arguments from runtime arguments:

```silk
fn (X, Y) add (x: X, y: Y) -> X {
  return x + y as X;
}

let a = add(1.123, 2); // infers X = f64, Y = int
```

Rules:

- Both **type** parameters (`T`) and **const** parameters (`N: usize`) may be
  inferred.
- Inference is driven by the runtime argument expressions and any types that
  are known at the call site:
  - literals (`123`, `1.0`, `"hi"`, `'a'`, `true`),
  - struct literals (`Point { ... }`),
  - explicit casts (`expr as Type`),
  - and name expressions (`x`) when the binding’s type is known (from an
    annotation like `let x: T = ...` or from a simple initializer like a
    literal/struct literal).
- Const parameters are inferred only from type structure:
  - array lengths (`T[N]`),
  - and const arguments in applied types (`Buffer(T, N)`),
  when the corresponding runtime argument type provides a concrete value.
- When inference cannot determine a type argument, compilation fails with an
  actionable diagnostic. Disambiguate by either:
  - inserting `as` casts on runtime arguments, or
  - using the explicit `;` form (`add(f64, int; 1.123, 2)`).
  When inference cannot determine a const argument, disambiguate by using the
  explicit `;` form (`take_buf(4; buf)`).

## Implementation notes

- Monomorphization produces a concrete instance for each referenced
  instantiation `Name(args...)`.
- Type names share one namespace within a `package`: `struct`, `interface`,
  `enum`, `error`, and `type` declarations may not reuse the same name.
- Name conflicts across generic arities are rejected (for example, `struct Foo`
  and `struct Foo(T)` cannot both exist in the same package namespace).
- Const parameters are currently restricted to integer primitive types; const
  values are usable in type positions (for example `T[N]`) but are not yet
  exposed as runtime values.

==============================================================================
DOCS: Interfaces (language/interfaces)
URL: /silk/docs/?p=language/interfaces
==============================================================================

# Interfaces

Interfaces allow types to declare that they implement a particular contract.
They are the foundation for standard-library “protocols” such as readers,
writers, iterators, and allocators.

Key components:

- The `interface` declaration.
- The `struct` that implements the interface.
- The `impl ... as ...` declaration that ties them together.
- A `module ... as ...` declaration for module-level conformance.

## Interface declarations

An interface declares a set of required method *signatures*.

Syntax:

```silk
interface Element {
  fn onclick(event: &Event) -> void;
}
```

Rules:

- Interface members are method declarations introduced with `fn`.
- Interface methods have **no body** and end with `;`.
- Parameter types in interface methods should be explicitly annotated (the
  compiler should not rely on type inference for interface contracts).
- Interface methods are part of a **public contract**:
  - interfaces do not have private members, and
  - interface method declarations do not accept visibility modifiers.

## Generic interfaces

Interfaces may declare type parameters:

```silk
interface Channel(T) {
  fn send(value: T) -> bool;
  fn recv() -> T?;
}
```

Rules:

- Generic parameter lists use the same syntax as structs (`(T, ...)`).
- Type parameters may provide default type arguments (`T = Type`). When defaults
  are present, use sites may omit trailing arguments that have defaults.
- The interface name is a **type constructor** and must be applied with the
  correct number of type arguments where a concrete interface type is required
  (for example in `impl ... as ...` declarations).

## `Self` in interface signatures

Within an interface method signature, the special type name `Self` refers to
the concrete implementing type when checking `impl Type as Interface { ... }`
conformance.

## Interface inheritance (`extends`)

Interfaces may use `extends` for **single inheritance**:

```silk
interface BaseLogger {
  fn log(msg: string) -> void;
}

interface FancyLogger extends BaseLogger {
  fn warn(msg: string) -> void;
}
```

Semantics:

- An interface that `extends` another interface inherits all of the base
  interface’s method signatures.
- A conformance declaration (`impl T as I` or `module ... as I`) must satisfy
  the full inherited interface surface.

Rules:

- `extends` is permitted only on `interface` declarations.
- Only single inheritance is permitted (at most one `extends` base).
- Cycles in `extends` chains are rejected.
- A derived interface may not redeclare a method with the same name as an
  inherited base method.

## Implementations (`impl ... as ...`)

An implementation block declares that a concrete type implements an interface
and provides method bodies.

Example:

```silk
interface Element {
  fn onclick(event: &Event) -> void;
}

struct Button {
  handle: i64;
}

impl Button as Element {
  fn constructor(...) -> Button { ... }
  fn onclick(self: &Button, event: &Event) -> void { ... }
}
```

Applied interface types:

```silk
interface Read(T) {
  fn read() -> T;
}

struct ByteSource { /* ... */ }

impl ByteSource as Read(u8) {
  fn read(self: &ByteSource) -> u8 { /* ... */ }
}
```

Compiler requirements:

- Represent interface types and `impl ... as ...` relationships.
- Enforce that all required interface methods are implemented with compatible
  signatures.
- Treat required interface methods as **public by definition**:
  - impl methods that satisfy an interface requirement may omit `public`, but
  - they may not be explicitly marked `private`.

Conformance rules (initial implementation):

- For an `interface I { fn m(p0: T0, ...) -> R; }`, the corresponding impl must
  provide a method `m` whose signature matches after accounting for the
  receiver:
  - the impl method’s first parameter is the receiver `self: &Type` (or
    `mut self: &Type`), and
    - the remaining parameters and result type must match the interface method.
- Exception (static protocol, implemented subset):
  - `std::interfaces::Deserialize(S)` is a static conversion protocol used by
    `as` casts. Its conformance does **not** use a receiver parameter:
    - `impl T as std::interfaces::Deserialize(S)` provides
      `fn deserialize(value: S) -> Self` (no `self` parameter),
    - calls use `T.deserialize(value)`.

Generic interface conformance rule:

- When the `as` clause names an applied generic interface type (for example
  `Read(u8)`), all type arguments must be fully known at the conformance site,
  unless the conformance itself is generic and binds those type parameters (for
  example `impl Data(T) as DataInterface(T)`).

## Module conformance (`module ... as ...`)

A module declaration may declare conformance to an interface:

```silk
interface Logger {
  fn log(msg: string) -> void;
}

module my_app::logger as Logger;

export fn log (msg: string) -> void {
  // ...
}
```

Conformance rules:

- For an `interface I { fn m(p0: T0, ...) -> R; }`, the corresponding module must
  provide a function `m` whose signature matches exactly:
  - there is no receiver parameter for module conformance, and
  - the parameter and result types must match the interface method.
- In Silk, module conformance is checked against the
  module’s **exported** functions (written as `export fn ...`), since those are
  the module members that are visible across module boundaries.

Generic module conformance:

- A module may declare conformance to an applied generic interface type
  (for example `module my_app::bytes as Read(u8);`).
- All interface type arguments must be fully specified (modules do not bind
  their own type parameters).

## Dispatch model (status)

objects / vtables) is part of the language design, but is not implemented yet.

For the initial compiler/backend subset, interface use is limited to:

- declaring interfaces and impl blocks, and
- calling methods directly on concrete types (no interface-typed values at
  runtime).
- special-case compiler hooks for specific interfaces (currently
  `std::interfaces::Drop` for deterministic cleanup; see

==============================================================================
DOCS: Language Cheat Sheet (language/cheat-sheet)
URL: /silk/docs/?p=language/cheat-sheet
==============================================================================

# Language Cheat Sheet


## Types (Surface Forms)

- Booleans: `bool` — `true`, `false`.
- Integers: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, `int`.
- Floats: `f32`, `f64`, `f128`.
- Char: `char`.
- String: `string`.
- Time: `Instant`, `Duration`.
- Optional: `T?` (sugar for `Option(T)`).
- References: `&T`.
- Arrays / slices: `T[]`, `T[N]`.
- Maps / dictionaries: `std::map::{HashMap, TreeMap}` (standard library).
- Function types: `fn(params) -> R` (discipline modifiers apply to function
  declarations; function types are unmodified in Silk).
- Function expressions (non-capturing, inferred `pure`):
  - expression body: `fn (x: int, y: int) -> x + y`
  - block body: `fn (x: int, y: int) -> int { return x + y; }`
- Structs / enums / interfaces:
  - `struct Name { ... }`, `struct Name extends Base { ... }`
  - `enum Name { ... }`
  - `interface Name { ... }`, `interface Name extends Base { ... }`

## Literals

- Integers: `0`, `42`, with base/suffixes as per the spec.
- Floats: `3.14`, `1.0e-9`.
- Booleans: `true`, `false`.
- Chars: `'A'`, escape sequences.
- Strings:
  - single-line: `"hello"`,
  - multi-line: multi-line quoted forms.
- Durations: numeric + unit, e.g. `10ms`, `2s`, `5min`.
- Aggregates:
  - arrays: `[1, 2, 3]`,
  - structs: `Point { x: 1, y: 2 }`.

## Operators

- Arithmetic: `+`, `-`, `*`, `/`, `%`.
- Bitwise: `&`, `|`, `^`, `~`, `<<`, `>>`.
- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`.
- Logical: `!`, `&&`, `||`.
- Assignment: `=`, `+=`, `-=`, `*=`, `/=`.
- Increment/decrement: `++`, `--` (statement-like `void`).
- Optional / nullability:
  - optional chaining: `?.`,
  - coalescing: `??`.
- Member/scope: `.`, `::`.
- Ranges: `..`, `..=`, `...`.
- Other punctuation: `,`, `;`, `:`, `->`, `=>`.


## Flow Control

- `if cond { ... } else { ... }` (statement form)
- `let v = if cond { a } else { b };` (`if` expression)
- `loop { ... }` (infinite loop; exits via `break`/`return`).
- `while (cond) { ... }`
- `for pattern in iterable { ... }` (ranges, builtin arrays/slices).
- `for (init; cond; step) { ... }` (C-style loop header).
- `async loop { ... }` / `task loop { ... }` (loop forms in async context).
- `match value { ... }` — pattern matching.
- `return expr;`
- `assert expr;` or `assert(expr, "message");`
- `break;`
- `continue;`
- Blocks: `{ stmt* }`.
- Expression statements: `expr;` (where allowed).


Executable entrypoint (initial rule):

- A minimal executable module defines exactly one top-level function:

  ```silk
  fn main() -> int {
    return 0;
  }
  ```

- This `main` function takes no parameters and returns `int`. The front-end
  enforces this shape for executable builds before code generation.

## Optionals & Mutability

- Declare optionals: `let x: T? = None;` or `let x: Option(T) = None;`.
- Create values: `None`, `Some(value)`.
- Use:
  - `user.profile?.email` — optional chaining.
  - `email ?? "default@example.com"` — coalescing.

Mutability:

- Parameters and references are immutable by default.
- Grant mutation via `mut`:
  - in function definition: `fn reset(mut r: &Runner) { ... }`,
  - at call site (syntax per spec).

## Structs, Impl Blocks, Interfaces

- Structs: `struct Packet { seq: u32, size: u16, flag: u8 }`
  - pure data, well-defined layout.
- Impl blocks: `impl Packet { fn size_bits(self: &Packet) -> u32 { ... } }`
- Interfaces:

  ```silk
  interface Element {
    fn onclick(event: &Event) -> void;
  }

  impl Button as Element {
    fn onclick(self: &Button, event: &Event) -> void { ... }
  }
  ```

See `structs-impls-layout.md` and `interfaces.md` for details.

## Regions & Buffers

- Regions (fixed-size allocation context):
  - declare: `const region arena: u8[1024];`
  - use: `with arena { let p: &Packet = new Packet{ ... }; }`
  - anonymous: `with 1024 { let p: &Packet = new Packet{ ... }; }`
- Buffers:
  - intrinsic `Buffer(T)` with `(ptr, capacity)`,
  - unsafe primitive underpinning higher-level collections.
- Allocation:
  - `new` uses the active region inside `with` (see `regions.md`).

## Concurrency

- Function modifiers:
  - `fn` — normal.
  - `async fn` — `await`-able; calling yields `Promise(T)`.
  - `task fn` — runs in parallel on a worker thread; calling yields `Task(T)`.
  - `async task fn` — `async` + `task`; calling yields `Promise(Task(T))`.
- Structured block:

	  ```silk
	  async fn get_dashboard_data() -> Dashboard {
	    // Note: the scheduler-backed `async { ... }` semantics are still design work,
	    // but the compiler implements `Task(T)`/`Promise(T)` handles, `yield`, and `await`.
	    let mut user: User;
	    let mut orders: Order[];

	    async {
	      let user_promise = fetch_user_profile(123);
	      let orders_promise = fetch_recent_orders(123);
	      user = await user_promise;
	      orders = await orders_promise;
	    }

	    return Dashboard(user, orders);
	  }
	  ```

  To receive task values, use `yield` inside a task context (`task { ... }` or `task fn`):

  ```silk
  task fn worker () -> int { return 42; }

  async fn main () -> int {
    let h = worker();
    task {
      let value: int = yield h;
      return value;
    }
  }
  ```

See `concurrency.md` for deeper semantics.

## Formal Silk

- `#const` — formal Silk declarations used inside specifications (not available at runtime).
- `#require` — preconditions.
- `#assure` — postconditions.
- `#assert` — block-local proof obligations.
- `#invariant` — invariants.
- `#variant` — termination measures.
- `#monovariant` — monotonic measures.
- `theory` / `#theory` — reusable proof obligations.

`#require` / `#assure` appear before functions; `#invariant` / `#variant` / `#monovariant` appear before loops; `#const` and `#assert` appear inside blocks. See `formal-verification.md`.

## External Declarations & ABI (Quick View)

- Declare external bindings:

  ```silk
  ext foo = fn (string) -> void;
  ext bar = u32;
  ```

- Strings:
  - Silk `string` is internally `{ ptr, len }`,
  - C side uses `SilkString { char *ptr; int64_t len; }` for embedding,
  - `ext` calls to typical C APIs may pass `const char *` derived from `string` where appropriate.

==============================================================================
DOCS: Language Spec Conventions (language/conventions)
URL: /silk/docs/?p=language/conventions
==============================================================================

# Language Spec Conventions

keep the language specification consistent and easy to navigate for both:

- first-time readers learning Silk, and
- returning readers looking up precise rules.


## Document Structure (Recommended)

Concept documents should be structured so readers can answer, quickly:

- “What is this feature for?”
- “What syntax does the compiler accept?”
- “What are the rules and edge cases?”
- “What works in the current compiler today?”

Recommended sections:

1. **One-paragraph summary**
2. **Implementation status** (if the concept is partially implemented)
3. **Surface syntax**
4. **Semantics** (evaluation order, scoping, control-flow behavior)
5. **Type checking rules** (static requirements and diagnostics)
6. **Examples**
   - minimal examples (smallest correct usage)
   - realistic examples (how the feature is used in real code)
7. **Common pitfalls**
8. **Related documents**

Not every concept needs every section, but the goal is that a reader should
never have to infer critical rules from examples.

## “Implementation status” Format

When a feature is not fully implemented end-to-end, the concept doc should
include an explicit “Implementation status” section near the top.

Use concrete statements, not vague language. Prefer describing support in
these layers:

- Parser: which surface forms are accepted.
- Checker: which typing/validation rules are enforced.
- Lowering/backends: which forms code-generate end-to-end on supported targets.
- C ABI / FFI: whether the feature is permitted at exported boundaries.

When something is rejected in Silk, include the diagnostic code

## Examples

Examples in language docs should follow these rules:

- Use 2-space indentation and spaces only.
- Prefer complete, runnable snippets when possible:

  ```silk
  fn main () -> int {
    return 0;
  }
  ```

- When an example requires multiple files, label them with comments, e.g.:

  ```silk
  // app/main.slk
  package app;
  ```

- When an example is intentionally invalid (to show a rule), label it and
  mention the expected diagnostic.

## Terminology

These terms are used consistently across the spec:

- **Expression**: a construct that produces a value and has a type.
- **Statement**: a construct evaluated for its effects and sequencing.
- **Block**: `{ stmt* }`, a scope boundary and the unit of structured control
  flow. (Whether blocks are also expressions depends on the concept; docs must
  be explicit.)
- **Current compiler subset**: the set of features that parse, type-check, and
  code-generate end-to-end in the current implementation.

## Cross-References

When describing a rule, link to the most relevant concept doc rather than
restating it everywhere. Common cross-links include:

==============================================================================
DOCS: Literals Overview (language/literals-overview)
URL: /silk/docs/?p=language/literals-overview
==============================================================================

# Literals Overview

This document provides a high-level overview of literals in Silk, with details split into dedicated documents for each category.

For first-time readers, a good path is:

2. this overview (what literal categories exist),
3. the specific literal docs below (syntax, semantics, and supported behavior).

Returning readers typically want the “Implementation Status” section near the top
of each literal concept doc, plus the “Relevant Tests” links for runnable
examples.

## Literal Categories

Silk includes the following literal categories:

- Numeric literals
- Duration literals
- Boolean literals
- Character literals
- String literals
- Regular expression literals
- Aggregate literals (arrays, structs)

Each literal form has well-defined syntax and type inference rules that the compiler must implement.

See:

- `literals-numeric.md`
- `literals-duration.md`
- `literals-boolean.md`
- `literals-character.md`
- `literals-string.md`
- `literals-regexp.md`
- `literals-aggregate.md`

==============================================================================
DOCS: Memory Model (Stack, Heap, and Moves) (language/memory-model)
URL: /silk/docs/?p=language/memory-model
==============================================================================

# Memory Model (Stack, Heap, and Moves)

This document specifies Silk’s intended memory model: how values are allocated,
passed, and how (future) heap-managed values interact with the type system.

minimal heap model for `new` on `linux/x86_64` and a small lexical
move/cleanup model for droppable values:

- `new` is supported for allocating non-opaque `struct` values on the heap and
  producing an `&Struct` reference.
- These heap allocations are managed via reference counting (RC) inserted by the
  compiler during lowering.

Regions and a richer move/borrow model remain design-in-progress. See
for current scope.

## Goals

- Make allocation behavior explicit and predictable.
- Prefer stack allocation for most local data.
- Prevent unsafe implicit lifetime extension (for example implicitly “moving”
  stack data into a longer-lived heap allocation).
- Keep borrow safety a compile-time property (no runtime borrow errors in the
  safe subset).

## Stack vs Heap

### Stack allocation (default)

Rule: values created without `new` are stack values by default.

- Locals hold their data directly (for example an `int` or a small POD `struct`).
- Passing to functions is **by value**. For ownership-tracked values, this is a
  move (the source binding is consumed); for plain scalars it behaves like a
  copy.
- Lifetime is lexical (ends when the scope ends).

This aligns with the compiler, which is value-oriented and does
not implement a general heap allocation model.

### Heap allocation (`new`) and boxed values

Rule: values created with `new` live on the
heap and are represented as an `&Struct` reference in user code.

- The reference value is passed by value (copying the reference representation).
- The underlying allocation’s lifetime is managed by compiler-inserted reference
  counting (RC) for values originating from `new`.

Important: this is currently an internal Silk-managed heap for Silk code, not an
FFI pointer model. The current implementation does not permit `&Struct` for
non-opaque structs in `ext` signatures; only `&Opaque` handles may cross the

#### Details

- `new` is supported only in function bodies (top-level `let` initializers
  cannot contain `new` in the current implementation).
- `new` is supported only when the checker can determine a concrete reference
  result type of the form `&Struct`. In the current implementation this happens
  in two ways:
  - from an expected type context `&Struct` (for example `let x: &Packet = new
    Packet{ ... };` or as a call argument where the parameter type is `&Struct`)
  - from the `new` operand itself when it names a struct type (for example
    `let x = new Packet{ ... };` or `let x = new Packet(...);`), which allows
    `let` bindings to infer `&Packet` without an explicit annotation
- Only non-opaque `struct` types are supported for `new`.
- Reference counting is applied only to `&Struct` values that originate from
  `new` (borrowed stack references are not treated as RC-managed values).
- The `silk build` CLI supports `--noheap` to disable heap allocation for the
  :
  - heap-backed `new` (outside a `with` region) is rejected with `E2027`,
  - `async`/`task`/`await`/`yield` and capturing closures are rejected with `E2027`,
  - `ext` bindings to libc heap primitives (`malloc`/`calloc`/`realloc`/`free`/etc) are rejected with `E2027` in non-stdlib modules,
  - `std::runtime::mem::{alloc,realloc,free}` traps when called without an active `with` region (no implicit heap fallback),
  - region-backed `new` inside `with` is still permitted.

#### Region-backed allocation (`with` + `region`)

In Silk, `new` may also allocate from a region when an active

- Inside `with <region> { ... }`, `new` allocates from the region’s backing
  bytes instead of calling the heap allocator.
- On last-release, region-backed `new` allocations run `drop` (when defined),
  but do not free their backing storage (region memory is not reclaimed by RC).

#### Reference counting rules

- `new` initializes the allocation’s RC cell to `1`.
- Copying an RC-managed `&Struct` binding (for example `let q: &T = p;`) emits an
  RC retain (increment).
- Assigning to an RC-managed `&Struct` binding (for example `p = q;` where `p` is
  a `var`) releases the previous value; when the RHS is an RC-managed binding, a
  retain is emitted before the release to keep self-assignment safe.
- Exiting a scope emits RC releases (decrement) for RC-managed bindings declared
  in that scope, including on fallthrough, `return`, `break`, and `continue`.
- Passing `new` directly as a call argument to a `&Struct` parameter allocates a
  temporary and releases it after the call completes.
- When an RC release decrements the count to `0`, the allocation is freed.

## Destructors (`Drop`)

In Silk, Silk supports deterministic cleanup for
resource-owning `struct` values via `std::interfaces::Drop`.

A `struct` type is considered “droppable” when it provides a method with this
surface signature (usually via an interface impl):

```silk
import std::interfaces;

impl T as std::interfaces::Drop {
  public fn drop (mut self: &T) -> void { ... }
}
```

Automatic invocation (current compiler):

- **Scope exit:** values are dropped when they go out of scope (including via
  fallthrough, `break`, and `continue`).
- **Return:** on `return`, the compiler drops all in-scope droppable bindings
  except any value moved into the return result (for example `return value;`
  and `return Some(value);` treat `value` as moved in Silk).
- **Overwrite:** assigning to an existing value drops the old value before the
  new value is copied in.
- **Heap last-release:** for `new` allocations managed by compiler-inserted RC,
  `drop` is called before freeing the backing allocation when the refcount
  reaches zero.

Notes and limitations:

- `drop` is resolved statically (no dynamic dispatch).
- Values that require deterministic cleanup should be treated as
  ownership-tracked:
  - consuming a binding moves it and suppresses scope-exit cleanup for that
    binding,
  - using a moved binding is rejected by the checker,
  - explicit ownership transfer may be written as `move <name>` (see

## No Implicit Heap Promotion

Planned rule: stack values cannot be implicitly promoted to heap-managed
storage. Any promotion must be explicit and must perform a copy.

This avoids accidental lifetime extension and makes performance characteristics
obvious.

The precise syntax for “heap-copy this value” is still under design; any
it is implemented.

## Closure Captures

Silk supports capturing closures as a subset of function values.

Representation:

- A function-typed value is a small pair: `{ func_ptr, env_ptr }`.
- `func_ptr` is a pointer to the closure code.
- `env_ptr` is either `0` (non-capturing) or a pointer to a heap-allocated
  environment box that stores captured values.

Calling convention:

- When `env_ptr == 0`, an indirect call behaves like a normal function-pointer
  call: `func_ptr(user_args...)`.
- When `env_ptr != 0`, the backend passes `env_ptr` as a hidden first argument
  to the closure function: `func_ptr(env_ptr, user_args...)`.

Environment allocation and lifetime ():

- Captures are by-value copies of **scalar** locals/parameters (`int`, fixed
  width ints, `bool`, `char`, `f32`, `f64`, `Instant`, `Duration`).
- The environment box begins with a `u64` refcount header, followed by the
  captured scalar fields in a stable order.
- Copying a closure value retains the environment (increments refcount) when
  `env_ptr != 0`.
- Dropping a closure value releases the environment (decrements refcount) when
  `env_ptr != 0`; when the refcount reaches zero the environment box is freed.

Limitations:

- Capturing non-scalar values (including `string`, structs, arrays/slices,
  optionals, and `Drop` types) is rejected in Silk.
- Captures are immutable snapshots; the  does not support
  capturing by reference or mutating captured state.

## Relationship to Borrowing and Mutability

- Borrow checking is intended to be a compile-time property in the safe subset:
  invalid borrows should be rejected statically.
  (call-scoped aliasing checks for `&T` parameters in Silk).

==============================================================================
DOCS: Mutability (language/mutability)
URL: /silk/docs/?p=language/mutability
==============================================================================

# Mutability

Mutability in Silk is “safe by default”: values are immutable unless explicitly marked mutable under clear rules using the `mut` keyword.

- All local bindings are immutable (read‑only) by default.
- `const` bindings are always immutable (there is no `const mut`).
- All function parameters are immutable (read‑only) by default.
- A **value** parameter may be declared `mut` to allow reassignment of the
  parameter binding inside the callee (this does not affect the caller).
- A borrowed reference parameter (`&T`) follows a two‑part `mut` borrow
  contract:
  - the parameter is declared `mut`, and
  - the call site uses `mut <expr>` to explicitly create a mutable borrow.
- A slice parameter (`T[]`) is a non-owning view; when the callee intends to
  mutate through a slice view, it also follows a two-part contract:
  - the parameter is declared `mut`, and
  - the call site uses `mut <expr>` to explicitly pass a mutable slice view.

This two‑part system makes mutation explicit and intentional.

## Local Mutability (`let mut`)

Local bindings introduced with `const` and `let` are immutable by default. To
allow a local binding to be updated, it must be declared with `let mut` (or
`var`, which is an alias for `let mut`):

```silk
fn main () -> int {
  let mut x: int = 0;
  x = 1;
  x += 2;
  return x;
}
```

Key rules:

- Only `let mut` bindings may appear on the left-hand side of an assignment.
- The left-hand side must refer to an existing binding (an lvalue).
- The type checker enforces that the assigned value’s type matches the binding’s type.

## The Principle: Safe by Default

Example from the spec:

```silk
fn read_runner(r: &Runner) {
  // This is OK:
  io::print("Points: {}", r.point);

  // This would be a compile-time error:
  // r.point = 5;
}
```

Key points:

- Borrowed references (`&T`) are read‑only unless explicitly declared `mut`.
- Attempts to mutate through a non‑mutable reference are compile‑time errors.

## Granting Permission to Mutate

To make mutation possible **through a borrowed reference**, `mut` is used both:

- **In the function definition**, to declare that the function intends to mutate:

  ```silk
  fn reset_runner(mut r: &Runner) {
    r.point = 0;
  }
  ```

- **At the call site**, to explicitly pass a mutable argument, acknowledging that the callee is allowed to modify it (syntax defined in the language reference).

The compiler uses this to:

- encode a clear contract that the function may modify its argument,
- ensure callers are consciously opting into mutation.

## Compiler Requirements

The compiler must:

- Enforce immutability by default for parameters and references.
- Require `mut` at both the declaration and call site for mutable borrows.
- Surface clear diagnostics when mutation is attempted without proper `mut` markings.
- Integrate mutability rules with regions, buffers, and concurrency:
  - disallow patterns that would lead to data races,
  - ensure that aliasing and lifetime rules are respected when mutation is allowed.

## Current Implementation Restrictions

the compiler implements:

- Local `let mut` bindings, including assignment and numeric compound assignment.
- `mut` value parameters (`fn inc(mut x: int) { x = x + 1; }`) as a callee-local
  mutable binding (no call-site `mut` marker is required).
- Borrowed reference parameters of the form `&Struct` for the current supported `struct` subset.
- The two-part `mut` borrow contract for mutable reference parameters:
  - parameter declared `mut` (e.g. `fn bump(mut p: &Pair)`), and
  - call site uses `mut <expr>` (e.g. `bump(mut pair)`).
- Field updates through both:
  - local `let mut` struct bindings (`pair.a = 1`, `pair.b += 2`), and
  - `mut` borrowed reference parameters (`p.a = 1`, `p.b += 2`).
- Local borrowed references (`&Struct`) as first-class values:
  - via the borrow operator `&expr` on borrowable lvalues (e.g. `&pair`, `&obj.field`), and
  - via implicit borrow coercions in contexts that expect `&T`
    (for example `let r: &Pair = pair;`).
  These borrows are checked with conservative **lexical lifetime** rules (they
  may not escape the scope of the borrowed stack storage).
- Local bindings of `&Struct` values that originate from heap allocation (`new`)
  or from calls that return `&Struct`:
  - these `&Struct` values are refcounted in Silk,
  - copying a `&Struct` binding (e.g. `let g: &File = f;`) creates an alias to
    the same underlying heap allocation and increments the refcount.

## Borrow Safety Rules ()

Borrowed references (`&T`) in Silk are safe-by-default
and, for now, use conservative **lexical lifetime** checks:

- Borrowed references can be created and stored as local values (see above).
- The callee can mutate a borrowed reference only when:
  - the parameter is declared `mut`, and
  - the caller uses `mut <expr>` at the call site.
- Mutable borrows must be explicit and must originate from a borrowable lvalue:
  - borrowing a local binding requires a writable base (`let mut`) or an
    already-mutable view, and
  - field borrows follow the same rule (the base must be writable).

Slice views (`T[]`) are also call-scoped and safe-by-default:

- A slice value is a non-owning view (pointer + length) and may alias other
  slice views into the same underlying storage.
- Slice range borrows are created via:
  - `&a[start..end]`
  - `&a[..end]`
  - `&a[start..]`
- A mutable slice view is created via `mut &a[...]` and is restricted:
  - the base must be a borrowable lvalue (a name or a field-access chain rooted
    at a name), and
  - the base storage must be writable (`let mut` for fixed arrays / structs, or
    an already-mutable view such as a `mut` borrowed reference parameter), or
    already a mutable slice view.
- A function parameter of slice type may be declared `mut` to allow mutation
  through the slice view, and requires the caller to pass a mutable slice view
  using `mut <expr>`.
- When a slice value is stored in a struct field (`xs: T[]`), the stored view’s
  mutability is tracked:
  - storing `&a[...]` stores a read-only view, and
  - storing `mut &a[...]` stores a mutable view.
  A call-site `mut <expr>` marker does not upgrade a read-only stored view into
  a mutable one; passing a field as `mut` requires that the field already holds
  a mutable view.

### Aliasing Restrictions (Per Call)

Within a single call expression, the compiler enforces conservative aliasing
rules to avoid creating multiple mutable views of the same storage:

- A given binding may be mutably borrowed at most once in a single call.
- A binding may not be both mutably and immutably borrowed in the same call.
- Multiple immutable borrows of the same binding are permitted.

For slice parameters (`T[]`), these same per-call aliasing restrictions apply.
Additionally, when both borrows are slice range borrows of the same base with
integer-literal bounds, the checker permits multiple mutable borrows in the same
call when it can prove the two ranges are disjoint (including when the slices
are first bound to locals and then passed by name).

When borrowing a range from an existing slice binding (for example `s: T[]`),
the checker interprets `&s[start..end]` as a subrange of the underlying base
(offset by `s`’s known bounds) for the purposes of overlap checks. This
disjointness reasoning is currently limited to integer-literal bounds and to
slice bindings whose own bounds are known.

For `&Struct` reference-typed local bindings and slice-typed (`T[]`) local
bindings, the compiler also tracks obvious aliasing introduced by copying and
ref “shape casts”:

- Copying a `&Struct` binding produces an alias (it refers to the same storage).
- Copying a slice binding (`T[]`) produces an alias (it refers to the same underlying storage).
- Casting `&S` to `&T` via `as` under the shape-cast rules produces an alias
  (it is a retyped view of the same storage).
- The per-call aliasing restrictions apply across aliases: within a single call
  expression, you may not take multiple mutable borrows (or both mutable and
  immutable borrows) of the same underlying reference, even if they are held
  under different local names.

Example (rejected):

```silk
fn swap(mut a: &Pair, mut b: &Pair) {
  // ...
}

fn main () -> int {
  let mut p: Pair = Pair{ a: 1, b: 2 };
  swap(mut p, mut p); // error: two mutable borrows of `p` in one call
  return 0;
}
```

Example (allowed, immutable):

```silk
fn sum2(a: &Pair, b: &Pair) -> int {
  return a.a + a.b + b.a + b.b;
}

fn main () -> int {
  let p: Pair = Pair{ a: 1, b: 2 };
  return sum2(p, p); // OK: multiple immutable borrows
}
```

## ABI Notes (Exported/C Boundaries)

At C ABI boundaries (`export fn`), reference types are supported only for
opaque handle types (`&Opaque` / `mut &Opaque`). Non-opaque `&Struct` borrows
are not ABI-stable; see the ABI and struct layout docs for the current rules.

==============================================================================
DOCS: Numeric Literals (language/literals-numeric)
URL: /silk/docs/?p=language/literals-numeric
==============================================================================

# Numeric Literals

Numeric literals produce integer (`int`, `u8`, `i128`, …) and floating-point
(`f32`, `f64`, `f128`) values.

In Silk, the sign is an operator: `-1` is a unary `-` expression applied to the
integer literal token `1`, not a distinct “negative literal” token.

## Quick Reference

```silk
fn main () -> int {
  let a = 42;        // int
  let b: u8 = 42;    // u8 (typed by context)

  let x: f64 = 1.5;  // f64
  let y: f32 = 1.5;  // f32 (typed by context)

  let d: Duration = 5ms;
  let t0: Instant = 0;

  return 0;
}
```

## Surface Syntax (Current Lexer)

In the current implementation, numeric literal tokens are recognized as:

- **Integer literal**:
  - decimal digits (`[0-9]+`),
  - binary prefix: `0b` / `0B` followed by binary digits (`[01]+`),
  - octal prefix: `0o` / `0O` followed by octal digits (`[0-7]+`),
  - hex prefix: `0x` / `0X` followed by hex digits (`[0-9a-fA-F]+`),
  - legacy octal: `0[0-7]+` (for example `017`).
- **Float literal**: digits, `.`, digits (`[0-9]+ '.' [0-9]+`)

Notes:

- A float literal must have digits on both sides of the `.`:
  - `1.0` is a float literal.
  - `1.` is not a float literal in the current lexer.
  - `.5` is not a float literal; write `0.5`.
- Numeric literals must start with a digit in the current lexer.
- The `-` sign is not part of the literal token:
  - `-1` parses as unary `-` applied to the integer literal `1`.
  - `-1.5` parses as unary `-` applied to the float literal `1.5`.
- A numeric token immediately followed by a duration unit suffix (e.g. `1s`,
  `500ms`, `1.5s`) is a single `Duration` literal token, not a number token
  followed by an identifier.
- A numeric literal token may not be immediately followed by an identifier
  start character or an ASCII digit (unless the identifier characters are part
  of a duration unit suffix). For example:
  - `3in` is a lexical error (write `3 in` or `3 * in` as intended),
  - `0b102` is a lexical error (invalid binary digit),
  - `08` is a lexical error in Silk because multi-digit literals starting with
    `0` are legacy octal (use `0o10` for octal 8, or write `8` for decimal).

## Type Rules ()


### Integer literals

- Without an expected type, an integer literal has type `int`.
- When a context provides an expected type that is:
  - an integer type (`u8`, `i64`, `int`, …), or
  - a time type (`Duration`, `Instant`),
  then the integer literal adopts that expected type.

Example: parameter context and “adopt the expected type”

```silk
fn id_u8 (x: u8) -> u8 {
  return x;
}

fn main () -> int {
  // `255` is contextually typed as `u8` because `id_u8` expects `u8`.
  let v: u8 = id_u8(255);
  if v != 255 {
    return 1;
  }
  return 0;
}
```

Example: time types share an `i64`-based representation in Silk
`Instant`/`Duration` values via context:

```silk
fn main () -> int {
  let t0: Instant = 0;
  let d: Duration = 1s;
  let t1: Instant = t0 + d;

  let diff: Duration = t1 - t0;
  if diff != d {
    return 1;
  }
  return 0;
}
```

### Float literals

- Without an expected type, a float literal has type `f64`.
- When a context provides an expected float type (`f32` or `f64`), the literal
  adopts that expected type.

```silk
fn id_f32 (x: f32) -> f32 {
  return x;
}

fn main () -> int {
  // `1.5` is contextually typed as `f32` because `id_f32` expects `f32`.
  let v: f32 = id_f32(1.5);
  if v != 1.5 {
    return 1;
  }
  return 0;
}
```

## Common Pitfalls

- **Trying to use suffixes**: `42u8` / `1.5f32` are not supported. Use type
  annotations (`let x: u8 = 42;`) or casts (`42 as u8`).
- **Using digit separators**: `1_000` is not supported yet.
- **Using exponent notation**: `1e6` is not supported yet.
- **Writing incomplete floats**: write `1.0` (not `1.`) and `0.5` (not `.5`).
  to convert explicitly when you need to combine integer and float values.

## Related Documents


## Relevant Tests

- Integer literal contextual typing (`u8` parameters):
- Integer wrap behavior in arithmetic:
- Float literal contextual typing (`f32` parameters):
- Float literal default type (`f64`):
- Float arithmetic and comparisons:
- Duration literals (numeric + unit suffix):
- Integer literal base prefixes and legacy octal:

==============================================================================
DOCS: Operators (language/operators)
URL: /silk/docs/?p=language/operators
==============================================================================

# Operators

This document summarizes the operator set and precedence for Silk.

## Operator Set

The language includes the following operators and delimiters:

- Assignment and compound assignment: `=`, `+=`, `-=`, `*=`, `/=`.
- Increment/decrement: `++`, `--` (prefix and postfix).
- Arithmetic: `+`, `-`, `*`, `/`, `%`.
  - In the current implementation:
    - integer operands support `+`, `-`, `*`, `/`, and `%`,
    - floating-point operands (`f32`/`f64`) support `+`, `-`, `*`, and `/`
      (no `%`).
    - unary `-x` is supported for both integer and floating-point operands.
    - time types support a small arithmetic subset:
      - `Duration + Duration`, `Duration - Duration`, and unary `-Duration`,
      - `Instant + Duration`, `Duration + Instant`, `Instant - Duration`,
      - and `Instant - Instant` (producing a `Duration`).
- Bitwise: `&`, `|`, `^`, `~`, `<<`, `>>`.
  - In the current implementation, bitwise operators are defined for
    integer operands (`int` and the fixed-width integer types):
    - `&`, `|`, `^` perform bitwise AND/OR/XOR on two integer values of the
      same type and produce a result of that same type.
    - `~x` performs bitwise NOT on an integer value and produces a result of
      that same type.
    - `<<`, `>>` shift the left-hand integer operand by an integer shift
      amount of the same type; `>>` uses an arithmetic right shift for
      signed integers (`i*`/`int`) and a logical right shift for unsigned
      integers (`u*`).
- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`.
  - In the current implementation, comparisons are defined for both integer
    operands and floating-point operands of the same type.
  - In Silk, `==` and `!=` are also defined for `bool`
    operands.
  - In Silk, comparisons are also defined for `Duration`
    and `Instant` when both operands have the same time type.
  - In Silk, `==` and `!=` are also defined for `string`
    operands, comparing the underlying UTF-8 byte sequences for equality
    (length check + bytewise compare).
  - In Silk, ordered comparisons over `string`
    (`<`, `<=`, `>`, `>=`) are defined as bytewise lexicographic ordering over
    the underlying UTF-8 byte sequences (unsigned byte comparison, with
    shorter-prefix ordering when one string is a prefix of the other).
  - In Silk, `==` and `!=` are also defined for supported
    optional values (`T?`, `string?`, optionals of the supported `struct`
    subset, and nested optionals `T??`):
    - `None == None` is true,
    - `Some(x) == Some(y)` compares the payload values for equality (recursively
      for nested optionals),
    - and `!=` is the logical negation of `==`.
    - In the current implementation, `None` and `Some(...)` can appear in
      equality expressions when the other operand has an optional type (for
      example `opt == None` and `opt == Some(x)`), using that other operand’s
      type to infer the optional payload type.
  - In Silk, `==` and `!=` are also defined for the
    performing slot-wise equality over the lowered scalar slots (including
    embedded strings, nested structs, and optionals); float slots use IEEE-754
    equality semantics. Ordered struct comparisons are not implemented.
  - Float comparisons follow IEEE-754 semantics: `NaN` compares unequal to
    everything (including itself), and ordered comparisons (`<`, `<=`, `>`,
    `>=`) are false when either operand is `NaN`.
- Logical: `!`, `&&`, `||`.
  - In the current implementation:
    - `!` is supported for `bool` operands.
- Member and scope: `.`, `::`, `?.`.
- In the current implementation:
  - `.` and `::` are supported,
  - and `?.` is supported for optional field access on the supported `struct`
- Casts: `as` and `as raw` (postfix).
  - Syntax:
    - numeric/shape cast: `<expr> as <Type>`,
    - raw bit-cast: `<expr> as raw <Type>`.
  - `as` is an explicit, potentially lossy conversion operator intended for
    primitive numeric conversions (see “Casts (`as`)” below).
  - `as raw` is an explicit bit reinterpretation operator intended for
    generic storage/marshalling of scalar values (see “Raw casts (`as raw`)”
    below).
- Typed error propagation: `?` (postfix).
  - Syntax: `<call_expr>?`.
  - This propagates typed errors from an error-producing call to the enclosing
- Ranges: `...`, `..=`, `..`.
- Other punctuation: `?`, `??`, `->`, `=>`, `,`, `;`, `(`, `)`, `{`, `}`, `[`, `]`, `_`, `:`.
  - In the current implementation, `??` is supported for optionals in the
    current backend subset (including scalar, `string`, and the current
    `struct` subset, plus nested optionals in the supported payload subset;
    annotations (`T?`) and as the postfix typed error propagation operator for

The lexer and parser must recognize these tokens exactly as specified, and precedence/associativity must match the formal grammar.

## Assignment

Assignment updates an existing binding (an lvalue). Assignment is “statement-like”:
it is parsed as an expression but has type `void` and is intended to appear as an
expression statement.

### `=`

`x = expr` evaluates `expr` and stores the resulting value into `x`.

Rules:

- The left-hand side must be an assignable lvalue. In the current implementation, it may be:
  - an identifier that refers to a local `let mut` binding, or
  - a struct field lvalue `name.field` where `name` is either:
    - a local `let mut` binding of a supported POD `struct`, or
    - a `mut` borrowed reference parameter (`mut name: &Struct`).
- Identifier lvalues must refer to `let mut` local bindings.
- The type of `expr` must match the binding’s type.
- The assignment expression has type `void`.

### Compound assignment (`+=`, `-=`, `*=`, `/=`)

Compound assignments are shorthand for “read-modify-write”:

- `x += y` is equivalent to `x = x + y` (and similarly for `-=`/`*=`/`/=`),
  with `y` evaluated exactly once.

Rules:

- The left-hand side must be an assignable lvalue (as described above for `=`).
- In the current implementation, compound assignments are supported only for numeric
  scalar types (integers and `f32`/`f64`), including numeric struct fields.
- The compound assignment expression has type `void`.

## Increment and Decrement (`++` / `--`)

`++x`, `x++`, `--x`, and `x--` increment or decrement an existing binding by
`1`.

In Silk, increment/decrement expressions are “statement-like”: they have type
`void` and are intended to appear only as expression statements.

Rules:

- The operand must be an assignable lvalue (the same lvalue rules as `=`).
- The operand type must be an integer scalar type (`int`, `i8`, `u8`, `i16`,
  `u16`, `i32`, `u32`, `i64`, `u64`, `size`, `usize`). (`isize` is accepted as
  an alias for `size`.)
- Prefix and postfix forms are equivalent in Silk (both update the binding and
  produce `void`).
- Conceptual desugaring:
  - `x++` and `++x` are equivalent to `x += 1;`
  - `x--` and `--x` are equivalent to `x -= 1;`

## `sizeof`

`sizeof <operand>` produces the size of a type or value in bytes.

Result type:

- `sizeof` always returns `usize`.

Evaluation mode:

- When the operand is a **type name** (a primitive type, `struct`/`enum` name,
  type alias, or qualified type name), `sizeof` is a compile-time constant.
- When the operand is a **compile-time constant value** (literals and other
  const-evaluable expressions), `sizeof` is a compile-time constant.
- When the operand is a **runtime value**, `sizeof` is evaluated at runtime.

`Sized` integration:

- Planned: for runtime values, if the operand type provides an instance method
  matching `std::interfaces::Sized` (`fn size(self: &Self) -> usize`),
  `sizeof value` will lower to a call of that method.
- For type operands, if the operand type provides a static, pure method
  `pure fn size() -> usize`, the compiler may fold `sizeof Type` to that value
  when the method body is const-evaluable; otherwise it falls back to the
  compiler’s built-in size model.

Built-in size model (current backend subset):

  each lowered scalar occupies one 8-byte slot.
- A `string` value occupies two slots (`(u64 ptr, i64 len)`), so `sizeof string`
  is `16` in Silk.
- A `T[]` slice value occupies two slots (`(u64 ptr, i64 len)`), so `sizeof T[]`
  is `16` in Silk.
- A `T[N]` fixed array occupies `N * sizeof(T)` bytes in Silk,
  using the element’s scalar-slot size.

Parsing note:

- Because `Name[expr]` is also indexing syntax, fixed array **type** operands
  should be parenthesized: `sizeof (u8[4])`. Without parentheses, `sizeof u8[4]`
  is parsed as an index expression.
- Because `as` binds at postfix precedence, `sizeof x as T` parses as
  `sizeof (x as T)`. To cast the result of `sizeof`, write `(sizeof x) as T`.

## `alignof`

`alignof <operand>` produces the alignment of a type or value in bytes.

Result type:

- `alignof` always returns `usize`.

Evaluation mode:

- When the operand is a **type name** (a primitive type, `struct`/`enum` name,
  type alias, or qualified type name), `alignof` is a compile-time constant.
- When the operand is a **compile-time constant value** (literals and other
  const-evaluable expressions), `alignof` is a compile-time constant.
- When the operand is a **runtime value**, `alignof` is evaluated at runtime.

Built-in alignment model (current backend subset):

- Alignments reflect the current scalar-slot lowering model
- All non-`void` types currently have alignment `8`.
- `alignof void` is `1`.

Parsing notes:

- As with `sizeof`, fixed array **type** operands should be parenthesized:
  `alignof (u8[4])`. Without parentheses, `alignof u8[4]` is parsed as an index
  expression.
- Because `as` binds at postfix precedence, `alignof x as T` parses as
  `alignof (x as T)`. To cast the result of `alignof`, write `(alignof x) as T`.

## `offsetof`

`offsetof(Type, field_path)` produces the byte offset of a struct-like field
within `Type` in the current memory layout model.

Result type:

- `offsetof` always returns `usize`.

Evaluation mode:

- `offsetof` is always a compile-time constant.

Operands:

- `Type` must name a `struct` or `error` type (including nested structs).
- `field_path` is one or more field identifiers separated by `.` (for example
  `b` or `inner.header.len`).

Built-in offset model (current backend subset):

- Offsets reflect the current scalar-slot lowering model
  8-byte cell, and composite fields (nested structs, optionals, strings, etc.)
  are expanded into their slot sequences in source order.
- `offsetof(Type, field)` returns the offset of the **first slot** of that
  field’s lowered representation, in bytes.
- When `field_path` traverses an optional `T?` field, it refers to the payload
  layout (the path implicitly skips the tag slot).

## `typename`

`typename <expr>` and `typename(<expr>)` produce a `string` naming the static
type of `<expr>`.

Result type:

- `typename` always returns `string`.

Evaluation mode:

- `typename` is always a compile-time constant string.

Operand notes ():

- When the operand is a bare name that does **not** resolve to an in-scope
  runtime binding (for example `int`, `User`, or `std::wasm::Module`), the
  compiler interprets it as a type name and returns that type’s name.
- Formatting uses the compiler’s normal type formatting (for example `T[]`,
  `&T`, and `fn (...) -> ...`).
- For monomorphized generic instantiations, the string is the human-readable
  display name (not an internal `__silk_mono__...` symbol).

## `is`

`<expr> is <Type>` checks whether the **static type** of `<expr>` conforms to
`<Type>`.

Result type:

- `is` always returns `bool`.

Evaluation mode:

- `is` is always a compile-time constant boolean.

Rules ():

- The right-hand side must be a type (primitive, nominal `struct`/`enum`/`error`,
  `interface`, a function type, or a type alias for one of those).
- If `<Type>` is a nominal `struct` type, `expr is Type` is true when the
  expression’s static type is exactly `Type` **or** a `struct` that `extends`
  `Type`.
- If `<Type>` is an `interface`, `expr is Interface` is true when the expression’s
  static type declares conformance (`impl T as Interface`) or when the operand is
  a module declared `module Name as Interface`.
- For primitive types, enum/error types, reference types (`&T`), slice/array types
  (`T[]`, `T[N]`), optionals (`T?`), and function types, `is` currently checks
  **exact type equality** (after resolving type aliases).

Notes:

- `is` does not perform runtime tagging or value inspection. For runtime
  discrimination of union/optional values, use `match` and the relevant pattern
  forms.

Examples:

```silk
type Adder = fn (x: int, y: int) -> int;
fn my_adder (x: int, y: int) -> int { return x + y; }
if my_adder is Adder { /* ... */ }

struct User { id: u64 = 0 }
struct Beep extends User { boop: string = "" }
let beep = Beep{ boop: "boop" };
if beep is User { /* ... */ }

let n = 123;
if n is int { /* ... */ }

interface Logger { fn log (value: string) -> void; }
module my_logger as Logger {
  export log (value: string) { /* ... */ }
}
if my_logger is Logger { /* ... */ }
```

## Wrapping and Overflow

The spec notes “Arithmetic Wraps” for certain operators. The checker and code generator must:

- Implement deterministic wrapping behavior for integer arithmetic where required.
- Clearly separate wrapping operations from checked or saturating variants (if exposed in the standard library).

## Casts (`as`)

`as` is a postfix operator that performs an explicit conversion to a target
type.

### Precedence

`as` binds at postfix precedence (like calls, field access, and `?`). For example:

- `a + b as int` parses as `a + (b as int)`.
- To cast the result of `new`, use parentheses so the cast applies to the heap
  reference: `(new Type{ ... }) as &Other`. Without parentheses,
  `new Type{ ... } as &Other` parses as `new (Type{ ... } as &Other)`.

### Supported conversions ()

In Silk, `as` is supported for primitive scalar
conversions:

- Integer → Integer (including `Instant`, `Duration`, and `char`):
  - The conversion is deterministic and may be lossy. It is performed by
    canonicalizing the underlying bits to the destination integer type
    (width truncation + sign/zero extension as appropriate). For scalar widths
    up to 64 bits this matches the behavior of `ir.CastInt` in the current IR;
    `i128`/`u128` follow the analogous rule over their `{ lo, hi }` lane layout.
- Float → Float:
  - `f32`/`f64`/`f128` conversions using standard IEEE-754 conversion and rounding.
- Integer → Float:
  - Converts the integer value to the destination float type (IEEE-754),
    with rounding when the integer cannot be represented exactly.
- Float → Integer:
  - Converts by truncating toward zero.
  - If the source value is `NaN`, the result is `0`.
  - If the source value is outside the destination integer’s representable
    range, the result saturates to the nearest bound (min/max for signed,
    `0`/max for unsigned).

- Struct → Struct (safe “shape cast”):
  - A cast from `S` to `T` is permitted when both `S` and `T` name **non-opaque**
    struct types and their fields match **positionally**:
    - same field count, and
    - for each index `i`, the field type of `S` at `i` is exactly the same type
      as the field type of `T` at `i` (field names may differ).
  - This is intended for “newtype-like” wrappers and schema evolution where two
    structs have the same shape but different field names.
  - Semantics: the cast produces a **value copy** of the underlying struct
    slots, retyped as `T`. The operation does not reorder fields.
- `&Struct` → `&Struct` (safe “shape cast” for references):
  - A cast from `&S` to `&T` is permitted when `S` and `T` are compatible under
    the same Struct → Struct “shape cast” rules above.
  - Semantics: the cast produces a **retyped view** of the same referenced
    storage. It does **not** allocate and does **not** copy the underlying
    struct slots.
  - For refcounted heap references created by `new`, the cast is still a view
    only: it must **not** change which `drop` implementation runs when the
    refcount reaches zero. The allocation’s concrete type (tracked through the
    value, not the view type) determines Drop behavior at the last release.
  - This means the two references alias: reading fields through the cast view
    observes updates made through the original reference (and vice versa).
  - Because the two references alias, the compiler’s per-call mutable-borrow
    restrictions treat aliases as the same storage: a single call expression
    may not take multiple mutable borrows (or both mutable and immutable
    borrows) of the same underlying reference, even if the aliases are held
  - This cast is intentionally conservative: it is permitted only when the
    compiler can prove the two referenced struct layouts are identical at the
    type level (same field types in the same order). It does **not** permit
    arbitrary “reinterpret pointer” casts.

- `u64` ↔ `T[]` / `T[N]` (unsafe pointer/slice view cast):
  - Silk’s  represents raw addresses as `u64`. For low-level
    byte-copy routines and runtime interop, `as` supports explicit conversions
    between raw addresses and array/slice views:
    - `ptr as T[]` constructs a `T[]` slice view where the pointer component is
      `ptr` and the length component is a dedicated **unknown-length** sentinel
      (in the current implementation, `i64.min`). The compiler does not validate
      the pointer value.
      - Indexing and assignment through an unknown-length slice are permitted
        but **unchecked**: the runtime performs no `index < len` bounds check.
      - Operations that require a known length (iteration, slicing, etc.) trap
        unless an explicit length is provided.
    - `ptr as T[](len)` constructs a `T[]` slice view where the pointer
      component is `ptr` and the length component is `len` (element count).
    - `slice as u64` extracts the pointer component of a `T[]` slice.
    - `arr as u64` extracts the address of element `0` of a fixed array `T[N]`
      (for `N == 0`, the result is `0`).
  - These casts remain **unsafe**:
    - the compiler does not validate pointer provenance (whether the address is
      valid for the claimed element type).
  - In Silk, indexed accesses through
    arrays/slices trap when:
    - the pointer is `0`,
    - the pointer is not 8-byte aligned,
    - the explicit length is negative (when provided),
    - the index is out of bounds (`index < len`) when the slice/array has a
      known (non-unknown) length.

- `Serialize(T)`-backed casts (explicit conversion via `serialize()`):
  - When the operand type provides a unique instance method named `serialize`
    matching the `std::interfaces::Serialize(T)` surface (`fn serialize(self: &Type) -> T`),
    `expr as T` is permitted and lowers to a call of that method.
  - The conversion is explicit (it does not introduce implicit coercions).
  - The `serialize` method must be infallible (no typed errors).
  - Purity rules apply: inside `pure fn`, the `serialize` method must be `pure`.
  - Limitation: the compiler must be able to resolve the
    receiver’s nominal type at the cast site so it can lower the implicit
    `serialize()` call. This includes name expressions, field accesses, calls,
    and array/slice indexing (`arr[i] as T`) in the current implementation.
- `Deserialize(S)`-backed casts (explicit conversion via `deserialize(...)`):
  - When the target type provides a unique **static** method named `deserialize`
    matching the `std::interfaces::Deserialize(S)` surface (`fn deserialize(value: S) -> Self`),
    `expr as Self` is permitted and lowers to `Self.deserialize(expr)`.
  - This rule is checked before struct shape casts: when both a `deserialize`
    conversion and a shape cast could apply, the `deserialize` conversion is
    used.
  - The conversion is explicit (it does not introduce implicit coercions).
  - The `deserialize` method must be infallible (no typed errors).
  - Purity rules apply: inside `pure fn`, the `deserialize` method must be `pure`.

Examples:

```silk
struct Data {
  value: string,
}

struct User {
  name: string,
}

fn main () -> int {
  let data = Data{ value: "hello" };
  let user = data as User;
  assert data.value == user.name;
  return 0;
}
```

```silk
struct A {
  value: string,
}

struct B {
  value: string,
}

fn set_value (mut b: &B, value: string) -> void {
  b.value = value;
}

fn main () -> int {
  let a: &A = new A{ value: "hello" };
  var b = a as &B;
  set_value(mut b, "world");
  assert a.value == "world";
  assert b.value == "world";
  return 0;
}
```

Notes:

- `as` does not participate in the implicit call-argument coercion mechanism
  destination struct and is used primarily for stdlib ergonomics).

## Raw casts (`as raw`)

`as raw` is a postfix operator that reinterprets the **raw bits** of a scalar
value as another scalar type. It is intended for use in generic collections
and low-level marshalling where numeric conversion would be incorrect (notably
when storing `f32`/`f64` values in integer-backed storage).

Syntax:

- `<expr> as raw <Type>`

Rules ():

- Both the operand and the target type must be numeric primitive types
  supported by the backend:
  - 64-bit-slot scalars: `i8`/`u8`/`i16`/`u16`/`i32`/`u32`/`i64`/`u64`/`int`,
    `f32`/`f64`, plus int-like primitives lowered to those scalars such as
    `Duration`/`Instant` and `char`.
  - 128-bit wide primitives: `i128`/`u128`/`f128` (two 8-byte lanes; `f128`
    stores the raw IEEE-754 binary128 bit pattern).
- `as raw` is not permitted for `string`, `void`, `&T`, optionals, arrays,
  maps, function types, or structs/enums.
- Semantics:
  - The operand’s current canonical scalar bits are reinterpreted as the target
    type’s canonical scalar bits (bit-level truncation/masking for narrower
    target widths such as `u8`/`u16`/`u32` and `f32`).
    - For 128-bit primitives, this is lane-wise:
      - the low lane is copied as `u64` bits,
      - the high lane is reinterpreted across `u64`/`i64` as needed,
      - when casting a 128-bit value to a <=64-bit target, the low lane is used,
      - when casting a <=64-bit *integer* value to `i128`/`u128`, the high lane
        is sign-extended (`i128`) or zero-extended (`u128`) in the current
        subset.
  - No numeric conversion is performed. For example, `1.0 as u64` yields
    `1`, while `1.0 as raw u64` yields the IEEE-754 bit pattern.

Examples:

```silk
let bits: u64 = (1.0 as f32) as raw u64;
let f: f32 = bits as raw f32;
```

==============================================================================
DOCS: Optional (language/optional)
URL: /silk/docs/?p=language/optional
==============================================================================

# Optional

The `Optional` type provides a safe way to represent values that may or may not
be present, instead of relying on sentinel values such as `null`.

- The nominal type constructor is `Option(T)`.
- The shorthand `T?` is sugar for `Option(T)` and is the recommended form.
- Optional values are constructed using `Some(...)` and `None` (the compiler
  also accepts `none` as an alias of `None`).
- The `null` literal is distinct from `None`, but may coerce to `None` when an
  optional type is expected.
- Use `match`, `?.` (optional chaining), and `??` (coalescing) to consume optionals.

## Declaring Optional Types

You can declare variables or fields as optional using either:

- `T?` (idiomatic suffix form),
- `Option(T)` (nominal form).

The language design treats these as equivalent.


- The type system (`src/types.zig`) models optional types, and the parser
  now accepts both:
  - the suffix form `T?` in type annotations, and
  - the nominal form `Option(T)` for simple cases (a single type argument),
    which is desugared into the same internal optional representation as
    `T?`.
  - For example, the following is valid today and type-checks successfully
    (note that the current compiler requires `let` initializers; see

    ```silk
    fn main () -> int {
      let a: string? = None;
      let b: Option(string) = None;
      return 0;
    }
    ```

- The current `linux/x86_64` IR→ELF backend subset now supports a first slice
  of optional *values* for a subset of payload types:
  - construct optionals via `None` and `Some(value)`,
  - access fields of optional structs via optional chaining
    (`opt?.field`, producing a `FieldType?` value),
  - use nested optionals (`T??`) for a subset of payloads in the current backend
    (see below),
  - compare supported optionals via `==` / `!=` (tag + payload equality; nested
    optionals compare recursively),
  - unwrap optionals via `??` (coalescing) with short-circuit evaluation of
    the fallback expression,
  - explicitly branch on optionals via the `match` expression (see
  - and pass/return such optionals between helpers in the supported IR
    subset.

  Supported optional payloads in this backend subset include:

  - scalars (`bool`, `char`, `f32`, `f64`, `int`, and fixed-width integers),
  - `string` (lowered as `{ ptr: u64, len: i64 }`),
  - enums (tagged unions) in the current enum backend subset (lowered as `(u64 tag, payload_0, payload_1, ...)`),
  - and the supported `struct` subset (0+ fields of supported value types,

  In this subset, optionals are represented at IR boundaries as a `Bool` tag
  followed by the payload scalars: `(Bool tag, payload0, payload1, ...)` where
  `tag=0` means `None` and `tag=1` means `Some(...)`. The payload scalar slots
  follow the same lowering rules as the underlying non-optional type (1 scalar
  for scalar payloads, 2 scalars for `string`, N scalars for the current `struct`
  subset, and N scalars for enums (including the enum’s own `u64` tag slot).

  Nested optionals (`T??`) are supported in this backend subset for the same
  payload subset (scalars, `string`, enums, and the supported `struct` subset).

  In this subset, `T??` is represented as an outer optional whose payload is
  the full inner optional representation: for example `int??` lowers as
  `(Bool tag0, Bool tag1, i64 payload)`.

- Not yet implemented:
  - optional chaining beyond the current optional-struct field access subset
    (for example chaining through optional fields, optional method calls, and
    optional indexing),
  - `match` over non-optional scrutinee types (and richer pattern forms beyond
    `None`/`Some(...)`),
  - and richer optional forms beyond the backend.

Note: optional payload equality (`==` / `!=`) is still limited in the current
backend subset; comparisons against `None` are supported broadly, but full
payload equality for all optional payload kinds (notably optional-of-enum) is
still evolving.

For the current C ABI mapping of optionals in exported function signatures

## Creating Optional Values

An optional can be:

- `None` — the empty state.
- `Some(value)` — the value‑holding state.

Examples from the spec:

- `let age: u32? = None;`
- `let age: u32? = Some(30);`
- `struct User = { profile: None };`
- `profile: Some({ email: "some@example.com", age: Some(30) })`

The compiler infers the optional’s element type from context when possible.

In the current implementation, equality comparisons provide optional type
context for `None` / `Some(...)` operands, so forms like `opt == None` and
`opt == Some(value)` type-check when `opt` has type `T?`.

## `None`: The Empty State

`None` represents the absence of a value.

Spelling note: `None` may also be written as `none` (alias). The `null` literal
is a distinct literal that can coerce to `None` in optional contexts.

Key points:

- `None` can be assigned to any `T?`; its concrete `T` is inferred.
- In pattern matching and control flow, `None` corresponds to the empty branch.

## `Some(value)`: The Value-Holding State

`Some(value)` wraps a concrete value in an `Option(T)`.

Key points:

- The type of `Some(value)` is `T?` (or `Option(T)`).
- Nested optionals are allowed (e.g. a struct containing fields that are `T?`).

## Optional-Coalescing Operator `??`

The `??` operator unwraps an optional by providing a fallback value if it is `None`.

From the spec:

- It “coalesces” the optional’s value and the default into a single, non‑optional result.
- The expression `opt ?? default_value` has type `T` when `opt` has type `T?`.
- When `opt` has type `T??`, the expression `opt ?? default_value` has type
  `T?` (it unwraps one optional layer).
- It composes naturally with optional chaining.

Example:

- `let email_address: string = user2.profile?.email ?? "no-email-provided@domain.com";`

## Using Optional Values

The spec provides several mechanisms for working with optionals:

- Optional chaining `?.`:
  - `user.profile?.email` yields `string?`.
  - If any link in the chain is `None`, the result is `None`.
- Coalescing `??`:
  - Converts an optional into a non‑optional by supplying a default.
- Explicit checking via `match`:
  - Pattern‑matching on `Some(...)` / `None` to handle both cases explicitly.

## Compiler Requirements

The compiler must:

- Support `T?` and `Option(T)` as equivalent surface forms.
- Ensure that `Some` / `None` usage is type‑correct.
- Track optionality in the type system and enforce checks when unwrapping.
- Implement `?.` and `??` with the short‑circuit semantics described above.
- Support `match` on `Option(T)` and integrate optionals with flow control and error reporting.

==============================================================================
DOCS: Packages, Imports, and Exports (language/packages-imports-exports)
URL: /silk/docs/?p=language/packages-imports-exports
==============================================================================

# Packages, Imports, and Exports

This document specifies the initial surface syntax for packages, imports, and
exports in Silk. The semantics are intentionally minimal for now and will be
extended as the compiler’s resolver and linker mature.

## Terminology

- **Source file**: a single `.slk` source file.
- **Package**: a named collection of source files that share a namespace (declared via
  `package ...;`).
- **Module declaration**: a `module ...;` header that declares a namespace and a
  **compile-time-only** module value, and may declare interface conformance via `as`.
- **Module set**: the set of source files the compiler is compiling together for a
  given command. Package imports can only resolve to packages that exist in this
  module set.
- **Named import**: `import { A, B as C } from "...";` (introduces unqualified names).
- **Default import**: `import X from "...";` (binds either a default export symbol or
  a namespace, depending on what is imported).
- **Namespace import**: a default import that binds a module or package namespace; you
  access its members as `X::Name`.

## Packages

A Silk program is organized into packages and source files.

Each source file may declare the package it belongs to using a `package`
declaration at the top of the file:

```silk
package my_app::core;
```

Rules:

- Each module MAY declare at most one `package` declaration.
- When present, the `package` declaration MUST appear before all other
  top-level declarations in the module; it is the first declaration in
  the file.
- Package names are sequences of identifiers separated by `::`.
  - As a special case, the keyword `task` is permitted as a `::`-qualified
    segment so `std::task` is a valid package name.
  - `std::strings`
  - `std::task`
  - `my_app::core`
  - `example`
- The standard library lives under the reserved `std::` namespace, for
  example `std::strings`, `std::memory`, etc.

If a source file omits a `package` declaration, it is treated as belonging to an
implementation-defined default package (for example, the “main” package for
an executable). The exact rules for default packages will be specified as
multi-module builds are implemented.

In the current `silk` CLI implementation, when building a package via a package
manifest (`silk.toml`), source files that omit `package` default to the

## Modules (`module`)

`module` declares a named module namespace and a **compile-time-only** module
value.

Syntax:

```silk
module my_app::core;
module my_app::core as SomeInterface;
```

Rules:

- A source file MAY declare at most one `module` declaration.
- A source file MAY declare at most one of:
  - a `package` declaration, or
  - a `module` declaration.
- When present, the `module` declaration MUST appear before all other top-level
  declarations in the source file; it is the first declaration in the file.
- Module names follow the same `::`-qualified naming rules as packages.
- Modules are **compile-time-only** values: there is no runtime representation
  for a module value.
- If a module declares `as <Interface>`, the compiler MUST validate that the
  module satisfies the interface surface as specified in

### Inline modules (`module Name { ... }`)

In addition to the source file header form (`module ...;`), Silk supports
**inline modules** as a nested-namespace mechanism inside a file:

```silk
package my_package;

export module inner_module {
  export fn hello () -> string {
    return "hello world";
  }
}
```

Rules (current compiler subset):

- Inline modules MUST appear at top level (not inside function blocks).
- The inline module name is a single identifier.
- The body is a brace-delimited list of top-level declarations; inline modules
  may be nested.
- `package`, header-form `module ...;`, and `import` declarations are not
  permitted inside an inline module body.
- Declarations inside an inline module are referenced from outside using `::`
  qualification (`inner_module::hello()`).
- Within an inline module body, unqualified name lookup for inline-module
  declarations is not implemented yet in Silk; use
  explicit `::` qualification.
- `export module Name { ... }` exports the namespace:
  - exported declarations inside it become part of the containing package’s
    export surface with their names prefixed by `Name::` (for example
    `inner_module::hello`),
  - nested `export module` declarations extend the prefix (for example
    `outer::inner::name`).

## Source File Header Ordering (Mandatory)

In each source file, top-level declarations must appear in this order:

1. Optional `package` or `module` declaration (`package ...;` or `module ...;`).
2. Zero or more `import` declarations, as a contiguous block.
3. All other top-level declarations.

This ordering is enforced by the parser/resolver and keeps dependency structure
easy to understand and tooling-friendly.

## Imports

Source files may refer to other packages or modules via `import` declarations:

```silk
package my_app::core;

import std::strings;

fn main () -> int {
  return 0;
}
```

Rules:

- `import` declarations MUST appear at top level (not inside functions or
  blocks).
- All `import` declarations in a module, if any, MUST appear after the
  optional `package` declaration (if present) and before any other kind of
  top-level declaration. In other words, imports form a contiguous block at
  the beginning of the module immediately following the optional package.
- An `import` path is a sequence of identifiers separated by `::`, matching
  the package naming rules above (including the `std::task` special case).
  - As with expression/type qualified names, an import path MAY start with `::`
    to explicitly name the global namespace (the unnamed package).
- `import` declarations identify dependencies and bring exported symbols
  from the imported package into scope in the importing module, subject to
  the visibility rules below.
- In the current implementation:
  - importing a package makes its exported `let` bindings with explicit
    type annotations visible as ordinary, unqualified names in the
    importing module (for example, `import util;` followed by `answer`
    refers to `util::answer` when `util` exports `let answer: int = 42;`),
  - imported exported `let` bindings are also reachable via qualified
    names of the form `pkg::name` (for example, `util::answer` after
    `import util;`); both unqualified (`answer`) and qualified
    (`util::answer`) forms are accepted for now, but the qualified form
    reflects the intended package-namespaced style,
  - exported functions (`export fn`) are callable across packages for the
    compiler’s current backend subset:
    - within a package, top-level functions form a shared namespace across
      all modules in that package (so functions in one module may call
      functions defined in another module of the same package),
    - when a module imports a package, that package’s `export fn`
      declarations become callable from the importing module,
    - both unqualified (`foo()`) and qualified (`util::foo()`) call forms
      are accepted initially for imported exports, matching the current
      constant-import behavior, though the qualified form reflects the
      intended package-namespaced style,
    - this callable subset is limited to the compiler’s current
      code generation subset (supported parameters/results, direct calls, and
      structured control flow supported by the IR→ELF backend on
      `linux/x86_64`),
  - struct type names (`struct` declarations) from imported packages are visible in the importing module for the current supported `struct` subset:
    - the qualified form `pkg::Struct` is always accepted when `pkg` is imported,
    - the unqualified form `Struct` is accepted when it is unambiguous across the module’s imports and does not conflict with a locally defined struct name,
    - when multiple imported packages define the same struct name, the unqualified form is rejected as ambiguous and the qualified form must be used,
  - enum type names (`enum` declarations) from imported packages are visible in the importing module for the current supported enum subset:
    - the qualified form `pkg::Enum` is always accepted when `pkg` is imported,
    - the unqualified form `Enum` is accepted when it is unambiguous across the module’s imports and does not conflict with a locally defined type name,
    - enum variants are referenced relative to the enum name (`Enum::Variant` or `pkg::Enum::Variant`),
  - if an imported package does not exist, resolution fails before
    type-checking (see the resolver).
  - a leading `::` on a qualified name forces lookup in the **global namespace**
    (the unnamed package), bypassing any same-named declarations in the current
    package or imported packages. This is intended as an explicit escape hatch
    for shadowing (for example, calling `::malloc(...)` when the current module
    also defines or exports `malloc`). The prefix is valid in both expression
    and type positions, including:
    - values: `::malloc(...)`,
    - types and struct literals: `::Foo` and `::Foo{...}`,
    - enum variant paths/patterns: `::E::Variant`.

### Qualified Symbol Imports

In addition to importing whole packages, a module may import a single symbol by
fully qualifying it:

```silk
import std::io::println;
import std::url::URL;
import ::malloc;
```

Semantics:

- If the import path matches a package name present in the module set, it is a
  **package import** (`import std::io;`).
- Otherwise, it is treated as a **qualified symbol import**:
  - the compiler finds the longest package-name prefix of the path,
  - the remaining suffix is the symbol name within that package (it may contain
    `::` due to exported inline modules),
  - the symbol is introduced into the importing module under its final path
    segment (for example, `println` for `import std::io::println;`).
- When the import path begins with `::`, the symbol is resolved from the global
  namespace (the unnamed package) and is not subject to package export gating.

`import { Name } from "...";` remains the preferred form when you need to rename
imports (`as`) or import from a file path.

Global namespace (`::name`) rules (current compiler subset):

- The global namespace is the package formed by modules that have **no**
  `package ...;` or header-form `module ...;` declaration (their package name is
  empty).
- `::Name` resolves `Name` from that global namespace, if a matching declaration
  exists in the current module set.
- `::Outer::Inner::Name` resolves `Outer::Inner::Name` from that same global
  namespace (for example, names nested under inline modules in a global module).
- Global names are only accessible via the explicit `::` prefix; there is no
  implicit “prelude import” of global symbols.

Future extensions may introduce aliasing (e.g. `import std::strings as str;`)
and more fine-grained import forms. Such features will be documented here
before they are implemented.

### Example: a two-module package program

Two modules can share a package name and export symbols for other packages to
use.

```silk
// util.slk
package util;

export let answer: int = 41;

export fn add1 (x: int) -> int {
  return x + 1;
}
```

```silk
// app.slk
package app;

import util;

fn main () -> int {
  // In the current implementation, both unqualified and qualified access are
  // accepted after importing a package. Prefer the qualified form to make the
  // origin explicit.
  if util::add1(util::answer) != 42 {
    return 1;
  }
  return 0;
}
```

### Package imports resolve against the module set

In the current implementation, a **package import** can only resolve if the
package exists in the current module set.

This matters most when you use package specifiers (`from "ns_pkg"`) or when you
expect a package import to find a package that is not otherwise present.

Tooling note (the `silk` CLI):

- The language semantics are still “imports resolve against the module set”.
  The CLI grows the module set by loading additional source files.
- In addition to auto-loading `std::...` packages from the stdlib root, the CLI
  MAY load non-`std::` packages from a **package search path** when a bare
  package specifier is imported (e.g. `import api from "my_api";`).
- The package search path is configured via `SILK_PACKAGE_PATH` (PATH-like:
  roots separated by `:` on POSIX).
- A package name like `my_api::core` maps to the filesystem candidate
  `<root>/my_api/core/silk.toml`. The first matching manifest in search order is
  used.
- Qualified imports that include extra `::` segments (e.g. `my_api::core::Thing`)
  are treated as qualified symbol imports: the CLI resolves the **longest**
  package prefix that exists (`my_api::core`, then `my_api`) and loads that
  package into the module set.

Example: bringing a package into the module set via a file import, then importing
the package namespace:

```silk
// main.slk
import { answer as ignored } from "./support_pkg_ns_pkg.slk"; // declares `package ns_pkg;`
import pkg from "ns_pkg"; // now resolves because `ns_pkg` exists in the module set

fn main () -> int {
  return pkg::add1(pkg::answer);
}
```

If you omit the file import (or otherwise fail to include a module that declares
`package ns_pkg;`), the package import fails with `E1001` (“unknown imported package”).

From the CLI, the usual fix is to ensure the missing package’s module(s) are
part of the command’s module set (for example by passing their `.slk` files to
`silk check` / `silk build`, or by adding a file import). See

## Import Specifier Imports (JS-style)

In addition to `import pkg::name;` package imports, Silk supports JS-style
import forms that use a string literal *import specifier* after `from`.

The current JS-style forms are:

- Named imports: `import { Name } from "<specifier>";`
- Default imports / namespace imports: `import Name from "<specifier>";`
- Ambient imports: `import "<specifier>";`

An import specifier string is interpreted in one of three ways:

- **File specifier**: the string begins with `./` or `../`, or is an absolute
  path. These imports resolve to a module by file path.
- **Std-root file specifier**: the string begins with `std/`. These imports
  resolve to a module by file path under the configured stdlib root (see the
- **Package specifier**: any other string. These imports resolve to a package
  by name (for example `"ui"` or `"std::strings"`).

Note: in Silk, package specifiers are matched literally
against package names present in the module set. In practice this means the
specifier must be a valid Silk package path (identifiers separated by `::`,
with `task` permitted as a `::` segment).

This mirrors the common JS convention that relative file imports must start
with `./` or `../`. Silk additionally reserves the `std/` prefix for stdlib
source imports resolved via the configured stdlib root.

Example (namespace-style imports):

```silk
import ui from "ui";                 // package namespace
import helpers from "./helpers.slk";  // file module namespace (if no default export)

fn main () -> void {
  let opts: &ui::WindowOptions = new ui::WindowOptions();
  helpers::do_something();
}
```

### Ambient imports

An ambient import loads a module into the module set without introducing any
imported names into local scope:

```silk
import "./my_api.slk";
import "std/io";
```

Notes:

- Ambient imports use the same specifier interpretation rules as other
  specifier-based imports:
  - `./` / `../` / absolute paths are resolved as file imports,
  - `std/<path>` is resolved under the configured stdlib root,
  - other strings are treated as package specifiers (for example `"ui"` or
    `"std::strings"`).
- Ambient imports do not bind a namespace or import any symbols. If you need to
  call a function or reference a type from the imported module, use a named
  import, a default import (namespace import), or a package import.
- Ambient imports are useful for declaring dependencies that exist only to:
  - satisfy prototype/definition conformance rules (see below), or
  - ensure a module is present in the module set so its types and methods are
    available for type checking and monomorphization.

### Named imports

Named imports import selected exported names directly into the importing
module:

```silk
import { StringBuilder, write_u8 as writeByte } from "./runtime.slk";
```

Notes:

- There is no combined `import foo, { bar } from "...";` form in the current grammar.
  Use separate `import` declarations.
- For non-`std/` file specifiers, include the `.slk` extension explicitly. (Only
  `std/...` specifiers get `.slk` appended automatically in the current implementation.)

Rules:

- File imports MUST appear in the same import-declaration block as package
  imports: after the optional `package` declaration and before any other
  top-level declaration.
- The `from` keyword is part of the import syntax.
- The `from` specifier may be either:
  - a string literal (`from "./file.slk"`, `from "std/io"`, `from "ns_pkg/sub"`), or
  - a package path (`from std::io;`, `from ns_pkg::sub;`).
- If the specifier is a **file specifier**, it is resolved relative to the
  importing file’s directory. `./` and `../` path segments are permitted.
  (Absolute paths are permitted for tooling, but downstream projects should
  prefer relative imports.)
- If the specifier is a **std-root file specifier** (`"std/<path>"` or
  `"std/<path>.slk"`), it is resolved relative to the configured stdlib root and
  then treated as a file import. If the `.slk` extension is omitted, it is
  appended during std-root resolution.
- If the specifier is a **package specifier**, it is interpreted as a package
  name (using the same `::`-separated syntax as `package` declarations) and is
  resolved via the package graph.
- The imported module MAY declare a `package` or omit it. File specifiers refer
  to the target module *by file path*, not by package name.

Exported names for named imports:

- Named imports can import:
  - exported values: `export fn`, `export let`, and exported `ext` bindings, and
  - type names: `struct`, `enum`, `error`, and `interface` declarations (treated
    as visible across module boundaries in the current implementation),
  - exported type aliases: `export type ...;`, and
  - exported Formal Silk theories: `export theory` declarations (importable so
    they can be applied via `#theory Name(args);`).
- `impl` blocks do not introduce importable names directly, but loading the
  imported module makes its methods available for method-call checking on the
  corresponding types.

Name binding rules:

- Each entry in the `{ ... }` list names one imported symbol.
- `as` can be used to rename an imported symbol (`Name as Alias`).
  - For values (`fn` / `let` / `ext`), this introduces a value alias.
  - For type names (`struct` / `enum` / `error` / `interface`) and exported
    type aliases (`export type`), this introduces a local `type` alias
    (transparent: it does not create a new type identity).
  - For Formal Silk theories (`export theory`), this introduces a theory alias.
- Imported names are introduced into the importing module as unqualified names
  (matching the existing behavior for package imports).
- Importing an unknown name from a file is an error.
- Importing the same value name from multiple file imports without aliasing is
  an error.
- Importing a value name that is already visible in the module (for example
  via same-package scope or a package import) is treated as a no-op in the
  current implementation **unless** it conflicts with a local declaration in
  the importing module.
- Importing a type name that is already visible in the module is treated as a
  no-op in the current implementation.

### Default imports and namespace imports

A module may declare a single *default export* and importing modules may bind
that default export with a JS-style default import:

```silk
// module.slk
package module;

export default fn () -> int {
  return 1 + 2;
}
```

```silk
// main.slk
import foo from "./module.slk";

fn main () -> int {
  let value = foo();
  if (value != 3) {
    return 1;
  }
  return 0;
}
```

Rules:

- Default exports are module-level and are consumed by default imports
  (`import Name from "<specifier>";`).
- A default export may be declared in either of two ways:
  - a default-exported function declaration:
    - `export default fn ...` (the function name is optional only in this form),
  - or a default-export statement:
    - `export default Name;` (names an in-scope symbol in the current module).
- Default exports may target any top-level symbol kind that can be referenced
  by name:
  - functions (`fn`),
  - top-level bindings (`let` / `const` / `var`),
  - external bindings (`ext`),
  - type aliases (`type`),
  - nominal types (`struct`, `enum`, `error`, `interface`),
  - Formal Silk theories (`theory`).
- Each module MAY declare **at most one** default export.
- A default export is distinct from named exports:
  - `export default fn add () -> int { ... }` declares a default export whose
    internal name is `add` within the module,
  - but it does **not** implicitly create a named export of `add` for other
    modules. To export it as a named export, write `export fn add ...` (or add
    an explicit named export form once one exists in the language).
- The function name after `fn` is optional only for default exports. When the
  name is omitted (`export default fn () -> ...`), the function is anonymous in
  the surface language and can only be referenced by importing it via a default
  file import.
- Default imports have two behaviors depending on whether a default export
  exists:

  - If the imported module declares `export default`, the local name binds to
    that default-exported symbol.
  - If the imported module does **not** declare a default export, the default
    import becomes a **namespace import**: the local name refers to the
    imported module’s namespace and its exported names are accessed via
    `foo::Name`.

  In other words: *if there is no explicit default export, the module’s
  namespace is treated as the default export.*

- When a default import binds a default export, it introduces a single
  unqualified name into the importing module:
  - if the default export is callable (a `fn` or an `ext` function), it binds a
    callable value name (`foo()`),
  - if the default export is a type (`struct`/`enum`/`error`/`interface`/`type`),
    it binds a type name usable in type positions (and as the head of struct
    literals),
  - if the default export is a Formal Silk theory, it binds a theory name that
    may be applied via `#theory foo(args...);`,
  - if the default export is a non-callable value (`let`/`const`/`var` or a
    non-function `ext`), it binds a value name.
  When a default import binds a namespace, it does not introduce any unqualified
  imported names; you must use `foo::Name` to access exported names.
- Using a namespace import name as a callable (e.g. `foo()`) is an error; add an
  explicit `export default` to the imported module or use a named import.

Package namespace imports:

- For a **package specifier** (for example `import ui from "ui";`), the default
  import binds the package’s default export when the package declares one.
  Otherwise, it binds a namespace and exported names are accessed via `ui::Name`.

## Exports

Top-level declarations can be marked as exported using the `export`
modifier:

```silk
package my_app::core;

export fn main () -> int {
  return 0;
}

export let answer: int = 42;
```

Rules:

- `export` is not allowed inside blocks; it applies only to module-level
  declarations. Inside `impl` blocks, `public` controls method visibility and
  `export` is reserved for static members.
- The initial implementation supports `export` on:
  - functions (`export fn ...`), including a declaration-only prototype form
    (`export fn name(...) -> T;`) used for header-style interface modules,
  - `let` and `const` bindings (`export let ...`, `export const ...`).
  - `ext` declarations (`export ext name = ...;`),
  - Formal Silk theories (`export theory Name(...) { ... }`),
  - `type` aliases (`export type Name = ...;`),
  - `struct` declarations (`export struct Name { ... }`),
  - `enum` declarations (`export enum Name { ... }`),
  - `error` declarations (`export error Name { ... }`),
  - `interface` declarations (`export interface Name { ... }`),
  - static members inside `impl` blocks (`impl T { export fn ... }` with no
    `self` receiver).
- The `export` modifier marks a declaration as part of the package’s
  externally visible surface. The exact visibility rules across packages
  (including how exports appear in the resolver and back-end symbol tables)
  will be specified and implemented alongside the package graph in

In the current implementation, most type names are treated as visible across
module boundaries once the relevant module(s) are loaded into the module set.
The `export` modifier is still recorded on type declarations so the
package/export model can be tightened later without changing source.

### Prototype exports (`export fn ...;`)

In addition to ordinary function definitions (`export fn ... { ... }`), a module
may declare a **prototype** (a declaration without a body) by terminating the
signature with `;`:

```silk
module bar;

export fn foo (value: string) -> int;
```

This is the Silk analogue of a C/C++ header prototype or a TypeScript `*.d.ts`
declaration file:

- Other modules may import the prototype (named import or namespace import) and
  type-check calls against its signature.
- The prototype itself does **not** provide an implementation. The symbol must
  be provided at link time by:
  - another Silk source file in the same package that defines `export fn foo ... { ... }`, and/or
  - an object/archive input that defines the symbol (for example a `.o`/`.a`
    produced by a C compiler).
- Prototype declarations may include Formal Silk contract annotations (`#require`
  / `#assure` / contract `#theory` uses). This is the visible contract surface
  for callers; when the implementation is precompiled and the function body is
  not available in the module set, callers still type-check and may verify call
  sites against the prototype’s contract surface.

When both a prototype declaration and a source-level implementation are present
in the same build/module set, the compiler enforces:

- the signatures match, and
- the implementation package explicitly imports the prototype module (via a
  file import) so the relationship is declared in source.

Example (consumer imports the prototype):

```silk
import { foo } from "./ibar.slk";

export fn main () -> int {
  return foo("hello");
}
```

Example (implementation imports the prototype and provides the body):

```silk
module bar;

import "./ibar.slk"; // ambient import; used for conformance only

export fn foo (value: string) -> int {
  return 0;
}
```

This pattern is equivalent in intent to describing the export surface as an
`interface` and declaring module conformance (`module ... as ...`), but it is
file-based and designed to support separate compilation + link-style workflows.

### Re-export declarations (`export { ... };`)

In addition to `export fn ...` and `export let ...`, Silk supports exporting an
*already in-scope name* via a re-export declaration:

```silk
import { my_function } from "./module.slk";
export { my_function };
```

This is the idiomatic way to build “barrel” modules that forward selected
exports from other modules.

Rules (current compiler subset):

- A re-export declaration must appear at top level and ends with `;`.
- Each entry in the `{ ... }` list names a **local** in-scope symbol.
  - The entry may rename the exported name: `export { localName as ExportedName };`.
- Re-exported names are part of the module/package export surface, so other
  modules may import them via `import { Name } from "./barrel.slk";`.
- In the current implementation, `export { ... }` supports values and exported
  Formal Silk theories (`theory` declarations). It does not export type names.

## Common Pitfalls

- **Forgetting semicolons**: `package` and `import` declarations end with `;` (parse error, `E0001`).
- **Imports not at the top**: imports must come immediately after the optional
  `package` declaration and before any other top-level declaration (`E0001`).
- **Assuming package imports find code automatically**: a package import can only
  resolve if the package exists in the module set (fix by adding the relevant `.slk`
  files to the build, or by file-importing them; missing packages are `E1001`).
- **Calling a namespace import**: if `import foo from "./mod.slk";` binds a namespace
  (because there is no default export), then `foo()` is invalid; use `foo::Name` or
  add `export default` (`E2018`).
- **Name collisions with named imports**: when importing from multiple modules, use
  `as` to rename one binding (`E2004`).

## Relevant Tests

- Package import + unqualified/qualified access:
- Namespace imports (file and package):
- Named imports + aliasing:
- Re-exports (`export { ... };`):
- Default exports:
- Importing types and using exported methods:

==============================================================================
DOCS: Refinement Types (language/refinement-types)
URL: /silk/docs/?p=language/refinement-types
==============================================================================

# Refinement Types

Refinement types are types annotated with logical predicates that constrain the
set of values they may represent. They are a tool for making illegal states
unrepresentable and for turning certain classes of bugs into compile-time
errors.

current compiler subset. Today, Silk provides verification annotations
(`#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`) and formal Silk declarations (`#const`)

Note: in Silk, any use of a `where` predicate is verification syntax. When
`where` predicates are implemented, their presence will require proof (VC
generation + Z3 discharge) for the compiled module set, per

## Overview

A refinement type consists of:

- a **base type** (for example `int`, `string`, `&T`, or a struct), and
- a **predicate** that must hold for all values of the refinement type.

The predicate is written in Silk’s specification expression language (the same
expression grammar used by `#require` / `#assure`).

## Proposed Surface Syntax

One intended surface form is a record-like binder with a `where` clause:

```silk
type NonEmptyString = { s: string where std::length(s) > 0 };
```

Notes:

- `type` aliases are not implemented yet (this is design work).
- The binder name (`s`) is a name for the value being constrained, usable
  inside the predicate.

## Checking Model

The compiler/verifier discharges refinement predicates using:

- constant-folding and local reasoning for literals and simple expressions,
- facts established by control-flow (guards) when the verifier can prove them,
- facts provided by contracts (`#require` / `#assure`) and invariants
  (`#invariant`),
- and, where necessary, explicit evidence via helper constructors or lemmas.

When the compiler cannot prove a predicate, the program should fail to compile
with a diagnostic that:

- points to the predicate that could not be proven, and
- suggests how to provide evidence (guard, constructor, or contract).

## Relationship to `#require` / `#assure`

Refinement types and function contracts are meant to compose:

- A parameter of a refinement type encodes a precondition at the type level.
- A refinement return type encodes a postcondition at the type level.

Example (design-only):

```silk
type NonZeroInt = { n: int where n != 0 };
fn safe_divide(numer: int, denom: NonZeroInt) -> int {
  return numer / denom;
}
```

## Implementation Notes

In the current implementation:

- there is no `type` alias declaration,
- there is no `where` clause in types,
- and there is no verifier that can prove user-defined predicates.

The existing verification directives (`#require`, `#assure`, `#assert`,
`#invariant`, `#variant`, `#monovariant`) are parsed, type-checked as `bool` where appropriate, and preserved
as metadata, but they do not yet affect code generation.

==============================================================================
DOCS: Regions (language/regions)
URL: /silk/docs/?p=language/regions
==============================================================================

# Regions

Regions provide a fixed-size, **statically allocated** block of memory that can
be used as an allocation context for `new`.

Regions are represented at runtime as a first-class `Region` handle value. A
`Region` value may be passed to functions, stored in structs, and exported.

## Syntax

### `Region` handle type

`Region` is a primitive value type representing a region allocation context.

Conceptually, a `Region` value contains:

- a base pointer to the backing bytes,
- a pointer to a mutable cursor cell (shared by copies of the handle), and
- a byte limit used for overflow checking.

Copying a `Region` value copies the handle; copies refer to the same backing
store and cursor.

### Declaring a region

A region declaration has the surface form:

```silk
const region arena: u8[1024];
```

Rules:

- `const region` is a declaration form (it is not a type).
- A region declaration has no initializer.
- The type annotation specifies the region backing size and must be a fixed
  byte array type: `u8[N]`.
- The declared name is bound as a `Region` value.

### Using a region: `with`

`with` establishes a region allocation context for the enclosed block.

#### 1) Bind an existing region

`with <region> { ... }` activates a named region binding:

```silk
struct Packet { x: int }

fn main () -> int {
  const region arena: u8[1024];

  with arena {
    let p: &Packet = new Packet{ x: 1 };
    // ...
  }

  return 0;
}
```

The `<region>` name may refer to any `Region`-typed binding, including a region
parameter passed to a function:

```silk
struct Packet { x: int }

fn alloc_in (r: Region) -> int {
  with r {
    let p: &Packet = new Packet{ x: 1 };
    return p.x;
  }
}
```

#### 2) Use an anonymous region with an explicit byte budget

`with <bytes> { ... }` (or `with(<bytes>) { ... }`) creates an anonymous region
backed by `<bytes>` writable bytes and activates it for the block:

```silk
struct Packet { x: int }

fn main () -> int {
  with 1024 {
    let p: &Packet = new Packet{ x: 1 };
    // ...
  }
  return 0;
}
```

Rules ():

- `<bytes>` must be a positive integer literal.

#### 3) Use a slice of an existing region (`from`)

`with <bytes> from <region> { ... }` creates an anonymous region backed by the
first `<bytes>` bytes of `<region>`:

```silk
struct Packet { x: int }

fn main () -> int {
  const region arena: u8[2048];

  with 1024 from arena {
    let p: &Packet = new Packet{ x: 1 };
    // ...
  }

  return 0;
}
```

You may also specify a byte slice of the source region:

```silk
with 1024 from arena[64..] {
  // uses bytes 64..(64 + 1024) of `arena`
}

with 1024 from arena[64..1088] {
  // uses bytes 64..1088 of `arena`
}
```

Rules ():

- `<bytes>` must be a positive integer literal.
- `<region>` must name a `Region` value that has a compile-time-known backing size
  In Silk (for example a `const region` declaration).
- Slice bounds use **byte offsets** (the region backing store is `u8[N]`).
- `<start>` / `<end>` must be non-negative integer literals.
- When an explicit `<end>` is present, it is exclusive (`[start..end]`).
- The `from` slice must contain at least `<bytes>` writable bytes:
  - `with <bytes> from r { ... }` requires `<bytes> <= sizeof(r)`.
  - `with <bytes> from r[start..end] { ... }` requires `<bytes> <= end - start`.
  - `with <bytes> from r[start..] { ... }` requires `<bytes> <= sizeof(r) - start`.

## Semantics

### Region-backed `new`

Within a `with <region> { ... }` block:

- any `new` allocation performed by the compiler’s `new` lowering uses the
  active region as its backing store,
- allocations are **8-byte aligned** in the current implementation subset,
- if the region does not have enough remaining space, the program traps.

Outside of a `with` block, `new` uses the current heap model described in

### Region-backed raw allocation (`std::runtime::mem::alloc`)

Within the dynamic extent of a `with <region> { ... }` block (including calls
performed while the block is active):

- `std::runtime::mem::alloc(n)` allocates an `n`-byte payload from the active
  region (8-byte aligned) and reserves an additional 8-byte header immediately
  before the returned pointer (used by the runtime to distinguish region-backed
  and heap-backed pointers and to record the allocation size),
- if the region does not have enough remaining space, the program traps.

Implication for `with <bytes>` limits: each `alloc(n)` consumes at least
`n + 8` bytes of region capacity (plus any alignment padding from 8-byte
alignment).

Region-backed raw allocations are bump-allocated. In the current runtime model:

- `std::runtime::mem::free` is a no-op for region-backed pointers,
- `std::runtime::mem::realloc` reallocates by allocating a new region block and
  copying bytes (it never calls libc `realloc` on a region-backed pointer).

### Nested `with`

Nested `with` blocks use the innermost active region:

```silk
with a {
  with b {
    // `new` uses region `b` here.
  }
}
```

## Reclaiming Region Memory ()

Regions are bump allocators: each allocation advances a cursor within the
backing byte buffer.

Because region-backed `new` allocations are still RC-managed in the current
subset and do not free backing bytes on last-release, reclaiming region memory
requires resetting the region cursor so the backing bytes can be reused.

Current behavior:

- `with <region> { ... }` activates the region but does **not** reset its cursor.
  - allocations across multiple `with <region>` blocks accumulate and can
    eventually overflow and trap.
- `with <bytes> { ... }` creates an anonymous region and resets its cursor to `0`
  on entry so repeated execution of the block starts from an empty region.
- `with <bytes> from <region>[...] { ... }` creates an anonymous region backed by
  a subrange of `<region>` and resets its cursor to the slice start on entry.

Important limitation:

- The compiler does not yet enforce “region allocations must not escape the
  `with` block”. Because anonymous-region cursors are reset on entry, code must
  treat pointers/`&Struct` values allocated inside `with <bytes> { ... }` and
  `with <bytes> from ... { ... }` as block-scoped.

## Exports

Region declarations may be exported and imported like other top-level bindings:

```silk
export const region global_arena: u8[4096];
```

Exporting a region exports a `Region` handle that refers to the same backing
bytes and cursor cell. Importing a region binds a `Region` value that may be
used with `with` like a locally declared region.

==============================================================================
DOCS: Regular Expression Literals (language/literals-regexp)
URL: /silk/docs/?p=language/literals-regexp
==============================================================================

# Regular Expression Literals

Regular expression literals represent `regexp` values: compiled regular
expression bytecode that can be used by `std::regex` helpers.

The regex literal syntax is modeled after JavaScript:

- `/pattern/flags`

## Syntax

### Delimiters and scanning

Regex literals are scanned by the parser (not the lexer):

- the opening delimiter is a single `/`,
- the closing delimiter is the first unescaped `/` that is **not** inside a
  character class (`[...]`),
- after the closing delimiter, the parser consumes ASCII letters as flags.

The parser does not interpret regex escapes: backslash sequences are preserved
as bytes for the regex engine.

### Empty patterns and `//`

Because `//` introduces a line comment, an empty regex literal `//` is not a
valid token sequence. Use an explicit empty pattern, for example `/(?:)/`.

## Flags

The supported flag set is intentionally small in Silk:

- `g` — global (recorded; does not change `std::regex::matches` semantics)
- `i` — ignore case
- `m` — multiline
- `s` — dotAll
- `y` — sticky
- `d` — indices (recorded; not surfaced by `std::regex` helpers)

The type checker rejects:

- unknown flags,
- duplicate flags (for example `/a/ii`).

## Semantics

- A regex literal’s value is a non-owning `{ ptr, len }` view (`regexp`) into
  compiled bytecode embedded in read-only data.
- The bytecode format is owned by the runtime regex engine; `regexp` values are
  opaque and must be consumed via `std::regex`.
- In Silk, matching is defined over the raw bytes of the input
  `string`, and match indices are byte offsets.

## Examples

### Basic `test`

```silk
import std::regex;

fn main () -> int {
  if std::regex::matches(/hello/, "hello world") {
    return 0;
  }
  return 1;
}
```

## Related Documents

==============================================================================
DOCS: Silk Syntax Tour (Soup to Nuts) (language/syntax-tour)
URL: /silk/docs/?p=language/syntax-tour
==============================================================================

# Silk Syntax Tour (Soup to Nuts)

This document is an example-driven tour of Silk’s **surface syntax**, from a
single-file “hello world” through modules/packages, declarations, statements,
expressions, and the Formal Silk verification directives.

This guide complements (not replaces):


## 0. Minimal Executable Module

The smallest executable is a module with a `main` function:

```silk
fn main () -> int {
  return 0;
}
```

Notes:

- Most statements end with `;`.
- Blocks are `{ stmt* }`.
- The entrypoint for an executable build is `main` returning `int` (see

## 1. Lexical Basics

### Whitespace and comments

Whitespace (spaces, tabs, newlines) is generally allowed between tokens.

Comments:

```silk
// Line comment
/* Block comment (non-nesting) */
```


```silk
/// Line doc comment
/**
 * Block doc comment
 *
 * @example silk
 * fn main () -> int { return 0; }
 */
fn main () -> int {
  return 0;
}
```

### Identifiers and qualified names

Names are often qualified with `::`:

```silk
package my_app::core;

import std::strings;

fn main () -> int {
  let s: string = std::strings::trim(" hi ");
  return 0;
}
```

### Formal Silk directive tokens (`#...`)

Formal Silk directives like `#require` and `#invariant` are **not comments**.
They are real tokens and are parsed as part of the language (see

```silk
#require x >= 0;
#assure result == x + 1;
fn inc (x: int) -> int {
  return x + 1;
}
```

## 2. Source File Structure: `package`/`module`, `import`, then declarations


1. Optional `package ...;` **or** `module ...;`
2. Zero or more `import ...;` declarations as a contiguous block
3. All other top-level declarations (`fn`, `let`, `struct`, `enum`, `impl`, …)

### `package`

```silk
// app/main.slk
package app;

fn main () -> int {
  return 0;
}
```

### `module` (compile-time-only module values)

```silk
// crypto/sha256.slk
module crypto::sha256;
```

Modules can declare interface conformance (design surface is implemented):

```silk
// drivers/uart.slk
module drivers::uart as Device;
```

## 3. Imports and Exports


### Package imports

```silk
package app;

import std::strings;

fn main () -> int {
  let s: string = trim(" hi "); // may be visible unqualified in the 
  let t: string = std::strings::trim(" hi ");
  return 0;
}
```

### File imports (`from "..."`)

Named import:

```silk
// main.slk
import { answer as the_answer } from "./util.slk";

fn main () -> int {
  return the_answer;
}
```

Default import (binds a default export if present, otherwise a namespace):

```silk
// module.slk
export default fn () -> int {
  return 3;
}
```

```silk
// main.slk
import foo from "./module.slk";

fn main () -> int {
  return foo();
}
```

### Named exports and re-exports

Export a declaration directly:

```silk
// util.slk
export let answer: int = 42;

export fn add1 (x: int) -> int {
  return x + 1;
}
```

Re-export an in-scope name:

```silk
// api.slk
import { answer } from "./util.slk";
export { answer as the_answer };
```

## 4. Top-Level Declarations (Overview + Examples)

This section shows the core top-level declaration forms:

- bindings: `const`, `let`, `var`
- functions: `fn` (plus `pure`/`async`/`task`)
- type aliases: `type`
- types: `struct`, `enum`, `interface`, `impl`, `error`
- external declarations: `ext`
- tests: `test`
- Formal Silk: `theory` (and `#...` directives)

### 4.1 Bindings: `const`, `let`, `let mut`, `var`

Example ( requires initializers; see `E2015`):

```silk
fn main () -> int {
  const answer: int = 42;
  let x: int = answer;
  let mut y: int = 0;
  var z: int = 1; // `var` is an alias for `let mut` ()

  y = y + 1;
  z += 2;
  return x + y + z;
}
```

Notes:

- `const` initializers must be compile-time evaluable in Silk
  (see `E2041`).
- Only `let mut`/`var` bindings are assignable lvalues (see
- Destructuring `let` bindings are supported for struct values:

  ```silk
  struct User { id: u64, name: string }
  let (id, name) = User{ id: 123, name: "alice" };

  struct Record { id: u64, data: string }
  let { data as d, id as i } = Record{ id: 456, data: "other" };
  ```

  Array destructuring is also supported:

  ```silk
  let records: Record[] = [{ id: 123, data: "a" }, { id: 456, data: "b" }];
  let [a, b] = records;
  ```

  Enum destructuring is also supported:

  ```silk
  import std::result;

  fn main () -> int {
    type R = std::result::Result(int, int);
    let Ok(value) = R.ok(7);
    return value;
  }
  ```

### 4.2 Functions: `fn` (plus `pure`, `async`, `task`)

Basic function declaration:

```silk
fn add (x: int, y: int) -> int {
  return x + y;
}
```


```silk
pure fn inc (x: int) -> int {
  return x + 1;
}
```


```silk
task fn worker () -> int {
  return 7;
}

async fn main () -> int {
  task {
    let t = worker(); // Task(int)
    let value: int = yield t;
    return value;
  }
}
```

#### Parameters: `mut`, defaults, and varargs

Mutable reference parameters require `mut` both in the signature and at the

```silk
struct Pair { a: int, b: int }

fn bump_a (mut p: &Pair) -> void {
  p.a += 1;
}

fn main () -> int {
  let mut p: Pair = Pair{ a: 1, b: 2 };
  bump_a(mut p);
  return p.a;
}
```

Default arguments ( restricts default expressions to a constant/literal subset):

```silk
fn add2 (x: int, y: int = 2) -> int {
  return x + y;
}
```


```silk
fn log (fmt: string, ...args: std::fmt::Arg) -> void {
  std::io::println(fmt, args);
}
```

#### Generic function parameter split (`;`) (Design, parsed but rejected)

Generic functions use `;` to separate compile-time parameters from value parameters:

```silk
// Design (currently rejected with `E2016`).
fn get_first(T, N: int; xs: &T[N]) -> T {
  return xs[0];
}
```

### 4.3 Function expressions (lambdas)

Example (non-capturing expression body):

```silk
fn main () -> int {
  let add = fn (x: int, y: int) -> x + y;
  return add(1, 2);
}
```

Example (block body with explicit return type):

```silk
fn main () -> int {
  let add = fn (x: int, y: int) -> int {
    return x + y;
  };
  return add(1, 2);
}
```


### 4.4 Type aliases: `type`

Basic alias:

```silk
type I = int;
```


```silk
type struct UserId = int;
type fn IntAdder = fn(int, int) -> int;
type pure fn PureIntAdder = fn(int, int) -> int;
```

### 4.5 Structs: `struct` and `impl`

Struct declarations (fields use `name: Type`, optional default with `=`):

```silk
struct Point {
  x: int = 0,
  y: int = 0,
}
```

Struct literals:

```silk
fn main () -> int {
  let p1: Point = Point{ x: 1, y: 2 };
  let x = p1.x;

  // Shorthand field init (`x` means `x: x`):
  let y: int = 3;
  let p2: Point = Point{ x, y };

  return x + p2.y;
}
```

Inferred struct literals require an expected struct type context:

```silk
fn main () -> int {
  let p: Point = { x: 1, y: 2 };
  return p.x + p.y;
}
```

Heap allocation (`new`) produces a `&Struct` reference in Silk:

```silk
struct Boxed { value: int }

fn main () -> int {
  let b: &Boxed = new Boxed{ value: 7 };
  return b.value;
}
```


```silk
impl Point {
  public fn sum (self: &Point) -> int {
    return self.x + self.y;
  }
}

fn main () -> int {
  let p: Point = Point{ x: 1, y: 2 };
  return p.sum();
}
```


```silk
// Design shape (field/layout rules and  limits are documented).
struct Base { x: int = 0 }
struct Derived extends Base { y: int = 0 }
```

### 4.6 Enums: `enum` + `match` expression

```silk
enum Color {
  Red,
  Rgb(u8, u8, u8),
}

fn to_int (c: Color) -> int {
  return match c {
    Color::Red => 0,
    Color::Rgb(r, g, b) => (r as int) + (g as int) + (b as int),
  };
}
```


### 4.7 Interfaces and `impl ... as ...`

```silk
interface Counter {
  fn inc() -> void;
  fn get() -> int;
}

struct Cell { value: int = 0 }

impl Cell as Counter {
  fn inc (mut self: &Cell) -> void {
    self.value += 1;
  }

  fn get (self: &Cell) -> int {
    return self.value;
  }
}
```


### 4.8 Typed errors: `error`, `panic`, `T | ErrorType...`, `match` statement, `?`

Error type declaration:

```silk
error OutOfBounds {
  index: int,
  len: int
}
```

Error-producing signatures use `|`:

```silk
fn get_at (xs: &u8[], index: int) -> u8 | OutOfBounds {
  if index < 0 || index >= std::length(xs) {
    panic OutOfBounds { index: index, len: std::length(xs) };
  }
  return xs[index];
}
```

Handling typed errors uses the `match` **statement** form:

```silk
fn main () -> int {
  match (get_at([1, 2, 3], 10)) {
    value => {
      return value as int;
    },
    err: OutOfBounds => {
      std::abort();
    }
  }
}
```

Propagating errors from calls uses postfix `?`:

```silk
// Example when `main` declares a compatible error set.
fn main () -> int | OutOfBounds {
  let x: u8 = get_at([1, 2, 3], 0)?;
  return x as int;
}
```


### 4.9 External declarations: `ext`


```silk
export ext puts = fn(string) -> int;
export ext c_abort "abort" = fn() -> void;
export ext errno "errno" = int;
```

Note: C variadics (`printf`-style `...`) via `ext` are not implemented yet; see


### 4.10 Tests: `test`

```silk
test "addition works" {
  if (1 + 2) != 3 {
    std::abort();
  }
}
```


### 4.11 Formal Silk theories: `theory`

Top-level theory (exportable/importable):

```silk
export theory nonzero (x: int) {
  #require x != 0;
}
```

Apply a theory inside a function:

```silk
import { nonzero } from "./theories.slk";

fn main () -> int {
  let x: int = 1;
  #theory nonzero(x);
  return 0;
}
```

Inline (block-local) theories use the same `#theory` token and are
disambiguated from theory use by `{ ... }` (inline declaration) vs `;` (use):

```silk
fn main (x: int, y: int) -> int {
  #theory local_sum_nonzero (x: int, y: int) {
    #const z = x + y;
    #assure z != 0;
  }

  #theory local_sum_nonzero(x, y);
  return 0;
}
```


## 5. Types (Surface Forms)


### Primitive types

```text
bool, i8/u8, i16/u16, i32/u32, i64/u64, int, f32/f64, char, string, void, Instant, Duration
```

### Optional types

```silk
fn main () -> int {
  let a: int? = None;
  let b: int? = Some(7);
  let c: int = b ?? 0;
  return c;
}
```

Nested optionals use `??` in type position (`T??` means “optional of optional”):

```silk
fn main () -> int {
  let x: int?? = Some(Some(1));
  let y: int? = x ?? None;
  return (y ?? 0);
}
```

Optional `match` expressions are the explicit form of optional consumption:

```silk
fn main () -> int {
  let x: int? = Some(7);
  let y: int = match x {
    None => 0,
    Some(v) => v,
  };
  return y;
}
```

### References

```silk
fn sum (p: &Point) -> int {
  return p.x + p.y;
}
```

### Arrays and slices

```silk
fn main () -> int {
  let xs: int[] = [1, 2, 3];
  return xs[0];
}
```

Fixed-length arrays use `T[N]`:

```silk
fn main () -> int {
  let xs: int[3] = [1, 2, 3];
  return xs[2];
}
```

### Function types

```silk
type IntBinOp = fn(int, int) -> int;

fn main () -> int {
  let add: IntBinOp = fn (x: int, y: int) -> x + y;
  return add(1, 2);
}
```

### Applied types and generics

Generic parameter lists on `struct`/`interface`/`impl` are implemented:

```silk
struct Box(T) { value: T }

fn main () -> int {
  let b: Box(int) = { value: 1 };
  return b.value;
}
```

const parameters/arguments and generic functions).

## 6. Statements (Inside Blocks)


### `if` / `else`

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  } else {
    return 1;
  }
}
```

### `loop`, `while`, `for`

```silk
fn main () -> int {
  let mut i: int = 0;
  while i < 3 {
    i += 1;
  }
  return i;
}
```


```silk
fn main () -> int {
  let mut sum: int = 0;
  for i in 0 .. 5 {
    sum += i;
  }
  return sum;
}
```

C-style `for` header:

```silk
fn main () -> int {
  let mut sum: int = 0;
  for (let mut i: int = 0; i < 5; i += 1) {
    sum += i;
  }
  return sum;
}
```

### `break`, `continue`, `return`

```silk
fn main () -> int {
  let mut i: int = 0;
  loop {
    i += 1;
    if i < 3 {
      continue;
    }
    break;
  }
  return i;
}
```

### `assert` and `panic`

```silk
fn main () -> int {
  assert 1 + 2 == 3;
  assert(2 + 2 == 4, "math is broken");
  return 0;
}
```


```silk
panic OutOfBounds { index: 1, len: 0 };
```

### `match` statement (typed errors)

pattern forms.

### `async { ... }` and `task { ... }`

Structured blocks (implemented as lexical blocks in Silk; see

```silk
async fn main () -> int {
  async {
    // async region
  }
  task {
    // task region
  }
  return 0;
}
```

### Concurrency operators: `await`, `await *`, `yield`, `yield *`

`await` unwraps `Promise(T)` values inside `async fn`:

```silk
async fn add2 (x: int) -> int {
  return x + 2;
}

async fn main () -> int {
  let p = add2(1); // Promise(int)
  let v: int = await p;
  return v;
}
```

`await *` awaits a collection of promises and yields a collected `T[]`:

```silk
async fn add1 (x: int) -> int {
  return x + 1;
}

async fn main () -> int {
  let values: int[] = await * [add1(1), add1(2), add1(3)];
  return values[0] + values[1] + values[2];
}
```

`yield` / `yield *` interact with `Task(T)` values (used inside `task` regions in
the ):

```silk
task fn producer (n: int) -> int {
  var i: int = 0;
  while i < n {
    yield i;
    i += 1;
  }
  return n;
}

async fn main () -> int {
  task {
    let t = producer(2); // Task(int)
    let values: int[] = yield * t;
    return values[0] + values[1] + values[2];
  }
}
```

## 7. Expressions (Precedence + Demonstrations)

Silk expressions follow a conventional precedence hierarchy. For the exact

### Literals and other primary expressions


```silk
fn main () -> int {
  // Booleans.
  let b: bool = true;

  // Integers and floats.
  let i: int = 42;
  let u: u8 = 0xFF;
  let f: f64 = 3.14;

  // Characters and strings.
  let ch: char = 'A';
  let s1: string = "hello";
  let s2: string = `raw \n no escapes`;

  // Durations.
  let d: Duration = 10ms;

  // Optionals.
  let opt: int? = Some(i);
  let x: int = opt ?? 0;

  // Arrays.
  let xs: int[] = [1, 2, 3];

  assert b;
  assert x == 42;
  assert xs[0] == 1;
  assert u == 0xFF;
  assert s1 == "hello";
  assert s2 == `raw \n no escapes`;
  assert ch == 'A';
  assert (f as int) == 3;
  assert (d as int) == (d as int);

  // `d` exists to demonstrate duration literal syntax. See `docs/language/literals-duration.md`.
  return 0;
}
```

### Postfix forms: calls, fields, indexing, casts, `?`, `++/--`

```silk
struct Point { x: int, y: int }

fn main () -> int {
  let xs: int[] = [10, 20, 30];
  let a: int = xs[0];
  let b: int = (a + 1) as int;
  let c: int = Point{ x: 1, y: 2 }.x;
  return b + c;
}
```

### `as` and `as raw`

`as` performs explicit numeric/shape casts and `as raw` performs raw bit casts

```silk
fn main () -> int {
  let bits: u64 = (1.0 as f32) as raw u64;
  let f: f32 = bits as raw f32;
  return f as int;
}
```

### Unary forms: `!`, `~`, `-`, `new`, `await`, `yield`, `mut`, `++/--`

```silk
fn main () -> int {
  let mut x: int = 0;
  ++x;
  x++;
  if !(x == 2) {
    return 1;
  }
  return 0;
}
```

`mut <expr>` is permitted only where a mutable borrow is required (most
commonly, in call arguments and method receivers):

```silk
struct Pair { a: int, b: int }

fn bump (mut p: &Pair) -> void {
  p.a += 1;
}

fn main () -> int {
  let mut p: Pair = Pair{ a: 0, b: 0 };
  bump(mut p);
  return p.a;
}
```

### Arithmetic, bitwise, comparisons, and boolean operators

```silk
fn main () -> int {
  let a: int = 1 + 2 * 3;
  let b: int = (a << 1) | 1;
  if (b >= 0) && (b != 0) {
    return b;
  }
  return 0;
}
```

### Optional operators: `?.` and `??`

```silk
struct User { email: string }

fn main () -> int {
  let user: User? = Some(User{ email: "a@b.c" });
  let email: string = user?.email ?? "unknown";
  if email == "a@b.c" {
    return 0;
  }
  return 1;
}
```

### Typed error propagation: postfix `?` on calls

```silk
fn main () -> int | OutOfBounds {
  let x: u8 = get_at([1, 2, 3], 0)?;
  return x as int;
}
```

## 8. Formal Silk (Verification) Syntax

Formal Silk is Silk’s compile-time verification surface (Z3-backed). It uses
directive tokens that attach to functions and loops:

- function contracts: `#require`, `#assure`, `#theory`
- loop contracts: `#invariant`, `#variant`, `#monovariant`
- formal Silk declarations: `#const`
- block-local proof obligations: `#assert`
- reusable proof bundles: `theory` / `#theory`

current restrictions.

### Contracts on functions

```silk
#require x >= 0;
#assure result == x + 1;
fn inc (x: int) -> int {
  return x + 1;
}
```

### Loop invariants, variants, and monovariants

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  #monovariant i;
  while i < limit {
    i += 1;
  }
  return 0;
}
```

### Theories (`theory` / `#theory`)

```silk
export theory add_commutes (x: int, y: int) {
  #assure (x + y) == (y + x);
}

#theory add_commutes(x, y);
fn add (x: int, y: int) -> int {
  return x + y;
}
```

## 9. Next References

If you want more detail on a specific construct, jump to:

==============================================================================
DOCS: Silkdoc (Documentation Comments) (language/doc-comments)
URL: /silk/docs/?p=language/doc-comments
==============================================================================

# Silkdoc (Documentation Comments)

This document specifies **Silkdoc**, Silk’s documentation-comment format.
Silkdoc comments are intended for tools (documentation generators, editors,
and the language server). They **do not** affect program semantics.

The goal is a familiar JSdoc feel with Silk/TypeScript-style type annotations.

## Comment Forms

Two doc-comment forms are recognized:

- **Block doc comments**: `/** ... */`
- **Line doc comments**: one or more consecutive lines starting with `///`

In both forms, doc comments attach to the *next* declaration when they appear
immediately before it with only whitespace/comments between them.

Initial implementation scope:

- Doc comments attach to **top-level declarations** (`package`, `module`,
  `import`, `fn`, `theory`, `let`, `struct`, `ext`, `interface`, `impl`).
- Doc comments also attach to:
  - methods inside `impl Type { ... }` blocks, and
  - method signatures inside `interface Name { ... }` blocks.
- For function declarations, doc comments attach even when one or more formal
  verification annotations (`#require` / `#assure`) appear between the doc
  comment and the `fn` keyword.
- Doc comments inside function bodies are treated as ordinary comments (not
  attached to anything).
- Attaching doc comments to struct fields, parameters, and locals is future
  work.

## Content Model

A doc comment contains:

- free-form text (Markdown-friendly) describing the declaration, and
- optional **tags** starting with `@`.

The free-form text is everything before the first tag line.

Any non-tag lines that appear after the first tag line are ignored unless they
are part of a multi-line tag body (for example `@example` or `@remarks`).

### Leading `*` convention

For block doc comments, the conventional leading `*` is ignored:

```silk
/**
 * Hello
 * world
 */
```

Tools strip the leading `*` (and one following space when present) before
parsing.

## Tags

Tags begin at the start of the logical line after stripping comment prefixes.

### `@param`

Declare a parameter description.

Syntax:

```text
@param <name>: <Type> <description...>
@param <name> <description...>
```


Example:

```silk
/**
 * Appends one byte to the vector, growing as needed.
 *
 * @param self: &std::vector::Vector(u8) The receiver.
 * @param value: u8 The byte to append.
 */
```

### `@returns`

Describe the return value.

Syntax:

```text
@returns <Type> <description...>
@returns <description...>
```

### `@throws`

Describe an error/exception-like condition.

Syntax:

```text
@throws <Type> <description...>
@throws <description...>
```

Note: the language does not yet have a stable error type; `@throws` is
documentation-only until `Result(T, E)` and error conventions are fully
implemented.

### `@external`

Indicate that a declaration is an **external FFI binding** (its implementation
is provided outside Silk).

This tag is typically used to document `ext` function declarations.

Syntax:

```text
@external
```

### `@example`

Provide an example snippet. The tag may optionally declare a language for
Markdown fenced code blocks.

Syntax:

```text
@example
<one or more lines of example text>

@example silk
<one or more lines of code>
```

The example body continues until the next tag line or the end of the doc
comment.

### Other tags

The initial toolchain may also recognize:

- `@since <text...>`
- `@deprecated <text...>`
- `@remarks <text...>` (may span multiple lines like `@example`)
- `@see <text...>` (repeatable)

Additional tags must be documented here before they are relied on by tooling.

### Formal Silkdoc tags

Silkdoc can document Formal Silk constructs without affecting verification.
These tags are documentation-only (they do not prove anything and do not
introduce Formal Silk obligations).

#### `@requires`

Document one precondition for a declaration (typically mirroring `#require` on a
function or a theory).

Syntax:

```text
@requires <Expr...>
```

This tag is repeatable.

#### `@assures`

Document one postcondition for a declaration (typically mirroring `#assure` on
a function or a theory).

Syntax:

```text
@assures <Expr...>
```

This tag is repeatable.

#### `@asserts`

Document one internal proof obligation (typically mirroring a `#assert` inside a
function or theory body).

Syntax:

```text
@asserts <Expr...>
```

This tag is repeatable.

#### `@theory`

Document one theory attachment or use (typically mirroring `#theory Name(args...);`).

Syntax:

```text
@theory <Name(args...)...>
```

This tag is repeatable.

### Manpage-oriented tags

The toolchain uses a small set of optional doc tags to generate `man(7)` pages
from source comments (`silk doc --man` and `silk man`).

These tags are documentation-only and do not affect program semantics.

#### `@misc`

Declare a conceptual documentation block intended for man section 7.

Syntax:

```text
@misc <label> <summary...>
@misc <label>
```

Notes:

- The `<label>` is an opaque identifier used by tooling for discovery (for
  example `silk man <label>`). It should be stable and globally unique within a
  package (recommendation: use a `pkg::topic` label).
- The optional `<summary...>` provides a one-line description for the manpage
  `NAME` section. When omitted, tools may derive a summary from the first line
  of the free-form description text.

#### `@cli`

Declare that a doc comment describes a command-line interface, intended for man
section 1.

Syntax:

```text
@cli <name>
@cli
```

When `<name>` is omitted, tools derive the command name from context (for
example the module name or executable name provided by the build system).

#### `@synopsis`

Provide one or more synopsis lines for a CLI manpage.

Syntax:

```text
@synopsis
<one or more lines of synopsis text>
```

The synopsis body continues until the next tag line or the end of the doc
comment.

#### `@option`

Declare a command-line option for a CLI manpage. This tag is repeatable.

Syntax:

```text
@option <prototype...>
@option `<prototype...>` <description...>
```

Examples:

```text
@option `-h, --help` Show help and exit.
@option `--out <path>` Write output to <path>.
```

#### `@command`

Declare a subcommand for a CLI manpage. This tag is repeatable.

Syntax:

```text
@command <name> <description...>
```

## Markdown Rendering

The documentation generator renders doc comments to Markdown using:

- the free-form text as the leading description (paragraphs preserved),
- `@param` entries as a “Parameters” list,
- `@returns` as a “Returns” section,
- `@throws` as a “Throws” section,
- `@requires`, `@assures`, `@asserts`, and `@theory` as dedicated sections (one
  bullet per tag instance),
- `@example` blocks as fenced code blocks.

The generator must keep formatting stable (deterministic output) so that
documentation diffs are meaningful.

==============================================================================
DOCS: String Literals (language/literals-string)
URL: /silk/docs/?p=language/literals-string
==============================================================================

# String Literals

String literals represent `string` values: immutable, length-tracked sequences of
bytes that are typically interpreted as UTF-8 text.

Use strings for:

- filenames and paths,
- user-visible messages,
- structured formats (JSON, CSV, etc),
- and general “text” data.

If you need a single Unicode scalar value, use `char` literals

## Semantics

- The value of a string literal is a sequence of bytes.
- By convention and by intent, `string` values represent UTF-8 text, but some
  escape forms (notably `\xNN`) can construct byte sequences that are not valid
  UTF-8. Avoid this unless you are intentionally working with raw bytes.
- String literals are immutable.
- Unless otherwise specified for a particular FFI surface, string literals do
  not implicitly include a trailing `\0` byte; length is carried explicitly.

## Single-Line Strings

Single-line string literals:

- Use standard quote-delimited syntax.
- Support escape sequences as described below.

## Raw Strings (Backtick)

Raw string literals are delimited by backticks:

- `` `...` ``
- They may include newlines directly.
- They do **not** process escape sequences: `\n` is two bytes (`'\'` and `'n'`).
- They still normalize embedded `\r\n` / `\r` in the source text to `\n`.

## Escape Sequences

Double-quoted string literals support the same escape spellings as character
literals:

- `\\` (backslash)
- `\"` (double quote)
- `\'` (single quote)
- `\n` (newline, U+000A)
- `\r` (carriage return, U+000D)
- `\t` (tab, U+0009)
- `\0` (NUL byte, U+0000)
- `\xNN` (byte escape, two hex digits)
- `\u{...}` (Unicode scalar value escape, 1–6 hex digits)

When decoding `\u{...}` escapes, the compiler must reject non-scalar Unicode
values (for example surrogate code points).

## Multi-Line Strings

Multi-line strings:

- Allow embedding newlines directly in the literal.
- Must be represented and encoded identically to `string` values produced at runtime.

## Line Ending Normalization

When decoding string literals, the compiler must normalize:

- `\r\n` to `\n`
- `\r` to `\n`

This applies both to embedded newlines in multi-line literals and to escaped
forms such as `\r`.

Note: a sequence of two escapes like `"\r\n"` is still two escapes. In the
current implementation, `\r` escapes become `\n`, so `"\r\n"` produces two line
feed bytes (`"\n\n"`).

## Examples

### Basic string literal

```silk
fn main () -> int {
  let s: string = "hello";
  if s == "hello" {
    return 0;
  }
  return 1;
}
```

### Escapes and byte escapes

```silk
fn main () -> int {
  // Quote and backslash escapes.
  if "\"" != "\x22" { return 1; }
  if "\\" != "\u{005C}" { return 2; }

  // Control escapes.
  if "\t" != "\x09" { return 3; }
  if "\n" != "\x0A" { return 4; }
  if "\r" != "\n" { return 5; } // `\r` is normalized to `\n` in the .

  // NUL bytes are permitted; strings are length-tracked (not NUL-terminated).
  if "\0" != "\x00" { return 6; }

  // Unicode escapes insert UTF-8 bytes for that scalar.
  if "é" != "\u{00E9}" { return 7; }

  return 0;
}
```

### Multi-line string literal (embedded newline)

```silk
fn main () -> int {
  let multi: string = "a
b";

  // Equivalent to using a `\n` escape.
  if multi != "a\nb" {
    return 1;
  }

  return 0;
}
```

### Raw multiline string literal (backticks)

```silk
fn main () -> int {
  let multi: string = `a
b`;
  if multi != "a\nb" {
    return 1;
  }

  // Backslashes are literal bytes in raw strings.
  if `a\nb` != "a\\nb" { return 2; }

  return 0;
}
```

## Common Pitfalls

- **Expecting NUL termination**: `"hi"` does not include an implicit `\0`.
  Use `\0` explicitly when you need it, and prefer APIs that are length-aware.
- **Using `\xNN` for non-ASCII characters**: `\xNN` inserts a raw byte, not a
  Unicode scalar. Use `\u{...}` for text.
- **Assuming multi-line indentation stripping**: multi-line strings include all
  bytes between the quotes, including indentation spaces.

## Related Documents


## Relevant Tests

- Core string equality and ordering:
- Escape coverage:
- Raw/backtick coverage:

The compiler must:

- Implement lexing and parsing for both `"..."` and `` `...` ``.
- Normalize line endings and escapes according to the spec.
- Ensure compatibility with the FFI `SilkString` representation.

==============================================================================
DOCS: Structs, Impl Blocks, and Memory Layout (language/structs-impls-layout)
URL: /silk/docs/?p=language/structs-impls-layout
==============================================================================

# Structs, Impl Blocks, and Memory Layout

Structs and impl blocks are separated:

- `struct` declarations define pure data layout.
- `impl` blocks attach behavior to types without changing their layout.

## `struct` Declarations

Structs define a composite data type made of named fields:

```silk
struct Packet {
  sequence: u32,
  size: u16,
  flag: u8,
}
```

Key rules:

- Structs contain only data members.
- Memory layout and padding are well-defined so that FFI and ABI rules can rely on them.

### Generic structs

Structs may declare type parameters:

```silk
struct Data(T) {
  value: T,
}
```

Rules:

- A generic `struct Name(T, ...)` introduces a **type constructor** `Name`.
- Outside a generic context, uses of the type must be fully applied (for
  example `Data(u8)`), not bare `Data`.
- A declaration name may not be reused across different generic arities (for
  example `struct Foo { ... }` and `struct Foo(T) { ... }` cannot both exist in
  the same namespace).

### Field Default Initializers

Struct fields may include an optional default initializer expression:

```silk
struct Point {
  x: int = 0,
  y: int = 0,
}
```

When a struct literal omits a field, the compiler initializes the field from its
default expression.

In Silk, default field expressions use the same
restriction as default function arguments:

- no name references, and
- no `new`.

Example:

```silk
struct Point {
  x: int = 0,
  y: int = 0,
}

fn main () -> int {
  let p = Point{ x: 5 };
  return p.y; // defaults to 0
}
```

### Single Inheritance (`extends`)

Silk supports **single inheritance** for `struct` declarations via `extends`.

Surface syntax:

```silk
struct Base {
  x: int,
  y: int = 0,
}

struct Derived extends Base {
  z: int,
}
```

Semantics:

- A derived struct inherits all fields of its base struct.
- The derived struct’s field sequence is:
  1) all base fields (in declaration order), then
  2) all derived fields (in declaration order).
- Field access on the derived struct can refer to inherited base fields
  directly (`d.x`, `d.y`).
- Default field initializers are inherited:
  - a `Derived{ ... }` literal may omit inherited fields that have defaults in
    the base struct.

Type checking rules:

- `extends` is permitted only on non-opaque `struct` declarations.
- The base name must resolve to a `struct` type in the compiled module set.
- Cycles in `extends` chains are rejected.
- A derived struct may not declare a field whose name conflicts with an
  inherited field name.

Notes:

- `extends` does not imply implicit subtyping in Silk:
  there is no implicit coercion from `Derived` to `Base` (or `&Derived` to
  `&Base`) yet.

### Opaque Structs (FFI Handles)

Opaque structs are a special form of `struct` declaration intended for safely
representing foreign pointers/handles from C APIs.

Syntax:

```silk
// Declares an opaque handle type.
struct MyFFIHandle;
```

An opaque struct has **no fields** and **no Silk-defined layout**. It exists
only as a nominal handle type that can be passed around safely.

Rules:

- Opaque structs **cannot be instantiated** (no struct literals).
- Opaque structs **do not support field/member access** (`.` / `?.`).
- Opaque structs **must not be used by value** in type positions (locals,
  parameters, results). Only the reference form `&MyFFIHandle` is allowed.

These rules increase safety at the language boundary:

- **Eliminates type confusion**: distinct handle types such as `&DatabaseHandle`
  and `&FileHandle` are not interchangeable.
- **Prevents invalid operations in Silk**: Silk code cannot read/write fields or
  assume a size/layout for the foreign type.

#### Safety and Undefined Behavior (UB)

Opaque handles do not carry lifetime information. You are responsible for
calling the corresponding destruction/free function provided by the foreign
library.

Using an opaque handle after it has been destroyed is **undefined behavior**.
The compiler does not currently enforce this at compile time.

#### ABI and Lowering ()

In Silk, an `&Opaque` value is lowered as a single pointer
scalar (`u64` on the current `linux/x86_64` target), rather than as a
struct-of-pointers like `&struct` borrows.

### Memory Layout (Intended Contract)

The long-term Silk design is for `struct` layout to match conventional C layout
rules for the corresponding field types on the target:

- **Sequential layout**: fields appear in memory in the exact order they are
  declared in the `struct` definition.
- **Alignment and padding**: each field is placed at an offset that is a
  multiple of the field type’s required alignment. The compiler inserts padding
  bytes where necessary.
- **Final padding**: the overall struct size is padded to a multiple of the
  struct’s alignment (typically the maximum alignment of its fields), so arrays
  of the struct keep each element correctly aligned.

Example (typical C layout on `linux/x86_64`):

```silk
struct Packet {
  sequence: u32, // 4 bytes
  size: u16,     // 2 bytes
  flag: u8,      // 1 byte
}
```

Conceptually, this layout would be:

- `sequence` at offset `0` (4 bytes)
- `size` at offset `4` (2 bytes)
- `flag` at offset `6` (1 byte)
- 1 byte of tail padding at offset `7` to make the total size a multiple of 4

Total size: 8 bytes (alignment 4).

### Memory Layout

the compiler does **not** implement packed C-like struct
layout yet. Instead, it uses a *scalar slot* model:

- A `struct` value is lowered into a sequence of scalar “slots” in source order,
  after recursively expanding certain composite field types:
  - `string` contributes two slots: `(u64 ptr, i64 len)`.
  - nested non-opaque structs contribute their slot sequence.
  - optionals contribute `(bool tag, payload slots...)`, where payload slots
    follow the lowering of the underlying non-optional type.
- When a `struct` is stored in memory (stack locals and heap boxes), each slot
  is stored in a separate **8-byte cell**.
  - This means sub-64-bit fields (`bool`, `i8`/`u8`, `i32`/`u32`, `f32`, `char`,
    etc.) are not packed yet.
  - Values are still *typed* as their declared scalar kinds (the checker and IR
    track widths/sign), but the physical in-memory representation is widened to
    one 8-byte slot per scalar.

This design keeps lowering/codegen simple and lets the compiler support nested
aggregates without committing to a final packed layout. The trade-off is that
the in-memory representation is not ABI-compatible with a C struct unless the
struct is restricted to ABI-safe 64-bit slots.

Example (current implementation): the `Packet` above is lowered as 3 scalar
slots and occupies 24 bytes when stored in memory (3 × 8-byte cells), even
though the intended C-like packed layout would be 8 bytes.

### ABI and Code Generation

The Silk language design includes full support for user-defined structs, nested
aggregates, and FFI-safe ABI mapping. The current compiler/backend
implementation supports only a narrow, explicitly documented subset:

- Only "plain" structs with **0+ fields** are supported by codegen.
  - Empty structs (`struct Empty {}`) are currently represented as a single
    placeholder `u64` slot in the scalar-slot model.
- Fields may be:
  - scalar primitive types (`bool`, fixed-width integers, `int`, `char`,
    `f32`/`f64`, `Instant`, `Duration`),
  - `string` (lowered as `{ ptr: u64, len: i64 }`),
  - nested (non-opaque) structs,
  - and optionals (`T?`) of supported payload types.
- At ABI boundaries (exported functions and `ext` declarations), structs must be
  ABI-safe: after slot-flattening, all slots must be `i64`/`u64`/`f64` (for
  example `string` fields are ABI-safe because they lower to `(u64, i64)`, but
  `bool`, `char`, and `f32` fields are not).
- Such structs are passed and returned by value by lowering them to their
  scalar slots in order and following the System V AMD64 ABI rules for
  those scalar slots:
  - integer-like slots consume general-purpose argument slots (`rdi`, `rsi`,
    `rdx`, `rcx`, `r8`, `r9`, then the stack),
  - `f32`/`f64` slots consume XMM argument slots (`xmm0`..`xmm7`, then the stack),
  - 1–2 slot results use `rax`/`rdx` for integer-like slots and `xmm0`/`xmm1`
    for float slots, with mixed aggregates using both,
  - 3+ slot results return indirectly via a hidden sret pointer passed in `rdi`
    (caller-allocated return buffer), with the callee storing each scalar slot
    sequentially and returning the pointer in `rax`.

Note: at the C ABI surface, exported functions accept ABI-safe structs by
flattening parameters to their scalar slots in order. For 1–2 slot structs this
is ABI-compatible with passing an equivalent by-value C struct parameter, while
for 3+ slot structs downstream C callers should declare separate scalar
parameters for the slots. Struct returns with 3+ slots use sret and are
ABI-compatible with returning an equivalent C struct by value.

This subset is intentionally small so that we can validate the end-to-end type
pipeline (parsing → checking → lowering → IR→ELF codegen) while keeping ABI
behavior consistent with C for the supported cases.

## `impl` Blocks

`impl` blocks attach functions and methods to existing types without affecting
memory layout.

The intent is to provide “high-level” APIs without baking behavior into `struct`
layout. In the initial implementation, `impl` blocks are *syntax and
type-checking structure*; code generation treats methods as ordinary functions
that follow the same calling conventions as other Silk functions.

### Generic impl blocks

If a type is declared with type parameters (struct or enum), its impl blocks
must also declare those type parameters:

```silk
struct Data(T) { value: T }

// OK:
impl Data(T) {
  fn get(self: &Self) -> T { return self.value; }
}

// Error:
// impl Data { ... }
```

This rule makes monomorphization explicit and ensures method receivers are not
ambiguous when the type is specialized.

### Syntax

```silk
impl List {
  // Ordinary static method (no receiver).
  fn init (cap: i64) -> List { ... }

  // Heap constructor used by `new List(...)` (special name, receiver + `void`).
  fn constructor (mut self: &Self, cap: i64) -> void { ... }

  // Instance method (receiver as first parameter).
  public fn len (self: &List) -> i64 { ... }

  // Mutating instance method (mutable receiver).
  public fn push (mut self: &List, value: u8) -> void { ... }
}
```

Rules:

- An `impl` block attaches methods to exactly one nominal type name (a `struct`
  or an `enum`).
- Multiple `impl` blocks may exist for the same type name; the compiler merges
  their methods (subject to duplicate-name rules).
- Methods inside an `impl` block are `fn` declarations (with bodies).
- The receiver, when present, is the first parameter and must be a borrowed
  reference to the `impl` type (`self: &Type` or `mut self: &Type`).
- Within an `impl` block, the special type name `Self` may be used anywhere a
  type name is accepted, and is treated as an alias for the `impl` type.
  For example, `self: &Self` is equivalent to `self: &Type`, and `-> Self` is
  equivalent to `-> Type`.
- Static methods omit the receiver parameter.
- Method visibility:
  - Methods are **private by default**: a method declared without an explicit
    visibility modifier is callable only within the **defining `impl { ... }`
    block**.
  - `public fn` marks a method as callable from outside the defining `impl`
    block.
  - `private fn` is permitted to make intent explicit.
  - `export` is reserved for static members (no `self` receiver) and is not
    permitted on instance methods; use `public fn` instead.
  - When an `impl` block declares conformance to an interface (`impl T as I`),
    the interface’s required methods are **public by definition**:
    - the corresponding impl methods may omit `public`, but
    - they may not be explicitly marked `private`.
- The method named `constructor` is treated specially:
  - it is only meaningful for `struct` types (it backs `new Type(...)`); enums
    do not support `constructor` methods in Silk,
  - it is `public` by default,
    - when explicitly marked `private`, it is callable only within the defining
      `impl { ... }` block,
  - it may be declared multiple times in a single `impl` block (an overload set),
  - its overload set includes `constructor` declarations across all merged
    `impl` blocks for the type,
  - it is invoked by heap allocation (`new Type(...)`) and by certain
  - `new Type(args...)` invokes the unique overload whose receiver is
    `mut self: &Type`, whose return type is `void`, and whose non-receiver
    parameter list matches `args...` after applying the normal call-argument
    type-checking rules,
  - if multiple overloads are applicable, the compiler prefers overloads that do
    **not** rely on implicit call-argument coercions (notably the `U -> &T`
    constructor coercion for `&T` parameters); if multiple overloads remain tied,
    the call is rejected as ambiguous.

### Call syntax

The surface call syntax uses field-access + call:

- Instance method call: `value.method(arg0, arg1, ...)`
- Static method call: `Type.method(arg0, arg1, ...)`

Semantically, method calls behave like ordinary function calls where the
receiver is passed as an explicit first argument.

Static-method receiver sugar ():

- If `value.method(...)` does not resolve to an instance method (a method whose
  first parameter is a receiver `self: &Type` / `mut self: &Type`), the
  compiler may resolve it as a call to a visible static method of the receiver
  type by inserting the receiver as the first argument: `Type.method(value, ...)`.
- This supports fluent chaining for value-consuming helper APIs like
  `std::result::Result.unwrap_or`:

  ```silk
  let r: R = /* ... */;
  let x: int = r.unwrap_or(0); // sugar for `R.unwrap_or(r, 0)`
  ```

Mutability rule ():

- If the method receiver is `self: &Type`, the call site passes a read-only
  borrow of the receiver (for example `value.method(...)`).
- If the method receiver is `mut self: &Type`, the call site must pass a
  mutable borrow of the receiver.
  - When the receiver is a **name binding** that is mutable (`let mut value = ...`)
    or a mutable reference binding (for example a `mut self: &Type` receiver),
    the compiler treats `value.method(...)` as a mutable receiver call (no
    `(mut value)` wrapper required).
  - The explicit `(mut value).method(...)` form is permitted but is no longer
    required for name receivers.

 limitations:

- Mutable receiver calls must use a name receiver; mutable borrows from
  non-name receiver expressions (for example `make().push(1)`) are rejected.
- Non-`mut` receivers may be arbitrary expressions (including calls), so
  chaining like `url.href().as_string()` is permitted.

Compiler requirements:

- Keep data layout and behavior separate in the IR.
- Preserve struct layout exactly for ABI and FFI.
- Enforce rules for opaque structs and UB as described in this document and the ABI spec.

==============================================================================
DOCS: Testing (language/testing)
URL: /silk/docs/?p=language/testing
==============================================================================

# Testing

This document specifies the initial **language-level testing** surface for
Silk.

The goal is a Zig-like authoring experience (tests live next to the code they
exercise) with a simple CLI runner that emits modern TAP output for downstream
consumption.

## `test` declarations

A `test` declaration is a top-level block of statements that the compiler can
compile and execute under `silk test`.

Syntax:

```silk
test "name" {
  // statements...
}
```

The string name is optional:

```silk
test {
  // statements...
}
```

Rules:

- `test` declarations MAY appear:
  - at top level (like `fn` and `let`), and
  - nested inside another `test` block (scoped subtests).
- A `test` block introduces its own scope (like a function body).
- Nested `test` blocks are executed inline, in source order, as part of the
  enclosing test’s execution. They may be used for hierarchical grouping and
  shared setup.
- `test` blocks may use `let`, `var`, control flow, and call functions/methods
  using the same expression subset as normal code.
- `return;` is allowed inside a `test` block (equivalent to ending the test
  early). `return <expr>;` is not allowed.

Doc comments:

- Doc comments (`/** ... */` and `/// ...`) attach to a `test` declaration the
  same way they attach to other top-level declarations.

## Running tests (`silk test`)

The `silk test` command:

- loads a module set (like `silk check` / `silk build`),
- discovers all `test` declarations in the module set, and
- executes them, emitting TAP output.

### TAP output

The initial runner uses TAP version 13 formatting:

- `TAP version 13`
- `1..N`
- `ok <n> - <name>`
- `not ok <n> - <name>`

### Assertions inside tests

In `silk test` builds, failed assertions do not abort the process. Instead:

- A failed `assert` records a test failure and execution continues.
- If the assertion has no explicit message, the compiler uses the assertion
  condition text as the message (e.g. `assert value != 123;` uses `value != 123`).
- The test executable exits non-zero if any failures were recorded so TAP output
  reflects failures.

The current runner still isolates top-level tests in separate processes, but a
single test case may now accumulate multiple failures.

## `std::test` (standard test helpers)

The standard library provides `std::test` helpers for test-only assertions that
record failures without aborting:

- `expect(ok: bool, message: string? = None);`
- `expect_equal(expected: X, actual: Y) -> bool;`
- `expect_error(err: E?) -> bool;`


Note: `std::test` helpers carry a Formal Silk contract requiring
`BUILD_MODE == "test"` via `std::formal.requires_test_mode()` so downstream
verification can model them as test-only APIs.

==============================================================================
DOCS: Type Unions (`T1 | T2 | ...`) (language/type-unions)
URL: /silk/docs/?p=language/type-unions
==============================================================================

# Type Unions (`T1 | T2 | ...`)

Silk supports **type unions** in type annotations. A union type represents a
value that is exactly one of several **member types**.

This feature exists to model small, explicit “one-of-these-types” outcomes
without requiring a dedicated nominal `enum` declaration for every case.


See also:

  is reserved for typed-error contracts),

## Surface Syntax

Union types use `|` between member types:

```silk
let x: Foo | Bar;
struct S { v: u8 | bool }
type U = Foo | Bar | Baz;
```

### Return types (important disambiguation)

In **function declarations**, unparenthesized `|` after `->` is reserved for
typed errors (`SuccessType | ErrorType...`). To write a union as a function’s
return type, the union must be parenthesized:

```silk
fn f () -> (Foo | Bar);
fn g () -> (Foo | Bar) | SomeTypedError;
```

This disambiguation is required so the parser and checker can treat typed-error
contracts as authoritative.

## Rules

The initial implementation intentionally supports only unions whose member
types have a safe, well-defined representation in the current compiler/backend
subset.

A union type `T1 | T2 | ... | Tn` is permitted when all member types are in the
supported union-member set:

- **Primitive scalar** types in `{ bool, char, i8, u8, i16, u16, i32, u32, i64,
  u64, int, usize, size, Instant, Duration }` (`isize` is accepted as an alias
  for `size`), and/or
- **Nominal POD structs** (including `error` types) and **nominal POD enums**
  that lower to a scalar-slot representation in Silk (no
  opaque structs).

Unions may freely **mix** primitive and nominal members in this subset.

For primitive members, the current native backend requires that **each member
type be distinguishable at injection sites**. In practice, that means a union
may not contain two primitive types that lower to the same backend scalar
representation (for example `int | i64`, `usize | u64`, `char | u32`,
`Duration | i64`). This restriction is specific to the backend
and may be relaxed once union injection uses full type identity rather than a
backend-scalar heuristic.

Notes:

- Nested unions are flattened: `(A | B) | C` is the same union as `A | B | C`.
- Duplicate member types are rejected.

## Semantics

A value of a union type is a **tagged** value:

- It stores a runtime tag identifying which member type is active.
- It stores the payload value in a uniform representation compatible with all
  members in Silk.

### Representation

In the current native backend subset, unions are lowered as:

- `(u64 tag, u64 payload_0, ..., u64 payload_(N-1))`

where `N` is the maximum scalar-slot count across the union’s member types
(primitive members contribute `1`).

Member payload values are stored/loaded via raw-bit casts (`cast_raw`) to and
from the `u64` payload slots. Unused payload slots are **zero-filled** on
injection and on widening coercions.

### Union-to-union coercions (supersets)

When a context expects a union type `U_sup`, a value of a union type `U_sub`
may be used if `U_sub`’s member set is a subset of `U_sup`’s member set. The
compiler remaps the runtime tag to the destination union’s tag numbering when
needed so pattern matches on the destination union remain correct.

If `U_sup`’s payload is larger than `U_sub`’s payload (because `U_sup` contains a
member with a larger scalar-slot representation), the payload is widened by
copying existing payload slots and zero-filling the newly-added slots.

### Construction (injection)

When a context expects a union type, a value whose type is one of the union’s
member types may be used directly and is injected into the union.

Examples:

```silk
struct A { x: int }
struct B { x: int }
type U = A | B;

fn main () -> int {
  let a: A = A{ x: 1 };
  let u: U = a; // inject `A` into `U`
  return 0;
}
```

## Matching (`match`)

Union values are consumed via `match` expressions using **typed binder**
patterns:

```silk
type U = A | B;

let out: int = match u {
  a: A => a.x,
  b: B => b.x,
};
```

Rules ():

- The scrutinee must have a union type.
- Patterns are restricted to `name: Type` (or `_: Type`) where `Type` is one of
  the union member types.
- Matches must be exhaustive: exactly one arm per member type (order does not
  matter).

==============================================================================
DOCS: Typed Errors (`error`, `panic`, and `T | ErrorType...`) (language/typed-errors)
URL: /silk/docs/?p=language/typed-errors
==============================================================================

# Typed Errors (`error`, `panic`, and `T | ErrorType...`)

Silk’s typed error system exists to eliminate the “trust gap” between a
function’s signature and its real behavior. There are no hidden exceptions and
no implicit panic channel: if a function can terminate due to a logic bug /
contract violation, it must say so in its signature, and the compiler must
enforce it.

This document specifies the surface syntax and checker rules for typed errors.

The compiler supports `error` declarations, `panic` statements, error-aware
return types (`T | ErrorType...`), and the `match` *statement* form for handling
typed errors (including the Terminal Arm Rule), plus the postfix `?`
propagation operator for error-producing calls.

## Overview

- An `error` represents an unrecoverable logic bug or contract violation.
- A function that can `panic` must declare that in its return type using `|`:
  - `fn get_at(xs: &u8[], index: int) -> u8 | OutOfBounds;`
- A typed error is triggered with `panic`, which terminates the current function
  and propagates the error to the caller.
- Typed errors are handled explicitly via `match` (statement form), and any arm
  that handles an error must end in a terminal statement.

This model is intentionally closer to “typed, explicit non-local errors” than
to try/catch exceptions or an implicit panic mechanism.

### Recoverable errors are values (not typed errors)

Typed errors are intentionally *not* the primary mechanism for routine runtime
failures such as:

- invalid user input,
- parsing failures,
- I/O failures.

Those should typically be modeled as ordinary values using `std::result::Result`
or optionals (`T?`) so callers can handle them and continue normal execution.

See:

  (recoverable URL parsing example).

## Declaring Error Types (`error`)

Syntax:

```silk
error OutOfBounds {
  index: int,
  len: int
}
```

Rules:

- `error Name { ... }` declares a nominal, struct-like type that represents an
  unrecoverable logic bug / contract violation.
- An `error` declaration has the same field rules as `struct` in the current
  compiler subset (scalar fields; see
- An `error` type may also be used as data (returned, stored, logged) when it is
  *not* part of a `T | ...` error contract.


- The compiler treats `error` as a distinct nominal type category (separate from
  `struct`) but reuses the same field/layout rules in Silk.

## Error-Producing Function Signatures (`T | ErrorType...`)

A function declares that it may `panic` by adding one or more error types after
its success type using `|`.

Examples:

```silk
fn get_at(xs: &u8[], index: int) -> u8 | OutOfBounds { ... }
fn parse() -> Packet? | PacketTooLarge { ... }
fn init() -> void | InitFailure { ... }
```

Note on `|` disambiguation:

- In function declarations, an unparenthesized `|` sequence after `->` is
  always parsed as a typed-error contract.
- To return a **union type** from a function, parenthesize the union:
  - `fn f () -> (A | B);`
  - `fn g () -> (A | B) | SomeError;`


Rules:

- The leftmost type is the single *success* type.
- Each type on the right side of `|` must name a declared `error` type.
- The list of error types in a signature is the complete contract: the
  implementation may not `panic` with any other error type.

Implementation notes:

- The current compiler models typed errors as a distinct “error set” attached to
  the function signature and to expressions that may `panic`.
- The success type is still a normal Silk type (including optionals).

## Triggering a Typed Error (`panic`)

Syntax:

```silk
panic OutOfBounds {
  index: index,
  len: std::length(xs)
};
```

Rules:

- `panic` constructs a value of the named `error` type and immediately
  terminates the current function, propagating the error to the caller.
- A `panic X { ... };` statement is only legal inside a function whose signature
  includes `| X` (directly or indirectly via propagation).

Implementation notes:

- `panic` is a statement (not an expression) in Silk.

## Propagating Typed Errors (`?`)

The postfix `?` operator propagates a typed error from an *error-producing call
expression* to the caller without requiring an explicit `match` at every call
site.

Syntax:

```silk
let value: T = error_call(...)?;
```

Semantics:

- If the call succeeds, `call()?` evaluates to the call’s success value.
- If the call panics with a declared error type, `call()?` immediately returns
  from the current function, propagating the same error to the caller.

Rules:

- `?` is only legal inside a function that declares an error contract
  (`-> SuccessType | ErrorType...`).
- The callee’s error set must be a subset of the enclosing function’s error set.
  Otherwise the call must be handled explicitly with a `match` statement that
  maps the error into the caller’s contract.
- `?` is only meaningful on an error-producing call expression (a call whose
  signature includes `| ErrorType...`). Applying `?` to an infallible call is a
  type-check error.

Implementation notes:

- In the current compiler, `call()?` is lowered as “call + tag dispatch; on
  error return the appropriate error payload; on success yield the value”,
  using the same encoding as the `match` statement lowering.

## Handling Typed Errors (`match` statement + Terminal Arm Rule)

When the scrutinee expression of a `match` statement may `panic` (i.e. its
signature includes `|`), the compiler activates a special rule for error arms.

### Match statement form

```silk
match (create_packet(user_size)) {
  Some(packet) => {
    io::println("ok");
  },
  None => {
    io::println("no packet");
  },
  err: PacketTooLarge => {
    log::critical("invalid packet size requested", err);
    std::abort();
  }
}
```

### Terminal Arm Rule

If the scrutinee expression has an error contract (`T | ErrorType...`), then
for any arm that matches an `error` type, the arm’s block must end with a
terminal statement.

Terminal statements are:

- `panic <ErrorType> { ... };` (propagate or map to another error)
- `std::abort();`
- `std::halt();`
- `std::reboot();`

Implementation notes:

- `std::abort()` is lowered as a terminal action:
  - in the native backend subset, this is routed through the platform
    `abort()` so the process terminates with `SIGABRT`,
  - in non-debug builds on `linux/x86_64`, the compiler disables core dumps
    (`prctl(PR_SET_DUMPABLE, 0, 0, 0, 0)`) before calling `abort()` to keep abort fast,
  - on backends/targets where `abort()` is unavailable, it is lowered to the
    backend’s `Trap` primitive.
- `std::halt()` and `std::reboot()` are currently lowered to `Trap` in the
  native backend subset.

This rule is intentionally *context-dependent*: it is triggered by the error
contract of the scrutinee expression, not by the fact that a type is declared
with `error`.

### Error types as data (no Terminal Arm Rule)

If a function returns an `error` type as a normal value (no `|` in its
signature), the special rule does not apply:

```silk
fn inspect_issues() -> PacketTooLarge;

match (inspect_issues()) {
  err: PacketTooLarge => {
    log::warn("non-critical issue", err);
    // Allowed to complete normally because the scrutinee is not a `T | ...`.
  }
}
```

### `match` statements over Result-like values (recoverable)

The `match` **statement** form can also be used to destructure common
recoverable result shapes such as `std::result::Result(T, E)`.

When the scrutinee expression is a **call expression** whose result type is
either:

- `std::result::Result(T, E)` (an `enum` with `Ok(T)` and `Err(E)` variants), or
- a “Result-like” struct with fields:
  - `value: T?`
  - `err: E?` where `E` is an `error` type,

then the checker accepts binder patterns of the form:

- `name => { ... }` / `_ => { ... }` for the success payload (binds `name` as `T`),
- `err: E => { ... }` for the error payload (binds `err` as `E`).

The Terminal Arm Rule does **not** apply in this form because the scrutinee is
not a `T | ErrorType...` typed-error expression; the error is a normal returned
value.

Runtime invariant (struct form, current backend): exactly one of `value` and
`err` must be `Some(...)`. If the invariant is broken, execution traps.

Implementation notes:

- The current compiler supports a match subset for optionals as an
  *expression* (`match x { None => expr, Some(v) => expr }`).
- The `match` expression also supports `Ok(...)` / `Err(...)` patterns for
- Typed error handling uses the *statement* form of `match` with block arms.

## Restrictions

### `pure fn`

`pure fn` must not introduce or handle typed errors:

- `pure fn` may not have a `|` in its return type.
- `pure fn` may not contain `panic` statements.

The checker enforces these rules in Silk (see

### `ext` boundary

Typed errors must not cross the external boundary. External shims must translate
typed errors into:

- explicit error return codes,
- nullable pointers / optionals,
- explicit error structs/enums,
- or a terminal action appropriate for the platform.

`|` (and rejects exported C ABI surfaces with `|`) in the current
implementation.

## Related proposals

- Open/variadic error sets for higher-order adapters (`E...`).
- `return <error>` as shorthand for `panic <error>` (AP131).

==============================================================================
DOCS: Types (language/types)
URL: /silk/docs/?p=language/types
==============================================================================

# Types

This document specifies the Silk type system used by the compiler front-end and type checker.

Implementation status (current compiler subset):

- Supported end-to-end: primitives, nominal `struct` types, optionals (`T?`),
  `&Struct` references (in function parameter types and as local values
  produced by `new` / calls that return `&Struct`), and array/slice types
  (`T[N]`, `T[]`) over element types that lower to a fixed scalar-slot sequence
  In Silk (including array literals, indexing reads, and
  iterable `for` loops). Indexed assignment targets (`xs[i] = v`) are supported
  for these element types; compound index ops require numeric scalar element
  types in Silk.
  - Parameterized nominal types (monomorphized): generic `struct` and
    `interface` declarations with **type parameters**, plus applied types in
    type positions (`Name(u8)`, `Name(string)`) for those declarations.
- Reserved intrinsics: the compiler currently exposes reserved, stdlib
  bring-up intrinsics for working with the `string` ABI (`__silk_string_ptr`,
  `__silk_string_len`, and `__silk_string_from_ptr_len`); these are not yet a
  stable user API and exist primarily to unblock `std::fmt`, `std::io`, and
  `std::args` while slice/iterator features are still evolving.
- Special-case: the nominal optional form `Option(T)` is accepted and desugared
  to `T?` in type annotations (it is not a general generics feature).
- Parsed but rejected by the current checker: const parameters and integer
  and the removed builtin map type form (`map(K, V)`) (`E2017`; use
  `std::map::{HashMap, TreeMap}` instead).
- Defined in the native backend subset: 128-bit scalar primitives
  (`i128`, `u128`, `f128`).
    these primitives lower to **two 8-byte slots** (`lo: u64`, `hi: u64`).
  - `f128` uses the IEEE‑754 binary128 bit pattern stored across those slots.
  - On `linux/x86_64` in the current backend implementation, `f128` arithmetic
    and some `as` casts lower to bundled runtime helper calls and rely on
    `libgcc_s.so.1` for `__float128` builtins.
- Typed errors (`error`, `panic`, and `T | ErrorType...`) are specified in
  contracts as an effect on function return types and expressions.
  - Separately, type unions (`T1 | T2 | ...`) are supported in type annotations
    return types, union returns must be parenthesized (`-> (A | B)`) because
    unparenthesized `|` after `->` is reserved for typed-error contracts.

## Quick Reference

The core categories are:

- Booleans: `bool`
  - Examples: `true`, `false`.
  - Notes: logical values.
- Integers (fixed width): `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`
  - Examples: `let n: i32 = 42;`.
  - Notes: signed/unsigned bit-widths.
- Integer (platform): `int`
  - Examples: `let n: int = 1;`.
  - Notes: implementation/default integer.
- Pointer-width integers: `usize`, `size`
  - Examples: `let n: usize = 1;`, `let n: size = -1;`.
  - Notes: unsigned/signed integer types whose width matches the target
    architecture pointer width (for example 64-bit on `linux/x86_64`).
  - Compatibility: `isize` is accepted as an alias for `size`.
- Floats: `f32`, `f64`, `f128`
  - Examples: `let x: f64 = 3.14;`.
  - Notes: IEEE‑754.
- Char: `char`
  - Examples: `'A'`.
  - Notes: Unicode scalar.
- String: `string`
  - Examples: `"hello"`.
  - Notes: immutable text; multi‑line strings supported.
- Regexp: `regexp`
  - Examples: `/hello/i`.
  - Notes: compiled regular expression bytecode; a non-owning `{ ptr, len }`
    view analogous to `string`. Regex literals compile at compile time; runtime
- Region handle: `Region`
  - Examples: `fn f (r: Region) -> int { with r { ... } }`.
- Void / Unit: `void`
  - Examples: `fn foo () -> void {}`.
  - Notes: functions that return nothing.
- Time Types: `Instant`, `Duration`
  - Examples: `let i: Instant = std::now();`.
  - Notes: specialized `i64`-based types for time measurement.
- Optional: `T?`
  - Examples: `User?`, `i32?`.
  - Notes: `None` / `none` is the canonical empty value; `null` may also be
    used when an optional type is expected and coerces to `None`. Use `match`,
    `?.`, `??`.
- None (value):
  - Examples: `None` / `none` (represented as `None` in code samples).
  - Notes: the distinguished empty value; typed as `T?`. The `null` literal is
    a distinct literal that can coerce to `None` when an optional type is
- Reference (borrow): `&T`
  - Examples: `&User`.
  - Notes: reference type; in Silk, `&Struct` may appear in
    parameter types and as local values when produced by `new` or by calls that
    return `&Struct`. Mutability follows the `mut` borrow contract and per-call
- Arrays / Slices: `T[]`, `T[N]`
  - Examples: `i32[]`, `byte[32]`.
  - Notes: dynamic slice vs fixed length (compile‑time `N`). In the current
    compiler/backend subset, arrays/slices are supported only when the element
    type lowers to a fixed scalar slot sequence in the current scalar-slot
    memory model (for example primitive scalars, `string`, and supported
    current scalar-slot memory model. in Silk, fixed array
    lengths are limited to `N <= 4096`. Indexing `xs[i]` traps when `i` is out
    of bounds in Silk.
- Function Types: `fn(params) -> R`
  - Examples: `fn(i32) -> i32`.
  - Notes: function types are part of the type grammar and function-typed
    values are supported as function values (including capturing closures) in
    the compiler.
    Concurrency disciplines (`task` / `async`) are implemented on function
    positions do not currently include discipline modifiers.
- Capturing Closures:
  - Notes: capturing closures are supported as function values with an
    environment; see “Function Types and Closures” below for 
    restrictions.
- Structs (nominal):
  - Surface: `struct Name { ... }` then `Name(...)`.
  - Examples: `Point`, `Option(T)`.
  - Notes: user‑defined records; may be parameterized.
- Enums (sum types):
  - Surface: `enum Name { ... }`.
  - Notes: nominal tagged unions as described in the spec.
- Type unions:
  - Surface: `T1 | T2 | ...` (type annotations).
  - Notes: a tagged “one-of-these-types” type for a small, explicitly defined

The compiler must represent these types faithfully in its internal type system and in the C99 ABI mappings, and it must follow the exact surface syntaxes indicated above when parsing and printing types.

## Type Aliases (`type`)

Silk supports compile-time-only type aliases via `type` declarations.

Syntax examples:

```silk
type Int32 = i32;
type struct Bar = Foo;
type fn IntAdder = fn(int, int) -> int;
type pure fn PureIntAdder = fn(int, int) -> int;
export type struct PublicBar = Foo;
```

Semantics (current compiler subset):

- A type alias introduces a new name for an existing type; it does **not**
  introduce a distinct nominal type.
- The type checker MUST treat uses of the alias name as equivalent to the alias
  target type (the alias is transparent).
- Type aliases may be used anywhere a type is expected (parameter/result types,
  local annotations, struct fields, `as` casts, etc.).
- Cycles in type aliases are rejected (`E2058`).

Kind tags:

- A `type` declaration may optionally specify a kind tag, for example
  `type struct Name = Foo;` or `type pure fn Name = fn(...) -> ...;`.
- When present, the compiler MUST validate that the resolved alias target
  matches the declared kind (`E2059`).

Import/export:

- `type` aliases may be exported (`export type ...;`) and imported as type names

## Implicit Call-Argument Coercions ()

In Silk, Silk supports a small, **opt-in** implicit
coercion mechanism for function call arguments. This exists to keep the
current standard library ergonomic while generics and richer overload
systems are still evolving.

There are two related mechanisms:

1. **Coercion to a nominal `struct` value** `T` (by-value parameters and
   varargs elements) via exported static ctor-like methods.
2. **Coercion to a borrowed reference** `&T` (read-only `&T` parameters) via a
   `constructor` method that initializes a compiler-generated stack temporary.

### 1) Coercion to `T` via exported static ctor-like methods

Rule (informal):

- When a function call argument type does not match a parameter type, and the
  parameter is a nominal `struct` type `T`, the compiler may rewrite the
  argument to a call of an exported, static ctor-like method on `T`.
- This also applies to varargs elements (`...args: T`).

Supported ctor-like method names (destination type opts in by defining these):

- `T.int(value: int) -> T`
- `T.i128(value: i128) -> T`
- `T.u64(value: u64) -> T`
- `T.u128(value: u128) -> T`
- `T.f64(value: f64) -> T`
- `T.f128(value: f128) -> T`
- `T.bool(value: bool) -> T`
- `T.char(value: char) -> T`
- `T.string(value: string) -> T`
- `T.regexp(value: regexp) -> T`
- `T.Region(value: Region) -> T`

Selection (source type → constructor):

- Signed integer primitives (`i8/i16/i32/i64/int/size/isize/Instant/Duration`) → `int`
- Signed wide integer primitive (`i128`) → `i128`
- Unsigned integer primitives (`u8/u16/u32/u64/usize`) → `u64`
- Unsigned wide integer primitive (`u128`) → `u128`
- Float primitives (`f32/f64`) → `f64`
- Wide float primitive (`f128`) → `f128`
- `bool` → `bool`
- `char` → `char`
- `string` → `string`
- `regexp` → `regexp`
- `Region` → `Region`

Integer width:

- When the source argument is a fixed-width integer, the compiler inserts an
  implicit integer cast to match the ctor parameter type before calling the
  ctor.
- When the source argument is `f32` and the selected ctor parameter type is
  `f64`, the compiler inserts an implicit float cast (`f32 -> f64`) before
  calling the ctor.

Example:

```silk
struct Counter {
  value: int,
}

impl Counter {
  public fn int (value: int) -> Counter {
    return Counter{ value: value };
  }
}

fn takes (c: Counter) -> int {
  return c.value;
}

fn main () -> int {
  let x: i32 = 7;
  return takes(x); // coerces via `Counter.int`
}
```

Notes:

- Coercions are only attempted when the destination type provides the matching
  exported static ctor method.
- Today this primarily exists to support `std::fmt::Arg` and ergonomic
  `std::io::print/println` calls without requiring explicit `Arg.*`
  wrappers everywhere.

### 2) Coercion to `&T` via `constructor` (stack temporary)

Rule (informal):

- When a call argument does not match a parameter type, and the parameter is a
  **read-only borrowed reference** `&T` to a nominal `struct` type `T`, the
  compiler may create an implicit stack temporary `tmp: T`, initialize it by
  invoking `tmp.constructor(...)`, and pass `&tmp` to the callee.

This is intentionally a *stack* construction mechanism:

- it does **not** allocate on the heap,
- it is compatible with `silk build --noheap`,
- and the temporary’s lifetime is the duration of the call (similar to how C++
  binds temporaries to `const&` parameters).

Eligibility requirements ():

- The parameter must be `&T` (not `mut &T`).
- The destination type `T` must provide a visible `constructor` overload with:
  - receiver `mut self: &T`,
  - exactly **one** non-receiver parameter (`value: U`),
  - return type `void`.
- The call argument type must match the selected overload’s `U` parameter type.
- If multiple overloads are viable for a given argument, the coercion is
  ambiguous and rejected (the call must be written with an explicit
  construction).

Example:

```silk
struct User {
  name: string,
}

impl User {
  fn constructor (mut self: &Self, name: string) -> void {
    self.name = name;
  }
}

fn print_user (user: &User) -> void {
  std::io::println("user.name = {}", user.name);
}

fn main () -> int {
  // Implicitly constructs a temporary `User` from a `string` for this call.
  print_user("alice");
  return 0;
}
```

Notes:

- This is an opt-in mechanism: types must provide the matching `constructor`.
- If the coercion is ambiguous (multiple viable conversion paths), the compiler
  rejects the call and requires an explicit construction.
- Because this coercion participates in ordinary call argument checking, it can
  make additional overloads applicable (for example a copy-constructor
  `constructor(mut self: &Self, other: &Self)` can accept a `string` argument by
  first constructing a temporary `Self` from `string`). Overload resolution
  prefers overloads that match without requiring such coercions.

## Explicit Casts (`as`)

Silk supports explicit casts using the postfix `as` operator:

```silk
let x: f64 = 3.14;
let n: int = x as int;
```

This operator is intended for explicit, potentially lossy primitive numeric
conversions. in Silk it also supports explicit conversions via
`std::interfaces::Serialize(T)` by lowering `expr as T` to `expr.serialize()`
when the operand type provides a matching `serialize` method.
For structured conversions, it also supports `std::interfaces::Deserialize(S)`
by lowering `expr as T` to `T.deserialize(expr)` when the target type provides
a matching static `deserialize` method.

The supported conversions and semantics for the compiler are

Notes:

- `as` is explicit. It does not introduce new implicit coercions.
- For call-argument ergonomics, see the separate opt-in coercion mechanism
  described above (“Implicit Call-Argument Coercions”).

## Nominal & Parameterized Types

Nominal types are introduced by declarations (e.g. `struct`, `enum`, `interface`) and are equal only to themselves. Parameterized types are constructed by applying a type constructor to type arguments.

The compiler must:

- Treat nominal types as distinct even if their field layout is identical.
- In the full language design, support parameterized types in all contexts
  where the spec permits them. in Silk, **type-parameter**
  generics are supported for nominal declarations (`struct` / `interface`) and
  for applied types in type positions (`Name(u8)`).
  - Const parameters and integer-literal type arguments (`Name(N: int)`,
    `Name(u8, 1024)`) remain tracked work and are rejected (`E2016`).
  - The `Option(T)` optional sugar described above remains supported for
    the .

### Parameterized type syntax (initial surface form)

The initial surface syntax for applying type arguments is:

- `TypeApply ::= TypeName '(' TypeArgListOpt ')'`
- `TypeName ::= Identifier ('::' Identifier)*`
- `TypeArgListOpt ::= TypeArgList | ε`
- `TypeArgList ::= TypeArg (',' TypeArg)* ','?`
- `TypeArg ::= Type | IntLiteral`

Examples:

```silk
Foo(int, 1024)
Mutex(Account)
Result(int, string)
```

Notes:

- A `TypeArg` may be a type (e.g. `int`, `&Foo`, `Option(string)`) or a
  compile-time integer literal for const-parameter-style arguments.
- The full semantics (declaring generic parameters, constraint checking, and
  monomorphization) are still evolving; the key requirement is that the
  compiler preserves the argument structure in the AST/type system so later
  stages can enforce and lower it.

## Reference Types

Reference types describe access to values rather than owning them (e.g. references, borrowed views, or other non-owning handles as specified in this document and related language docs).

Key requirements:

- Distinguish owning vs. non-owning types in the type system.
- Preserve aliasing and lifetime constraints so that regions, buffers, and FFI safety rules can be enforced.

Current implementation notes:

- `&Struct` is supported in function parameter types and as local values when
  produced by heap allocation (`new`) or by calls that return `&Struct`.
- Borrowed `&Struct` references may also be created from stack values:
  - via the borrow operator `&expr` on borrowable lvalues, and
  - via implicit borrow coercions in contexts that expect `&T`
    (for example `let r: &Pair = pair;`).
  These borrows are checked with conservative lexical lifetime rules (they may
  not escape the scope of the borrowed stack storage).
- Mutable reference parameters use the two-part `mut` contract and conservative

## Function Types and Closures (Implementation Status)

the compiler:

- Parses function types in type positions (most notably for `ext` declarations).
- Implements function expressions (lambdas) in expression positions:
  - expression body form: `fn (x: int, y: int) -> x + y`
  - block body form: `fn (x: int, y: int) -> int { return x + y; }`
- Function expressions may not declare `&T` parameters in Silk.
- Function expressions are inferred as `pure` when they are **non-capturing**:
  - they may call only `pure` functions,
  - they may not mutate (`let mut`/`var`, assignment),
  - they may not allocate (`new`),
  - they may not use typed error contracts or `panic`.
- The checker also supports purity inference (“auto-pure”) for ordinary function
  declarations and `impl` methods. When inferred, these functions/methods are
  treated as `pure` for call checking and are callable from `pure` code.
- Capturing closures are implemented as a subset of function values:
  - a function expression body may reference **immutable** locals/parameters
    from an enclosing scope; those values are captured by value into a heap
    environment,
  - In Silk, only **scalar** captures are supported (`int`, fixed
    width ints, `bool`, `char`, `f32`, `f64`, `Instant`, `Duration`),
  - capturing closures are not `pure` (they have an environment) and are
    rejected in `pure` code in Silk.
- Function values are supported end-to-end for this subset (non-capturing and
  capturing):
  - they may be passed as arguments, returned from functions, stored in
    structs/arrays, and called indirectly.
  - the runtime representation is a pair `{ func_ptr, env_ptr }` as specified
- Discipline modifiers for function declarations (`pure` / `task` / `async`) are
  implemented. Function types in type positions do not currently include
  discipline modifiers.

==============================================================================
DOCS: Varargs (Variable Arguments) (language/varargs)
URL: /silk/docs/?p=language/varargs
==============================================================================

# Varargs (Variable Arguments)

Silk supports declaring functions that accept a variable number of trailing
arguments (“varargs”). This is used heavily by `std::io::print` /
`std::io::println` for formatted output.

## Syntax

Varargs are declared by prefixing the final parameter with `...`:

```silk
fn log (fmt: string, ...args: std::fmt::Arg) -> void {
  std::io::println(fmt, args);
}
```

Rules:

- A function may declare **at most one** varargs parameter.
- The varargs parameter must be **the final** parameter in the list.
- The varargs parameter must have an explicit **type annotation**.
- Varargs parameters are **not** permitted to be `mut` in Silk.
- Varargs parameters may not have a default expression (`= ...`) in the current
  subset.

## Call Semantics

At call sites:

- All non-varargs parameters are matched positionally as usual.
- Any additional arguments are collected into the varargs parameter.

Example:

```silk
std::io::println("hello {s} answer={d}", "world", 42);
```

Here `"world"` and `42` become varargs elements.

### Forwarding

Because Silk does not yet have a general “spread” operator for calls, the
current implementation supports forwarding a varargs pack when you pass a
varargs binding as the final argument.

```silk
fn log (fmt: string, ...args: std::fmt::Arg) -> void {
  // `args` is forwarded as-is to `println`.
  std::io::println(fmt, args);
}
```

This is primarily intended for building wrappers that preserve the caller’s
argument list without repacking.

## Representation

In Silk, a varargs parameter is lowered as a
fixed-size **pack value** with:

- `len: int` — the number of provided varargs arguments.
- `a0 .. a(N-1)` — storage for up to `N` arguments (implementation-defined,
  currently `N = 32`).

The pack is passed by value using the same “flattened scalar slot” ABI as other
POD structs.

Notes:

- Accessing `aK` where `K >= len` is a logic error (the value is unspecified).
- Calls supplying more than `N` varargs arguments are rejected.

## FFI (C Variadics)

This document is about Silk varargs. C variadic functions declared via `ext`
(`printf`-style `...`) are a separate concern and are **not** implemented yet
In Silk.

==============================================================================
DOCS: `std::` Conventions (std/conventions)
URL: /silk/docs/?p=std/conventions
==============================================================================

# `std::` Conventions

conventions for the Silk standard library. New and refactored `std::` APIs must
follow this document; older surfaces may temporarily diverge but
must be migrated as they are touched.

This document exists to keep `std::` APIs consistent across modules.

## Public vs Internal API

- Only `export` declarations are considered part of the stable public surface.
- Non-exported declarations are internal implementation details and may change
  freely.
- Internal helper packages may exist under names such as `std::internal::...`
  or `std::sys::...`, but these are not stable surfaces.

## Naming

- Packages use `std::area` naming (`std::strings`, `std::fs`, `std::net`).
- Types use `PascalCase` (`String`, `Vector(T)`, `Path`, `File`).
- Functions and methods use `snake_case` (`read_all`, `push`, `starts_with`).
- Constants use `SCREAMING_SNAKE_CASE`.

## Documentation

All user-facing `std::` APIs must be documented in source using doc comments

- public types (`struct`, `enum`, `error`, `interface`),
- public functions/methods (including constructors like `init`, `empty`,
  `invalid`, `default`),
- public Formal Silk theories exposed for reuse (for example under
  `std::formal`).

source-level doc comments are the machine-consumable layer used by `silk doc`,
`silk man`, and editor tooling (hover and completion documentation).

## Allocation and Ownership

`std::` should be explicit about allocation:

- Prefer allocation-free views (`Slice(T)`, `Str`) for APIs that can operate on
  borrowed data.
- Allocating APIs should accept an explicit allocator (or region) parameter, or
  clearly document which allocator is used.
- Avoid hidden global allocation in core functionality. Convenience helpers may
  exist, but must be clearly marked.

String ownership (initial design intent):

- The built-in `string` type is a UTF-8 byte sequence represented as a
- The stdlib provides an owned string builder/container (`String`) whose memory
  management is explicit and interoperable with `string`.

## Construction and Defaults

Public `std::` types should be easy to construct correctly, without callers
needing to know internal sentinel values or manually fill out large structs.

- Every public `std::` struct should provide an explicit “safe default” constructor:
  - container/builder types should provide `empty()` (preferred over requiring `init(0)`),
  - handle/resource types should provide `invalid()` (or an equivalent clearly-named constructor) and ensure methods either:
    - treat invalid handles as no-ops (for example `close`/`drop`), or
    - return a recoverable error (for example `InvalidInput`) rather than trapping.
- If a type’s primary constructor requires configuration (capacity, hash function pointers, etc.), provide a convenience constructor that uses a sensible default:
  - for capacity-driven containers: `empty()` and a parameterized constructor (`init(cap)` in Silk; consider `with_capacity(cap)` long-term),
  - for option/config structs: a `default()` constructor or clearly-named presets (for example `read_only()` / `write_only()`).
- `Drop` types must be safe to drop in their default/empty/invalid state and should be idempotent when possible (invalidate the handle/pointer after freeing).
- Constructors must not silently “succeed” while discarding failures:
  - if `init(cap)` allocates, it must return a recoverable error (`Result(...)`
    or an optional error return) when allocation fails,
  - `empty()` exists for infallible construction.

## Errors

recoverable error values (`T?` and `std::result::Result(T, E)`). Public `std::`
APIs should follow these rules:

- Use `T?` when “absence” is the only meaningful error case and no additional
  error information is required (e.g. `pop() -> T?`).
- Use a result type when callers need to distinguish multiple error causes.
  with `Ok(T)` / `Err(E)` cases.
- Prefer that the **primary** API name returns `Result(...)` / optional error,
  rather than exporting parallel `*_result` variants.
- Callers that want to discard error details can:
  - compare an optional error return against `None`, or
  - for `Result(T, E)`:
    - prefer `match (r)` when `T` or `E` may implement `Drop`,
    - use `ResultType.ok_value(r)` / `unwrap(r)` / `unwrap_or(r, fallback)` / `err_value(r)` only when the active payload is copy-safe (does not implement `Drop`).
  Avoid exporting parallel `*_opt` helpers that hide error information.
- Do not use `bool` returns for fallible operations that can fail for multiple
  reasons; return an optional error (`ErrorType?`) or `Result(T, E)` instead.
- Keep OS/runtime-specific error mechanisms (such as POSIX `errno`) out of the
  public surface. Map them into stable, portable error kinds/codes in the
  top-level `std::` module and confine the platform details to `std::runtime`.
- Do not expose typed error contracts (`T | ErrorType...`) or `panic` for
  routine runtime failures such as I/O errors or parse failures. Prefer
  `Result(...)` or an optional error return (`ErrorType?` where `None` is
  success).
- Do not call `assert` / `std::abort()` from `std::` APIs. Malformed inputs,
  invariant violations, and resource exhaustion must be surfaced as recoverable
  errors.

## Formal Silk Contracts

`std::` should actively use Formal Silk to document and enforce invariants in
low-level code (buffers, parsing, and pointer/length handling):

- Prefer reusable theories from `std::formal` (for example `slice_well_formed`
  and `vector_well_formed`) over ad-hoc `#require` / `#assert` boilerplate.
- Contracts must reflect real runtime invariants (avoid over-strong
  preconditions that callers cannot prove). When handling untrusted inputs,
  validate at runtime and return a recoverable error value rather than relying
  on preconditions.
  that the verifier currently skips `std::...` modules; contracts in `std::`
  are still valuable as precise documentation and for future verification work.

## UTF-8 and Text

- `string` is defined as UTF-8 bytes.
- APIs that operate on “characters” must be explicit about whether they mean:
  - bytes,
  - Unicode scalar values (`char`),
  - or grapheme clusters (locale/text-segmentation dependent).
- By default, indexing/slicing is byte-based and does not validate UTF-8 unless
  an API explicitly says it does.

## Platform Baselines

- Hosted baseline: POSIX behavior for filesystem, networking, and clocks.
- Freestanding baseline: no OS; only core modules are available.

Each hosted API must clearly document which POSIX calls it relies on and which
errors are surfaced to callers.

==============================================================================
DOCS: `std::` Module Structure (std/package-structure)
URL: /silk/docs/?p=std/package-structure
==============================================================================

# `std::` Module Structure

build integration for `std::`. A first, minimal slice of the build integration
is implemented (auto-resolving `std::...` imports from a configurable stdlib
root), while most std APIs remain unimplemented.

This document defines how the standard library is organized and how it is made
available to user programs.

## Namespace Model

- `std::` is a **reserved namespace root**.
- The standard library is a **distribution of modules** whose module names begin
  with `std::...`:
  - `std::strings`
  - `std::memory`
  - `std::arrays`
  - `std::bits`
  - `std::interfaces`
  - `std::map`
  - `std::set`
  - `std::algorithms`
  - `std::temporal`
  - `std::semver`
  - `std::url`
  - `std::io`
  - `std::env`
  - `std::process`
  - `std::path`
  - `std::fs`
  - `std::net`
  - `std::tls`
  - `std::http`
  - `std::https`
  - `std::websocket`
- Each source file in the stdlib declares which module it defines using a
  `module` declaration:

  ```silk
  module std::strings;
  ```

The compiler treats module/package names (including `std::...`) as part of the

## `std::runtime` (Runtime Interface Layer)

`std::runtime` is a dedicated namespace under `std::` that defines low-level,
platform/environment primitives in a **pluggable** way.

Design intent:

- Higher-level `std::...` modules (like `std::fs`, `std::task`, `std::sync`) are
  written against `std::runtime::...` interfaces.
- The shipped stdlib provides a default hosted POSIX backend under
  `std::runtime::posix::...` and the corresponding `std::runtime::...` modules
  delegate to it.
- Alternative stdlib roots can provide different runtime implementations (for
  example Windows or embedded) without changing the public `std::...` surface.


## Linking by Default (Requirement)

`std::` must be **linked by default** for normal `silk build` workflows:

- The compiler provides a default stdlib *root* (an implementation-defined
  directory shipped with the compiler distribution).
- That root is automatically included in the compiler’s package/module search
  path during builds, so that:

  ```silk
  import std::strings;
  ```

  resolves without the user having to explicitly pass the stdlib source files
  on the command line.

Notes:

- This does **not** imply an implicit `import std::...;` prelude; importing is
  explicit. Linking-by-default means “`std::` is available to import”.
- The compiler should only compile/link the std modules that are reachable from
  the user’s imports (and any internal dependencies), rather than eagerly
  compiling all of `std::`.

## Swappability (Requirement)

The default stdlib must be replaceable by an alternate implementation:

- The build configuration may override the stdlib root used for resolving
  `std::...` imports.
- A replacement stdlib is expected to provide compatible packages and exported
  APIs under the same `std::...` names.
- The language and C ABI remain stable regardless of stdlib choice; `std::` is
  ordinary Silk code and does not change core semantics.

The concrete selection mechanism is a compiler/driver responsibility and must

Current toolchain behavior (first slice):

- Both the `silk` CLI and the `libsilk.a` embedding build path resolve
  `std::...` imports from a stdlib root selected by:
  - an explicit override (`--std-root` for `silk`, or `silk_compiler_set_std_root` for embedders), otherwise
  - `SILK_STD_ROOT` (environment variable) when set, otherwise
  - a `std/` directory in the current working directory (development default), otherwise
  - `../share/silk/std` relative to the current executable (installed default).
- Mapping is deterministic: `std::foo::bar` resolves to `<std_root>/foo/bar.slk`.

## Static Archive Distribution (Current Toolchain)

For distribution and incremental development, the stdlib can be built into a
static archive for a specific target ABI:

- `make stdlib` compiles each `std/**/*.slk` module (including `std/runtime/...`)
  to an ELF object via
  `silk build --kind object` and archives them into `zig-out/lib/libsilk_std.a`.
- This archive is target-specific (e.g. `linux/x86_64` ELF objects) and should
  be treated as one artifact per supported target triple/ABI, not as a
  universally portable library.

Current toolchain behavior (`linux/x86_64`):

- The compiler still loads stdlib Silk sources from the configured stdlib root
  for parsing/type-checking (so the language-level package graph is validated),
  but executable code generation treats *auto-loaded* `std::...` modules as
  **external** and resolves their exported functions from the prebuilt archive
  when one is available.
- Archive discovery (in order):
  - `--std-lib <path>` (or `--std <path>.a` / `-std <path>.a`) when provided, otherwise
  - `SILK_STD_LIB` (environment variable) when set,
  - `zig-out/lib/libsilk_std.a` when using the in-repo `std/` root (development),
  - `../lib/libsilk_std.a` relative to the installed `silk` executable,
  - common installed-layout heuristics derived from the selected stdlib root.

Archive member naming (scheme):

- to avoid basename collisions (for example `std/task.slk` and
  `std/runtime/posix/task.slk`), archive member names are based on the std-root
  relative path with `/` replaced by `_`, and `.slk` replaced by `.o`,
- for example: `std/runtime/posix/task.slk` → `runtime_posix_task.o`.
- When no suitable archive is found (or on unsupported targets), the compiler
  falls back to compiling the reachable std sources into the build as part of
  module-set code generation.
- `--nostd` disables stdlib auto-loading and therefore also avoids linking the
  default std archive; users may still explicitly provide their own `std::...`
  modules as ordinary inputs when desired.
- `--std-root <path>` (or `--std <path>` / `-std <path>` when `<path>` does **not** end in `.a`) selects an alternate stdlib root, and
  the corresponding archive is discovered via the same `--std-lib` / `SILK_STD_LIB` and
  installed-layout rules.

## Hosted vs Freestanding

The stdlib should be layered:

- A “core” subset that does not require OS services (collections, algorithms,
  string utilities, formatting, etc.).
- Hosted modules (`std::fs`, `std::net`, parts of `std::temporal` and
  `std::io`) that rely on POSIX syscalls or POSIX-like APIs.

This layering allows `std::` to be used in freestanding environments while
still offering a full POSIX-oriented API when available.

## Versioning and Compatibility

The standard library is shipped with the compiler and should be versioned:

- Public, exported APIs under `std::...` should follow semantic versioning.
- A compiler may require a minimum stdlib version, and should report a clear
  error when an incompatible stdlib root is selected.

==============================================================================
DOCS: `std::algorithms` (std/algorithms)
URL: /silk/docs/?p=std/algorithms
==============================================================================

# `std::algorithms`

implemented yet.

`std::algorithms` provides common algorithms over collections (primarily
`std::arrays::Slice(T)` and related types).

See also:


## Details

A tiny, non-generic subset is implemented in `std/algorithms.slk` for early
bring-up. These helpers operate on concrete scalar types and are intended to be
replaced or complemented by generic slice/collection algorithms as soon as the
necessary language features exist.

```silk
module std::algorithms;

export fn min_int (a: int, b: int) -> int;
export fn max_int (a: int, b: int) -> int;
export fn clamp_int (x: int, lo: int, hi: int) -> int;

export fn min_u64 (a: u64, b: u64) -> u64;
export fn max_u64 (a: u64, b: u64) -> u64;
export fn clamp_u64 (x: u64, lo: u64, hi: u64) -> u64;

export fn min_f64 (a: f64, b: f64) -> f64;
export fn max_f64 (a: f64, b: f64) -> f64;
export fn clamp_f64 (x: f64, lo: f64, hi: f64) -> f64;

export fn abs_i64 (x: i64) -> i64;
export fn abs_int (x: int) -> int;
export fn abs_f64 (x: f64) -> f64;

export fn min_duration (a: Duration, b: Duration) -> Duration;
export fn max_duration (a: Duration, b: Duration) -> Duration;

export fn min_instant (a: Instant, b: Instant) -> Instant;
export fn max_instant (a: Instant, b: Instant) -> Instant;
```

## Scope

`std::algorithms` is responsible for:

- Searching, sorting, and transformation routines.
- Designed to work with `std::arrays` and other iterable types.

## Initial API Surface (Illustrative)

The initial algorithms target `Slice(T)` since it is the most universal view
type for contiguous collections.

```silk
module std::algorithms;

export fn linear_search (T, s: std::arrays::Slice(T), needle: T) -> int?;
export fn binary_search (T, s: std::arrays::Slice(T), needle: T, cmp: fn(T, T) -> int) -> int?;

export fn sort (T, s: std::arrays::Slice(T), cmp: fn(T, T) -> int) -> void;
export fn stable_sort (T, s: std::arrays::Slice(T), cmp: fn(T, T) -> int) -> void;

export fn min (T, s: std::arrays::Slice(T), cmp: fn(T, T) -> int) -> T?;
export fn max (T, s: std::arrays::Slice(T), cmp: fn(T, T) -> int) -> T?;
```

Notes:

- Sorting should be in-place where possible.
- Stable sorting may require temporary allocations; this should be explicit
  (accept an allocator) or clearly documented.

## Future Work

- `dedup`, `partition`, `reverse`, `rotate`, `shuffle`.
- Iterator-based algorithms once iterators and `for` are fully implemented.

==============================================================================
DOCS: `std::args` (std/args)
URL: /silk/docs/?p=std/args
==============================================================================

# `std::args`

`std/args.slk` to make early programs ergonomic while `string[]` parameters and
richer slice/iterator features are still future work.

`std::args` focuses on the hosted `linux/x86_64` executable entrypoint shape:

```silk
fn main (argc: int, argv: u64) -> int { ... }
```

Where `argv` is a raw pointer to the process `argv` pointer list (`char**` in C).

See also:


## API

The following items are implemented in `std/args.slk`:

```silk
module std::args;

// Read argv pointers.
export fn argv_ptr (argv: u64, index: int) -> u64;
export fn argv_cstr (argv: u64, index: int) -> u64;

// Inspect NUL-terminated C strings.
export fn cstr_byte (cstr: u64, index: int) -> u8;
export fn cstr_len (cstr: u64) -> int;

// Convert stable C strings to Silk `string` views (no allocation, no copy).
export fn cstr_string (cstr: u64) -> string;
export fn argv_string (argv: u64, index: int) -> string;

// Convenience wrapper for (argc, argv).
struct Args {
  argc: int,
  argv: u64,
}

impl Args {
  public fn init (argc: int, argv: u64) -> Args;
  public fn count (self: &Args) -> int;
  public fn ptr (self: &Args, index: int) -> u64;
  public fn get (self: &Args, index: int) -> string;
}
```

### Safety notes

- `cstr_len` scans memory until it finds a `0` byte. If the pointer is invalid
  or the string is not NUL-terminated, behavior is undefined.
- `cstr_string` / `argv_string` return `string` **views** into existing memory.
  They do not copy or allocate, and therefore do not provide ownership. The
  caller must ensure the pointed-to bytes remain valid for the lifetime of the
  returned `string`. For process `argv` strings this is typically valid for the
  lifetime of the process.

## String construction intrinsic

The current implementation uses a reserved, compiler-backed intrinsic
to construct `string` values at the ABI/IR level:

- `__silk_string_from_ptr_len(ptr: u64, len: int) -> string`

This intrinsic is intended only for stdlib bring-up (in particular `std::args`
and C-string bridging) and is **not** a stable user API.

==============================================================================
DOCS: `std::arrays` (std/arrays)
URL: /silk/docs/?p=std/arrays
==============================================================================

# `std::arrays`

for early FFI-friendly bridging; higher-level owning containers live in
`std::vector`.

`std::arrays` provides array and vector-like types built on top of the `Buffer(T)`

See also:


## Current API

A tiny generic subset is implemented in `std/arrays.slk` to provide a
non-owning, FFI-friendly slice representation for early bridging:

```silk
module std::arrays;

import std::interfaces;

struct Slice(T) {
  ptr: u64,
  len: i64,
}

impl Slice(T) {
  public fn init (ptr: u64, len: i64) -> Slice(T);
  public fn get (self: &Slice(T), index: i64) -> T;
  public fn set (self: &Slice(T), index: i64, value: T) -> void;
  public fn at (self: &Slice(T), index: i64) -> T?;
  public fn try_set (self: &Slice(T), index: i64, value: T) -> bool;
  public fn first (self: &Slice(T)) -> T?;
  public fn last (self: &Slice(T)) -> T?;
  public fn iter (self: &Slice(T)) -> SliceIter(T);
}

impl Slice(T) as std::interfaces::Len {
  public fn len (self: &Slice(T)) -> i64;
}

impl Slice(T) as std::interfaces::IsEmpty {
  public fn is_empty (self: &Slice(T)) -> bool;
}

struct SliceIter(T) {
  ptr: u64,
  len: i64,
  index: i64,
}

impl SliceIter(T) {
  public fn init (slice: Slice(T)) -> SliceIter(T);
}

impl SliceIter(T) as std::interfaces::Iterator(T) {
  public fn next (mut self: &SliceIter(T)) -> T?;
}

// Packed byte views (for byte-oriented OS/FFI APIs).
struct ByteSlice {
  ptr: u64,
  len: i64,
}

impl ByteSlice {
  public fn init (ptr: u64, len: i64) -> ByteSlice;
  public fn get (self: &ByteSlice, index: i64) -> u8;
  public fn set (self: &ByteSlice, index: i64, value: u8) -> void;
  public fn at (self: &ByteSlice, index: i64) -> u8?;
  public fn try_set (self: &ByteSlice, index: i64, value: u8) -> bool;
  public fn first (self: &ByteSlice) -> u8?;
  public fn last (self: &ByteSlice) -> u8?;
  public fn iter (self: &ByteSlice) -> ByteSliceIter;
}

impl ByteSlice as std::interfaces::Len {
  public fn len (self: &ByteSlice) -> i64;
}

impl ByteSlice as std::interfaces::IsEmpty {
  public fn is_empty (self: &ByteSlice) -> bool;
}

struct ByteSliceIter {
  ptr: u64,
  len: i64,
  index: i64,
}

impl ByteSliceIter {
  public fn init (slice: ByteSlice) -> ByteSliceIter;
}

impl ByteSliceIter as std::interfaces::Iterator(u8) {
  public fn next (mut self: &ByteSliceIter) -> u8?;
}
```

Notes:

- This type is a placeholder until the intrinsic `Buffer(T)` surface and safe
  view/borrowing rules land end-to-end.
- In the current API, `ptr` is represented as a raw `u64`
  address for early FFI-friendly bridging. The constructors enforce basic
  invariants via `#require`:
  - `len >= 0`, and
  - `ptr != 0` when `len > 0` (a null pointer is permitted only for empty
    slices).
  In the shipped stdlib sources, these invariants are also packaged as
  reusable theories in `std::formal` (for example `slice_well_formed(ptr, len)`).
- `get` / `set` are intentionally low-level in Silk and
  are unchecked beyond `#require` contracts. They are implemented using
  compiler-backed memory intrinsics routed through `std::runtime::mem` (see
- `Slice(T)` uses the scalar-slot memory model of the compiler:
  elements occupy `sizeof(T)` bytes (8 bytes per scalar slot), so multi-slot
  values like `string` and non-opaque structs/enums are supported.
  For byte-oriented APIs that require packed bytes, use `ByteSlice`.
- `at` / `try_set` are the “checked” accessors in Silk:
  - `at` returns `None` when `index` is out of bounds,
  - `try_set` returns `false` when `index` is out of bounds.
- `SliceIter(T)` provides a minimal sequential iterator for `Slice(T)` values.
  It implements `std::interfaces::Iterator(T)`; iteration is by value (copies).

## Scope

`std::arrays` is responsible for:

- Slice/view types over contiguous elements.
- Helpers for fixed-size arrays (`T[N]`) and for working with slices derived
  from them.
- Iteration utilities compatible with the `for` loop semantics (once `for` is

## Core Types (Initial Design)

- `Slice(T)` — a non-owning view over `T` elements (`ptr + len`).
- `std::vector::Vector(T)` — the owning, growable sequence type.
- Fixed-size arrays (`T[N]`) are part of the language design; `std::arrays`
  provides helpers and algorithms that operate on them via `Slice(T)` views.

Illustrative sketch (non-authoritative):

- `std::arrays::Slice(T)` for views, and
- `std::vector::Vector(T)` for owning growth.

## Indexing and Bounds

The stdlib should provide both:

- checked accessors that return `T?` (or a result) on out-of-bounds, and
- unchecked accessors for verified code paths.

The exact behavior must be consistent across the stdlib; see

==============================================================================
DOCS: `std::bits` (std/bits)
URL: /silk/docs/?p=std/bits
==============================================================================

# `std::bits`

and byte-order helper subset is implemented in `std/bits.slk` for the current
backend subset.

`std::bits` provides common bit “twiddling” helpers:

- byte swaps (`bswap_*`),
- bit rotations (`rotl_*`, `rotr_*`),
- and bit counts (`popcount_*`, `clz_*`, `ctz_*`).

See also:


## API

```silk
module std::bits;

export pure fn bswap_u16 (x: u16) -> u16;
export pure fn bswap_u32 (x: u32) -> u32;
export pure fn bswap_u64 (x: u64) -> u64;

export pure fn rotl_u32 (v: u32, shift: u32) -> u32;
export pure fn rotr_u32 (v: u32, shift: u32) -> u32;

export pure fn rotl_u64 (v: u64, shift: u32) -> u64;
export pure fn rotr_u64 (v: u64, shift: u32) -> u64;

export pure fn popcount_u32 (x: u32) -> u32;
export pure fn clz_u32 (x: u32) -> u32;
export pure fn ctz_u32 (x: u32) -> u32;

export pure fn popcount_u64 (x: u64) -> u32;
export pure fn clz_u64 (x: u64) -> u32;
export pure fn ctz_u64 (x: u64) -> u32;
```

### Rotation semantics

- `rotl_u32` / `rotr_u32` mask the shift amount by `31`.
- `rotl_u64` / `rotr_u64` mask the shift amount by `63`.

This means all shift values are valid and rotations do not rely on any
target-specific shift masking behavior.

### Count semantics

- `popcount_*` counts the number of 1-bits.
- `clz_*` counts leading zeros.
- `ctz_*` counts trailing zeros.

For `clz_*` and `ctz_*`, when the input is `0` the function returns the full
bit width (`32` or `64`).

## Example

```silk
import std::bits;

fn main () -> int {
  let x: u32 = std::bits::rotl_u32(1, 5);
  if x != ((1 as u32) << 5) {
    return 1;
  }

  let y: u64 = std::bits::bswap_u64(4660); // 0x0000_0000_0000_1234
  if y == 0 {
    return 2;
  }

  return 0;
}
```

==============================================================================
DOCS: `std::buffer` (std/buffer)
URL: /silk/docs/?p=std/buffer
==============================================================================

# `std::buffer`

intrinsic `Buffer(T)` type for low-level, unsafe contiguous memory access (see

In the current stdlib, `std::buffer` provides a packed byte
buffer (`BufferU8`) plus width-oriented buffer aliases built on
`std::vector::Vector(T)` for common scalar element types. This keeps buffer
usage ergonomic without relying on per-type `Vec*` stand-ins.

See also:


## Current API

`std::buffer` provides:

- `BufferU8`: an owning, growable **packed byte buffer** (byte-addressed `ptr`,
  with `len` and `cap` measured in bytes).
- width-oriented scalar buffer aliases built on `std::vector::Vector(T)` for
  convenience in Silk.

### `BufferU8`

```silk
module std::buffer;

import std::arrays;
import std::memory;

struct BufferU8 {
  ptr: u64,
  cap: i64,
  len: i64,
}

impl BufferU8 {
  public fn init (cap: i64) -> std::result::Result(BufferU8, std::memory::AllocFailed);
  public fn empty () -> BufferU8;
  public fn push (mut self: &BufferU8, value: u8) -> std::memory::OutOfMemory?;
  public fn push_bytes (mut self: &BufferU8, bytes: std::arrays::ByteSlice) -> std::memory::OutOfMemory?;
  public fn pop (mut self: &BufferU8) -> u8?;
  public fn get (self: &BufferU8, index: i64) -> u8;
  public fn set (mut self: &BufferU8, index: i64, value: u8) -> void;
  public fn at (self: &BufferU8, index: i64) -> u8?;
  public fn try_set (mut self: &BufferU8, index: i64, value: u8) -> bool;
  public fn swap_remove (mut self: &BufferU8, index: i64) -> u8?;
  public fn clear (mut self: &BufferU8) -> void;
  public fn reserve_additional (mut self: &BufferU8, additional: i64) -> std::memory::OutOfMemory?;
  public fn as_bytes (self: &BufferU8) -> std::arrays::ByteSlice;
  public fn drop (mut self: &BufferU8) -> void;
}
```

### Width-oriented aliases

```silk
module std::buffer;

import std::vector;

// Signed integers.
export type BufferI8 = std::vector::Vector(i8);
export type BufferI16 = std::vector::Vector(i16);
export type BufferI32 = std::vector::Vector(i32);
export type BufferI64 = std::vector::Vector(i64);

// Unsigned integers.
export type BufferU16 = std::vector::Vector(u16);
export type BufferU32 = std::vector::Vector(u32);
export type BufferU64 = std::vector::Vector(u64);

// Floating point.
export type BufferF32 = std::vector::Vector(f32);
export type BufferF64 = std::vector::Vector(f64);
```

Notes:

- `BufferU8` is a packed byte buffer. Its `ptr` can be passed directly to
  byte-oriented OS/FFI APIs alongside `len`.
- `BufferU8.init(cap)` returns `Err(AllocFailed)` rather than silently
  returning an empty buffer when allocation fails. Use `BufferU8.empty()` for
  infallible construction.
- growth paths (`reserve_additional`, `push`, `push_bytes`) surface allocation
  failure as `std::memory::OutOfMemory?` (including internal size arithmetic
  overflow; leaves the buffer unchanged on failure).
- The width-oriented aliases are still backed by `std::vector::Vector(T)` in
  the , so their underlying storage follows the

==============================================================================
DOCS: `std::crypto` (std/crypto)
URL: /silk/docs/?p=std/crypto
==============================================================================

# `std::crypto`

primitives backed by the system `libsodium` library on the hosted
`linux/x86_64` baseline.

The long-term goal is:

- a cohesive, ergonomic `std::crypto` API surface that is suitable for Silk
  programs,
- a thin, auditable mapping to libsodium primitives (no bespoke crypto),
- pervasive use of Formal Silk contracts/theories to document and verify:
  - buffer shape invariants (`len >= 0`, non-null when non-empty),
  - constant-size requirements (keys/nonces/MAC sizes),
  - “no aliasing required” rules where relevant.

Security note:

- Formal Silk can help specify *shape* invariants and prevent a large class of
  memory/length bugs, but it does **not** prove cryptographic security.

## Linkage and Toolchain Integration

On `linux/x86_64` with the glibc dynamic loader (`ld-linux`), `silk build`
automatically adds `libsodium.so.23` as a `DT_NEEDED` dependency when a program
imports libsodium-backed extern symbols (for example via `import std::crypto;`).

This mirrors the existing behavior for `libc.so.6` so downstream users do not
have to pass `--needed libsodium.so.23` for normal hosted builds.

## Byte Buffers

The current `std::vector`/`std::buffer` element model stores each
generic element in an 8-byte slot (even for `u8`), so `std::vector::Vector(u8)`
is not a packed byte array suitable for OS/FFI byte-oriented APIs.

For byte-oriented APIs, the stdlib provides packed byte types:

- `std::arrays::ByteSlice` — a non-owning `{ ptr, len }` view over packed bytes
  (`len` in bytes).
- `std::buffer::BufferU8` — an owning `{ ptr, cap, len }` packed byte buffer
  (`cap`/`len` in bytes).

`std::crypto` expresses byte-oriented inputs and outputs in terms of these
types (instead of exposing raw `(ptr, len)` pairs directly in public APIs).

The underlying raw allocation and load/store operations are provided by
`std::runtime::mem`.

## Current API (Initial)

The initial `std::crypto` module is organized as:

- `std::crypto` (core helpers and libsodium init)
- `std::crypto::random` (CSPRNG)
- `std::crypto::hash` (generic hashing)
- `std::crypto::aead` (AEAD: ChaCha20-Poly1305 IETF and XChaCha20-Poly1305 IETF)
- `std::crypto::secretbox` (secret-key authenticated encryption)
- `std::crypto::box` (public-key authenticated encryption)
- `std::crypto::sign` (signatures)

Key design rules:

- public APIs avoid `sodium_` prefixes; libsodium symbol names remain in private
  `ext` declarations,
- APIs accept explicit output buffers (typically `mut out: &std::buffer::BufferU8`),
  and may grow those buffers via `reserve_additional` when needed,
- where libsodium requires out-parameters and the current language subset cannot
  take the address of a stack scalar, APIs may require caller-provided scratch
  bytes (for example by requiring extra capacity in a `BufferU8` beyond the
  returned `len`),
- functions return recoverable error values:
  - `ErrorType?` where `None` is success,
  - `std::result::Result(T, ErrorType)` where `Ok(T)` is success and `Err(ErrorType)` is failure
    (use `Result(bool, ErrorType)` for fallible predicates).

### AEAD (`std::crypto::aead`)

The current AEAD surface provides two constructions:

- **ChaCha20-Poly1305 (IETF)** — `chacha20poly1305_ietf_*`
- **XChaCha20-Poly1305 (IETF)** — `xchacha20poly1305_ietf_*`

For each construction:

- size queries: `*_key_bytes()`, `*_nonce_bytes()`, `*_tag_bytes()` (each returns `i64`)
- sealing: `*_seal(mut c: &std::buffer::BufferU8, m: std::arrays::ByteSlice, ad: std::arrays::ByteSlice, nonce: std::arrays::ByteSlice, key: std::arrays::ByteSlice) -> std::crypto::CryptoError?`
  - returns `None` on success, otherwise `Some(CryptoError)`
  - sets `c.len = ciphertext_len` on success
  - requires extra capacity (`ciphertext_len + 8`) for libsodium’s `clen_p` out-parameter scratch in Silk
- opening: `*_open(mut m: &std::buffer::BufferU8, c: std::arrays::ByteSlice, ad: std::arrays::ByteSlice, nonce: std::arrays::ByteSlice, key: std::arrays::ByteSlice) -> std::crypto::CryptoError?`
  - returns `None` on success, otherwise `Some(CryptoError)`
  - sets `m.len = message_len` on success
  - requires extra capacity (`message_len + 8`) for libsodium’s `mlen_p` out-parameter scratch in Silk

Associated data is optional: callers may pass `ad = { ptr: 0, len: 0 }`.


- key derivation (`kdf`, `pwhash`),
- streaming (`secretstream`),
- constant-time and secure-memory helpers (`mprotect`, `mlock`, guarded alloc),
- full libsodium surface coverage where it makes sense for `std::`.

==============================================================================
DOCS: `std::env` (std/env)
URL: /silk/docs/?p=std/env
==============================================================================

# `std::env`


`std::env` provides access to process environment variables.

The current implementation targets a hosted POSIX baseline (Linux/glibc) and is
implemented on top of the pluggable `std::runtime::env` interface. WASI support
is partially implemented: `get` works, while `set` remains unsupported (see
“Platform notes”).

## API

```silk
module std::env;

import std::process;
import std::strings;

enum SetVarErrorKind { InvalidKey, OutOfMemory, Unknown }

error SetVarFailed { code: int }

export fn get (key: string) -> string?;
export fn set (key: string, value: string) -> SetVarFailed?;

export fn cwd () -> string?;
export fn home_dir () -> string?;
export fn temp_dir () -> string;

// Working-directory helpers that query the OS (not the environment).
export fn get_current_dir () -> std::process::GetCwdResult;
export fn set_current_dir (path: string) -> std::process::ChdirFailed?;
```

### `get`

`std::env::get(key)` returns:

- `Some(value)` when the variable exists, otherwise
- `None`.

The returned `string` is a **view** into the underlying runtime environment
storage. It does not copy. On POSIX, `get` does not allocate. On WASI, `get`
may allocate once on first use to cache an environment snapshot (WASI requires
caller-provided buffers for `environ_get`).

Callers should treat the view as valid only until the environment is mutated
(for example by calling `std::env::set`). On WASI Preview 1, environment
mutation is not supported by the runtime, so values returned by `get` remain
valid for the process lifetime.

Example:

```silk
import std::env;
import { println } from "std/io";

fn main () -> int {
  let v_opt = std::env::get("FOO");
  match (v_opt) {
    Some(v) => println("FOO = {}", v),
    None => println("FOO does not exist"),
  };
  return 0;
}
```

### `set`

`std::env::set(key, value)` updates the current process environment.

Errors are reported as an optional error value (`SetVarFailed?`).

`SetVarFailed` does not expose platform `errno` values. Use
`SetVarFailed.kind()` to classify failures into `SetVarErrorKind` values.

Example:

```silk
import std::env;
import { println } from "std/io";

fn main () -> int {
  if std::env::set("FOO", "BAR") != None {
    println("failed to set FOO");
    return 1;
  }
  return 0;
}
```

## Platform notes

- **POSIX (default shipped stdlib)**: implemented via `getenv(3)` and
  `setenv(3)`.
- **WASI**:
  - `get` is implemented via WASI Preview 1 `environ_sizes_get` /
    `environ_get` and caches the returned environment buffer for the process
    lifetime,
  - `set` is not supported on WASI Preview 1 and always fails (returns
    `Some(SetVarFailed{ code: ... })` with `kind() == Unknown`).
  - `get_current_dir` / `set_current_dir` are implemented via the virtual cwd
    layer backing `std::process::getcwd` / `std::process::chdir` (they do not
    mutate `$PWD`).

## Directory helpers

`std::env` also provides a tiny subset for common directory
queries.

### `cwd`

`std::env::cwd()` returns the current working directory as a `string?`.

Current implementation:

- returns `std::env::get("PWD")`.

This is a pure environment-variable view and may be missing or stale if the
process environment is not kept in sync with the real working directory.

On `wasm32-wasi`, `$PWD` is often unset and does not track the virtual cwd used
by `std::process::chdir`; prefer `get_current_dir` when you need the runtime
working directory.

### `get_current_dir`

`std::env::get_current_dir()` returns the current working directory as an owned
`std::strings::String`.

This is an alias for `std::process::getcwd()` and queries the OS, not the
process environment.

Ownership:

- Callers must drop the returned `String` when finished.

### `set_current_dir`

`std::env::set_current_dir(path)` changes the current working directory.

This is an alias for `std::process::chdir(path)`.

### `home_dir`

`std::env::home_dir()` returns the user’s home directory as a `string?`.

Current implementation:

- returns `std::env::get("HOME")`.

### `temp_dir`

`std::env::temp_dir()` returns a temporary-directory path as a `string`.

Current implementation:

1. uses `TMPDIR` when set,
2. otherwise uses `TMP` or `TEMP` when set,
3. otherwise returns `"/tmp"`.

==============================================================================
DOCS: `std::flag` (std/flag)
URL: /silk/docs/?p=std/flag
==============================================================================

# `std::flag`

line argument parser modeled after Go’s `flag` package, but shaped to match
`std::` conventions (explicit `Result(...)` errors, no leaky out-params, and a
clear separation between flags, positionals, and `--` rest arguments).

`std::flag` is intended for programs that use the native hosted entrypoint:

```silk
fn main (argc: int, argv: u64) -> int { ... }
```

and the current `std::args::Args` view.

See also:


## Design goals

- **Typed flags**: parse `bool`, `int`, `i64`, `u64`, and `string` values.
- **Typed positionals**: declare and parse positional arguments (required and
  optional), separate from flags.
- **`--` rest**: support `--` to stop parsing flags and expose the remaining
  arguments as a “rest” list for forwarding to subcommands/tools.
- **Stable errors**: return a structured `FlagFailed` value (no `errno`, no
  sentinel returns, no hidden error state).
- **No hidden allocation**: the parser stores only string *views* into the
  original argv bytes; it does not copy argument strings.

## Parsing rules ()

Given an argv slice `args[start..]` (typically `start = 1` to skip `argv[0]`):

- `--` terminates **flag parsing**; arguments after `--` are captured as
  **rest** and are never interpreted as flags.
- While parsing flags:
  - tokens beginning with `--` match **long names** (`--name`, `--name=value`),
  - tokens beginning with `-` match **either** a long name or a declared alias
    (`-name`, `-name=value`, `-a`, `-a=value`),
  - a lone `-` terminates flag parsing and starts positional mode (the `-` token
    itself is captured as the first positional),
  - the first token that does not begin with `-` starts **positional** mode.
- While in positional mode:
  - tokens are captured as **positionals** (even if they begin with `-`),
  - `--` may still appear to start **rest**.

This matches the common “flags first, then args” convention and avoids
misclassifying negative numbers once positional mode begins.

## Public API (initial)

```silk
module std::flag;

import std::args;
import std::result;

enum FlagErrorKind { ... }

struct FlagFailed {
  code: int,
  arg_index: int,
  detail: i64,
}

impl FlagFailed {
  public fn kind (self: &FlagFailed) -> FlagErrorKind;
  public fn arg_opt (self: &FlagFailed, args: &std::args::Args) -> string?;
  public fn arg (self: &FlagFailed, args: &std::args::Args) -> string;
}

struct BoolOptions { name: string, alias: string, default_value: bool, usage: string }
struct IntOptions { name: string, alias: string, default_value: int, usage: string }
struct I64Options { name: string, alias: string, default_value: i64, usage: string }
struct U64Options { name: string, alias: string, default_value: u64, usage: string }
struct StringOptions { name: string, alias: string, default_value: string, usage: string }

struct FlagSet { ... }

struct BoolFlag { index: i64 }
struct IntFlag { index: i64 }
struct I64Flag { index: i64 }
struct U64Flag { index: i64 }
struct StringFlag { index: i64 }

struct PosString { index: i64 }
struct PosInt { index: i64 }
struct PosI64 { index: i64 }
struct PosU64 { index: i64 }

struct ParsedArgs { ... }

export type ParseResult = std::result::Result(ParsedArgs, FlagFailed);
export type BoolFlagResult = std::result::Result(BoolFlag, FlagFailed);
export type IntFlagResult = std::result::Result(IntFlag, FlagFailed);
export type I64FlagResult = std::result::Result(I64Flag, FlagFailed);
export type U64FlagResult = std::result::Result(U64Flag, FlagFailed);
export type StringFlagResult = std::result::Result(StringFlag, FlagFailed);

export type PosStringResult = std::result::Result(PosString, FlagFailed);
export type PosIntResult = std::result::Result(PosInt, FlagFailed);
export type PosI64Result = std::result::Result(PosI64, FlagFailed);
export type PosU64Result = std::result::Result(PosU64, FlagFailed);
```

Notes:

- Flag/positional “handles” (`BoolFlag`, `PosString`, …) are small, copyable
  indices into the owning `FlagSet`. This keeps the API explicit and avoids
  exporting raw pointers.
- Handle structs have safe defaults (their `index` field defaults to an invalid
  sentinel). `FlagSet.get_*` methods treat invalid handles as “missing” and
  return zero values (`false`, `0`, or `""`) rather than reading out of bounds.
- Usage strings may be retrieved from the owning `FlagSet` via
  `get_flag_usage(handle.index)` and `get_positional_usage(handle.index)` when
  building usage/help output (or via `handle.usage(fs)`).
- `ParsedArgs` provides views of:
  - all positional tokens after flags (including the `--` rest segment),
  - and raw rest tokens (after `--`).
- Typed values are retrieved from the `FlagSet` via the returned handles.
- Flag declarations prefer options structs (`BoolOptions`, `IntOptions`, ...).
- Options structs use `default_value` because `default` is a reserved keyword.

## Example

```silk
import std::args;
import std::flag;
import { println } from "std/io";

fn main (argc: int, argv: u64) -> int {
  let a = std::args::Args.init(argc, argv);
  let mut fs = std::flag::FlagSet.init();

  let verbose_r = (mut fs).bool({ name: "verbose", alias: "v", default_value: false, usage: "enable verbose logging" });
  let out_r = (mut fs).string({ name: "out", alias: "", default_value: "out.txt", usage: "output path" });
  let input_r = (mut fs).positional_string("input", "input file");

  if verbose_r.is_err() { (mut fs).drop(); return 2; }
  if out_r.is_err() { (mut fs).drop(); return 2; }
  if input_r.is_err() { (mut fs).drop(); return 2; }

  let verbose: std::flag::BoolFlag = match (verbose_r) {
    Ok(v) => v,
    Err(_) => {},
  };
  let out: std::flag::StringFlag = match (out_r) {
    Ok(v) => v,
    Err(_) => {},
  };
  let input: std::flag::PosString = match (input_r) {
    Ok(v) => v,
    Err(_) => {},
  };

  let parsed_r = (mut fs).parse_args(a, 1);
  match (parsed_r) {
    Err(e) => {
      println("flag parse error: kind={} at argv[{}]: {}", e.kind(), e.arg_index, e.arg(a));
      (mut fs).drop();
      return 2;
    },
    Ok(p) => {
      if fs.get_bool(verbose) {
        println("out={}", fs.get_string(out));
      }
      println("input={}", fs.get_pos_string(input));

      // `--` rest args (for forwarding).
      var i: int = 0;
      while i < p.rest_count() {
        println("rest[{}]={}", i, p.rest(a, i));
        i += 1;
      }
      (mut fs).drop();
      return 0;
    }
  }
}
```

==============================================================================
DOCS: `std::fmt` (std/fmt)
URL: /silk/docs/?p=std/fmt
==============================================================================

# `std::fmt`

in `std/fmt.slk` and is intentionally scoped to the current compiler/backend
subset (no generics, no runtime interface dispatch).

`std::fmt` provides a shared, Zig-`std.fmt`-style format-string syntax and a
small formatting engine used by `std::io::print` / `std::io::println`.

See also:


## Format String Syntax (Zig-compatible subset)

A format string is a `string` containing literal text and **placeholders**.

### Escaping braces

- `{{` renders a literal `{`
- `}}` renders a literal `}`

### Placeholders

Placeholders are written with `{ ... }`:

- `{}` — formats the next argument (sequential).
- `{0}` — formats argument 0 (positional).
- `{d}` — formats the next argument using a specifier (here: decimal).
- `{0x}` — formats argument 0 using a specifier (here: hex lower).

Placeholders may also include **format options** after a colon `:`:

- `{:10}` — width 10 (default alignment).
- `{:>10}` — width 10, right-aligned.
- `{:=^10}` — width 10, center-aligned, filled with `=`.
- `{:04}` — width 4, zero-padded (special case: leading `0` implies `fill='0'`).

Precision is written after a dot:

- `{e:.5}` — scientific formatting with precision 5 (when supported by the value type).

### Grammar (informal)

Within `{ ... }`:

- optional **argument selector**:
  - digits: `0`, `1`, `2`, ...
  - bracketed index: `[0]`, `[1]`, ... (reserved for future named arguments; the current implementation accepts only numeric indices)
- optional **specifier string** (examples: `d`, `x`, `s`, `c`, `e`)
- optional `:` followed by:
  - optional `fill` + `alignment`:
    - `<` left, `^` center, `>` right
    - `fill` is any single byte placed immediately before the alignment character (example: `*^`)
  - optional `width`:
    - digits (`10`), or bracketed index (`[1]`) to take the width from another argument
  - optional `.` and optional `precision`:
    - digits (`.3`), or bracketed index (`.[1]`) to take the precision from another argument

## Current API

Because the language does not yet have generics, the current API uses an
explicit argument carrier type (`Arg`). With language-level varargs, the
formatter now accepts a variable number of arguments (up to the current
compiler’s varargs limit).

### `Arg`

`std::fmt::Arg` is a POD carrier used by `std::io` printing:

- `Arg.missing()` — missing argument placeholder.
- `Arg.int(value: int)` — signed integer argument.
- `Arg.i128(value: i128)` — signed 128-bit integer argument.
- `Arg.u64(value: u64)` — unsigned integer / pointer-sized argument.
- `Arg.u128(value: u128)` — unsigned 128-bit integer argument.
- `Arg.f64(value: f64)` — floating-point argument (both `f32` and `f64` coerce to this ctor).
- `Arg.f128(value: f128)` — 128-bit floating-point argument.
- `Arg.bool(value: bool)` — boolean argument.
- `Arg.char(value: char)` — Unicode scalar argument (formatted as UTF-8 bytes for `{c}` / `{u}`; invalid codepoints render as U+FFFD).
- `Arg.string(value: string)` — string argument.
- `Arg.regexp(value: regexp)` — regexp argument (currently formatted as placeholder text).
- `Arg.Region(value: Region)` — region argument (currently formatted as placeholder text).

Compiler convenience: the compiler supports an opt-in implicit
call-argument coercion mechanism for struct types that provide exported static
ctor methods (`int`/`i128`/`u64`/`u128`/`f64`/`f128`/`bool`/`char`/`string`/`regexp`/`Region`).
`std::fmt::Arg` implements these ctors, so callers can pass primitives directly
to `std::io::print` / `std::io::println` without explicit `Arg.*` wrappers.


### Supported specifiers ()

The current formatter supports:

- `s` — string
- `d` — decimal number (`int`/`u64`/`i128`/`u128` and `f64`/`f128`)
- `b` — binary integer
- `o` — octal integer
- `x` — lowercase hex integer
- `X` — uppercase hex integer
- `e` — scientific `f64`/`f128`
- `c` — Unicode scalar (`char`) rendered as UTF-8 bytes
- `u` — Unicode scalar (`char`) rendered as UTF-8 bytes
- `any` — alias for default formatting in Silk

When the specifier is empty (`{}`), a default is chosen based on the argument
kind.

Zig-compat note: when a width is specified (and non-zero), signed integers
include an explicit sign for non-negative values (for example `"{:4}"` formats
`123` as `"+123"`).

Limitation: formatting signed integers (`int`/`i128`) in
non-decimal bases (`b`/`o`/`x`/`X`) requires non-negative values.

Float formatting is implemented for `f64` in Silk:

- `{}` / `{d}` format as decimal by default, with an automatic scientific fallback
  for very small / very large magnitudes.
- `{e}` formats in scientific notation.
- precision (`.{N}`) controls the number of digits after the decimal point
  (default: 6), and width/alignment apply like other formatting kinds.

Hex float formatting (`{x}` on floats) and full debug formatting (`{any}`
recursing through arbitrary types) remain future work.

`f128` formatting is implemented by converting values to `f64` for formatting,
so output precision is limited to `f64` precision in Silk.

## High-Level Formatting (`format`)

`std::fmt` provides a high-level convenience for producing formatted strings:

```silk
import { println } from "std/io";
import format from "std/fmt";
import std::fmt;
import std::strings;
import std::result;

type StringAllocResult = std::result::Result(std::strings::String, std::fmt::Error);

fn main () -> int {
  const a = 1;
  const b = 2;

  let hello_r: StringAllocResult = format("hello {}", "world");
  if hello_r.is_err() {
    return 1;
  }
  let mut hello: std::strings::String = match (hello_r) {
    StringAllocResult::Ok(v) => v,
    StringAllocResult::Err(_) => std::strings::String.empty(),
  };

  let sum_r: StringAllocResult = format("a + b = {}", a + b);
  if sum_r.is_err() {
    (mut hello).drop();
    return 2;
  }
  let mut sum: std::strings::String = match (sum_r) {
    StringAllocResult::Ok(v) => v,
    StringAllocResult::Err(_) => std::strings::String.empty(),
  };

  println("{}", hello.as_string());
  println("sum of {}", sum.as_string());
  (mut sum).drop();
  (mut hello).drop();
  return 0;
}
```

Signature:

```silk
export default fn format (fmt: string, ...args: Arg) -> std::result::Result(std::strings::String, std::fmt::Error);
```

Notes ():

- `format` is also available as a named export (`import { format } from "std/fmt";`).
- The returned `std::strings::String` is an owned, NUL-terminated string buffer.
  - When heap-backed, it is freed on Drop (calls `std::runtime::mem::free`).
- Use `String.as_string()` to obtain a borrowed `string` view.
- For bounded allocations, format into caller-owned storage with `format_to_buffer_u8`.

==============================================================================
DOCS: `std::formal` (std/formal)
URL: /silk/docs/?p=std/formal
==============================================================================

# `std::formal`

that encode common proof obligations (non-negativity, bounds checks, and basic
container invariants).

These theories are intended to:

- de-duplicate repetitive `#require` / `#assure` clauses across the standard
  library, and
- give downstream code a small set of “standard lemmas” for Z3-backed
  verification.

theory semantics.

## Importing and using theories

Theories are imported with named imports and applied via `#theory`:

```silk
import { nonnegative_i64, bounds_i64 } from "std/formal";

#theory nonnegative_i64(len);
#theory bounds_i64(index, len);
fn get_at (index: i64, len: i64) -> i64 {
  return index;
}
```

## Initial theory set

The current `std::formal` module exports (at minimum) the following
theories:

- `nonnegative_i64(x: i64)` — proves/assumes `x >= 0`.
- `nonnull_u64(ptr: u64)` — proves/assumes `ptr != 0`.
- `bounds_i64(index: i64, len: i64)` — proves/assumes `0 <= index < len`.
- `slice_well_formed(ptr: u64, len: i64)` — proves/assumes:
  - `len >= 0`
  - `len == 0 || ptr != 0`
- `vector_well_formed(ptr: u64, len: i64, cap: i64)` — proves/assumes:
  - `len >= 0`
  - `cap >= 0`
  - `len <= cap`
  - `cap == 0 || ptr != 0`

==============================================================================
DOCS: `std::fs` (std/filesystem)
URL: /silk/docs/?p=std/filesystem
==============================================================================

# `std::fs`

filesystem API backed by `std::runtime::fs`. It exposes a low-level `File`
handle and byte-oriented I/O primitives, staying within the current compiler’s
feature set.

The public `std::fs` surface does not expose POSIX `errno`. Runtime-specific
details live under `std::runtime`.

See also:


## Platform notes

- Hosted baseline (`linux/x86_64`): `std::runtime::fs` delegates to
  `std::runtime::posix::fs` and uses POSIX syscalls.
- `wasm32-wasi`: `std::runtime::fs` is backed by `std::runtime::wasi::fs` and
  requires the embedder to provide at least one preopened directory. Paths are
  interpreted as relative to the first preopened directory found via
  `fd_prestat_get` (sandbox root):
  - absolute paths (`/foo/bar`) are interpreted relative to the sandbox root,
  - relative paths (`foo/bar`) are resolved against a virtual working directory
    managed by `std::process::chdir` / `std::process::getcwd`,
  - `.` and `..` segments are normalized; `..` cannot escape above the sandbox root.

## API

A hosted POSIX baseline exists today in `std/fs.slk`. The low-level OS bindings
are provided via `std::runtime::fs` (which defaults to a POSIX implementation
in the shipped stdlib).

```silk
module std::fs;

export fn exists (path: string) -> bool;
export fn can_read (path: string) -> bool;
export fn can_write (path: string) -> bool;
export fn can_exec (path: string) -> bool;

enum FSErrorKind {
  OutOfMemory,
  NotFound,
  PermissionDenied,
  AlreadyExists,
  NotADirectory,
  IsADirectory,
  InvalidInput,
  UnexpectedEof,
  Unknown,
}

struct FSFailed {
  code: int,
  requested: i64,
}

impl FSFailed {
  public fn kind (self: &FSFailed) -> FSErrorKind;
}

export type FSError = FSFailed;

export type FSIntResult = std::result::Result(int, FSFailed);
export type FSI64Result = std::result::Result(i64, FSFailed);
export type FSErrorIntResult = std::result::Result(int, FSError);
export type FSBufferU8Result = std::result::Result(std::buffer::BufferU8, FSError);
export type FSStringResult = std::result::Result(std::strings::String, FSError);

struct OpenOptions {
  read: bool,
  write: bool,
  create: bool,
  truncate: bool,
  append: bool,
  mode: int,
}

impl OpenOptions {
  public fn read_only () -> OpenOptions;
  public fn write_only () -> OpenOptions;
  public fn read_write () -> OpenOptions;
  public fn create_truncate (mode: int) -> OpenOptions;
  public fn create_append (mode: int) -> OpenOptions;
}

enum SeekWhence {
  Start,
  Current,
  End,
}

// A file descriptor wrapper.
struct File {
  fd: int,
}

export type FileResult = std::result::Result(File, FSFailed);

impl File {
  // Construct an invalid/closed file handle (`fd = -1`).
  public fn invalid () -> File;

  // Open a file (portable options, hosted baseline implementation).
  public fn open (path: string, opts: OpenOptions) -> FileResult;
  public fn open_read (path: string) -> FileResult;
  public fn open_write (path: string) -> FileResult;
  public fn create (path: string, mode: int) -> FileResult;
  public fn append (path: string, mode: int) -> FileResult;
  public fn is_valid (self: &File) -> bool;
  public fn close (mut self: &File) -> FSFailed?;

  // Byte I/O (hosted baseline).
  public fn read (self: &File, buf: std::arrays::ByteSlice) -> FSIntResult;
  public fn read_exact (self: &File, buf: std::arrays::ByteSlice) -> FSFailed?;
  public fn write (self: &File, buf: std::arrays::ByteSlice) -> FSIntResult;
  public fn seek (self: &File, offset: i64, whence: SeekWhence) -> FSI64Result;
  public fn tell (self: &File) -> FSI64Result;
  public fn size (self: &File) -> FSI64Result;
  public fn sync (self: &File) -> FSFailed?;
  public fn truncate (self: &File, len: i64) -> FSFailed?;

  // Convenience helpers.
  public fn read_to_end (self: &File, mut out: &std::buffer::BufferU8) -> FSErrorIntResult;
  public fn write_all (self: &File, buf: std::arrays::ByteSlice) -> FSFailed?;
}

// Files are closed on scope exit and on overwrite.
impl File as std::interfaces::Drop {
  public fn drop (mut self: &File) -> void;
}

// Convenience helpers for common whole-file operations.
export fn read_file (path: string) -> FSBufferU8Result;
export fn read_file_string (path: string) -> FSStringResult;
export fn write_file (path: string, buf: std::arrays::ByteSlice, mode: int) -> FSIntResult;
export fn append_file (path: string, buf: std::arrays::ByteSlice, mode: int) -> FSIntResult;
export fn write_file_string (path: string, contents: string, mode: int) -> FSIntResult;
export fn append_file_string (path: string, contents: string, mode: int) -> FSIntResult;
export fn copy_file (src: string, dst: string, mode: int) -> FSErrorIntResult;

// Path-based helpers (`None` on success).
export fn unlink (path: string) -> FSFailed?;
export fn rename (old_path: string, new_path: string) -> FSFailed?;
export fn mkdir (path: string, mode: int) -> FSFailed?;
export fn rmdir (path: string) -> FSFailed?;
export fn mkdir_all (path: string, mode: int) -> FSError?;
```

Notes:

- These functions call POSIX/libc `access(2)` via `ext`. Executable outputs
  import external libc symbols. On `linux/x86_64` with the glibc dynamic loader
  (`ld-linux`), `silk` automatically adds `libc.so.6` as a `DT_NEEDED`
  dependency when external symbols are present, so `--needed libc.so.6` is not
  required for typical `std::fs` use.
  - This applies to other `std::fs` POSIX bindings as well (`open(2)`,
    `read(2)`, `close(2)`, etc.).
  - `std::fs` maps runtime failures into a portable `FSErrorKind` set; the raw
    platform error mechanism (for example POSIX `errno`) is not part of the
    public API. The mapping from the platform mechanism into stable
    `FSFailed.code` values is performed by `std::runtime::fs`.
  - `mkdir_all` is a convenience helper for `mkdir -p` behavior. In the current
    hosted subset it treats `EEXIST` as success and does not distinguish an
    existing directory from an existing non-directory at the same path.

## Scope

`std::fs` is responsible for:

- File and directory creation, deletion, and enumeration.
- Basic metadata operations.

, `std::fs` APIs still accept raw `string` paths.

Hosted baseline:

- POSIX paths are treated as opaque byte sequences (not necessarily UTF-8).
- APIs that accept `string` paths must specify encoding behavior. The initial
  baseline assumes UTF-8 on POSIX but does not require it for all operations.

## Core Types (Initial Design)

- `Path` / `PathBuf` for path manipulation (borrowed vs owned).
- `File` for open file handles.
- `Dir` / directory iteration.
- `Metadata` for stat-like information.

Illustrative sketch:

```silk
module std::fs;

export enum FsError {
  NotFound,
  PermissionDenied,
  AlreadyExists,
  NotADirectory,
  IsADirectory,
  InvalidPath,
  Unknown,
}

export struct OpenOptions {
  read: bool,
  write: bool,
  create: bool,
  truncate: bool,
}

export fn open (path: string, opts: OpenOptions) -> Result(File, FsError);
export fn read_to_string (alloc: std::memory::Allocator, path: string) -> Result(std::strings::String, FsError);
```

## Future Work

- Symlink support and canonicalization.
- File watching (platform-dependent).

==============================================================================
DOCS: `std::ggml` (std/ggml)
URL: /silk/docs/?p=std/ggml
==============================================================================

# `std::ggml`


`std::ggml` exposes the ggml tensor library to Silk programs. The long-term
goal is to make ggml the standard tensor backend for Silk’s ML-oriented
standard library surface.

Upstream:

- Repository: `ggml-org/ggml`
- Pinned version: `v0.9.5`

## Goals

- Provide a safe, Silk-native wrapper layer over the ggml C API.
- Keep raw access available for power users (with explicit unsafe/pointer APIs).
- Make building/linking predictable by treating ggml as a core vendored
  dependency (similar to libsodium/mbedTLS/libssh2/sqlite in the hosted
  baseline).

## ABI / FFI Notes

The current Silk backend subset uses a scalar-slot memory model for structs
`ext`), passing C structs by value is only ABI-safe when the struct’s flattened
slots are all `i64`/`u64`/`f64`.

For FFI with upstream C APIs, note that Silk’s `int` currently maps to `i64` on
`linux/x86_64`. The `std::ggml` bindings therefore use `i32` for ggml’s C
`int`/`enum` values (type codes, status values, indices, and thread counts) to
match the upstream ABI.

ggml includes several C entrypoints that accept small structs by value (notably
`ggml_init(struct ggml_init_params)`), where the C layout includes `bool` and
`size_t`. This is not ABI-safe to call directly from Silk in Silk.

Therefore, `std::ggml` uses a tiny C shim layer (built as part of the toolchain)
to expose ABI-safe wrapper functions for the few by-value-struct APIs.

## Build + Dependency Workflow

`zig build deps` is responsible for fetching/building ggml and staging:

- headers into `vendor/include/` (for shim compilation),
- static archives into `vendor/lib/x64-linux/` (for linking),


On `linux/x86_64`, `silk build` automatically links the staged ggml archives
when `std::ggml` is included in the module set. If the archives are missing,
the build fails with an actionable error pointing to `zig build deps`.

When linking `.o` / `.a` inputs, `silk build` also auto-links ggml if any input
references `silk_ggml_init` (for example, when a prebuilt static library was
produced from Silk code that uses `std::ggml`). This keeps downstream consumers
from needing to import `std::ggml` purely to satisfy link/runtime dependencies.

The current auto-linked archives are:
`libggml.a`, `libggml-base.a`, `libggml-cpu.a`, and `libsilk_ggml_shims.a`.

Because ggml is built as C++ on the hosted baseline, the produced executables
and shared libraries also depend on the system C++ runtime (`libstdc++`) and
math library (`libm`); `silk build` adds these as `DT_NEEDED` entries when it
auto-links ggml.

## Intended Surface (Initial)

The initial surface is intentionally small:

- create/free a ggml context,
- create basic tensors,
- compute a graph,
- basic tensor inspection helpers.

The module is expected to grow incrementally as we map more of the upstream API
into a stable Silk wrapper layer.

==============================================================================
DOCS: `std::http` (std/http)
URL: /silk/docs/?p=std/http
==============================================================================

# `std::http`

HTTP/1.1 request/response parsing and a small blocking client/server connection
API on top of `std::net::TcpStream`.

See also:

- RFC 7230 / RFC 7231 (HTTP/1.1 message syntax and semantics)

## Scope (Current)



- HTTP/1.1 request line and response status line parsing.
- Case-insensitive header scanning (`header(name)`).
- Body handling via `Content-Length` (read/write).
- Blocking I/O over `std::net::TcpStream`.

Not implemented (yet):

- Chunked transfer encoding (`Transfer-Encoding: chunked`).
- HTTP/2 or HTTP/3.
- Streaming bodies (incremental read/write APIs).
- Automatic decompression, redirects, cookies, proxies, etc.

## Public API

```silk
module std::http;

import std::net;
import std::result;
import std::strings;

export let DEFAULT_MAX_HEADER_BYTES: i64 = 16384;

// Errors use a small set of integer kind codes.
export let ERR_IO: int = 1;
export let ERR_TOO_LARGE: int = 2;
export let ERR_BAD_MESSAGE: int = 3;
export let ERR_UNSUPPORTED_TRANSFER_ENCODING: int = 4;
export let ERR_BAD_CONTENT_LENGTH: int = 5;
export let ERR_OUT_OF_MEMORY: int = 6;

export error Error {
  kind: int,
}

// Parsed HTTP request backed by owned bytes.
struct Request { /* opaque */ }
export type RequestResult = std::result::Result(Request, Error);
impl Request {
  public fn parse (input: string) -> RequestResult;
  public fn method (self: &Request) -> string;
  public fn target (self: &Request) -> string;
  public fn version (self: &Request) -> string;
  public fn header (self: &Request, name: string) -> string?;
  public fn body (self: &Request) -> string;
}

// Parsed HTTP response backed by owned bytes.
struct Response { /* opaque */ }
export type ResponseResult = std::result::Result(Response, Error);
impl Response {
  public fn parse (input: string) -> ResponseResult;
  public fn version (self: &Response) -> string;
  public fn status_code (self: &Response) -> int;
  public fn reason (self: &Response) -> string;
  public fn header (self: &Response, name: string) -> string?;
  public fn body (self: &Response) -> string;
}

// A blocking connection wrapper that can read/write one message at a time.
struct Connection { /* opaque */ }
impl Connection {
  public fn from_stream (stream: std::net::TcpStream) -> Connection;
  public fn is_valid (self: &Connection) -> bool;
  public fn close (mut self: &Connection) -> Error?;

  // Client helpers.
  public fn write_request (self: &Connection, method: string, target: string, host: string, body: string) -> Error?;
  public fn read_response (mut self: &Connection) -> ResponseResult;

  // Server helpers.
  public fn read_request (mut self: &Connection) -> RequestResult;
  public fn write_response (self: &Connection, status: int, reason: string, body: string) -> Error?;
}
```

Notes:

- This API is currently blocking and uses `Connection: close` by default.
- Parsed messages own their backing bytes and return borrowed `string` views into
  those bytes; the returned views are valid until the message is dropped.

## Example (Client)

```silk
import std::http;
import std::net;

fn trap (T;) -> T {
  std::abort();
}

export fn main () -> int {
  // Plain HTTP to a loopback server (no DNS in the current stdlib).
  let addr = net::SocketAddrV4.loopback(8080);
  let stream_r = net::TcpStream.connect(addr);
  if stream_r.is_err() {
    return 1;
  }
  let stream: net::TcpStream = match (stream_r) {
    net::TcpStreamResult::Ok(v) => v,
    net::TcpStreamResult::Err(_) => trap(net::TcpStream;),
  };

  let mut conn = http::Connection.from_stream(stream);
  let w_err: http::Error? = conn.write_request("GET", "/", "localhost", "");
  if w_err != None {
    (mut conn).close();
    return 2;
  }

  let resp_r = (mut conn).read_response();
  if resp_r.is_err() {
    (mut conn).close();
    return 3;
  }
  let resp: http::Response = match (resp_r) {
    http::ResponseResult::Ok(v) => v,
    http::ResponseResult::Err(_) => trap(http::Response;),
  };
  _ = resp.status_code();
  (mut conn).close();
  return 0;
}
```

## Validation Rules

- `Content-Length` must parse as a non-negative decimal value.
- When `Transfer-Encoding` is present and not equal to `"identity"`, parsing
  fails with `ERR_UNSUPPORTED_TRANSFER_ENCODING`.
- Request/response header blocks are limited by `DEFAULT_MAX_HEADER_BYTES`
  (and per-connection configuration where applicable).

==============================================================================
DOCS: `std::https` (std/https)
URL: /silk/docs/?p=std/https
==============================================================================

# `std::https`

small HTTPS client/server connection API on top of `std::tls` (mbedTLS) and
`std::net::TcpStream`.

See also:

- RFC 2818 (HTTP over TLS)

## Scope (Current)



- Blocking TLS handshake using `std::tls::Session`.
- HTTPS request/response I/O using the same message model as `std::http`.

Not implemented (yet):

- Certificate verification (CA store), hostname verification, and SNI/ALPN
  configuration beyond current defaults.
- Non-blocking integration with an async runtime.

## Public API

```silk
module std::https;

import std::http;
import std::net;
import std::result;

export let ERR_CONNECT: int = 1;
export let ERR_TLS: int = 2;
export let ERR_IO: int = 3;
export let ERR_HTTP: int = 4;
export let ERR_OUT_OF_MEMORY: int = 5;

export error Error {
  kind: int,
}

struct Connection { /* opaque */ }
export type ConnectionResult = std::result::Result(Connection, Error);
impl Connection {
  // Establish TCP, then perform a TLS client handshake.
  public fn connect (addr: std::net::SocketAddrV4) -> ConnectionResult;
  public fn is_valid (self: &Connection) -> bool;
  public fn close (mut self: &Connection) -> Error?;

  public fn write_request (self: &Connection, method: string, target: string, host: string, body: string) -> Error?;
  public fn read_request (mut self: &Connection) -> http::RequestResult;
  public fn write_response (self: &Connection, status: int, reason: string, body: string) -> Error?;
  public fn read_response (mut self: &Connection) -> http::ResponseResult;
}

struct Server { /* opaque */ }
export type ServerResult = std::result::Result(Server, Error);
impl Server {
  // Listen on TCP, accept, then perform a TLS server handshake with the provided
  // certificate and private key (PEM).
  public fn listen (addr: std::net::SocketAddrV4, backlog: int, cert_pem: string, key_pem: string) -> ServerResult;
  public fn is_valid (self: &Server) -> bool;
  public fn local_port (self: &Server) -> std::net::NetIntResult;
  public fn accept (mut self: &Server) -> ConnectionResult;
  public fn close (mut self: &Server) -> Error?;
}
```

Notes:

- This API is blocking and intended for the hosted POSIX baseline.
- For now, TLS configuration uses current defaults and does not verify
  certificates; this will be tightened as `std::tls` grows.

==============================================================================
DOCS: `std::interfaces` (std/interfaces)
URL: /silk/docs/?p=std/interfaces
==============================================================================

# `std::interfaces`

non-generic standard-library interfaces (“protocols”) that can be used today to
express common capabilities across `std::` types.

Dynamic interface dispatch (trait objects / vtables) is part of the language
design, but is not implemented yet. in Silk,
interfaces are used for:

- declaring interface contracts, and
- compile-time conformance checking via `impl Type as Interface { ... }`.
- one compiler-backed convention: `std::interfaces::Drop` is used for automatic
  cleanup of values at well-defined points (see “Drop semantics” below).

See also:


## API

`std/interfaces.slk` currently defines the following interfaces:

```silk
module std::interfaces;

interface Drop {
  fn drop () -> void;
}

interface Len {
  fn len () -> i64;
}

interface Capacity {
  fn capacity () -> i64;
}

interface IsEmpty {
  fn is_empty () -> bool;
}

interface Sized {
  fn size () -> usize;
}

interface Clear {
  fn clear () -> void;
}

interface ReserveAdditional {
  fn reserve_additional (additional: i64) -> std::memory::OutOfMemory?;
}

interface WriteU8 {
  fn write_u8 (value: u8) -> std::memory::OutOfMemory?;
}

interface ReadU8 {
  fn read_u8 () -> u8?;
}

interface Iterator(T) {
  fn next () -> T?;
}

interface Serialize(S = string) {
  fn serialize () -> S;
}

interface Deserialize(S = string) {
  fn deserialize (value: S) -> Self;
}
```

Notes:

- Most of these interfaces intentionally avoid generics; they are meant to be
  usable within the . `Serialize` and `Deserialize`
  are generic, but default their representation type parameter to `string` so
  the common case does not require explicit type arguments.
- `ReserveAdditional` and `WriteU8` return `std::memory::OutOfMemory?` so
  allocation-backed types can report allocation failure as a recoverable value
  instead of trapping.
- `Iterator(T)` is modeled after Rust’s `Iterator` and represents a sequential
  producer of values. Implementations typically use a receiver of the form
  `public fn next (mut self: &Type) -> T?`, so calling `next` requires an
  explicit mutable borrow at the call site: `(mut it).next()`.
  - `for x in it { ... }` can also be used when `it.next() -> T?`; the loop
    evaluates the iterator expression once and calls `next()` repeatedly until
- Most interfaces use an implicit receiver: the interface method signature
  omits `self`, and the corresponding `impl` method includes `self` as its
- Exception: `Deserialize(S)` is a static protocol used by `as` casts; its
  `impl` method does **not** take a `self` receiver and is called as
  `Type.deserialize(value)`.
- Planned: `Sized` will be used by the `sizeof` operator for value operands:
  when a concrete type provides `fn size(self: &T) -> usize`, `sizeof value`
- `Serialize` is also recognized by the `as` cast operator:
  - when a type provides `serialize(self: &T) -> S`, an explicit cast
- `Deserialize` is also recognized by the `as` cast operator:
  - when a type provides `deserialize(value: S) -> Self`, an explicit cast

## Drop semantics

`std::interfaces::Drop` is recognized by the compiler as the standard way for a
type to release resources it owns (file descriptors, heap allocations, OS
handles, etc.). A type is considered “droppable” when it provides a method with
this surface signature:

```silk
impl T as std::interfaces::Drop {
  public fn drop (mut self: &T) -> void { ... }
}
```

Automatic invocation (current compiler):

- **Scope exit:** when a `struct` *value* binding goes out of scope (including
  via fallthrough, `break`, and `continue`), the compiler calls `drop` before
  the storage is discarded.
- **Return:** on `return`, the compiler drops all in-scope droppable bindings
  except any value moved into the return result (for example `return value;`
  and `return Some(value);` treat `value` as moved in Silk).
- **Overwrite:** when a `struct` *value* binding is overwritten via assignment,
  the compiler calls `drop` on the old value before copying in the new value.
- **Heap last-release:** for compiler-managed `new` allocations (`&T` with RC),
  the compiler calls `drop` before freeing the backing allocation when the
  refcount reaches zero.

Notes and limitations ():

- `drop` is resolved statically (no dynamic dispatch).
- `drop` should invalidate the value so calling it multiple times is safe.
- The language does not yet implement a general move/ownership model; **do not
  rely on copying `Drop` types** to be safe until move/copy semantics are
  specified and enforced.
  cleanup is performed.

## Example (Conformance)

```silk
import std::interfaces;

struct Counter {
  value: i64,
}

impl Counter as std::interfaces::Len {
  public fn len (self: &Counter) -> i64 {
    return self.value;
  }
}
```

==============================================================================
DOCS: `std::io` (std/io)
URL: /silk/docs/?p=std/io
==============================================================================

# `std::io`

are implemented in `std/io.slk` via `std::runtime::io`; buffered and
async I/O remain future work.

`std::io` provides console and basic stream I/O.

Hosted baseline: POSIX file descriptors and blocking I/O. Future extensions may
include async integration.

See also:


## Current API

The current stdlib provides basic unbuffered stdio primitives
(stdin reads and stdout/stderr writes), plus a small formatting surface
(implemented without libc varargs; formatted bytes are written via
`std::runtime::io::write`):

```silk
module std::io;

enum IOErrorKind {
  OutOfMemory,
  BadFileDescriptor,
  NotFound,
  PermissionDenied,
  WouldBlock,
  Interrupted,
  BrokenPipe,
  InvalidInput,
  Unknown,
}

struct IOFailed { code: int, requested: i64 }
export type IOResult = std::result::Result(int, IOFailed);
export type IOError = IOFailed;
export type IOErrorIntResult = std::result::Result(int, IOError);

export fn read (fd: int, buf: std::arrays::ByteSlice) -> IOResult;
export fn write (fd: int, buf: std::arrays::ByteSlice) -> IOResult;
export fn write_all (fd: int, buf: std::arrays::ByteSlice) -> IOFailed?;
export fn read_to_end (fd: int, mut out: &std::buffer::BufferU8) -> IOErrorIntResult;

export fn read_stdin (buf: std::arrays::ByteSlice) -> IOResult;
export fn write_stdout (buf: std::arrays::ByteSlice) -> IOResult;
export fn write_stderr (buf: std::arrays::ByteSlice) -> IOResult;

export fn puts (s: string) -> IOFailed?;

export fn print (fmt: string, ...args: std::fmt::Arg) -> PrintFailed?;

export fn println (fmt: string, ...args: std::fmt::Arg) -> PrintFailed?;

export fn eprint (fmt: string, ...args: std::fmt::Arg) -> PrintFailed?;

export fn eprintln (fmt: string, ...args: std::fmt::Arg) -> PrintFailed?;
```

Notes:

- `print`/`println` accept Zig-`std.fmt`-style format strings (see
  the current compiler’s varargs limit).
- `eprint`/`eprintln` are the stderr equivalents of `print`/`println`.
- `IOFailed.code` is a stable stdlib error code; callers should prefer `IOFailed.kind()`.
- Invalid buffer arguments report `IOErrorKind::InvalidInput`.
- `read_to_end` returns `IOErrorIntResult` (`Ok(total_bytes)` or `Err(IOFailed)`), where allocation failure is reported as `IOErrorKind::OutOfMemory` and `IOFailed.requested`.
- For ergonomics, `std::fmt::Arg` opts into the compiler’s implicit
  passing primitive values (`int`/fixed-width ints, `usize`/`size`, `f32`/`f64`,
  `bool`, `char`, `string`, `regexp`, `Region`) directly when calling functions
  that expect `Arg` parameters (including varargs), so you can write
  `println("hello {}", "world")` without explicit `Arg.*` wrappers.
- Executable outputs import external libc symbols. On `linux/x86_64` with the
  glibc dynamic loader (`ld-linux`), `silk` automatically adds `libc.so.6` as a
  `DT_NEEDED` dependency when external symbols are present, so `--needed libc.so.6`
  is not required for typical hosted `std::io` use.
- `string` parameters in `ext` calls are lowered as C-string pointers in the
  current backend subset (the backing bytes include a trailing NUL terminator;
  Silk `string` length excludes it).

Example (formatted printing):

```silk
import std::io;

fn main () -> int {
  std::io::println("hello {s} answer={d}", "world", 42);
  return 0;
}
```

Example (stdin → stdout echo using unbuffered reads/writes):

```silk
import std::io;
import std::arrays;
import std::runtime::io;
import std::runtime::mem;

fn main () -> int {
  let buf: u64 = std::runtime::mem::alloc(64);
  if buf == 0 {
    return 2;
  }

  while true {
    let r: std::io::IOResult = std::io::read_stdin(std::arrays::ByteSlice{ ptr: buf, len: 64 });
    if r.is_err() {
      std::runtime::mem::free(buf);
      return 3;
    }

    let n: int = match (r) {
      std::io::IOResult::Ok(v) => v,
      std::io::IOResult::Err(_) => 0,
    };
    if n == 0 {
      break;
    }

    let w_err: std::io::IOFailed? = std::io::write_all(std::runtime::io::STDOUT_FD, std::arrays::ByteSlice{ ptr: buf, len: n as i64 });
    if w_err != None {
      std::runtime::mem::free(buf);
      return 4;
    }
  }

  std::runtime::mem::free(buf);
  return 0;
}
```
## Scope

`std::io` is responsible for:

- Standard input, output, and error streams.
- Simple printing and formatted output APIs.

## Core Interfaces (Initial Design)

The stdlib should standardize reader/writer interfaces:

```silk
module std::io;

export enum IOErrorKind {
  // Stable error kinds (portable subset).
  PermissionDenied,
  NotFound,
  BrokenPipe,
  WouldBlock,
  UnexpectedEof,
  Unknown,
}

export interface Writer {
  write: fn(self: &Writer, bytes: std::arrays::Slice(u8)) -> Result(int, IOErrorKind);
  flush: fn(self: &Writer) -> IOErrorKind?;
}

export interface Reader {
  read: fn(self: &Reader, dst: std::arrays::Slice(u8)) -> Result(int, IOErrorKind);
}
```

The concrete representation of interfaces will evolve with the language; the
key point is that `std::fs` and `std::net` can reuse the same I/O traits.

## Convenience API

- stdout/stderr: `print`/`println` and `eprint`/`eprintln` (formatted output).
- unbuffered primitives: `read_stdin`, `write_stdout`, `write_stderr`.
- future (design): `stdout()` / `stderr()` / `stdin()` handle-returning helpers
  built on a stable reader/writer interface.

## Future Work

- Buffered I/O wrappers (`BufReader`, `BufWriter`).
- Async-aware adapters once the async runtime (event loop + coroutine lowering)
  is implemented; `std::task` exists today but provides only blocking helpers.

==============================================================================
DOCS: `std::json` (std/json)
URL: /silk/docs/?p=std/json
==============================================================================

# `std::json`

stringifier suitable for Silk programs.

Primary goals:

- Correct, spec-driven parsing of RFC 8259 JSON (objects, arrays, strings,
  numbers, booleans, null).
- A memory model that works well with the compiler:
  - parse produces an index-based DOM stored inside a `Document`,
  - arrays/objects use integer “next” links (no `&T` struct fields).
- High performance by default:
  - **borrowed parsing** avoids allocating for unescaped strings and numbers by
    slicing into the input string,
  - strings are only allocated when they contain escapes that must be decoded.
- Deterministic output:
  - compact `stringify` and configurable `stringify_pretty`.

## Data Model

The DOM is represented by an index table owned by a `Document`:

- A `Document` owns:
  - node tables (`tag`, payload fields, sibling links),
  - optional owned allocations for decoded strings and owned-number lexemes.
- JSON values are referred to by `ValueId` (an `i64` node index).

In Silk, struct fields do not support reference types
(`&T` / `&T?`) and `std::vector::Vector(T)` is scalar-slot-oriented (raw-cast
storage). `std::json` therefore stores its DOM as scalar tables and uses index
links for arrays/objects.

### Arrays and Objects

- Arrays store a `first_child` id and each element node stores a `next` id.
- Objects store a `first_member` id and each member node stores:
  - a key `string` view,
  - a value `ValueId`,
  - a `next` member id.

## Strings

- Parsed string values are exposed as decoded UTF-8 `string` views:
  - when the source contains **no escapes**, the string is borrowed from the
    input (zero-copy),
  - when the source contains escapes, the decoded bytes are stored in an owned
    allocation tracked by the `Document` and the view points to that allocation.
- Supported escapes:
  - `\\`, `\"`, `\/`, `\b`, `\f`, `\n`, `\r`, `\t`
  - `\uXXXX` (including surrogate pairs).

## Numbers

`std::json` preserves the number lexeme (as a `string` view) and also provides
helpers to interpret it as `i64` and/or `f64` when needed.

## Parsing

Two parse modes are provided as `Document` methods:

- **Borrowed**: `doc.parse(s)` borrows unescaped strings and number lexemes from
  `s`. The caller must ensure `s` outlives any `string` views read from `doc`.
- **Owned**: `doc.parse_owned(s)` copies all strings and number lexemes into
  allocations tracked by `doc` (independent of `s`).

Both methods:

- clear the `Document` first,
- return `ParseResult` (`Ok(root)` on success, `Err(ParseError)` on error),
- and record the result on the `Document`:
  - `doc.is_ok()` reports success,
  - `doc.root_value()` returns the root `ValueId` on success,
  - `doc.err` contains the parse error details (`kind`, byte `offset`, and 1-based `line`/`column`).

Allocation failures are also reported as ordinary parse errors:

- on out-of-memory, parse returns `Err(ParseError{ kind: ERR_OUT_OF_MEMORY, ... })` and sets
  `doc.err.kind` to `ERR_OUT_OF_MEMORY`.

In Silk, `Document` is typically used as a
heap reference:

```silk
import std::json;

let mut doc: &Document = new Document();
let root_r: std::json::ParseResult = (mut doc).parse(`{"a":1}`);
```

## Stringifying

- `stringify(doc, value)` returns `Result(String, OutOfMemory)` containing compact JSON.
- `stringify_pretty(doc, value, indent)` returns `Result(String, OutOfMemory)` containing
  pretty-printed JSON with a fixed number of spaces per indent level.


- streaming tokenization (SAX-style) for very large inputs,
- a writer interface that can stream output without building a whole string,
- JSON Pointer helpers (RFC 6901) for querying nested values.

==============================================================================
DOCS: `std::limits` (std/limits)
URL: /silk/docs/?p=std/limits
==============================================================================

# `std::limits`


This module provides shared numeric limits for Silk primitive types.

The initial surface is intentionally small and focuses on min/max bounds for
fixed-width integer primitives (useful for validating conversions and host
APIs that cap sizes to a particular width, such as `i32`).

## API

```silk
module std::limits;

export const I8_MIN: i8;
export const I8_MAX: i8;
export const U8_MAX: u8;

export const I16_MIN: i16;
export const I16_MAX: i16;
export const U16_MAX: u16;

export const I32_MIN: i32;
export const I32_MAX: i32;
export const U32_MAX: u32;

export const I64_MIN: i64;
export const I64_MAX: i64;
export const U64_MAX: u64;

export const I128_MIN: i128;
export const I128_MAX: i128;
export const U128_MAX: u128;

export const INT_MIN: int;
export const INT_MAX: int;
```

## Example

Validating that a host-facing length fits in `i32`:

```silk
import std::limits;

fn validate_len (len: i64) -> bool {
  return len >= 0 && len <= (std::limits::I32_MAX as i64);
}
```

==============================================================================
DOCS: `std::map` — Maps and Dictionaries (std/map)
URL: /silk/docs/?p=std/map
==============================================================================

# `std::map` — Maps and Dictionaries

`std::map` provides the standard associative container surfaces:

- `HashMap(K, V)` — an unordered map backed by a hash table.
- `TreeMap(K, V)` — an ordered map backed by a red-black tree.

targets the compiler and will grow as the language gains
first-class move/Drop semantics for values stored inside heap-backed data
structures.

## Design Goals

- Provide a consistent, ergonomic key→value container story in `std::` without
  relying on a builtin `map(K, V)` type form.
- Make allocation behavior explicit and compatible with regions (`with`) and
  `--noheap`.
- Keep the API close in spirit to C++’s `std::unordered_map` and `std::map`
  (operations, complexity expectations, and terminology), adapted to Silk.

## Important Limitations

In Silk:

- `HashMap(K, V)` and `TreeMap(K, V)` store keys and values by value, but do not
  automatically run `Drop` for stored keys/values when entries are overwritten
  or removed.
- `HashMap(K, V)` stores keys and values in the compiler’s **scalar-slot**
  layout (`sizeof(K)` / `sizeof(V)` bytes, multiples of 8 in the current
  subset). This supports multi-slot value types such as `string` and non-opaque
  structs/enums over supported primitives.
- `TreeMap(K, V)` is still limited by its current node layout and, for now,
  should be treated as **single-slot** storage (keys/values that lower to a
  single `u64` slot).
- These containers are intended for “plain” value types:
  - primitive scalars,
  - `string` views,
  - and small POD structs over those primitives.
- Avoid storing refcounted `&Struct` heap references or owned Drop-managed
  structs (for example `std::strings::String`) as keys/values until the
  compiler has complete Drop integration for values stored inside container
  memory.

These limits are expected to be relaxed as the compiler grows a complete memory
model for container element drops.

## HashMap (`HashMap(K, V)`)

### Construction

`HashMap` requires user-supplied hashing and equality functions (similar to the
custom `Hash` and `KeyEqual` types of C++ `std::unordered_map`):

```silk
import std::map;
import std::result;
import std::memory;

type Map = std::map::HashMap(u64, int);
type InitResult = std::result::Result(Map, std::memory::AllocFailed);

fn hash_u64 (k: u64) -> u64 { return k; }
fn eq_u64 (a: u64, b: u64) -> bool { return a == b; }

fn main () -> int {
  let init_r: InitResult = Map.init(16, hash_u64, eq_u64);
  if init_r.is_err() { return 1; }
  let mut m: Map = match (init_r) {
    InitResult::Ok(v) => v,
    InitResult::Err(_) => Map.empty(hash_u64, eq_u64),
  };
  let put_r = (mut m).put(1, 10);
  if put_r.is_err() { (mut m).drop(); return 2; }

  let v: int = m.get(1) ?? 0;
  (mut m).drop();
  return v;
}
```

`HashMap.init(cap, ...)` validates the requested capacity:

- `cap < 0` returns `AllocErrorKind::InvalidInput`.
- very large `cap` values that would overflow internal sizing arithmetic return
  `AllocErrorKind::Overflow`.

### Core API

`HashMap(K, V)` provides:

- `fn empty (hash: fn(K) -> u64, eq: fn(K, K) -> bool) -> HashMap(K, V);`
- `fn init (cap: i64, hash: fn(K) -> u64, eq: fn(K, K) -> bool) -> std::result::Result(HashMap(K, V), std::memory::AllocFailed);`
- `fn len (self: &HashMap(K, V)) -> i64;`
- `fn is_empty (self: &HashMap(K, V)) -> bool;`
- `fn capacity (self: &HashMap(K, V)) -> i64;`
- `fn contains_key (self: &HashMap(K, V), key: K) -> bool;`
- `fn get (self: &HashMap(K, V), key: K) -> V?;`
- `fn put (mut self: &HashMap(K, V), key: K, value: V) -> std::result::Result(V?, std::memory::OutOfMemory);`  
  Inserts or replaces and returns the previous value, if present.
- `fn remove (mut self: &HashMap(K, V), key: K) -> V?;`
- `fn iter (self: &HashMap(K, V)) -> HashMapIter(K, V);`
- `fn clear (mut self: &HashMap(K, V)) -> void;`
- `fn reserve_additional (mut self: &HashMap(K, V), additional: i64) -> std::memory::OutOfMemory?;`
- `fn drop (mut self: &HashMap(K, V)) -> void;`  
  Releases the table backing memory.

Complexity expectations:

- average `O(1)` for `get`/`put`/`remove` when the hash distribution is good,
- worst case `O(n)` in adversarial collision patterns.

## TreeMap (`TreeMap(K, V)`)

`TreeMap` is an ordered map. It requires an ordering function.

### Core API

`TreeMap(K, V)` provides:

- `fn init (cmp: fn(K, K) -> int) -> TreeMap(K, V);`  
  Contract: `cmp(a, b) < 0` iff `a < b`; `cmp(a, b) == 0` iff keys are equal.
- `fn len (self: &TreeMap(K, V)) -> i64;`
- `fn is_empty (self: &TreeMap(K, V)) -> bool;`
- `fn contains_key (self: &TreeMap(K, V), key: K) -> bool;`
- `fn get (self: &TreeMap(K, V), key: K) -> V?;`
- `fn put (mut self: &TreeMap(K, V), key: K, value: V) -> std::result::Result(V?, std::memory::OutOfMemory);`
- `fn remove (mut self: &TreeMap(K, V), key: K) -> V?;`
- `fn iter (self: &TreeMap(K, V)) -> TreeMapIter(K, V);`
- `fn clear (mut self: &TreeMap(K, V)) -> void;`
- `fn drop (mut self: &TreeMap(K, V)) -> void;`

Complexity expectations:

- `O(log n)` lookup/insert/remove.

## Iteration

Both maps provide iteration through an iterator interface:

- `HashMapIter(K, V)` implements `std::interfaces::Iterator(Entry(K, V))`.
- `TreeMapIter(K, V)` implements `std::interfaces::Iterator(Entry(K, V))`.

The produced item type is:

```silk
struct Entry(K, V) {
  key: K,
  value: V,
}
```

Notes:

- Iteration is by value (copies out `key` and `value`).
- `HashMap` iteration order is unspecified.
- `TreeMap` iteration yields entries in ascending key order (as defined by `cmp`).

==============================================================================
DOCS: `std::math` (std/math)
URL: /silk/docs/?p=std/math
==============================================================================

# `std::math`

algebra utilities intended for graphics and general-purpose computation.

The initial focus is:

- vectors and matrices (fixed-size and dynamic-dimension),
- predictable, SIMD-friendly layouts (contiguous storage for dynamic forms),
- safe shape-checking APIs for dynamic operations.

Longer-term, `std::math` will also grow:

- fast SIMD implementations for hot operations,
- trig and transcendental functions (sin/cos/exp/log),
- higher-precision scalar support (`f128`, `u128`) for advanced numeric work and
  future tensor integration. The primitives are part of the supported native
  backend subset; `std::math` will add `f128`-based surfaces incrementally as
  needed.

See also:


## Module Structure

- `std::math` (this file) is the user-facing entrypoint.
- `std::math::vector` contains vector types and operations.
- `std::math::matrix` contains matrix types and operations.

## Error Model

Dynamic-dimension operations return `Result(T, MathFailed)` when shapes are
incompatible (for example adding vectors of different lengths).

## Current API (Initial Subset)

```silk
module std::math;

import std::math::vector;
import std::math::matrix;

// Re-export core types for ergonomic imports.
export type Vec2f = std::math::vector::Vec2f;
export type Vec3f = std::math::vector::Vec3f;
export type Vec4f = std::math::vector::Vec4f;
export type Vec2d = std::math::vector::Vec2d;
export type Vec3d = std::math::vector::Vec3d;
export type Vec4d = std::math::vector::Vec4d;
export type VectorF32 = std::math::vector::VectorF32;
export type VectorF64 = std::math::vector::VectorF64;

export type Mat2f = std::math::matrix::Mat2f;
export type Mat3f = std::math::matrix::Mat3f;
export type Mat4f = std::math::matrix::Mat4f;
export type Mat2d = std::math::matrix::Mat2d;
export type Mat3d = std::math::matrix::Mat3d;
export type Mat4d = std::math::matrix::Mat4d;
export type MatrixF32 = std::math::matrix::MatrixF32;
export type MatrixF64 = std::math::matrix::MatrixF64;

export type MathError = std::math::vector::MathFailed;

export type F32Result = std::math::vector::F32Result;
export type F64Result = std::math::vector::F64Result;
export type BoolResult = std::math::vector::BoolResult;
export type VectorF32Result = std::math::vector::VectorF32Result;
export type VectorF64Result = std::math::vector::VectorF64Result;
export type MatrixF32Result = std::math::matrix::MatrixF32Result;
export type MatrixF64Result = std::math::matrix::MatrixF64Result;
```

`std::math::vector` (initial subset):

```silk
module std::math::vector;

import std::result;
import std::vector;

export enum MathErrorKind {
  InvalidInput,
  ShapeMismatch,
  OutOfMemory,
}

export error MathFailed {
  kind: MathErrorKind,
}

export struct Vec2f { x: f32, y: f32 }
export struct Vec3f { x: f32, y: f32, z: f32 }
export struct Vec4f { x: f32, y: f32, z: f32, w: f32 }

export struct Vec2d { x: f64, y: f64 }
export struct Vec3d { x: f64, y: f64, z: f64 }
export struct Vec4d { x: f64, y: f64, z: f64, w: f64 }

impl Vec2f {
  public fn add (self: &Vec2f, rhs: Vec2f) -> Vec2f;
  public fn sub (self: &Vec2f, rhs: Vec2f) -> Vec2f;
  public fn scale (self: &Vec2f, s: f32) -> Vec2f;
  public fn dot (self: &Vec2f, rhs: Vec2f) -> f32;
  public fn hadamard (self: &Vec2f, rhs: Vec2f) -> Vec2f;
  public fn length_squared (self: &Vec2f) -> f32;
  public fn distance_squared (self: &Vec2f, rhs: Vec2f) -> f32;
  public fn lerp (self: &Vec2f, rhs: Vec2f, t: f32) -> Vec2f;
}

impl Vec3f {
  public fn add (self: &Vec3f, rhs: Vec3f) -> Vec3f;
  public fn sub (self: &Vec3f, rhs: Vec3f) -> Vec3f;
  public fn scale (self: &Vec3f, s: f32) -> Vec3f;
  public fn dot (self: &Vec3f, rhs: Vec3f) -> f32;
  public fn cross (self: &Vec3f, rhs: Vec3f) -> Vec3f;
  public fn hadamard (self: &Vec3f, rhs: Vec3f) -> Vec3f;
  public fn length_squared (self: &Vec3f) -> f32;
  public fn distance_squared (self: &Vec3f, rhs: Vec3f) -> f32;
  public fn lerp (self: &Vec3f, rhs: Vec3f, t: f32) -> Vec3f;
}

impl Vec4f {
  public fn add (self: &Vec4f, rhs: Vec4f) -> Vec4f;
  public fn sub (self: &Vec4f, rhs: Vec4f) -> Vec4f;
  public fn scale (self: &Vec4f, s: f32) -> Vec4f;
  public fn dot (self: &Vec4f, rhs: Vec4f) -> f32;
  public fn hadamard (self: &Vec4f, rhs: Vec4f) -> Vec4f;
  public fn length_squared (self: &Vec4f) -> f32;
  public fn distance_squared (self: &Vec4f, rhs: Vec4f) -> f32;
  public fn lerp (self: &Vec4f, rhs: Vec4f, t: f32) -> Vec4f;
}

impl Vec2d {
  public fn add (self: &Vec2d, rhs: Vec2d) -> Vec2d;
  public fn sub (self: &Vec2d, rhs: Vec2d) -> Vec2d;
  public fn scale (self: &Vec2d, s: f64) -> Vec2d;
  public fn dot (self: &Vec2d, rhs: Vec2d) -> f64;
  public fn hadamard (self: &Vec2d, rhs: Vec2d) -> Vec2d;
  public fn length_squared (self: &Vec2d) -> f64;
  public fn distance_squared (self: &Vec2d, rhs: Vec2d) -> f64;
  public fn lerp (self: &Vec2d, rhs: Vec2d, t: f64) -> Vec2d;
}

impl Vec3d {
  public fn add (self: &Vec3d, rhs: Vec3d) -> Vec3d;
  public fn sub (self: &Vec3d, rhs: Vec3d) -> Vec3d;
  public fn scale (self: &Vec3d, s: f64) -> Vec3d;
  public fn dot (self: &Vec3d, rhs: Vec3d) -> f64;
  public fn cross (self: &Vec3d, rhs: Vec3d) -> Vec3d;
  public fn hadamard (self: &Vec3d, rhs: Vec3d) -> Vec3d;
  public fn length_squared (self: &Vec3d) -> f64;
  public fn distance_squared (self: &Vec3d, rhs: Vec3d) -> f64;
  public fn lerp (self: &Vec3d, rhs: Vec3d, t: f64) -> Vec3d;
}

impl Vec4d {
  public fn add (self: &Vec4d, rhs: Vec4d) -> Vec4d;
  public fn sub (self: &Vec4d, rhs: Vec4d) -> Vec4d;
  public fn scale (self: &Vec4d, s: f64) -> Vec4d;
  public fn dot (self: &Vec4d, rhs: Vec4d) -> f64;
  public fn hadamard (self: &Vec4d, rhs: Vec4d) -> Vec4d;
  public fn length_squared (self: &Vec4d) -> f64;
  public fn distance_squared (self: &Vec4d, rhs: Vec4d) -> f64;
  public fn lerp (self: &Vec4d, rhs: Vec4d, t: f64) -> Vec4d;
}

// Dynamic-dimension vector (owning).
export struct VectorF32 {
  data: std::vector::Vector(f32),
}

export struct VectorF64 {
  data: std::vector::Vector(f64),
}

export type VectorF32Result = std::result::Result(VectorF32, MathFailed);
export type F32Result = std::result::Result(f32, MathFailed);
export type VectorF64Result = std::result::Result(VectorF64, MathFailed);
export type F64Result = std::result::Result(f64, MathFailed);
export type BoolResult = std::result::Result(bool, MathFailed);

impl VectorF32 {
  public fn empty () -> VectorF32;
  public fn init (len: i64) -> VectorF32Result;
  public fn len (self: &VectorF32) -> i64;
  public fn as_slice (self: &VectorF32) -> std::arrays::Slice(f32);
  public fn get (self: &VectorF32, index: i64) -> f32;
  public fn set (mut self: &VectorF32, index: i64, value: f32) -> void;
  public fn fill (mut self: &VectorF32, value: f32) -> void;

  public fn add (self: &VectorF32, rhs: &VectorF32) -> VectorF32Result;
  public fn sub (self: &VectorF32, rhs: &VectorF32) -> VectorF32Result;
  public fn add_in_place (mut self: &VectorF32, rhs: &VectorF32) -> BoolResult;
  public fn sub_in_place (mut self: &VectorF32, rhs: &VectorF32) -> BoolResult;
  public fn scale (self: &VectorF32, s: f32) -> VectorF32Result;
  public fn scale_in_place (mut self: &VectorF32, s: f32) -> void;
  public fn dot (self: &VectorF32, rhs: &VectorF32) -> F32Result;
}

impl VectorF64 {
  public fn empty () -> VectorF64;
  public fn init (len: i64) -> VectorF64Result;
  public fn len (self: &VectorF64) -> i64;
  public fn as_slice (self: &VectorF64) -> std::arrays::Slice(f64);
  public fn get (self: &VectorF64, index: i64) -> f64;
  public fn set (mut self: &VectorF64, index: i64, value: f64) -> void;
  public fn fill (mut self: &VectorF64, value: f64) -> void;

  public fn add (self: &VectorF64, rhs: &VectorF64) -> VectorF64Result;
  public fn sub (self: &VectorF64, rhs: &VectorF64) -> VectorF64Result;
  public fn add_in_place (mut self: &VectorF64, rhs: &VectorF64) -> BoolResult;
  public fn sub_in_place (mut self: &VectorF64, rhs: &VectorF64) -> BoolResult;
  public fn scale (self: &VectorF64, s: f64) -> VectorF64Result;
  public fn scale_in_place (mut self: &VectorF64, s: f64) -> void;
  public fn dot (self: &VectorF64, rhs: &VectorF64) -> F64Result;
}
```

`std::math::matrix` (initial subset):

```silk
module std::math::matrix;

import std::result;
import std::vector;
import std::math::vector;

export type MathFailed = std::math::vector::MathFailed;
export type MathErrorKind = std::math::vector::MathErrorKind;
export type F32Result = std::math::vector::F32Result;
export type BoolResult = std::math::vector::BoolResult;
export type VectorF32Result = std::math::vector::VectorF32Result;

export struct Mat2f { m00: f32, m01: f32, m10: f32, m11: f32 }
export struct Mat3f { /* row-major */ }
export struct Mat4f { /* row-major */ }

export struct Mat2d { m00: f64, m01: f64, m10: f64, m11: f64 }
export struct Mat3d { /* row-major */ }
export struct Mat4d { /* row-major */ }

impl Mat2f {
  public fn identity () -> Mat2f;
  public fn mul_vec2 (self: &Mat2f, v: std::math::vector::Vec2f) -> std::math::vector::Vec2f;
  public fn mul_mat2 (self: &Mat2f, rhs: Mat2f) -> Mat2f;
  public fn transpose (self: &Mat2f) -> Mat2f;
}

impl Mat3f {
  public fn identity () -> Mat3f;
  public fn mul_vec3 (self: &Mat3f, v: std::math::vector::Vec3f) -> std::math::vector::Vec3f;
  public fn mul_mat3 (self: &Mat3f, rhs: Mat3f) -> Mat3f;
  public fn transpose (self: &Mat3f) -> Mat3f;
}

impl Mat4f {
  public fn identity () -> Mat4f;
  public fn translation (tx: f32, ty: f32, tz: f32) -> Mat4f;
  public fn scale (sx: f32, sy: f32, sz: f32) -> Mat4f;
  public fn mul_vec4 (self: &Mat4f, v: std::math::vector::Vec4f) -> std::math::vector::Vec4f;
  public fn mul_mat4 (self: &Mat4f, rhs: Mat4f) -> Mat4f;
  public fn transpose (self: &Mat4f) -> Mat4f;
}

impl Mat2d {
  public fn identity () -> Mat2d;
  public fn mul_vec2 (self: &Mat2d, v: std::math::vector::Vec2d) -> std::math::vector::Vec2d;
  public fn mul_mat2 (self: &Mat2d, rhs: Mat2d) -> Mat2d;
  public fn transpose (self: &Mat2d) -> Mat2d;
}

impl Mat3d {
  public fn identity () -> Mat3d;
  public fn mul_vec3 (self: &Mat3d, v: std::math::vector::Vec3d) -> std::math::vector::Vec3d;
  public fn mul_mat3 (self: &Mat3d, rhs: Mat3d) -> Mat3d;
  public fn transpose (self: &Mat3d) -> Mat3d;
}

impl Mat4d {
  public fn identity () -> Mat4d;
  public fn translation (tx: f64, ty: f64, tz: f64) -> Mat4d;
  public fn scale (sx: f64, sy: f64, sz: f64) -> Mat4d;
  public fn mul_vec4 (self: &Mat4d, v: std::math::vector::Vec4d) -> std::math::vector::Vec4d;
  public fn mul_mat4 (self: &Mat4d, rhs: Mat4d) -> Mat4d;
  public fn transpose (self: &Mat4d) -> Mat4d;
}

// Dynamic-dimension matrix (row-major, owning).
export struct MatrixF32 {
  rows: i64,
  cols: i64,
  data: std::vector::Vector(f32), // length = rows * cols
}

export struct MatrixF64 {
  rows: i64,
  cols: i64,
  data: std::vector::Vector(f64), // length = rows * cols
}

export type MatrixF32Result = std::result::Result(MatrixF32, MathFailed);
export type MatrixF64Result = std::result::Result(MatrixF64, MathFailed);

impl MatrixF32 {
  public fn empty () -> MatrixF32;
  public fn init (rows: i64, cols: i64) -> MatrixF32Result;
  public fn as_slice (self: &MatrixF32) -> std::arrays::Slice(f32);
  public fn fill (mut self: &MatrixF32, value: f32) -> void;
  public fn at (self: &MatrixF32, row: i64, col: i64) -> F32Result;
  public fn set (mut self: &MatrixF32, row: i64, col: i64, value: f32) -> BoolResult;

  public fn add (self: &MatrixF32, rhs: &MatrixF32) -> MatrixF32Result;
  public fn sub (self: &MatrixF32, rhs: &MatrixF32) -> MatrixF32Result;
  public fn scale (self: &MatrixF32, s: f32) -> MatrixF32Result;
  public fn add_in_place (mut self: &MatrixF32, rhs: &MatrixF32) -> BoolResult;
  public fn sub_in_place (mut self: &MatrixF32, rhs: &MatrixF32) -> BoolResult;
  public fn scale_in_place (mut self: &MatrixF32, s: f32) -> void;
  public fn mul (self: &MatrixF32, rhs: &MatrixF32) -> MatrixF32Result; // matmul
  public fn mul_vec (self: &MatrixF32, rhs: &std::math::vector::VectorF32) -> VectorF32Result;
  public fn transpose (self: &MatrixF32) -> MatrixF32Result;
}

impl MatrixF64 {
  public fn empty () -> MatrixF64;
  public fn init (rows: i64, cols: i64) -> MatrixF64Result;
  public fn as_slice (self: &MatrixF64) -> std::arrays::Slice(f64);
  public fn fill (mut self: &MatrixF64, value: f64) -> void;
  public fn at (self: &MatrixF64, row: i64, col: i64) -> F64Result;
  public fn set (mut self: &MatrixF64, row: i64, col: i64, value: f64) -> BoolResult;

  public fn add (self: &MatrixF64, rhs: &MatrixF64) -> MatrixF64Result;
  public fn sub (self: &MatrixF64, rhs: &MatrixF64) -> MatrixF64Result;
  public fn scale (self: &MatrixF64, s: f64) -> MatrixF64Result;
  public fn add_in_place (mut self: &MatrixF64, rhs: &MatrixF64) -> BoolResult;
  public fn sub_in_place (mut self: &MatrixF64, rhs: &MatrixF64) -> BoolResult;
  public fn scale_in_place (mut self: &MatrixF64, s: f64) -> void;
  public fn mul (self: &MatrixF64, rhs: &MatrixF64) -> MatrixF64Result; // matmul
  public fn mul_vec (self: &MatrixF64, rhs: &std::math::vector::VectorF64) -> VectorF64Result;
  public fn transpose (self: &MatrixF64) -> MatrixF64Result;
}
```

## Notes on `f128` / `u128`

`std::math` intends to expose higher precision scalars for numeric work and
tensor integration. The language primitives `i128` / `u128` / `f128` are now
part of the supported native backend subset; `std::math` currently focuses on
`f32` and `f64` surfaces and will add higher-precision variants incrementally
as needed.

==============================================================================
DOCS: `std::memory` (std/memory)
URL: /silk/docs/?p=std/memory
==============================================================================

# `std::memory`

implemented yet.

`std::memory` provides allocation interfaces and low-level memory utilities.
It sits at the bottom of most other std modules.

See also:


## API

A small subset is implemented in `std/memory.slk` for early compiler bring-up.
These helpers are pure and operate on scalar types only, plus a shared
allocation-failure error type used across `std::`.

```silk
module std::memory;

export error OutOfMemory {
  requested: i64
}

enum AllocErrorKind {
  OutOfMemory,
  InvalidInput,
  Overflow,
  Unknown,
}

export error AllocFailed {
  code: int,
  requested: i64,
}

impl AllocFailed {
  public fn kind (self: &AllocFailed) -> AllocErrorKind;
}

export fn alloc_failed (kind: AllocErrorKind, requested: i64) -> AllocFailed;

export fn is_power_of_two_u64 (x: u64) -> bool;
export fn align_up_u64 (value: u64, alignment: u64) -> u64;
export fn align_down_u64 (value: u64, alignment: u64) -> u64;
export fn div_ceil_u64 (n: u64, d: u64) -> u64;
```

Notes:

- `align_*` functions require `alignment` to be a power of two.
- `OutOfMemory` is the shared error type returned by allocation-backed
  containers and builders (for example `std::vector::Vector` and
  `std::strings::StringBuilder`) when capacity growth cannot allocate.
- `AllocFailed` is a small, stable “constructor failed” error used by APIs
  like `BufferU8.init` / `Vector(T).init` where invalid inputs (negative
  capacities, overflow) must be distinguished from out-of-memory.
## Scope

`std::memory` is responsible for:

- Defining allocator interfaces used by other `std::` modules.
- Providing safe wrappers around region allocation and the intrinsic `Buffer(T)` type
  (where possible).
- Providing low-level memory operations (`memcpy`, `memcmp`, zeroing, etc.).
- Defining common allocation error conventions (`OutOfMemory`, etc.).

Non-goals (initially):

- A full garbage collector (explicit allocation is the design baseline).
- Region inference beyond the region model already described in the language
  docs.

## Intrinsics and Their Std Surface

The language defines:


The buffer document enumerates intrinsic operations under the `std::buffer::`
namespace (allocation, read/write, drop, view/slice). The `std::memory` design
assumes those operations exist and that
higher-level containers in `std::arrays` and `std::strings` are layered on top.

## Allocator Interface (Initial Design)

The stdlib needs a first-class allocator abstraction so that:

- containers can be written without hardcoding a global heap,
- freestanding builds can provide their own allocator,
- hosted builds can use an OS-backed allocator.

Illustrative sketch:

```silk
module std::memory;

export enum AllocError {
  OutOfMemory,
}

export interface Allocator {
  // Allocate `n` elements of type `T`.
  alloc: fn(T, n: int) -> Result(Buffer(T), AllocError);
  // Resize an existing allocation.
  realloc: fn(T, buf: Buffer(T), old_n: int, new_n: int) -> Result(Buffer(T), AllocError);
  // Free an allocation.
  free: fn(T, buf: Buffer(T), n: int) -> void;
}
```

The exact interface depends on how generics and interfaces are represented in
the implemented language. The key requirement is that containers can accept an
allocator value and use it consistently.

## Common Utilities

`std::memory` should provide low-level routines that are useful across the
stdlib:

- `copy(dst, src, n)`
- `move(dst, src, n)`
- `set(dst, byte, n)`
- `zero(dst, n)`
- `equal(a, b, n)`

These should have both safe and “unchecked” variants where appropriate, so that
verified code can elide bounds checks while still keeping safety explicit.

==============================================================================
DOCS: `std::net` (std/networking)
URL: /silk/docs/?p=std/networking
==============================================================================

# `std::net`

helper subset plus hosted **IPv4/IPv6 TCP** and **IPv4/IPv6 UDP** socket APIs
are implemented in `std/net.slk`. Async/event-loop integration remains future
work.

`std::net` provides networking primitives on POSIX systems.

See also:


## API

A small, non-socket subset exists in `std/net.slk` for early bring-up:

```silk
module std::net;

export fn bswap_u16 (x: u16) -> u16;
export fn bswap_u32 (x: u32) -> u32;

export fn htons (x: u16) -> u16;
export fn ntohs (x: u16) -> u16;
export fn htonl (x: u32) -> u32;
export fn ntohl (x: u32) -> u32;

struct Ipv4Addr {
  value: int,
}

impl Ipv4Addr {
  public fn from_octets (a: int, b: int, c: int, d: int) -> Ipv4Addr;
  public fn from_u32 (value: int) -> Ipv4Addr;
  public fn value (self: &Ipv4Addr) -> int;
  public fn a (self: &Ipv4Addr) -> int;
  public fn b (self: &Ipv4Addr) -> int;
  public fn c (self: &Ipv4Addr) -> int;
  public fn d (self: &Ipv4Addr) -> int;
  public fn is_loopback (self: &Ipv4Addr) -> bool;
}

// Compatibility wrappers (free functions).
export fn ipv4 (a: int, b: int, c: int, d: int) -> Ipv4Addr;
export fn ipv4_from_u32 (value: int) -> Ipv4Addr;

export fn ipv4_value (addr: Ipv4Addr) -> int;
export fn ipv4_a (addr: Ipv4Addr) -> int;
export fn ipv4_b (addr: Ipv4Addr) -> int;
export fn ipv4_c (addr: Ipv4Addr) -> int;
export fn ipv4_d (addr: Ipv4Addr) -> int;
export fn ipv4_is_loopback (addr: Ipv4Addr) -> bool;
```

Notes:

- This is currently implemented as a byte-swap for the `linux/x86_64`
  little-endian hosted baseline.

## Hosted TCP API

`std::net` exposes a small TCP API for hosted targets via the
pluggable runtime interface `std::runtime::net`:

```silk
module std::net;

enum NetErrorKind {
  BadFileDescriptor,
  PermissionDenied,
  WouldBlock,
  Interrupted,
  ConnectionRefused,
  TimedOut,
  AddressInUse,
  AddressNotAvailable,
  NetworkUnreachable,
  HostUnreachable,
  NotConnected,
  BrokenPipe,
  InvalidInput,
  OutOfMemory,
  Unknown,
}

error NetFailed { code: int, requested: i64 }

export type NetIntResult = std::result::Result(int, NetFailed);

struct SocketAddrV4 {
  ip_value: int,
  port: int,
}

impl SocketAddrV4 {
  public fn from_ipv4_value (ip_value: int, port: int) -> SocketAddrV4;
  public fn from_octets (a: int, b: int, c: int, d: int, port: int) -> SocketAddrV4;
  public fn loopback (port: int) -> SocketAddrV4;
  public fn ip (self: &SocketAddrV4) -> Ipv4Addr;
  public fn port (self: &SocketAddrV4) -> int;
}

struct Ipv6Addr {
  hi: u64,
  lo: u64,
}

impl Ipv6Addr {
  public fn from_u64s (hi: u64, lo: u64) -> Ipv6Addr;
  public fn from_segments (s0: u16, s1: u16, s2: u16, s3: u16, s4: u16, s5: u16, s6: u16, s7: u16) -> Ipv6Addr;
  public fn hi (self: &Ipv6Addr) -> u64;
  public fn lo (self: &Ipv6Addr) -> u64;
  public fn is_loopback (self: &Ipv6Addr) -> bool;
  public fn is_unspecified (self: &Ipv6Addr) -> bool;
}

struct SocketAddrV6 {
  ip_hi: u64,
  ip_lo: u64,
  port: int,
  scope_id: int,
}

impl SocketAddrV6 {
  public fn from_ipv6_u64s (ip_hi: u64, ip_lo: u64, port: int, scope_id: int) -> SocketAddrV6;
  public fn from_ipv6 (ip: Ipv6Addr, port: int, scope_id: int) -> SocketAddrV6;
  public fn loopback (port: int) -> SocketAddrV6;
  public fn ip (self: &SocketAddrV6) -> Ipv6Addr;
  public fn port (self: &SocketAddrV6) -> int;
  public fn scope_id (self: &SocketAddrV6) -> int;
}

struct TcpStream {
  fd: int,
}

export type TcpStreamResult = std::result::Result(TcpStream, NetFailed);

impl TcpStream {
  public fn invalid () -> TcpStream;
  public fn is_valid (self: &TcpStream) -> bool;
  public fn connect (addr: SocketAddrV4) -> TcpStreamResult;
  public fn connect_v6 (addr: SocketAddrV6) -> TcpStreamResult;
  public fn close (mut self: &TcpStream) -> NetFailed?;
  public fn read (self: &TcpStream, buf: std::arrays::ByteSlice) -> NetIntResult;
  public fn write (self: &TcpStream, buf: std::arrays::ByteSlice) -> NetIntResult;
  public fn write_all (self: &TcpStream, buf: std::arrays::ByteSlice) -> NetFailed?;
  public fn write_string (self: &TcpStream, s: string) -> NetFailed?;
  public fn shutdown_read (self: &TcpStream) -> NetFailed?;
  public fn shutdown_write (self: &TcpStream) -> NetFailed?;
  public fn shutdown (self: &TcpStream) -> NetFailed?;
}

struct TcpListener {
  fd: int,
}

export type TcpListenerResult = std::result::Result(TcpListener, NetFailed);

impl TcpListener {
  public fn invalid () -> TcpListener;
  public fn is_valid (self: &TcpListener) -> bool;
  public fn listen (addr: SocketAddrV4, backlog: int) -> TcpListenerResult;
  public fn listen_v6 (addr: SocketAddrV6, backlog: int) -> TcpListenerResult;
  public fn accept (self: &TcpListener) -> TcpStreamResult;
  public fn local_port (self: &TcpListener) -> NetIntResult;
  public fn local_port_v6 (self: &TcpListener) -> NetIntResult;
  public fn close (mut self: &TcpListener) -> NetFailed?;
}
```

Notes:

- This API is currently **blocking** (no non-blocking sockets/event loop yet).
- The current implementation targets hosted `linux/x86_64` via `std::runtime::net`
  (POSIX sockets); `wasm32-wasi` has no Preview 1 sockets, so the runtime
  stubs return error values.
- `TcpStream`/`TcpListener` wrap raw file descriptors; avoid copying these
  values until the language has move-only handle types.
- If you want to discard error details, prefer `match (r)` when the `Result`
  payload may implement `Drop` (for example `TcpStream` / `TcpListener`), since
  `ResultType.ok_value(r)` copies the `Result` payload in Silk.

## Hosted UDP API

`std::net` also exposes a small UDP API for hosted targets. The API is
datagram-oriented but remains blocking.

```silk
module std::net;

struct UdpSocket {
  fd: int,
  domain: int,
}

export type NetError = NetFailed;
export type UdpSocketResult = std::result::Result(UdpSocket, NetFailed);

struct UdpRecvFrom {
  n: int,
  addr: SocketAddr,
}

export type UdpRecvFromResult = std::result::Result(UdpRecvFrom, NetError);

struct SocketAddr {
  domain: int,
  ip_value: int,
  ip_hi: u64,
  ip_lo: u64,
  port: int,
  scope_id: int,
}

impl SocketAddr {
  public fn from_v4 (addr: SocketAddrV4) -> SocketAddr;
  public fn from_v6 (addr: SocketAddrV6) -> SocketAddr;
  public fn is_v4 (self: &SocketAddr) -> bool;
  public fn is_v6 (self: &SocketAddr) -> bool;
  public fn v4 (self: &SocketAddr) -> SocketAddrV4?;
  public fn v6 (self: &SocketAddr) -> SocketAddrV6?;
  public fn port (self: &SocketAddr) -> int;
}

impl UdpSocket {
  public fn invalid () -> UdpSocket;
  public fn is_valid (self: &UdpSocket) -> bool;

  public fn bind_v4 (addr: SocketAddrV4) -> UdpSocketResult;
  public fn bind_v6 (addr: SocketAddrV6) -> UdpSocketResult;

  public fn connect_v4 (addr: SocketAddrV4) -> UdpSocketResult;
  public fn connect_v6 (addr: SocketAddrV6) -> UdpSocketResult;

  public fn local_port (self: &UdpSocket) -> NetIntResult;
  public fn close (mut self: &UdpSocket) -> NetFailed?;

  // Connected I/O (uses `read(2)` / `write(2)`).
  public fn read (self: &UdpSocket, buf: std::arrays::ByteSlice) -> NetIntResult;
  public fn write (self: &UdpSocket, buf: std::arrays::ByteSlice) -> NetIntResult;

  // Unconnected datagrams.
  public fn send_to (self: &UdpSocket, addr: SocketAddr, buf: std::arrays::ByteSlice) -> NetIntResult;
  public fn recv_from (self: &UdpSocket, buf: std::arrays::ByteSlice) -> UdpRecvFromResult;
}
```

Notes:

- `send_to` / `recv_from` require the socket domain to match `addr.domain`
  (`AF_INET` for IPv4, `AF_INET6` for IPv6).

## Scope

`std::net` is responsible for:

- Sockets and basic protocols.
- Integration with concurrency primitives (`async`, `task`).

## Core Types (Initial Design)

- `IpAddr` (`V4` / `V6`) and `SocketAddr`.
- `TcpStream`, `TcpListener`, `UdpSocket`.

Illustrative sketch:

```silk
module std::net;

export enum NetError {
  ConnectionRefused,
  TimedOut,
  AddressInUse,
  NetworkUnreachable,
  WouldBlock,
  Unknown,
}

export fn tcp_connect (addr: SocketAddr) -> Result(TcpStream, NetError);
export fn tcp_listen (addr: SocketAddr) -> Result(TcpListener, NetError);
```

## Blocking vs Async

The initial hosted baseline may be blocking I/O. Once the language’s async
model is implemented, `std::net` should provide:

- non-blocking sockets + integration with an event loop,
- `async fn` wrappers for common operations,
- integration with task offloading for blocking adapters (design target:
  `std::task::run_blocking()`; until that exists, users can explicitly use a
  `task fn` wrapper around blocking calls).

## Future Work

- DNS resolution, TLS integration (as optional packages).

==============================================================================
DOCS: `std::number` (std/number)
URL: /silk/docs/?p=std/number
==============================================================================

# `std::number`


This module provides small, dependency-light number parsing and formatting
helpers.

The initial surface focuses on:

- stable, strict parsing from `string` to numeric types, and
- formatting numeric values into owned `std::strings::String` outputs.

## API

### Parsing

Parsing functions return `Result(T, ParseFailed)` for explicit error handling.

```silk
module std::number;

export enum ParseErrorKind {
  InvalidInput,
  Overflow,
  OutOfMemory,
  Unknown,
}

export error ParseFailed {
  code: int,
  offset: int,
}

export type AtodResult = std::result::Result(f64, ParseFailed);
export type Atou64Result = std::result::Result(u64, ParseFailed);
export type Atoi64Result = std::result::Result(i64, ParseFailed);
export type Atou32Result = std::result::Result(u32, ParseFailed);
export type Atoi32Result = std::result::Result(i32, ParseFailed);
export type Atou128Result = std::result::Result(u128, ParseFailed);
export type Atoi128Result = std::result::Result(i128, ParseFailed);

export fn atod (s: string) -> AtodResult;
export fn atou64 (s: string) -> Atou64Result;
export fn atoi64 (s: string) -> Atoi64Result;
export fn atou32 (s: string) -> Atou32Result;
export fn atoi32 (s: string) -> Atoi32Result;
export fn atou128 (s: string) -> Atou128Result;
export fn atoi128 (s: string) -> Atoi128Result;
```

Notes:

- `atou*` parses base-10 unsigned integers; `atoi*` parses base-10 signed
  integers with an optional leading `+`/`-`.
- The integer parsers accept `_` as a digit separator between
  digits (for example `1_000_000`).
- `atod` is strict: the entire input must be consumed (no trailing bytes).
- `ParseFailed.offset` is a byte offset into the original input.
- `atod` may report `OutOfMemory` if the runtime needs temporary storage.

### Formatting

Formatting functions allocate and return owned `std::strings::String` values.

```silk
export fn dtoa (value: f64) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);

export fn u64toa (value: u64) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);
export fn i64toa (value: i64) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);
export fn u32toa (value: u32) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);
export fn i32toa (value: i32) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);

export fn u128toa (value: u128) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);
export fn i128toa (value: i128) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);
```

## Related Documents

==============================================================================
DOCS: `std::path` (std/path)
URL: /silk/docs/?p=std/path
==============================================================================

# `std::path`


`std::path` provides path manipulation utilities.

Design goals (modeled after Rust `std::path` and Node.js `path`):

- **Borrowed vs owned**: `string` values are non-owning views; `std::path::PathBuf`
  is an owned, growable path buffer for building paths incrementally.
- **POSIX-first**: the initial shipped implementation uses `/` as the separator
  and does not implement Windows drive/UNC path rules yet.
- **Allocation-aware**: functions that produce new paths return owned
  `std::strings::String` values (callers must drop them).

## API

```silk
module std::path;

import std::strings;

export let SEP: string = "/";
export let DELIMITER: string = ":";

// Owned path buffer (like Rust `PathBuf`).
struct PathBuf {
  ptr: u64,
  cap: i64,
  len: i64,
}

impl PathBuf {
  public fn empty () -> std::result::Result(PathBuf, std::memory::OutOfMemory);
  public fn from_string (s: string) -> std::result::Result(PathBuf, std::memory::OutOfMemory);
  public fn as_string (self: &PathBuf) -> string;
  public fn clear (mut self: &PathBuf) -> void;
  public fn push (mut self: &PathBuf, part: string) -> std::memory::OutOfMemory?;
  public fn pop (mut self: &PathBuf) -> bool;
}

// Inspection.
export fn is_absolute (path: string) -> bool;

// Building and normalization.
export fn join (a: string, b: string) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);
export fn normalize (path: string) -> std::result::Result(std::strings::String, std::memory::OutOfMemory);

// Inspection helpers (views into the input string).
export fn dirname (path: string) -> string;
export fn basename (path: string) -> string;
export fn extname (path: string) -> string;
export fn stem (path: string) -> string;
```

Notes:

- On POSIX, the root path `"/"` has no basename, so `basename("/") == ""`.

## Separator and delimiter

- `SEP` is the path component separator. On POSIX it is `"/"`.
- `DELIMITER` is the environment-variable path list delimiter. On POSIX it is
  `":"` (for example `PATH=/bin:/usr/bin`).

## Ownership and allocation

Functions that return `std::strings::String` allocate an owned buffer.

Callers must drop returned owned strings when finished:

```silk
import std::path;
import std::strings;

fn main () -> int {
  match std::path::join("/tmp", "file.txt") {
    mut p => {
      // ...
      (mut p).drop();
      return 0;
    },
    err: std::memory::OutOfMemory => { return 1; }
  }
}
```

## `normalize`

`std::path::normalize(path)` rewrites a path into a canonical form for the
hosted POSIX subset:

- collapses repeated `/` separators,
- removes `.` components,
- resolves `..` components when possible,
- removes trailing `/` separators (except for the root path),
- preserves a leading `/` for absolute paths,
- returns `"."` for empty relative results and `"/"` for empty absolute results.

Notes:

- This is a lexical normalization. It does not access the filesystem and does
  not resolve symlinks.

## Platform notes

- **POSIX (default shipped stdlib)**: `/` separator and `:` delimiter.
- **Windows**: not implemented yet (drive letters, UNC paths, `\` separators).

## `join` note

`std::path::join(a, b)` follows Rust `Path::join` semantics:

- when `b` is absolute, the result is `normalize(b)` (the base `a` is discarded).

==============================================================================
DOCS: `std::process` (std/process)
URL: /silk/docs/?p=std/process
==============================================================================

# `std::process`


`std::process` provides access to process-level operations that are not tied to
environment variables, such as the current working directory.

The current implementation targets a hosted POSIX baseline (Linux/glibc) and is
implemented on top of the pluggable `std::runtime::process` interface. WASI
support is partially implemented (see “Platform notes”).

## API

```silk
module std::process;

  import std::result;
  import std::strings;

  enum ChdirErrorKind { InvalidInput, NotFound, NotADirectory, PermissionDenied, Unknown }
  error ChdirFailed { code: int }

  enum GetCwdErrorKind { OutOfMemory, NotFound, PermissionDenied, Unknown }
  error GetCwdFailed { code: int, requested: i64 }

export type GetCwdError = GetCwdFailed;
export type GetCwdResult = std::result::Result(std::strings::String, GetCwdError);

export fn chdir (path: string) -> ChdirFailed?;
export fn getcwd () -> GetCwdResult;
```

## Child processes (`std::process::child`)

`std::process::child` provides hosted child-process execution (spawn/wait/kill)
and high-level output capture.

For convenience, `std::process` re-exports the high-level `std::process::child`
surface so downstream users can write:

```silk
import std::process;

let mut cmd = std::process::Command.init("/bin/echo");
cmd.arg("hello");
let out_r = cmd.output();
```

See the `std::process::child` source (`std/process/child.slk`) for the exact,
current API surface.

## `getcwd`

`std::process::getcwd()` returns the current working directory as an owned
`std::strings::String`.

Ownership:

- Callers must drop the returned `String` when finished.

Errors are reported as a recoverable result:

- `getcwd` has signature `-> GetCwdResult`,
- on success: `value = Some(String)`, `err = None`,
- on failure: `value = None`, `err = Some(GetCwdFailed{ code, requested })` (use `GetCwdFailed.kind()` to distinguish failure kinds).

`GetCwdFailed` does not expose platform `errno` values. Use `GetCwdFailed.kind()`
to classify failures into `GetCwdErrorKind` values.

## `chdir`

`std::process::chdir(path)` changes the process working directory.

Errors are reported as an optional error value:

- `chdir` has signature `-> ChdirFailed?`,
- it returns `None` on success,
- it returns `Some(ChdirFailed{ code })` when the underlying runtime operation fails.

`ChdirFailed` does not expose platform `errno` values. Use `ChdirFailed.kind()`
to classify failures into `ChdirErrorKind` values.

Notes:

- `chdir` does not update environment variables like `PWD`. Use
  `std::process::getcwd()` to query the real current directory.

## Platform notes

- **POSIX (default shipped stdlib)**: implemented via `getcwd(3)` and
  `chdir(2)`.
- **Child processes (POSIX)**: implemented via `fork(2)` + `exec*` + `waitpid(2)`
  with pipe-based stdio and poll-based output capture.
- **WASI (Preview 1)**: `getcwd` and `chdir` are implemented via a virtual
  working directory. `std::process::child` operations remain unsupported.

==============================================================================
DOCS: `std::readline` (std/readline)
URL: /silk/docs/?p=std/readline
==============================================================================

# `std::readline`


`std::readline` provides a small, ergonomic readline-style API for reading a
single line of user input with interactive editing and history when stdin is
connected to a TTY.

The shipped implementation is based on the bundled `linenoise` sources under
`src/linenoise.{c,h}` and is exposed through the bundled runtime support
archive (`libsilk_rt`).

## Overview

Typical use:

```silk
import std::readline;

export fn main () -> int {
  let r = readline.read_line("> ");
  match (r) {
    Ok(line_opt) => match (line_opt) {
      Some(line) => {
        // ...
        (mut line).drop();
        return 0;
      },
      None => return 0, // EOF
    },
    Err(_) => {
      // Ctrl-C or other failures.
      return 1;
    },
  }
}
```

## API

### Reading

- `read_line(prompt: string = "", add_history: bool = true) -> Result(String?, ReadLineFailed)`
  - `Ok(Some(line))` on success,
  - `Ok(None)` on EOF,
  - `Err(ReadLineFailed)` on failure.

### Mode flags

- `set_multiline(enabled: bool) -> void` — enable multi-line editing.
- `set_mask_mode(enabled: bool) -> void` — enable password masking (`***`).
- `clear_screen() -> void` — clear the terminal screen.
- `print_key_codes() -> void` — print key codes for debugging.

### History

- `history_add(line: string) -> bool` — returns false when the line is not
  added (duplicates, history disabled, or internal allocation failure).
- `history_set_max_len(max_len: int) -> bool` — set the max retained entries.
- `history_load(path: string) -> Result(bool, ReadLineFailed)`
  - `Ok(true)` when loaded,
  - `Ok(false)` when the file does not exist,
  - `Err(ReadLineFailed)` on other failures.
- `history_save(path: string) -> ReadLineFailed?` — `None` on success.

### Errors

`ReadLineFailed` uses stable `std::io`-style error codes. Use
`ReadLineFailed.kind()` to classify common cases:

- `Interrupted` — returned for Ctrl-C.
- `OutOfMemory` — allocation failure (including `--noheap` builds with no
  installed runtime allocator).
- `InvalidInput` — invalid path/prompt lengths or internal overflow guards.
- `Unknown` — other failures.

## Semantics

- TTY vs. non-TTY:
  - when stdin is a TTY, input is edited interactively (arrow keys, history),
  - when stdin is not a TTY (piped input), the implementation reads a line from
    stdin without interactive editing; prompts are not displayed in this mode.
- EOF:
  - `Ok(None)` is returned on end-of-input (Ctrl-D on an empty line in TTY mode,
    or EOF on stdin in non-TTY mode).
- Ownership:
  - `read_line` returns an owned `std::strings::String`. Drop it when finished.

## Keybindings (TTY mode)

Keybindings are implemented by the bundled `linenoise` line editor. Exact
behavior depends on the terminal, but common bindings include:

- Left/Right arrows — move by one character (UTF-8 aware).
- Up/Down arrows — navigate history.
- Home/End — move to start/end of line.
- Backspace/Delete — delete characters.
- Ctrl+W — delete previous word (space-delimited).
- Ctrl+Left / Ctrl+Right — move by word (identifier/punctuation runs).
- Alt+Left / Alt+Right — move by word (when the terminal sends xterm-style CSI
  modifier sequences).
- Alt+B / Alt+F — move by word (Meta key sequences: `ESC b` / `ESC f`).

## Implementation Notes

- Internal `linenoise` heap usage is routed through the `silk_rt_malloc_bytes`
  allocator surface so embedders can override allocations via
  `silk_rt_set_allocator` (`include/silk_rt.h`).
- The returned line is copied into an owned allocation compatible with
  `std::runtime::mem::free` / `std::strings::String.drop()` (payload pointer
  includes the standard 8-byte header used by the hosted runtime).

## Limitations

- `linenoise` completion/hints callbacks are not exposed yet (they require a
  stable callback/FFI story for passing function pointers between Silk and C).
- The non-blocking `linenoiseEdit*` API is not exposed yet.

==============================================================================
DOCS: `std::regex` (std/regex)
URL: /silk/docs/?p=std/regex
==============================================================================

# `std::regex`


This module provides regular expression helpers built on top of:

- the `regexp` primitive (compiled regex bytecode view), and
- a boxed/owned `RegExp` type for runtime-compiled patterns.

Regex literals are part of the language surface:

- `/pattern/flags` produces a `regexp` value, compiled at compile time (see

## API

The initial `std::regex` surface is intentionally small and focuses on:

- basic matching (`matches`, `exec`, `match_first`),
- searching and iteration (`search`, `iter`),
- runtime compilation (`RegExp.compile(...)`),
- explicit ownership via the `RegExp` boxed type.

```silk
module std::regex;

export const EXEC_MATCH: int = 1;
export const EXEC_NO_MATCH: int = 0;
export const EXEC_ERR_MEMORY: int = -1;
export const EXEC_ERR_TIMEOUT: int = -2;
export const EXEC_ERR_INVALID_INPUT: int = -3;

export struct ExecResult {
  // Use `std::regex::EXEC_*` constants.
  code: int,
  start: int,
  end: int,
}

export fn exec (re: regexp, input: string) -> ExecResult;
export fn matches (re: regexp, input: string) -> bool;
export fn is_match (re: regexp, input: string) -> bool; // compatibility alias
export fn search (re: regexp, input: string, start: int) -> ExecResult;
export fn match_first (re: regexp, input: string) -> string?;

export struct MatchIter {
  re: regexp,
  input: string,
  input_len: i64,
  offset: int,
  done: bool,
}

export fn iter (re: regexp, input: string) -> MatchIter;

export error CompileFailed {
  code: int,
}

export struct RegExp {
  // Owned compiled bytecode.
  value: regexp,
}

impl RegExp {
  public fn empty () -> RegExp;
  public fn compile (pattern: string, flags: string) -> std::result::Result(RegExp, CompileFailed);
  public fn as_regexp (self: &RegExp) -> regexp;
}

impl RegExp as std::interfaces::Drop {
  public fn drop (mut self: &RegExp) -> void;
}
```

Notes:

- The `regexp` primitive is a non-owning `{ ptr, len }` view; regex literals
  embed compiled bytecode in rodata, and `RegExp` owns heap-allocated bytecode.
- `ExecResult.start` / `end` are byte offsets into the input `string`.
- `ExecResult` implements `std::interfaces::Len` (`len() -> i64`), returning the
  matched byte length (`end - start`) when `code == EXEC_MATCH` and `0` otherwise.
- `test` and `match` are reserved keywords in Silk; this module uses
  `matches` and `match_first` instead.
- `MatchIter` provides `next() -> ExecResult?` and can be consumed with
  `for m in std::regex::iter(re, input) { ... }`.
  - matches are yielded as `ExecResult` values with `code == EXEC_MATCH`,
  - a runtime error (`code < 0`) is yielded once and then the iterator ends,
  - empty matches advance by 1 byte to guarantee progress.

## Related Documents

==============================================================================
DOCS: `std::result` (std/result)
URL: /silk/docs/?p=std/result
==============================================================================

# `std::result`


`std::result` standardizes the common “success or error” return shape so that
APIs across `std::` compose cleanly.

## `Result(T, E)`

`Result(T, E)` models a recoverable “success or error” outcome.

### Representation

`Result(T, E)` is a tagged union:

```silk
enum Result(T, E) {
  Ok(T),
  Err(E),
}
```

### Core API

```silk
module std::result;

enum Result(T, E) {
  Ok(T),
  Err(E),
}

impl Result(T, E) {
  public fn ok (value: T) -> Result(T, E);
  public fn err (err: E) -> Result(T, E);

  public fn is_ok (self: &Result(T, E)) -> bool;
  public fn is_err (self: &Result(T, E)) -> bool;

  public fn unwrap_or (value: Result(T, E), fallback: T) -> T;

  public fn ok_value (value: Result(T, E)) -> T?;
  public fn unwrap (value: Result(T, E)) -> T?;
  public fn err_value (value: Result(T, E)) -> E?;
}
```

Notes:

- `Result` does not provide aborting unwrap helpers; use `unwrap()` /
  `ok_value()` / `err_value()` (or a `match`) to recover the payload.
- `unwrap()` is a non-aborting alias of `ok_value()` and returns `T?`.
- `is_ok()` / `is_err()` borrow the `Result` and are safe for all payload types.
- `unwrap_or()` / `ok_value()` / `unwrap()` / `err_value()` currently take the
  `Result` by value as a current workaround (the language does not yet
  support by-value receivers for instance methods). This copies the active
  payload and is only safe when the active payload does not implement `Drop`.
  For `Result` values that may hold `Drop` payloads (for example `String`,
  `BufferU8`, `TcpStream`), prefer `match (r)` to extract values safely.
- Callback-based combinators (for example `map` / `and_then`) are deferred until
  the IR backend supports non-scalar function-typed parameters and results.
- `match` supports a shorthand for `Result` destructuring:
  - when the scrutinee type is `Result(T, E)`, patterns `Ok(v)` / `Err(e)` are
    accepted as shorthand for `R::Ok(v)` / `R::Err(e)` where `R` is the scrutinee
    enum type.
- Callers typically introduce a local alias for the instantiated enum so the
  alias name can be used as a qualifier for constructors and patterns when a
  type context is not available:

```silk
import std::result;

type R = std::result::Result(int, string);

fn main () -> int {
  let x: R = R.ok(123);
  if x.is_err() { return 1; }
  if R.unwrap_or(x, 0) != 123 { return 2; }
  return 0;
}
```

In type-directed contexts, `Ok(...)` / `Err(...)` can be used without a
qualifier. For example:

```silk
import std::result;

error Oops {
  code: int
}

fn foo (oops: bool) -> std::result::Result(int, Oops) {
  if (oops) {
    return Err(Oops{ code: 123 });
  }
  return Ok(0);
}
```

==============================================================================
DOCS: `std::runtime` (std/runtime)
URL: /silk/docs/?p=std/runtime
==============================================================================

# `std::runtime`


`std::runtime` defines a *runtime interface layer* that sits underneath the
rest of the standard library.

The goal is to make OS- and environment-specific primitives **pluggable** while
keeping the public `std::...` APIs stable. The default `std` shipped with the
compiler targets a hosted POSIX baseline, but other environments (Windows,
non-POSIX, embedded, sandboxed runtimes) should be able to provide their own
runtime implementation by supplying an alternate stdlib root with compatible
`std::runtime::...` modules.

## Motivation

- `std::fs`, `std::task`, `std::sync`, and other OS-facing std modules need
  low-level primitives (files, clocks, threads, syscalls).
- Those primitives differ significantly across platforms.
- Keeping these differences confined to `std::runtime::...` avoids scattering
  `ext` and platform `#if` style logic across the entire stdlib.

## Structure

The std runtime is organized as:

- `std::runtime::<area>` — a stable interface module used by the rest of std.
- `std::runtime::posix::<area>` — the default POSIX-backed implementation used
  by the compiler’s shipped stdlib on hosted targets.

Example:

- `std::runtime::fs` is the interface used by `std::fs`.
- `std::runtime::posix::fs` provides the POSIX implementation using `ext` calls
  like `open(2)`, `read(2)`, and `close(2)`.

In the shipped stdlib today:

- `std::runtime::mem` delegates to `std::runtime::posix::mem`,
- `std::runtime::fs` delegates to `std::runtime::posix::fs` (hosted baseline;
  on `wasm32-wasi` the compiler rewrites this to `std::runtime::wasi::fs`,
  which implements a filesystem subset using WASI Preview 1 preopened
  directories and resolves relative paths against a virtual cwd),
- `std::runtime::io` delegates to `std::runtime::posix::io` (hosted baseline;
  on `wasm32-wasi` the compiler rewrites this to `std::runtime::wasi::io`,
  which implements stdio primitives and maintains a POSIX-shaped `errno` cell
  for higher-level wrappers like `std::runtime::process`),
- `std::runtime::task` delegates to `std::runtime::posix::task`,
- `std::runtime::sync` delegates to `std::runtime::posix::sync`,
- `std::runtime::time` delegates to `std::runtime::posix::time`,
- `std::runtime::env` delegates to `std::runtime::posix::env`,
- `std::runtime::process` delegates to `std::runtime::posix::process` (hosted baseline;
  on `wasm32-wasi` the compiler rewrites this to `std::runtime::wasi::process`,
  which implements `_exit` via WASI `proc_exit` and `chdir`/`getcwd` via a
  virtual cwd layer),
- `std::runtime::net` delegates to `std::runtime::posix::net` (hosted sockets),
- `std::runtime::regex` is implemented via bundled runtime support (`libsilk_rt`) and is used by `std::regex`,
- `std::runtime::unicode` is implemented via bundled runtime support (`libsilk_rt`) and is used by `std::unicode`,
- `std::runtime::number` is implemented via bundled runtime support (`libsilk_rt`) and is used by `std::number`,
- `std::runtime::readline` is implemented via bundled runtime support (`libsilk_rt`) and is used by `std::readline`.

The long-term shape is still that `std::runtime::<area>` remains the stable
interface point, while platform backends (such as `std::runtime::posix::<area>`
and `std::runtime::windows::<area>`) can exist as separate modules in an
alternate stdlib root without changing higher-level `std::...` modules.

## Interface Design Rules

- The `std::runtime::...` surface is allowed to be low-level and `unsafe`:
  raw pointers, integer error codes, and OS-specific constants are acceptable.
- When an operation can fail, prefer returning the error code *as a value*
  (via `std::result::Result(T, int)` or an optional error `int?`) so callers do
  not need to pair a sentinel return with a separate `errno()` query.
- Higher-level, ergonomic, and allocation-aware APIs belong in `std::...`
  modules (for example `std::fs::File.read_to_end`).
- `std::runtime::...` modules should avoid exposing platform-specific struct
  layouts directly to Silk code when possible; prefer integer-like handles and
  pointer-plus-size patterns.
- The stable contract is the *Silk-level signature* in `std::runtime::...`,
  not the specific `ext` spellings used by the POSIX backend.
- Low-level primitives should be localized:
  - libc allocator `ext` bindings (`malloc`/`free`/`realloc`) and compiler-backed
    raw-memory/string intrinsics (`__silk_*`) live in `std::runtime::posix::mem`
    (and analogous backend `mem` modules),
  - other runtime backend modules should call those exported wrappers instead
    of declaring duplicate allocator/intrinsic `ext` sites.
    - for example, the shipped WASI backends (`std::runtime::wasi::io` and
      `std::runtime::wasi::time`) use `std::runtime::wasi::mem` for allocation
      and `__silk_*` intrinsics.

## Current Scope

Runtime areas in the shipped stdlib:

- `std::runtime::mem` — low-level allocation and compiler-backed intrinsics used by
  higher-level std modules (`alloc`/`realloc`/`free`, raw `load`/`store`, and
  string view helpers).
    allocations are routed to that region for the dynamic extent of the `with`
    block (including calls into stdlib code):
    - `std::runtime::mem::alloc` allocates from the active region instead of the heap,
    - `std::runtime::mem::realloc` reallocates region pointers by allocating a
      new region block and copying bytes (it never calls libc `realloc` on a
      region-backed pointer),
    - `std::runtime::mem::free` is a no-op for region-backed pointers.
  - pointers returned by `std::runtime::mem::alloc` are owned by Silk; they must
    be released with `std::runtime::mem::free` and are not valid to pass to libc
    `free()` directly.
- `std::runtime::build` — build metadata provided by the compiler:
  - `is_debug() -> bool` returns `true` when the current artifact was compiled with `silk ... --debug` (or `-g`).
  - `kind() -> string` returns the current build kind (`"executable"`, `"object"`, `"static"`, or `"shared"`).
  - `mode() -> string` returns the current build mode (`"debug"`, `"release"`, or `"test"`).
  - `version() -> string` returns the current package version when building a package, otherwise `"0.0.0"`.
- `std::runtime::fs` — filesystem primitives used by `std::fs` (hosted baseline;
  on `wasm32-wasi` the shipped backend supports a small subset using the first
  preopened directory as a sandbox root, and resolves relative paths against a
  virtual cwd (`std::runtime::wasi::cwd`)).
- `std::runtime::io` — low-level stdio primitives used by `std::io` (on
  `wasm32-wasi`, rewritten to `std::runtime::wasi::io`, which maintains a
  POSIX-shaped `errno` cell for wrappers that still query `errno()`).
- `std::runtime::task` — hosted task/runtime primitives used by `std::task`
  (sleep/yield_now/available parallelism; currently blocking OS-thread operations;
  delegates to `std::runtime::posix::task` in the shipped stdlib).
- `std::runtime::sync` — hosted synchronization primitives used by `std::sync`
  (mutexes/condvars and allocation helpers; delegates to
  `std::runtime::posix::sync` in the shipped stdlib).
- `std::runtime::time` — hosted time primitives used by `std::temporal` and
  other std modules:
  - monotonic clock reads (`monotonic_now_ns`),
  - Unix wall-clock timestamp reads (`unix_now_ns` / `unix_now_ms`),
  - delegates to `std::runtime::posix::time` in the shipped stdlib.
- `std::runtime::env` — hosted environment primitives used by `std::env`
  (process environment variables; delegates to `std::runtime::posix::env` in the
  shipped stdlib on hosted targets. On `wasm32-wasi` the compiler rewrites the
  backend to `std::runtime::wasi::env`, which implements `getenv` via
  `environ_sizes_get` / `environ_get` (caching the environment snapshot for the
  process lifetime) and leaves `setenv` unsupported).
- `std::runtime::process` — hosted process primitives used by `std::process`
  (current working directory plus child-process primitives for `std::process::child`;
  delegates to `std::runtime::posix::process` in the shipped stdlib on hosted
  targets. On `wasm32-wasi`, `_exit` is implemented via `proc_exit`, while
  `chdir`/`getcwd` are implemented via a virtual cwd layer
  (`std::runtime::wasi::cwd`); hosted child-process operations remain
  unsupported).
- `std::runtime::net` — hosted networking primitives used by `std::net`
  (IPv4/IPv6 TCP + UDP sockets; delegates to `std::runtime::posix::net` in the shipped stdlib).
  - `std::runtime::regex` / `std::runtime::unicode` / `std::runtime::number` / `std::runtime::readline` —
  non-OS-specific runtime helpers used by `std::{regex,unicode,number,readline}`. These
  are implemented via `ext` bindings to a small bundled runtime support library
  (`libsilk_rt`) that ships alongside the compiler.
  - the compiler statically links this bundled runtime support into executable
    and shared-library outputs (no runtime `DT_NEEDED` dependency on
    `libsilk_rt*`).
  - embedders can override internal allocation used by `libsilk_rt` (for
    example regex runtime compilation) by calling `silk_rt_set_allocator` (see
    `include/silk_rt.h`) before invoking any `silk_rt_*` entrypoints. This hook
    affects allocations routed through `silk_rt_malloc_bytes` /
    `silk_rt_realloc_bytes` / `silk_rt_free_bytes`; it does not change the
    allocator used by `std::runtime::mem` for heap-backed pointers.
  - when building with `--noheap`, the compiler links `libsilk_rt_noheap.a`
    instead of `libsilk_rt.a`. In that configuration, `libsilk_rt` performs no
    default heap allocation unless an embedder installs an allocator via
    `silk_rt_set_allocator`.

Follow-ups are expected to introduce additional runtime areas:

- WASI networking (via WASI sockets or similar proposals) when supported by the toolchain targets.

## Providing a Custom Runtime

To provide your own runtime implementation underneath the standard library,
ship an alternate stdlib root that includes compatible `std::runtime::...`
modules.

For a CLI-focused walkthrough of selecting a std root and archive, see

At a minimum, your stdlib root should provide the runtime areas used by the
higher-level std modules you want to reuse. For example, to reuse the shipped
`std::task` and `std::sync`, provide:

- `std/runtime/task.slk` implementing the `std::runtime::task` interface
  (`available_parallelism`, `yield_now`, `sleep_us`),
- `std/runtime/sync.slk` implementing the `std::runtime::sync` interface
  (`alloc_zeroed`, `heap_free`, mutex/condvar ops),

and similarly for `std::fs` (`std/runtime/fs.slk`) if you reuse `std::fs`.

To reuse `std::io`, provide `std/runtime/io.slk` implementing the
`std::runtime::io` interface (`STDIN_FD`, `STDOUT_FD`, `STDERR_FD`, `read`,
`write`, `puts`, and hosted fd helpers used by `std::process::child` such as
`dup2`, `pipe`, `poll`, and `set_cloexec`).

Fallible operations should return errors directly:

- value-returning operations use `std::result::Result(T, int)` where `Err(int)`
  is a stable, area-specific error code consumed by higher-level `std::...`
  wrappers (for example `std::io::IOFailed.code`),
- status operations use optional errors (`int?`), returning `None` on success
  and `Some(code)` on failure.

On hosted POSIX, runtime wrappers typically map `errno` into these stable codes
inside `std::runtime::<area>` so callers do not need to pair sentinel returns
with a separate `errno()` query.

To reuse hosted time helpers in `std::temporal`, provide `std/runtime/time.slk`
implementing the `std::runtime::time` interface (`monotonic_now_ns`,
`unix_now_ns`, and `unix_now_ms`).

### Selecting the Runtime (Toolchain)

Because `std::runtime` is part of the stdlib source tree, selecting a custom
runtime is done by selecting a custom stdlib root:

- CLI: pass `--std-root <path>` (and optionally `--std-lib <path>` to provide a
  prebuilt std archive), or set `SILK_STD_ROOT` / `SILK_STD_LIB`.
- Embedding ABI: set `silk_compiler_set_std_root` (and optionally set
  `SILK_STD_LIB` to point at a prebuilt std archive).

When no suitable std archive is provided, the compiler can fall back to
compiling the reachable std sources as part of the build on supported targets.

### Building a Custom Std Archive (linux/x86_64)

For `linux/x86_64` in the current toolchain, a prebuilt stdlib archive
(`libsilk_std.a`) contains one ELF object per std module.

Archive member naming requirement (current scheme):

- the archive member name is the module path relative to the std root with `/`
  replaced by `_`, and `.slk` replaced by `.o`,
- for example: `std/runtime/posix/task.slk` → `runtime_posix_task.o`.

The in-repo `make stdlib` target produces archives with this naming scheme.

==============================================================================
DOCS: `std::semver` (std/semver)
URL: /silk/docs/?p=std/semver
==============================================================================

# `std::semver`

precedence comparison.

This module is intentionally strict and focused:

- Parses **exact** Semantic Versioning 2.0.0 strings:
  `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`.
- Provides SemVer **precedence comparison** (`cmp`) per the SemVer 2.0.0 rules:
  - `major/minor/patch` are compared numerically.
  - prerelease identifiers are compared per SemVer rules.
  - build metadata is **ignored** for precedence.
- Avoids hidden allocation: `parse` returns a `Version` that borrows `string`
  slices from the input.

## Public API

### Parsing

- `parse(input: string) -> ParseResult`
  - Returns `Ok(Version)` on success.
  - Returns `Err(ParseError)` on error.

`ParseResult` is `std::result::Result(Version, ParseError)`.

`ParseError.offset` is a **byte offset** into the original `input`.
`ParseError.kind()` reports a stable error kind.

Allocation and lifetimes:

- `parse` does **not** allocate.
- `Version.prerelease` and `Version.build` are `string?` slices into `input`.
  The caller must ensure `input` remains alive for as long as the returned
  `Version` is used.

### Version values

`Version` has these fields:

- `major: u64`
- `minor: u64`
- `patch: u64`
- `prerelease: string?` — the substring after `-` (without the `-`).
- `build: string?` — the substring after `+` (without the `+`).

### Comparison

- `Version.cmp(other: &Version) -> int`
  - Returns `-1` if `self` has lower precedence than `other`.
  - Returns `0` if `self` and `other` have equal precedence.
  - Returns `1` if `self` has higher precedence than `other`.

Notes:

- Build metadata does not affect precedence, so:
  - `1.0.0+1` and `1.0.0+2` compare equal (`cmp == 0`),
  - but they are not exactly equal (`eq` is false).

## Example

```silk
import std::semver;

fn main () -> int {
  let r = std::semver::parse("1.2.3-alpha.1+build.5");
  if r.is_err() { return 1; }
  let v: std::semver::Version = match (r) {
    Ok(v) => v,
    Err(_) => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None },
  };

  if v.major != 1 { return 2; }
  if v.prerelease == None { return 3; }

  let ar = std::semver::parse("1.0.0-alpha");
  let br = std::semver::parse("1.0.0");
  if ar.is_err() { return 4; }
  if br.is_err() { return 5; }
  let a: std::semver::Version = match (ar) { Ok(v) => v, Err(_) => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None } };
  let b: std::semver::Version = match (br) { Ok(v) => v, Err(_) => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None } };
  if a.cmp(b) >= 0 { return 6; }

  return 0;
}
```

==============================================================================
DOCS: `std::set` — Sets (std/set)
URL: /silk/docs/?p=std/set
==============================================================================

# `std::set` — Sets

`std::set` provides standard set container surfaces:

- `SetMap(T)` — an unordered set backed by an open-addressing hash table.
- `TreeSet(T)` — an ordered set backed by a red-black tree.

targets the compiler and will grow as the language gains
first-class move/Drop semantics for values stored inside heap-backed data
structures.

## Design Goals

- Provide a consistent “set of unique values” container story in `std::` that
  mirrors `std::map`:
  - hashing + equality for `SetMap(T)`,
  - ordering comparison for `TreeSet(T)`.
- Make allocation behavior explicit and compatible with regions (`with`) and
  `--noheap`.
- Keep terminology and operation shapes close to C++ (`std::unordered_set` and
  `std::set`), adapted to Silk’s current method/optional model.

## Important Limitations

In Silk:

- `SetMap(T)` and `TreeSet(T)` store elements by value, but do not automatically
  run `Drop` for stored elements when entries are removed.
- These sets are intended for “plain” value types:
  - primitive scalars,
  - `string` views,
  - and small POD structs over those primitives.
- Avoid storing Drop-managed structs as set elements until the compiler has
  complete Drop integration for values stored inside container memory.

## Hash Set (`SetMap(T)`)

### Core API

`SetMap(T)` provides:

- `fn empty (hash: fn(T) -> u64, eq: fn(T, T) -> bool) -> SetMap(T);`
- `fn init (cap: i64, hash: fn(T) -> u64, eq: fn(T, T) -> bool) -> std::result::Result(SetMap(T), std::memory::AllocFailed);`
- `fn len (self: &SetMap(T)) -> i64;`
- `fn is_empty (self: &SetMap(T)) -> bool;`
- `fn capacity (self: &SetMap(T)) -> i64;`
- `fn contains (self: &SetMap(T), key: T) -> bool;`
- `fn insert (mut self: &SetMap(T), key: T) -> std::result::Result(bool, std::memory::OutOfMemory);`  
  Returns `true` when `key` was not already present.
- `fn remove (mut self: &SetMap(T), key: T) -> bool;`  
  Returns `true` when `key` was present and removed.
- `fn iter (self: &SetMap(T)) -> SetMapIter(T);`
- `fn clear (mut self: &SetMap(T)) -> void;`
- `fn reserve_additional (mut self: &SetMap(T), additional: i64) -> std::memory::OutOfMemory?;`
- `fn drop (mut self: &SetMap(T)) -> void;`

`SetMap.init(cap, ...)` validates the requested capacity:

- `cap < 0` returns `AllocErrorKind::InvalidInput`.
- very large `cap` values that would overflow internal sizing arithmetic return
  `AllocErrorKind::Overflow`.

Complexity expectations:

- average `O(1)` for `contains`/`insert`/`remove` when the hash distribution is good,
- worst case `O(n)` in adversarial collision patterns.

## Ordered Set (`TreeSet(T)`)

`TreeSet(T)` is an ordered set. It requires an ordering function.

### Core API

`TreeSet(T)` provides:

- `fn init (cmp: fn(T, T) -> int) -> TreeSet(T);`  
  Contract: `cmp(a, b) < 0` iff `a < b`; `cmp(a, b) == 0` iff keys are equal.
- `fn len (self: &TreeSet(T)) -> i64;`
- `fn is_empty (self: &TreeSet(T)) -> bool;`
- `fn contains (self: &TreeSet(T), key: T) -> bool;`
- `fn insert (mut self: &TreeSet(T), key: T) -> std::result::Result(bool, std::memory::OutOfMemory);`
- `fn remove (mut self: &TreeSet(T), key: T) -> bool;`
- `fn iter (self: &TreeSet(T)) -> TreeSetIter(T);`
- `fn clear (mut self: &TreeSet(T)) -> void;`
- `fn drop (mut self: &TreeSet(T)) -> void;`

Complexity expectations:

- `O(log n)` lookup/insert/remove.

## Iteration

Both sets provide iteration through an iterator interface:

- `SetMapIter(T)` implements `std::interfaces::Iterator(T)`.
- `TreeSetIter(T)` implements `std::interfaces::Iterator(T)`.

Notes:

- Iteration is by value (copies out each element).
- `SetMap` iteration order is unspecified.
- `TreeSet` iteration yields values in ascending order (as defined by `cmp`).

==============================================================================
DOCS: `std::sqlite` (std/sqlite)
URL: /silk/docs/?p=std/sqlite
==============================================================================

# `std::sqlite`

primitives for the hosted POSIX baseline using the system `libsqlite3` shared
library.

The initial goals are:

- a small but usable database/statement API (`Database`, `Stmt`),
- a non-leaking, portable error model (`SqliteFailed`) that surfaces stable
  error kinds while retaining SQLite return codes as structured detail,
- safe defaults (`invalid()` handles, idempotent `drop()`), so resource cleanup
  is reliable even in early-return code.

## Linkage and Toolchain Integration

On `linux/x86_64` with the glibc dynamic loader (`ld-linux`), `silk build`
automatically adds `libsqlite3.so.0` as a `DT_NEEDED` dependency when a program
imports `sqlite3_*` extern symbols (for example via `import std::sqlite;`).

To build the vendored static library artifact used for embedding and future
bundling, run `zig build deps`. This downloads and extracts the pinned SQLite
amalgamation source:

- upstream: `https://www.sqlite.org/2026/sqlite-amalgamation-3510200.zip`
- output staging (hosted baseline):
  - `vendor/deps/sqlite-amalgamation-3510200/` (source; ignored),
  - `vendor/lib/x64-linux/libsqlite3.a` (static library; ignored),
  - `vendor/include/sqlite3.h` + `vendor/include/sqlite3ext.h` (headers; ignored).

## Error Model

`std::sqlite` uses `std::result::Result(T, E)` and optional-error returns for
fallible operations that do not return a value.

The stable error value is `SqliteFailed`:

```silk
module std::sqlite;

export error SqliteFailed {
  code: int, // stable ERR_* code
  rc: int,   // primary SQLite rc
  detail: int,  // extended rc when available
}
```

Callers that want a portable classification should use `SqliteFailed.kind()`.
The raw SQLite return codes remain available for debugging/telemetry.

## Handles and Lifetimes

- `Database` and `Stmt` are handle types with safe defaults:
  - `Database.invalid()` / `Stmt.invalid()` construct invalid handles.
  - `drop()` is idempotent and safe to call on invalid handles.
- Borrowed column accessors:
  - `Stmt.column_text(col) -> string?` and `Stmt.column_blob(col) -> ByteSlice?`
    return views into SQLite-owned memory.
  - These views are valid until the next `step`/`reset`/`finalize` on the same
    statement.
- Copy helpers:
  - `Stmt.column_text_copy` copies into `std::strings::String`.
  - `Stmt.column_blob_copy` copies into `std::buffer::BufferU8`.

## Current API (Initial)

The current `std::sqlite` surface currently lives in `std/sqlite.slk` and
provides:

- `Database`: `open`, `open_read_only`, `open_in_memory`, `exec`, `prepare`,
  `busy_timeout_ms`, `changes`, `last_insert_rowid`,
- `Stmt`: `bind_int`, `bind_i64`, `bind_text`, `bind_blob`, `step`, `reset`,
  `clear_bindings`, `column_*` accessors, and `finalize`/`drop`.

==============================================================================
DOCS: `std::ssh2` (std/ssh2)
URL: /silk/docs/?p=std/ssh2
==============================================================================

# `std::ssh2`

for the hosted POSIX baseline using the system `libssh2` shared library.

The initial goals are:

- a small but usable SSH2 client session API (`Session`, `Channel`),
- an SFTP client API (`Sftp`, `SftpHandle`) suitable for remote filesystem access,
- a non-leaking, portable error model that does not expose raw libssh2 error
  codes as the primary API surface,
- pervasive use of Formal Silk theories to document and verify byte-buffer
  invariants for FFI operations.

## Linkage and Toolchain Integration

On `linux/x86_64` with the glibc dynamic loader (`ld-linux`), `silk build`
automatically adds `libssh2.so.1` as a `DT_NEEDED` dependency when a program
imports `libssh2_*` extern symbols (for example via `import std::ssh2;`).

This mirrors existing behavior for `libc.so.6`, `libsodium.so.23`, and
`libmbedtls.so.14` so downstream users do not have to pass
`--needed libssh2.so.1` for normal hosted builds.

To build the vendored static library artifact used for embedding and future
bundling, run `zig build deps`. This stages `vendor/lib/x64-linux/libssh2.a`
from `vendor/deps/libssh2` (tag `libssh2-1.11.1`). The current deps workflow
builds libssh2 using the OpenSSL backend.

## Error Model

The `std::ssh2` API uses `std::result::Result(T, E)` and a stable `Ssh2Failed`
error value. The underlying libssh2 error code is retained as structured detail
(`Ssh2Failed.detail`) for debugging and telemetry.

Non-blocking I/O is surfaced via `Ssh2ErrorKind::WouldBlock` (mapped from
`LIBSSH2_ERROR_EAGAIN`).

Public error/value types in Silk:

```silk
module std::ssh2;

import std::result;

enum Ssh2ErrorKind {
  OutOfMemory,
  InvalidInput,
  WouldBlock,
  InitFailed,
  SessionFailed,
  HandshakeFailed,
  AuthFailed,
  ChannelFailed,
  SftpFailed,
  KnownHostsFailed,
  AgentFailed,
  Unknown,
}

export error Ssh2Failed {
  code: int,
  detail: int,
}

export type Ssh2IntResult = std::result::Result(int, Ssh2Failed);
export type Ssh2I64Result = std::result::Result(i64, Ssh2Failed);

export type SessionResult = std::result::Result(Session, Ssh2Failed);
export type ChannelResult = std::result::Result(Channel, Ssh2Failed);
export type SftpResult = std::result::Result(Sftp, Ssh2Failed);
export type SftpHandleResult = std::result::Result(SftpHandle, Ssh2Failed);

enum KnownHostCheck {
  Match,
  Mismatch,
  NotFound,
}

export type KnownHostCheckResult = std::result::Result(KnownHostCheck, Ssh2Failed);

// Agent iteration uses `Ok(Some(identity))` and `Ok(None)` for end-of-list.
export type AgentNextIdentityResult = std::result::Result(AgentIdentity?, Ssh2Failed);
```

## Byte Buffers and Formal Silk

`std::ssh2` expresses byte-oriented inputs and outputs using the standard packed
byte types:

- `std::arrays::ByteSlice` — non-owning `{ ptr, len }` byte view.
- `std::buffer::BufferU8` — owning `{ ptr, cap, len }` packed byte buffer.

FFI entrypoints that accept or fill byte buffers use Formal Silk theories such
as `slice_well_formed(ptr, len)` to document shape invariants (`len >= 0` and
non-null when non-empty).

## Current API (Initial)

The current `std::ssh2` surface currently lives in a single module
`std/ssh2.slk` (`module std::ssh2;`) and provides:

- `Session` — init/free, blocking mode, timeouts, handshake, disconnect, and
  common authentication helpers,
- `Channel` — open session channels, exec/shell/subsystem, read/write/close,
  and exit status,
- `Sftp` / `SftpHandle` — basic SFTP operations and directory iteration,
- `KnownHosts` — OpenSSH known_hosts read/check/write helpers (`check*` returns `KnownHostCheckResult`),
- `Agent` — ssh-agent integration for publickey auth (`next_identity` returns `AgentNextIdentityResult`).

This module may be split into submodules as the stdlib grows to keep the code
base navigable and to support additional optional dependency backends.

==============================================================================
DOCS: `std::stream` (std/stream)
URL: /silk/docs/?p=std/stream
==============================================================================

# `std::stream`

for **byte streams** designed to work well with Silk’s `async`/`task` model.

The core goals of the  are:

- **Ergonomic piping** between producers and consumers.
- **Backpressure** via bounded buffering.
- **Safe chunk ownership** across tasks using an owned `Bytes` type (no borrowed
  slice lifetime hazards).

Runtime note ():

- `ReadableStream.read()` / `WritableStream.write()` are **blocking OS-thread**
  operations implemented with mutex/condvar primitives.

See also:


## API

```silk
module std::stream;

import std::arrays;
import std::buffer;
import std::memory;
import std::result;

export enum StreamErrorKind {
  OutOfMemory,
  InvalidInput,
  Closed,
  Full,
  Cancelled,
  Aborted,
  RuntimeFailed,
  Unknown,
}

export error StreamFailed {
  code: int,
}

impl StreamFailed {
  public fn kind (self: &StreamFailed) -> StreamErrorKind;
}

// Owned, immutable byte chunks.
export struct Bytes {
  handle: u64,
}

export type BytesResult = std::result::Result(Bytes, std::memory::AllocFailed);

impl Bytes {
  public fn empty () -> Bytes;
  public fn is_empty (self: &Bytes) -> bool;
  public fn len (self: &Bytes) -> i64;
  public fn as_slice (self: &Bytes) -> std::arrays::ByteSlice;
  public fn copy_from (slice: std::arrays::ByteSlice) -> BytesResult;
  public fn copy_from_string (s: string) -> BytesResult;
  public fn take_from_buffer (mut buf: &std::buffer::BufferU8) -> BytesResult;
}

// Read outcomes.
export enum Read {
  Done,
  Pending,
  Chunk(Bytes),
}

export type ReadResult = std::result::Result(Read, StreamFailed);

// Readable end.
export struct ReadableStream {
  handle: u64,
}

impl ReadableStream {
  public fn invalid () -> ReadableStream;
  public fn is_valid (self: &ReadableStream) -> bool;
  public fn cap (self: &ReadableStream) -> int;
  public fn len (self: &ReadableStream) -> int;
  public fn is_closed (self: &ReadableStream) -> bool;
  public fn read (self: &ReadableStream) -> ReadResult;
  public fn try_read (self: &ReadableStream) -> ReadResult;
  public fn cancel (self: &ReadableStream) -> void;
  public fn destroy (mut self: &ReadableStream) -> void;
}

// Writable end.
export struct WritableStream {
  handle: u64,
}

impl WritableStream {
  public fn invalid () -> WritableStream;
  public fn is_valid (self: &WritableStream) -> bool;
  public fn cap (self: &WritableStream) -> int;
  public fn len (self: &WritableStream) -> int;
  public fn is_closed (self: &WritableStream) -> bool;
  public fn write (self: &WritableStream, mut chunk: Bytes) -> StreamFailed?;
  public fn try_write (self: &WritableStream, mut chunk: Bytes) -> StreamFailed?;
  public fn close (self: &WritableStream) -> void;
  public fn abort (self: &WritableStream, err: StreamFailed) -> void;
  public fn destroy (mut self: &WritableStream) -> void;
}

// A paired in-memory stream (writable → readable).
export struct PassThroughStream {
  readable: ReadableStream,
  writable: WritableStream,
}

export type PassThroughResult = std::result::Result(PassThroughStream, StreamFailed);

impl PassThroughStream {
  public fn init_default () -> PassThroughResult;
  public fn init (cap: int) -> PassThroughResult;
  public fn take_readable (mut self: &PassThroughStream) -> ReadableStream;
  public fn take_writable (mut self: &PassThroughStream) -> WritableStream;
}

// Transformer output.
export type TransformBytesResult = std::result::Result(Bytes, StreamFailed);

// A paired transform stage.
export struct TransformStream {
  readable: ReadableStream,
  writable: WritableStream,
  transform_readable: ReadableStream,
  transform_writable: WritableStream,
}

export type TransformResult = std::result::Result(TransformStream, StreamFailed);

impl TransformStream {
  public fn init_default () -> TransformResult;
  public fn init (cap: int) -> TransformResult;
  public fn init_with_caps (cap_in: int, cap_out: int) -> TransformResult;
  public fn take_readable (mut self: &TransformStream) -> ReadableStream;
  public fn take_writable (mut self: &TransformStream) -> WritableStream;
  public fn take_transform_readable (mut self: &TransformStream) -> ReadableStream;
  public fn take_transform_writable (mut self: &TransformStream) -> WritableStream;
}

// Pipe a readable into a writable until done.
export fn pipe_to (mut src: ReadableStream, mut dst: WritableStream) -> std::result::Result(int, StreamFailed);
```

## Semantics

### Backpressure

Each stream has a bounded in-memory queue. The `cap` is expressed in **chunks**
(`Bytes` values), not bytes:

- `PassThroughStream.init(cap)` / `TransformStream.init(cap)` require `cap > 0`
  (otherwise they return `Err(StreamFailed)` with `kind() == InvalidInput`).
- `WritableStream.write()` blocks while the queue is full.
- `ReadableStream.read()` blocks while the queue is empty (until closed or errored).

### Close vs cancel vs abort

- `WritableStream.close()`:
  - graceful end-of-stream,
  - readers drain remaining buffered chunks and then observe `Read::Done`.
- `ReadableStream.cancel()`:
  - marks the stream cancelled,
  - discards buffered chunks,
  - causes writers to fail with a `Cancelled` error.
- `WritableStream.abort(err)`:
  - marks the stream aborted with `err`,
  - discards buffered chunks,
  - causes readers to return `Err(err)` from `read` / `try_read`.

### Transform streams

`TransformStream` models a Web Streams-style transform stage.

In Silk, `std::stream` does **not** attach a transformer
callback internally. Instead, `TransformStream` exposes two bounded pipes and
expects you to run the transform loop in a task:

- input pipe: producers write to `writable`, transformer reads from
  `transform_readable`,
- output pipe: transformer writes to `transform_writable`, consumers read from
  `readable`.

This design composes naturally with task-based structured concurrency: run the
transform loop in a `task` and rely on backpressure to bound memory.

## Usage patterns

### Producer → consumer (tasks)

```silk
import std::stream;

task fn producer (w: std::stream::WritableStream) -> int { ... }
task fn consumer (r: std::stream::ReadableStream) -> int { ... }

async fn main () -> int {
  task {
    let pt_r = std::stream::PassThroughStream.init_default();
    if pt_r.is_err() { return 1; }
    let mut pt: std::stream::PassThroughStream = match (pt_r) {
      Ok(v) => v,
      Err(_) => std::stream::PassThroughStream{
        readable: std::stream::ReadableStream.invalid(),
        writable: std::stream::WritableStream.invalid(),
      },
    };

    let w = (mut pt).take_writable();
    let r = (mut pt).take_readable();

    let hp = producer(w);
    let hc = consumer(r);

    let rp: int = (yield * hp)[0];
    let rc: int = (yield * hc)[0];
    if rp != 0 { return rp; }
    if rc != 0 { return rc; }
    return 0;
  }
}
```

### Transform stage (tasks)

`TransformStream` is a pair of pipes intended to be driven by a transformer task.
Typical wiring:

- producer writes to `take_writable()`,
- transformer reads from `take_transform_readable()` and writes to
  `take_transform_writable()`,
- consumer reads from `take_readable()`.

### Piping

`pipe_to` is a structured copy loop:

- closes `dst` when `src` ends,
- aborts/cancels on error.

```silk
import std::stream;

fn run_pipeline (src: std::stream::ReadableStream, dst: std::stream::WritableStream) -> int {
  let r = std::stream::pipe_to(src, dst);
  return match (r) {
    Ok(_) => 0,
    Err(_) => 1,
  };
}
```

## Notes

- The  uses blocking primitives; it is intended to become
  suspension-friendly once the async runtime exists.
- Drop semantics are designed to avoid leaked pipes:
  - dropping `ReadableStream` cancels the stream (writers start failing),
  - dropping `WritableStream` closes the stream
    (readers observe `Read::Done` after draining).
- `PassThroughStream.take_readable` / `take_writable` exist to make ownership
  transfer ergonomic in Silk (moving out of struct fields is
  limited).

==============================================================================
DOCS: `std::strings` (std/strings)
URL: /silk/docs/?p=std/strings
==============================================================================

# `std::strings`

implemented in `std/strings.slk` to support early toolchain bring-up; the rest
of this document describes the intended long-term API.

This module provides string utilities and abstractions built on top of the core
`string` type (UTF-8 bytes) and the `Buffer(T)` intrinsic.

See also:


## Current API

The following functions exist today in `std/strings.slk` and are available to
import:

```silk
module std::strings;

export fn eq (a: string, b: string) -> bool;
export fn ne (a: string, b: string) -> bool;
export fn lt (a: string, b: string) -> bool;
export fn le (a: string, b: string) -> bool;
export fn gt (a: string, b: string) -> bool;
export fn ge (a: string, b: string) -> bool;

export fn is_empty (s: string) -> bool;
export fn or_empty (s: string?) -> string;

export fn trim (s: string) -> string;
export fn trim_start (s: string) -> string;
export fn trim_end (s: string) -> string;

export fn pad_left (s: string, min_len: i64, pad: string) -> std::result::Result(String, std::memory::OutOfMemory);
export fn pad_right (s: string, min_len: i64, pad: string) -> std::result::Result(String, std::memory::OutOfMemory);
export fn pad_center (s: string, min_len: i64, pad: string) -> std::result::Result(String, std::memory::OutOfMemory);
```

Notes:

- These are simple wrappers over the language’s built-in string comparisons and
  optional-coalesce operator (`??`), chosen because they are implementable in
  the compiler.
- This surface will grow alongside language/runtime features
  required for richer string operations (slicing, iteration, allocation, etc.).

In addition, a low-level `StringBuilder` type exists today for
incremental byte construction:

```silk
struct StringBuilder {
  ptr: u64,
  cap: i64,
  len: i64,
}

impl StringBuilder {
  public fn init (cap: i64) -> std::result::Result(StringBuilder, std::memory::AllocFailed);
  public fn empty () -> StringBuilder;
  public fn push_u8 (mut self: &StringBuilder, value: u8) -> std::memory::OutOfMemory?;
  public fn pop_u8 (mut self: &StringBuilder) -> u8?;
  public fn get_u8 (self: &StringBuilder, index: i64) -> u8;
  public fn set_u8 (mut self: &StringBuilder, index: i64, value: u8) -> void;
  public fn into_string (mut self: &StringBuilder) -> std::result::Result(String, std::memory::OutOfMemory);
}

impl StringBuilder as std::interfaces::ReserveAdditional {
  public fn reserve_additional (mut self: &StringBuilder, additional: i64) -> std::memory::OutOfMemory?;
}
```

Notes:

- `StringBuilder` builds raw bytes. It can be converted into an owned `String`
  via `into_string`; the resulting `String` can then yield a borrowed `string`
  view via `String.as_string()`.
- `StringBuilder` allocation failure is recoverable:
  - `init(cap)` returns `Err(AllocFailed)` when the initial allocation fails (or
    when `cap` is invalid),
  - `empty()` exists for infallible construction,
  - growth paths (`push_u8`, `reserve_additional`, `into_string`) return
    `std::memory::OutOfMemory?` / `Result(...)` and leave the builder unchanged
    on failure (including internal size arithmetic overflow).
- `StringBuilder` conforms to common `std::interfaces` protocols:
  - `Len`, `Capacity`, `IsEmpty`, `Clear`, `ReserveAdditional`, `WriteU8`, and `Drop`.

An owned `String` type exists today for dynamically produced strings:

```silk
struct String {
  ptr: u64,
  cap: i64,
  len: i64,
}

impl String {
  public fn empty () -> String;
  public fn from_string (s: string) -> std::result::Result(String, std::memory::OutOfMemory);
  public fn from_buffer_u8 (mut v: &std::buffer::BufferU8) -> std::result::Result(String, std::memory::OutOfMemory);
  public fn as_string (self: &String) -> string;

  public fn push_u8 (mut self: &String, value: u8) -> std::memory::OutOfMemory?;
  public fn push_string (mut self: &String, s: string) -> std::memory::OutOfMemory?;
  public fn push_repeat_u8 (mut self: &String, byte: u8, count: i64) -> std::memory::OutOfMemory?;

  public fn trim (mut self: &String) -> void;
  public fn trim_start (mut self: &String) -> void;
  public fn trim_end (mut self: &String) -> void;

  public fn pad_left (mut self: &String, min_len: i64, pad: string) -> std::memory::OutOfMemory?;
  public fn pad_right (mut self: &String, min_len: i64, pad: string) -> std::memory::OutOfMemory?;
  public fn pad_center (mut self: &String, min_len: i64, pad: string) -> std::memory::OutOfMemory?;
}
```

Notes:

- The current `String` maintains a trailing NUL terminator so the
  `string` view it yields is safe to pass to C APIs that expect `const char *`.
- The current `String` implementation does **not** validate UTF‑8.
- `String.as_string()` yields a non-owning view into the `String` allocation;
  callers must not use the returned `string` after the `String` is dropped.

## Scope

`std::strings` is responsible for:

- Construction, slicing, and concatenation.
- UTF-8-aware utilities (iteration by `char`, validation when constructing from
  raw bytes).
- Interoperability with FFI (`SilkString`, C-string compatibility).

Non-goals (initially):

- Locale-aware collation and normalization (future work).
- Full Unicode grapheme segmentation (future work).

## Core Types (Initial Design)

The language provides a built-in `string` type (an immutable UTF-8 byte
sequence). The stdlib adds:

- `Str` — a non-owning view over UTF-8 bytes (useful when the caller wants an
  explicit view type rather than `string`).
- `String` — an owning, growable UTF-8 string backed by `Buffer(u8)` plus a
  length (a dynamic array of bytes that maintains UTF-8 validity).
- `StringBuilder` — a convenience for incremental construction; typically a
  thin wrapper around `String` or a packed byte buffer (for example
  `std::buffer::BufferU8`).

Key invariants:

- `String` must always contain valid UTF-8.
- When converting a `String` to a `string` for FFI, the backing storage must be
  null-terminated (with the trailing `\0` byte not counted in `.len`), matching

## API Sketch (Illustrative)

These signatures are illustrative and will be refined alongside the language
features required to implement them (references, generics, enums/results, etc.).

```silk
module std::strings;

export struct String {
  // Invariant: `buf[0..len]` is valid UTF-8; `buf[len] == 0` for C interop.
  buf: Buffer(u8),
  len: int,
}

export fn empty () -> String;
export fn from_string (alloc: std::memory::Allocator, s: string) -> String;
export fn from_utf8 (alloc: std::memory::Allocator, bytes: std::arrays::Slice(u8)) -> Result(String, Utf8Error);

export fn as_string (s: &String) -> string;
export fn len_bytes (s: string) -> int;
export fn is_empty (s: string) -> bool;

export fn starts_with (s: string, prefix: string) -> bool;
export fn ends_with (s: string, suffix: string) -> bool;
export fn find (s: string, needle: string) -> int?;

export fn concat (alloc: std::memory::Allocator, a: string, b: string) -> String;
```

## FFI Interop

`string` values crossing the C ABI use `SilkString { ptr, len }` as documented

`std::strings` should provide helpers for common interop patterns:

- Passing `string` to C APIs that expect `const char *` (use `.ptr`; Silk’s
  runtime representation guarantees a trailing NUL).
- Producing an owned, NUL-terminated string for FFI calls that require the
  backing storage to outlive the call (e.g. when C stores the pointer).

## Future Work

- `split`, `replace`, `join`.
- UTF-8 scalar iteration (`chars()`), case mapping, and normalization.
- Formatting integration (shared with `std::io`).

Implementation must respect the ownership and lifetime rules from

==============================================================================
DOCS: `std::sync` (std/sync)
URL: /silk/docs/?p=std/sync
==============================================================================

# `std::sync`

synchronization primitives used by the current `task` lowering on
`linux/x86_64`.

This is an intentionally narrow subset intended for early bring-up:

- It is intentionally small and conservative (a hosted baseline, not a final
  async runtime).
- It uses a simple **handle-based** representation backed by heap-allocated
  state and runtime-provided synchronization primitives (`std::runtime::sync`,
  which defaults to a POSIX/pthread backend in the shipped stdlib).
- All blocking operations block the **current OS thread**.

See also:


## API

```silk
module std::sync;

import std::result;

enum SyncErrorKind {
  OutOfMemory,
  InvalidInput,
  Closed,
  Full,
  RuntimeFailed,
  Unknown,
}

export error SyncFailed {
  code: int,
}

// A pthread-backed mutex handle.
struct Mutex {
  handle: u64,
}

impl Mutex {
  public fn invalid () -> Mutex;
  public fn is_valid (self: &Mutex) -> bool;
  public fn init () -> std::result::Result(Mutex, SyncFailed);
  public fn lock (self: &Mutex) -> SyncFailed?;
  public fn unlock (self: &Mutex) -> SyncFailed?;
  public fn destroy (mut self: &Mutex) -> void;
}

// A pthread-backed condition variable handle.
struct Condvar {
  handle: u64,
}

impl Condvar {
  public fn invalid () -> Condvar;
  public fn is_valid (self: &Condvar) -> bool;
  public fn init () -> std::result::Result(Condvar, SyncFailed);
  public fn wait (self: &Condvar, m: &Mutex) -> SyncFailed?;
  public fn signal (self: &Condvar) -> SyncFailed?;
  public fn broadcast (self: &Condvar) -> SyncFailed?;
  public fn destroy (mut self: &Condvar) -> void;
}

// A bounded channel of `T` values.
struct Channel(T) {
  handle: u64,
}

// A non-owning, copyable view of a channel handle.
struct ChannelBorrow(T) {
  handle: u64,
}

impl Channel(T) {
  public fn invalid () -> Channel(T);
  public fn init_default () -> std::result::Result(Channel(T), SyncFailed);
  public fn init (cap: int) -> std::result::Result(Channel(T), SyncFailed);
  public fn borrow (self: &Channel(T)) -> ChannelBorrow(T);
  public fn cap (self: &Channel(T)) -> int;
  public fn len (self: &Channel(T)) -> int;
  public fn is_closed (self: &Channel(T)) -> bool;
  public fn try_send (self: &Channel(T), value: T) -> SyncFailed?;
  public fn send (self: &Channel(T), value: T) -> SyncFailed?;
  public fn try_recv (self: &Channel(T)) -> T?;
  public fn recv (self: &Channel(T)) -> T?;
  public fn close (self: &Channel(T)) -> void;
  public fn destroy (mut self: &Channel(T)) -> void;
}

impl ChannelBorrow(T) {
  public fn send (self: &ChannelBorrow(T), value: T) -> SyncFailed?;
}

// A simple cancellation token (blocking wait).
struct CancellationToken {
  handle: u64,
}

// A non-owning, copyable view of a cancellation token handle.
struct CancellationTokenBorrow {
  handle: u64,
}

impl CancellationToken {
  public fn invalid () -> CancellationToken;
  public fn is_valid (self: &CancellationToken) -> bool;
  public fn init () -> std::result::Result(CancellationToken, SyncFailed);
  public fn borrow (self: &CancellationToken) -> CancellationTokenBorrow;
  public fn cancel (self: &CancellationToken) -> void;
  public fn is_cancelled (self: &CancellationToken) -> bool;
  public fn wait (self: &CancellationToken) -> void;
  public fn destroy (mut self: &CancellationToken) -> void;
}

impl CancellationTokenBorrow {
  public fn cancel (self: &CancellationTokenBorrow) -> void;
  public fn is_cancelled (self: &CancellationTokenBorrow) -> bool;
  public fn wait (self: &CancellationTokenBorrow) -> void;
}
```

Notes:

- `Mutex.init`, `Condvar.init`, and `CancellationToken.init` return
  `Result(...)`. `Channel(T).init` / `init_default` return `Result(...)`.
- `Channel(T).invalid()` returns an inert handle (`handle == 0`); operations treat it as closed/empty and return `InvalidInput` for sends.
- `CancellationToken.invalid()` returns an inert handle; it is treated as already cancelled so waits do not block.
- Handle types are trivially copyable in the current language subset; copying a
  handle duplicates the pointer. Destroying (or dropping) any copy invalidates
  the others.
- When sending a channel handle across a `task` boundary, prefer passing a
  non-owning view (`ChannelBorrow(T)`) obtained via `c.borrow()` so ownership
  stays with the original `Channel(T)`.
- When sending a cancellation token across a `task` boundary, prefer passing a
  non-owning view (`CancellationTokenBorrow`) obtained via `tok.borrow()` so
  ownership stays with the original `CancellationToken`.
- `Condvar.wait(self: &Condvar, m: &Mutex)` is called as `cv.wait(m)` — the
  compiler implicitly borrows the `m` binding for `&T` parameters (there is no
  general `&expr` operator in Silk).
- `Channel(T).recv()` returns `None` once the channel is closed *and* empty.
- `Channel(T).try_send()` returns `Some(SyncFailed)` when the channel is closed
  or full.
- `Channel(T).try_recv()` returns `None` when the channel is empty. Use
  `is_closed()` to distinguish between “empty” and “closed and empty” when
  needed.

==============================================================================
DOCS: `std::task` (std/task)
URL: /silk/docs/?p=std/task
==============================================================================

# `std::task`

task/runtime utilities on `linux/x86_64`.

This is **not** the full async runtime design. There is not yet a coroutine
transform or event loop in the compiler/runtime, so `yield`/`yield *`, `await`,
and the helpers below may block the current OS thread.

See also:


## API

```silk
module std::task;

enum SleepUntilErrorKind { NoMonotonicClock, Unknown }
error SleepUntilFailed { code: int }

// Return the number of logical CPUs available (>= 1).
export fn available_parallelism () -> int;

// Hint to the OS scheduler that the current thread can yield.
export fn yield_now () -> void;

// Block the current OS thread for at least `ms` milliseconds.
export fn sleep_ms (ms: int) -> void;

// Block the current OS thread for at least `d`.
export fn sleep (d: Duration) -> void;

// Block the current OS thread until `deadline` (monotonic time).
export fn sleep_until (deadline: Instant) -> SleepUntilFailed?;
```

Notes:

- `available_parallelism()` is intended to be used by future schedulers and
  higher-level concurrency utilities. It is implemented using a hosted libc
  query (`get_nprocs`) and clamps to `>= 1`.
- `yield_now()` and `sleep_ms()` are blocking thread operations (they are not
  async-aware until an event loop exists).
- `sleep_ms(ms)` is implemented by converting `ms` to microseconds and calling
  `std::runtime::task::sleep_us`; large sleeps may be performed in chunks.
- `sleep(d)` is a blocking thread operation and is implemented using `usleep`
  (microsecond resolution, rounded up).
- `sleep_until(deadline)` is a blocking thread operation and is implemented by
  reading `std::temporal::now_monotonic()` and calling `sleep(deadline - now)`.
  - It returns `Some(SleepUntilFailed{ ... })` when a monotonic clock read fails
    (`std::temporal::now_monotonic()` returns `Err(...)`).

Implementation note:

- In the shipped stdlib, `std::task` delegates its OS-facing behavior to the
  pluggable runtime interface `std::runtime::task` (which defaults to a POSIX
  backend under `std::runtime::posix::task`).

==============================================================================
DOCS: `std::temporal` (std/temporal)
URL: /silk/docs/?p=std/temporal
==============================================================================

# `std::temporal`

is implemented in `std/temporal.slk`:

- `Instant`/`Duration` convenience helpers, plus
- pure calendar/time utilities (`Date`, `TimeOfDay`, `DateTime`) that do not
  depend on OS clocks.

A hosted monotonic clock source (`now_monotonic`) is implemented via
`std::runtime::time`. The runtime also exposes Unix wall-clock timestamps via
`unix_now_ns` / `unix_now_ms`, but higher-level UTC/local timestamp helpers
remain future work.

`std::temporal` provides utilities built around the `Instant` and `Duration`
model for date/time computations.

See also:


## API

The following helpers exist today in `std/temporal.slk` and are available to
import.

```silk
module std::temporal;

export let NANOSECOND: Duration = 1ns;
export let MICROSECOND: Duration = 1us;
export let MILLISECOND: Duration = 1ms;
export let SECOND: Duration = 1s;
export let MINUTE: Duration = 1min;
export let HOUR: Duration = 1h;
export let DAY: Duration = 1d;

export fn duration_zero () -> Duration;
export fn is_zero (d: Duration) -> bool;
export fn is_negative (d: Duration) -> bool;
export fn duration_abs (d: Duration) -> Duration;
export fn duration_to_secs_trunc (d: Duration) -> i64;
export fn duration_from_secs (seconds: i64) -> Duration;

export fn add (t: Instant, d: Duration) -> Instant;
export fn sub (t: Instant, d: Duration) -> Instant;
export fn since (later: Instant, earlier: Instant) -> Duration;

export fn before (a: Instant, b: Instant) -> bool;
export fn after (a: Instant, b: Instant) -> bool;

enum TemporalErrorKind { OutOfMemory, NoMonotonicClock, InvalidInput, Overflow, Unknown }
error TemporalFailed { code: int, requested: i64 }
export type InstantResult = std::result::Result(Instant, TemporalFailed);
export type TemporalStringResult = std::result::Result(std::strings::String, TemporalFailed);

export fn now_monotonic () -> InstantResult;

struct Date { year: int, month: int, day: int }
struct TimeOfDay { hour: int, minute: int, second: int, nanosecond: int }
struct DateTime { date: Date, time: TimeOfDay }

// Validation + construction (pure; returns optional on invalid inputs).
Date.try_from_ymd(year: int, month: int, day: int) -> Date?;
TimeOfDay.try_from_hms_nano(hour: int, minute: int, second: int, nanosecond: int) -> TimeOfDay?;
DateTime.try_from_date_time(date: Date, time: TimeOfDay) -> DateTime?;

// Unix conversions (UTC; pure). Days are relative to 1970-01-01.
Date.to_unix_days(self: &Date) -> i64?;
Date.from_unix_days(days: i64) -> Date;
Date.iso_weekday(self: &Date) -> int?;

TimeOfDay.to_nanos_of_day(self: &TimeOfDay) -> i64?;
TimeOfDay.from_nanos_of_day(ns: i64) -> TimeOfDay?;

DateTime.to_unix_timestamp_ns(self: &DateTime) -> i64?;
DateTime.from_unix_timestamp_ns(ns: i64) -> DateTime?;

// Formatting/parsing (strict ISO-8601 subsets; allocation in formatting).
export fn format_date_iso (d: Date) -> TemporalStringResult;
export fn format_time_iso (t: TimeOfDay) -> TemporalStringResult;
export fn format_datetime_iso (dt: DateTime) -> TemporalStringResult;

enum ParseErrorKind { InvalidInput, InvalidLength, InvalidDigit, InvalidSeparator, InvalidRange, TrailingInput, Unknown }
error ParseError { code: int, offset: i64 }
export type DateParseResult = std::result::Result(Date, ParseError);
export type TimeParseResult = std::result::Result(TimeOfDay, ParseError);
export type DateTimeParseResult = std::result::Result(DateTime, ParseError);

export fn parse_date_iso (s: string) -> DateParseResult;
export fn parse_time_iso (s: string) -> TimeParseResult;
export fn parse_datetime_iso (s: string) -> DateTimeParseResult;
```

## Scope

`std::temporal` is responsible for:

- Access to time sources:
  - a monotonic clock for measuring durations (`Instant`),
  - a wall-clock time source (UTC/local timestamps) for `DateTime` (future work).
- Conversions between units and convenience helpers for `Duration`.
- Pure calendar/time computations that do not require OS services:
  - validation and construction of `Date`, `TimeOfDay`, and `DateTime`,
  - Unix epoch conversions (days/seconds/nanoseconds),
  - strict ISO formatting/parsing helpers.

## Clock APIs (Initial Design)

The language examples use `std::now()`; the stdlib should make the clock source
explicit:

`std::temporal` currently exposes only a monotonic clock read:

Notes:

- `now_monotonic()` must be monotonic (not subject to wall-clock adjustments).
- Sleeping is exposed via `std::task` (`sleep` / `sleep_until`) in the current
  stdlib.

## Duration Helpers

`Duration` literals exist at the language level. The stdlib adds helpers such
as:

- `to_millis(d)`, `to_secs(d)`
- checked arithmetic (`checked_add`, `checked_mul`) where overflow behavior
  needs to be explicit.

## Future Work

- Wall-clock time (`now_utc`, `now_local`) via higher-level wrappers on top of
  `std::runtime::time::unix_now_ns` / `unix_now_ms`.
- Time zones and DST rules (separate module layered on top of `DateTime`).
- Richer formatting/parsing (locale-aware, RFCs) layered on top of `std::fmt`.

==============================================================================
DOCS: `std::test` (std/test)
URL: /silk/docs/?p=std/test
==============================================================================

# `std::test`

record test failures without aborting the process.

These helpers are intended to be used under `silk test` and integrate with the

Each helper also carries a Formal Silk contract requiring `BUILD_MODE == "test"`
via `std::formal.requires_test_mode()` so downstream verification can model
them as test-only APIs.

## Public API

### `expect`

```silk
expect(ok: bool, message: string? = None);
```

Semantics:

- When `ok` is `true`, `expect` does nothing.
- When `ok` is `false`, `expect` records a test failure.
  - When `message` is `Some(...)`, it is used as the failure message.
  - When `message` is `None`, the default message is `"expect failed"`.

### `expect_equal`

```silk
fn (X, Y) expect_equal (expected: X, actual: Y) -> bool;
```

Semantics:

- Returns `true` when `expected == (actual as X)` and records no failure.
- Returns `false` when `expected != (actual as X)` and records a failure.

Note: in Silk, equality must be supported for the
concrete instantiated types used at the call site.

### `expect_error`

```silk
fn (E) expect_error (err: E?) -> bool;
```

Semantics:

- Returns `true` when `err` is `Some(...)`.
- Returns `false` when `err` is `None` and records a failure.

==============================================================================
DOCS: `std::tls` (std/tls)
URL: /silk/docs/?p=std/tls
==============================================================================

# `std::tls`

primitives for the hosted POSIX baseline using the system `mbedTLS` shared
libraries.

The initial goals are:

- a small but usable `std::tls` session API for clients and servers,
- a transport-agnostic I/O model so TLS can be layered over `std::net::TcpStream`
  or custom runtimes,
- end-to-end runnable tests that do not depend on real sockets (to keep the
  test suite runnable in sandboxed environments).

## Linkage and Toolchain Integration

On `linux/x86_64` with the glibc dynamic loader (`ld-linux`), `silk build`
automatically adds `libmbedtls.so.14` as a `DT_NEEDED` dependency when a program
imports `mbedtls_*` extern symbols (for example via `import std::tls;`).

Because `libmbedtls.so.14` declares `DT_NEEDED` dependencies on
`libmbedx509.so.1` and `libmbedcrypto.so.7`, downstream users typically do not
need to list those libraries explicitly.

## API

### Error model

The current `std::tls` API uses `std::result::Result(T, E)` and a stable
`TlsFailed` error value instead of exposing raw mbedTLS error codes.

TLS I/O is transport-driven: when using a non-blocking transport (such as
`MemPipe`), operations may report that they would block and must be retried.
This is surfaced as a `TlsFailed` whose `kind()` is:

- `TlsErrorKind::WouldBlockRead`
- `TlsErrorKind::WouldBlockWrite`

Public error/value types in Silk:

```silk
module std::tls;

import std::result;

enum TlsErrorKind {
  OutOfMemory,
  InvalidInput,
  BadCertificate,
  BadPrivateKey,
  ConfigFailed,
  SetupFailed,
  WouldBlockRead,
  WouldBlockWrite,
  TlsFailure,
  Unknown,
}

export error TlsFailed {
  code: int,
}

export type TlsIntResult = std::result::Result(int, TlsFailed);
export type SessionResult = std::result::Result(Session, TlsFailed);
```

### `Session`

`Session` is a TLS state machine configured as either a client or a server.

Key operations:

- `Session.client() -> SessionResult` — create a client session with a default
  configuration suitable for tests.
- `Session.server(cert_pem: string, key_pem: string) -> SessionResult` — create
  a server session using PEM-encoded certificate and private key.
- `set_bio_mempipe(bio: u64) -> void` — attach a `MemPipe` endpoint context via
  mbedTLS `ssl_set_bio` using `std::tls::mem_send` and `std::tls::mem_recv`.
- `set_bio_fd(fd: int) -> void` — attach a hosted POSIX file descriptor as the
  underlying stream transport (for example a `std::net::TcpStream` socket).
- `handshake_step() -> TlsIntResult` — advance the handshake state machine by
  one call (returns `Ok(0)` when complete; `Err(...)` on error).
- `read(buf: std::arrays::ByteSlice) -> TlsIntResult` — read decrypted
  application bytes.
- `write(buf: std::arrays::ByteSlice) -> TlsIntResult` — write application
  bytes.
- `write_all(buf: std::arrays::ByteSlice) -> TlsFailed?` — write all
  application bytes (retries internally on `WouldBlockRead` /
  `WouldBlockWrite`).
- `write_string(s: string) -> TlsFailed?` — convenience helper over
  `write_all`.
- `close_notify() -> TlsFailed?` — send a TLS close-notify alert.

`Session` implements `std::interfaces::Drop` and releases all associated mbedTLS
state on drop.

### `MemPipe`

`MemPipe` is an in-memory transport used for tests and for embedding scenarios
where the TLS peer-to-peer byte stream is modeled explicitly.

It provides two endpoint context pointers:

- `client_ctx() -> u64`
- `server_ctx() -> u64`

These pointers can be passed to `Session.set_bio_mempipe(...)`.

## Notes and Limitations ()

- The current `std::tls` API is intentionally small; higher-level features
  (hostname verification, CA stores, ALPN, session resumption, etc.) will be
  specified and implemented as the language and stdlib grow.
- The  wires `Session` to transports via `MemPipe` and hosted
  POSIX file descriptors (`set_bio_fd`). General user-provided transport
  callbacks are planned but require additional FFI expressiveness beyond the
  current compiler subset.
- The initial tests use `MemPipe` instead of real sockets so `make test` can run
  in environments where `socket(2)` is restricted.

==============================================================================
DOCS: `std::toml` (std/toml)
URL: /silk/docs/?p=std/toml
==============================================================================

# `std::toml`

builds an index-based DOM suitable for the compiler.

Primary goals:

- Correct, spec-driven parsing of TOML v1.0 documents:
  - key/value pairs,
  - dotted keys,
  - tables (`[table]`) and array-of-tables (`[[table]]`),
  - strings, integers, floats, booleans, datetimes, arrays, inline tables.
- A memory model that works well with the :
  - parse produces an index-based DOM stored inside a `Document`,
  - arrays/tables are represented via integer “next” links (no `&T` struct
    fields).
- High performance by default:
  - **borrowed parsing** avoids allocating for simple strings/numbers by slicing
    into the input string,
  - allocations are only performed for escaped strings and for owned parsing.

## Data Model

The DOM is represented by an index table owned by a `Document`:

- A `Document` owns:
  - node tables (`tag`, payload fields, sibling links),
  - optional owned allocations for decoded strings and owned lexemes.
- TOML values are referred to by `ValueId` (an `i64` node index).

Tables store a linked list of `member` nodes (key/value pairs). Arrays store a
linked list of element nodes.

## Strings

- Basic strings (`"..."`) support TOML escapes including Unicode `\\uXXXX` /
  `\\UXXXXXXXX`.
- Literal strings (`'...'`) do not interpret escapes.
- Multiline basic/literal strings (`\"\"\"...\"\"\"` and `'''...'''`) are parsed,
  including TOML’s line-ending normalization rules.

Parsed string values are exposed as UTF-8 `string` views:

- when the source contains no escapes and borrowed parsing is used, the string
  view points into the input (zero-copy),
- otherwise, decoded bytes are stored in an owned allocation tracked by the
  `Document`.

## Numbers

`std::toml` preserves numeric lexemes as `string` views and provides helpers to
interpret them as `i64` and/or `f64` when needed:

- integers support `_` separators and `0x`/`0o`/`0b` bases,
- floats support `_` separators, fractional/exponent forms, and special values.

## Datetimes

TOML datetime values are preserved as lexeme `string` views. A future version
of `std::toml` will integrate with `std::temporal` once the necessary
infrastructure is stable.

## Parsing

Two parse modes are provided as `Document` methods:

- **Borrowed**: `doc.parse(s)` borrows unescaped strings and numeric/datetime
  lexemes from `s`. The caller must ensure `s` outlives any `string` views read
  from `doc`.
- **Owned**: `doc.parse_owned(s)` copies all strings and lexemes into allocations
  tracked by `doc` (independent of `s`).

Both methods:

- clear the `Document` first,
- return `ParseResult` (`Ok(root)` on success, `Err(ParseError)` on error),
- and record the result on the `Document`:
  - `doc.is_ok()` reports success,
  - `doc.root_value()` returns the root `ValueId` on success,
  - `doc.err` contains the parse error details (`kind`, byte `offset`, and 1-based `line`/`column`).

Allocation failures are also reported as ordinary parse errors:

- on out-of-memory, parse returns `Err(ParseError{ kind: ERR_OUT_OF_MEMORY, ... })` and sets
  `doc.err.kind` to `ERR_OUT_OF_MEMORY`.

In the current executable backend subset, `Document` is typically
used as a heap reference:

```silk
import std::toml;

let mut doc: &Document = new Document();
let root_r: std::toml::ParseResult = (mut doc).parse(`a = 1`);
```

## Planned Follow-ups

- Streaming tokenization (SAX-style) for very large inputs.
- Canonical TOML emission/serialization once the DOM/query surface stabilizes.
- Rich datetime parsing and integration with `std::temporal`.

==============================================================================
DOCS: `std::unicode` (std/unicode)
URL: /silk/docs/?p=std/unicode
==============================================================================

# `std::unicode`


This module provides practical Unicode helpers focused on:

- code point classification (whitespace, identifier rules, casing metadata),
- surfaces that are easy to support in Silk.


## API

```silk
module std::unicode;

export fn is_white_space (c: char) -> bool;
export fn is_id_start (c: char) -> bool;
export fn is_id_continue (c: char) -> bool;

export fn is_cased (c: char) -> bool;
export fn is_case_ignorable (c: char) -> bool;
```

Notes:

- These helpers classify a single Unicode scalar value (`char`).
- String-level Unicode features (normalization, grapheme segmentation, etc.)
  are future work and require UTF-8 decoding APIs.

## Related Documents

==============================================================================
DOCS: `std::url` (std/url)
URL: /silk/docs/?p=std/url
==============================================================================

# `std::url`


This module focuses on:

- WHATWG URL parsing (absolute and relative-with-base).
- Canonical URL serialization (`href`) and origin serialization (`origin`).
- Host parsing (domain / IPv4 / IPv6 / opaque) and percent-encoding sets.
- URLSearchParams-style query parsing and mutation.

## Public API

### Parsing

- `parse(input: string) -> URLResult`
  - Parses an absolute URL (requires a scheme).
- `parse_with_base(input: string, base: &URL) -> URLResult`
  - Parses `input` as a URL relative to `base` using WHATWG relative resolution rules.

`URLResult` is `std::result::Result(URL, ParseError)`:

- `Ok(URL)` on success.
- `Err(ParseError)` on error.

Since `URL` owns heap allocations and implements `std::interfaces::Drop`, prefer
`match (r)` to extract values rather than `URLResult.ok_value(r)` /
`URLResult.err_value(r)`.

`ParseError.offset` is a byte offset into the sanitized input:

- leading/trailing ASCII whitespace is trimmed,
- ASCII tab/newline bytes are stripped (`\\t`, `\\n`, `\\r`).

`ParseError.kind` is one of the exported `ERR_*` constants. Use `error_message(kind)` to format a human-readable message.

Note: there is also a convenience method `URL.parse(input: string) -> URLResult`
which forwards to `std::url::parse`.

### URL record

`URL` is an owned URL record with accessor methods:

- `URL` owns heap allocations and implements `std::interfaces::Drop`; it is
  released automatically at scope exit and may also be dropped explicitly via
  `(mut url).drop()`.
- `href() -> std::result::Result(std::strings::String, std::memory::OutOfMemory)` — canonical serialization of the full URL.
- `origin() -> std::result::Result(std::strings::String, std::memory::OutOfMemory)` — serialized origin (opaque origins serialize as `"null"`).
- `scheme() -> string`
- `username() -> string`
- `password() -> string`
- `host() -> string?` — hostname (no port); `None` for null hosts.
- `port() -> int?`
- `path() -> string`
- `query() -> string?` — query without `?`.
- `fragment() -> string?` — fragment without `#`.

### URLSearchParams

`URLSearchParams` stores a URL-encoded query string and exposes common operations:

- `URLSearchParams` owns its query buffer and implements `std::interfaces::Drop`.
- `URLSearchParams.empty() -> URLSearchParams`
- `URLSearchParams.from_string(s: string) -> std::result::Result(URLSearchParams, std::memory::OutOfMemory)`
  - Accepts either `"a=b&c=d"` or `"?a=b&c=d"`.
- `to_string() -> std::result::Result(std::strings::String, std::memory::OutOfMemory)` — the encoded query string (no leading `?`).
- `len() -> i64` — number of fields.
- `has(name: string) -> std::result::Result(bool, std::memory::OutOfMemory)`
- `get(name: string) -> std::result::Result(std::strings::String?, std::memory::OutOfMemory)` — decoded value (`Ok(Some(value))`), `Ok(None)` when absent, or `Err(OutOfMemory)`.
- `append(name: string, value: string) -> std::memory::OutOfMemory?`
- `delete(name: string) -> std::memory::OutOfMemory?`
- `set(name: string, value: string) -> std::memory::OutOfMemory?`
- `sort() -> std::memory::OutOfMemory?` — stable sort by decoded name, then re-serialize.

## Notes

- This module does not implement the JavaScript `URL` object API (setters, live `searchParams` binding, etc.); it provides a low-level URL record plus helpers that follow the WHATWG parsing and serialization rules.

==============================================================================
DOCS: `std::uuid` (std/uuid)
URL: /silk/docs/?p=std/uuid
==============================================================================

# `std::uuid`

identifier primitive with full support for UUID versions **1, 3, 4, 5, 6, 7,
and 8** (RFC 4122 + RFC 9562 family).

Goals:

- a small, auditable implementation (no external dependencies required for
  parsing/formatting and name-based UUIDs),
- explicit constructors for each UUID version,
- ergonomic helpers (parse, format, version/variant inspection),
- Formal Silk contracts for buffer and shape preconditions.

## Representation

`UUID` is represented as two `u64` words:

- `hi`: the first 8 bytes (bytes 0..7) in network order,
- `lo`: the last 8 bytes (bytes 8..15) in network order.

This matches the canonical string form:

`xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`

where the leftmost hex pairs correspond to lower byte indices.

## Parsing and Formatting

The current API supports:

- parsing:
  - canonical hyphenated form (`8-4-4-4-12` hex digits),
  - optional surrounding braces (`{...}`),
  - optional `urn:uuid:` prefix,
- formatting:
  - canonical hyphenated lowercase string form.

API notes:

- `std::uuid::parse(s: string) -> std::uuid::ParseResult` returns
  `Ok(UUID)` on success, otherwise `Err(ParseError)`.
  - `ParseError.kind()` reports a stable error kind.
  - `ParseError.offset` reports the byte offset into the original input string.
- `UUID.to_string_lower() -> Result(String, OutOfMemory)` allocates an owned
  string.

## Version and Variant

- `UUID.version()` returns the 4-bit version field (0..15).
- `UUID.is_rfc4122()` checks the RFC 4122/RFC 9562 variant (`10xx` in the
  variant field).

## Supported Versions

The std surface provides constructors for:

- **v1**: time-based (Gregorian epoch, 100ns ticks) with `{ timestamp_100ns,
  clock_seq, node }` inputs.
- **v3**: name-based (MD5 over `namespace || name`).
- **v4**: random-based (122 random bits + version/variant bits).
- **v5**: name-based (SHA-1 over `namespace || name`).
- **v6**: reordered time-based (same inputs as v1; timestamp bits reordered for
  lexical sorting).
- **v7**: Unix-epoch time-based (48-bit milliseconds + 74 random bits).
- **v8**: custom (caller-provided 128-bit value with version/variant applied).

Fallibility:

- `std::uuid::{v1,v3,v5,v6,v7}` return `std::uuid::UUIDResult` (`Result(UUID, UUIDFailed)`).
- `std::uuid::timestamp_100ns_from_unix_ns` returns `Result(u64, UUIDFailed)` and
  may fail with `Overflow`.
- `std::uuid::random::*` returns `std::uuid::UUIDResult` and may fail due to
  `InitFailed` (libsodium) or `NoTime` (missing clock).

`std::uuid::random` also provides `v1_now` / `v6_now` / `v7_now` using
`std::runtime::time::unix_now_ns` / `unix_now_ms` so callers can generate UUIDs
without passing explicit timestamps.


- richer formatting options (uppercase, simple hex, braced form, URN form),
- UUIDv2 (DCE Security) if/when `std::process` exposes stable UID/GID APIs.

==============================================================================
DOCS: `std::vector` (std/vector)
URL: /silk/docs/?p=std/vector
==============================================================================

# `std::vector`

vector type `Vector(T)` used broadly across `std::`.

`Vector(T)` is an owning container with:

- a contiguous heap allocation,
- a logical length (`len`), and
- a capacity (`cap`) in elements.

the compiler uses a conservative scalar-slot memory model
for most scalar values; `std::vector` is specified in terms of the logical
element type `T`, not a stable packed byte layout. In particular, in the
 `Vector(T)` stores elements using the scalar-slot
layout of `T` (each slot is 8 bytes). Each element occupies `sizeof(T)` bytes
(a multiple of 8 in Silk), so multi-slot values like `string` and
non-opaque structs/enums are supported. This is still not a packed byte
representation: for example `sizeof(u8) == 8` in Silk, so
`Vector(u8)` stores one byte per 8-byte slot. Use `std::buffer::BufferU8` when
packed bytes matter.

Where byte-exact layout matters (I/O buffers, strings), the stdlib uses
`std::buffer::BufferU8`, a packed byte buffer whose `ptr` points to
byte-addressed memory and whose `len`/`cap` are in bytes.

See also:


## Current API

```silk
module std::vector;

import std::arrays;
import std::interfaces;

struct Vector(T) {
  ptr: u64,
  cap: i64,
  len: i64,
}

impl Vector(T) {
  public fn init (cap: i64) -> std::result::Result(Vector(T), std::memory::AllocFailed);
  public fn empty () -> Vector(T);
  public fn push (mut self: &Vector(T), value: T) -> std::memory::OutOfMemory?;
  public fn pop (mut self: &Vector(T)) -> T?;
  public fn get (self: &Vector(T), index: i64) -> T;
  public fn set (mut self: &Vector(T), index: i64, value: T) -> void;
  public fn at (self: &Vector(T), index: i64) -> T?;
  public fn try_set (mut self: &Vector(T), index: i64, value: T) -> bool;
  public fn swap_remove (mut self: &Vector(T), index: i64) -> T?;
  public fn extend_from_slice (mut self: &Vector(T), s: std::arrays::Slice(T)) -> std::memory::OutOfMemory?;
  public fn as_slice (self: &Vector(T)) -> std::arrays::Slice(T);
  public fn iter (self: &Vector(T)) -> std::arrays::SliceIter(T);
}

impl Vector(T) as std::interfaces::Len {
  public fn len (self: &Vector(T)) -> i64;
}

impl Vector(T) as std::interfaces::Capacity {
  public fn capacity (self: &Vector(T)) -> i64;
}

impl Vector(T) as std::interfaces::IsEmpty {
  public fn is_empty (self: &Vector(T)) -> bool;
}

impl Vector(T) as std::interfaces::Clear {
  public fn clear (mut self: &Vector(T)) -> void;
}

impl Vector(T) as std::interfaces::ReserveAdditional {
  public fn reserve_additional (mut self: &Vector(T), additional: i64) -> std::memory::OutOfMemory?;
}

impl Vector(T) as std::interfaces::Drop {
  public fn drop (mut self: &Vector(T)) -> void;
}
```

Notes:

- `Vector(T)` is intentionally low-level in Silk:
  - `init(cap)` returns `Err(AllocFailed)` when allocation fails or when `cap`
    is invalid.
  - prefer `Vector.empty()` over `Vector.init(0)` for a clear “default” constructor.
  - growth paths (`reserve_additional`, `push`, `extend_from_slice`) surface
    allocation failure as `std::memory::OutOfMemory?` (including internal size
    arithmetic overflow; leaves the vector unchanged on failure).
- Bounds checks are expressed as `#require` contracts (and reusable `std::formal`
  theories) for verifier tooling; they are not runtime checks in the current
  compiler subset.
- `at` / `try_set` are “checked” accessors:
  - `at` returns `None` when `index` is out of bounds,
  - `try_set` returns `false` when `index` is out of bounds.
- `swap_remove` removes an element by swapping in the last element (O(1), order not preserved).

==============================================================================
DOCS: `std::websocket` (std/websocket)
URL: /silk/docs/?p=std/websocket
==============================================================================

# `std::websocket`

WebSocket implementation on top of `std::net::TcpStream` (client + server
handshake, framing, ping/pong, close, fragmentation).

See also:

- RFC 6455: The WebSocket Protocol (wire format + handshake)

## Overview

`std::websocket` is a protocol layer that upgrades an HTTP/1.1 connection to a
WebSocket and then sends/receives WebSocket frames.

Design goals (current implementation):

- Work for hosted POSIX builds using `std::net`.
- Be fully interoperable with other WebSocket implementations (browsers,
  Node.js, etc.) for the supported feature set:
  - version 13 handshake,
  - masked client→server frames,
  - unmasked server→client frames,
  - fragmentation and continuation frames,
  - ping/pong, close.
- Provide a small, blocking server that accepts one connection at a time.

Non-goals (for now):

- HTTP server integration beyond the upgrade handshake (no HTTP routing layer).
- TLS (`wss://`) integration (use `std::tls` + a future adapter layer).
- Per-message compression (RSV1 / `permessage-deflate`).

## Public API

```silk
module std::websocket;

import std::net;
import std::arrays;
import std::result;
import std::strings;

// Message opcodes (subset).
export let OPCODE_TEXT: int = 1;
export let OPCODE_BINARY: int = 2;

// Handshake errors.
export let ERR_HANDSHAKE_IO: int = 1;
export let ERR_HANDSHAKE_TOO_LARGE: int = 2;
export let ERR_HANDSHAKE_BAD_REQUEST: int = 3;
export let ERR_HANDSHAKE_MISSING_KEY: int = 4;
export let ERR_HANDSHAKE_BAD_VERSION: int = 5;
export let ERR_HANDSHAKE_BAD_ACCEPT: int = 6;
export let ERR_HANDSHAKE_OUT_OF_MEMORY: int = 7;

export error HandshakeError {
  kind: int,
}

export type WebSocketResult = std::result::Result(WebSocket, HandshakeError);
export type WebSocketServerResult = std::result::Result(WebSocketServer, HandshakeError);

// Protocol/runtime errors during frame processing.
export let ERR_PROTOCOL_IO: int = 1;
export let ERR_PROTOCOL_CLOSED: int = 2;
export let ERR_PROTOCOL_BAD_FRAME: int = 3;
export let ERR_PROTOCOL_TOO_LARGE: int = 4;
export let ERR_PROTOCOL_OUT_OF_MEMORY: int = 5;

export error ProtocolError {
  kind: int,
}

export type MessageResult = std::result::Result(Message, ProtocolError);

struct Message {
  opcode: int,              // OPCODE_TEXT or OPCODE_BINARY
  data: std::strings::String, // owned bytes (UTF-8 for text)
}

struct WebSocket {
  // opaque handle
}

impl WebSocket {
  // Server-side: perform the HTTP upgrade handshake on an accepted TCP stream.
  public fn accept (stream: std::net::TcpStream) -> WebSocketResult;

  // Client-side: connect and perform the HTTP upgrade handshake.
  public fn connect (addr: SocketAddrV4, host: string, path: string) -> WebSocketResult;

  public fn is_valid (self: &WebSocket) -> bool;
  public fn close (mut self: &WebSocket) -> ProtocolError?;

  // Read the next complete application message (text or binary).
  // Ping frames are answered automatically and do not surface as messages.
  public fn read_message (mut self: &WebSocket) -> MessageResult;

  // Send a single unfragmented message.
  public fn write_text (self: &WebSocket, text: string) -> ProtocolError?;
  public fn write_bytes (self: &WebSocket, bytes: std::arrays::ByteSlice) -> ProtocolError?;
}

struct WebSocketServer {
  // opaque handle
}

impl WebSocketServer {
  public fn listen (addr: SocketAddrV4, backlog: int) -> WebSocketServerResult;
  public fn is_valid (self: &WebSocketServer) -> bool;
  public fn local_port (self: &WebSocketServer) -> std::net::NetIntResult;
  public fn accept (mut self: &WebSocketServer) -> WebSocketResult;
  public fn close (mut self: &WebSocketServer) -> HandshakeError?;
}
```

Notes:

- This API is currently **blocking**.
- Handle types wrap OS resources; avoid copying `WebSocket` / `WebSocketServer`
  values until the language has move-only handles.

## Protocol Rules Enforced

The implementation enforces the following RFC 6455 requirements:

- Client→server frames **must** be masked; server→client frames **must not** be masked.
- Reserved bits (RSV1/2/3) must be zero (compression/extensions are not supported).
- Control frames (ping/pong/close):
  - are not allowed to be fragmented (`FIN = 1`),
  - must have payload length ≤ 125.
- Close frames trigger an attempted close reply and then the connection is
  treated as closed from the API’s perspective.

==============================================================================
DOCS: ECMAScript FFI (`std::js::ecma`) (std/js-ecma)
URL: /silk/docs/?p=std/js-ecma
==============================================================================

# ECMAScript FFI (`std::js::ecma`)


This module defines a small, environment-agnostic interface for interacting
with an ECMAScript engine from Silk.

Scope constraints:

- **ECMAScript only**: this module intentionally exposes **no** DOM/Web APIs, no
  Node.js APIs, and no host-environment globals beyond what ECMAScript itself
  requires to exist on the global object.
- It is intended as a shared substrate for future tooling such as `silk bindgen`
  (for example: **Web IDL → Silk** bindings when targeting WASM and calling out
  to a JavaScript host).

## High-Level API

The public Silk surface is centered around:

- `Context` — an execution context / realm handle.
- `Value` — a JS value handle (primitives and objects).
- `Error` — a typed error representing host failures or thrown JS exceptions.

The API is intentionally minimal but ergonomic:

- obtain a default context (`Context.default_ctx()`),
- access the global object (`ctx.global()`),
- get/set properties (`ctx.get(obj, name)`, `ctx.set(obj, name, value)`),
- call functions and constructors (`ctx.call(...)`, `ctx.construct(...)`),
- convert common primitives (`ctx.bool(...)`, `ctx.f64(...)`, `ctx.string_utf8(...)`),
- convert values to UTF‑8 (`ctx.to_utf8_string(value)`).

## Naming Conventions (camelCase vs snake_case)

JavaScript global objects use `camelCase` naming conventions for functions and
methods, but Silk style is `snake_case`.

`std::js::ecma` exposes `snake_case` names for JavaScript intrinsics.
Additionally, acronyms within a method name are all lower case. For example,
JavaScript `decodeURI` is exposed as Silk `decode_uri`.

## `js_sys`-Modeled Surface (ECMAScript Intrinsics)

On top of the minimal `Context`/`Value`/`Error` API, `std::js::ecma` provides
names for common ECMAScript-standard globals (modeled after Rust’s `js_sys`).

Important constraints:

- **No environment APIs**: no DOM/Web APIs, no Node.js APIs, and no other
  host-specific globals.
- These bindings are intentionally shallow: they define stable names and small
  helpers; most behavior is accessed via `get`/`call` against the underlying JS
  values.

### Provided Names

Modules / global objects:

- `Atomics`
- `Intl`
- `JSON`
- `Math`
- `Reflect`
- `WebAssembly` (when provided by the host)

Struct-style JS value wrappers:

- `Array`, `Object`, `Function`, `Number`, `Boolean`, `Symbol`, `JsString`
- `Promise`, `Proxy`
- `Map`, `Set`, `WeakMap`, `WeakSet`, `WeakRef`
- `RegExp`, `Date`
- `Error`, `EvalError`, `RangeError`, `ReferenceError`, `SyntaxError`,
  `TypeError`, `UriError`
- `ArrayBuffer`, `SharedArrayBuffer`, `DataView`
- Typed arrays: `Int8Array`, `Int16Array`, `Int32Array`, `Uint8Array`,
  `Uint8ClampedArray`, `Uint16Array`, `Uint32Array`, `Float32Array`,
  `Float64Array`, `BigInt64Array`, `BigUint64Array`
- BigInt: `BigInt`
- Iteration protocol: `Iterator`, `IteratorNext`, `Iter`, `IntoIter`,
  `ArrayIter`, `ArrayIntoIter`, `AsyncIterator`, `Generator`
- Conversion placeholder: `TryFromIntError`

Global functions (snake_case):

- `decode_uri`, `decode_uri_component`
- `encode_uri`, `encode_uri_component`
- `escape`, `unescape`
- `eval`
- `global`
- `is_finite`
- `parse_float`, `parse_int`
- `try_iter`

## The “Silk Ext JavaScript Standard Interface”

This std module is implemented on top of a required set of `ext` symbols that
must be provided by the embedding environment.

Two common implementation strategies:

- **WASM host**: provide the symbols as imported wasm functions (the compiler
  maps `ext foo = ...;` to `env.foo`).
- **Native embedder**: provide the symbols in a linked library that uses an
  engine such as JavaScriptCore, QuickJS, or V8.

### Handle Model

All handles are represented as `u64` at the ABI boundary:

- `ctx: u64` — a context handle (must be non-zero).
- `value: u64` — a value handle (must be non-zero).

`0` is reserved as an invalid handle and is used as the failure sentinel for
`u64`-returning operations.

Implementers define the concrete meaning of handles (pointers, indices into a
table, tagged integers, etc.) but MUST keep them stable for as long as the
handle is “retained” by Silk.

### Error Reporting Contract

Operations that can fail either:

- return `0` (for `u64` results), or
- return non-zero (for `int` results),

and in that case the implementation MUST set a per-context “last error” record
retrievable via `silk_js_error_code` / `silk_js_error_take_exception`.

Error codes are stable integers:

- `0` — no error / unknown (should not be observed after a failing call)
- `1` — a JS exception was thrown (`silk_js_error_take_exception` returns the thrown value)
- `2` — out of memory / allocation failure in the host
- `3` — invalid handle / wrong realm / misuse detected by the host
- `4` — not implemented by this host

Notes:

- For iterator helpers (e.g. `try_iter`), implementations SHOULD return a
  canonical, stable handle for `undefined` and `null` per-context so equality
  checks against `silk_js_undefined` / `silk_js_null` work as expected.

### Required External Symbols (v0)

These symbols are required by `std::js::ecma` (external names are fixed
and stable):

```silk
// Context / lifetime
ext silk_js_ctx_default = fn () -> u64;
ext silk_js_retain = fn (u64, u64) -> void;
ext silk_js_release = fn (u64, u64) -> void;

// Error retrieval (after a failing call)
ext silk_js_error_code = fn (u64) -> int;
ext silk_js_error_take_exception = fn (u64) -> u64;

// Common primitives
ext silk_js_undefined = fn (u64) -> u64;
ext silk_js_null = fn (u64) -> u64;
ext silk_js_bool = fn (u64, bool) -> u64;
ext silk_js_i64 = fn (u64, i64) -> u64;
ext silk_js_f64 = fn (u64, f64) -> u64;
ext silk_js_string_utf8 = fn (u64, string) -> u64;

// Global + property access
ext silk_js_global = fn (u64) -> u64;
ext silk_js_get = fn (u64, u64, string) -> u64;
ext silk_js_set = fn (u64, u64, string, u64) -> int;

// Calls
ext silk_js_call = fn (u64, u64, u64, u64, i64) -> u64;
ext silk_js_construct = fn (u64, u64, u64, i64) -> u64;

// String extraction
ext silk_js_to_string = fn (u64, u64) -> u64;
ext silk_js_string_utf8_len = fn (u64, u64) -> i64;
ext silk_js_string_utf8_write = fn (u64, u64, u64, i64) -> i64;
```

Notes:

- In Silk, passing a Silk `string` to `ext` lowers as a
  NUL-terminated `const char *`. Therefore `silk_js_string_utf8` expects UTF‑8
  without embedded NUL bytes.
- The `*_write` function copies **raw UTF‑8 bytes** (no NUL terminator) into the
  destination buffer and returns the number of bytes written.

## Future Work

Expected follow-ups as `silk bindgen` becomes concrete:

- richer conversions (arrays, maps, typed arrays / `ArrayBuffer` via a separate
  environment-specific layer),
- promise integration (job queue hooks),
- structured cloning / JSON convenience helpers on top of ECMAScript intrinsics,
- a codegen layer that maps Web IDL types onto `std::js::ecma` calls.

==============================================================================
DOCS: Standard Library Overview (`std::`) (std/overview)
URL: /silk/docs/?p=std/overview
==============================================================================

# Standard Library Overview (`std::`)

intended API and structure. A minimal in-tree stdlib source tree also
exists under `std/` (used by the toolchain to satisfy `import std::...;`).

As of the compiler, the in-tree stdlib includes a
small but functional set of utilities implemented purely in Silk (including
monomorphized, type-parameter generics for core collection types),
plus a tiny hosted POSIX baseline for OS-facing modules (`std::fs`, `std::task`,
`std::sync`, `std::io`) implemented via the `std::runtime` interface layer
(the shipped POSIX runtime backend uses `ext` and therefore requires linking
libc for executable outputs).

The Silk standard library, `std::`, provides foundational functionality built
on top of the language core (regions, buffers, concurrency, etc.). It is intended
to be:

- **Linked by default** for normal builds driven by `silk`.
- **Swappable**: an alternative `std::` implementation can be selected at build
  time, without changing the language or the C ABI.
- **POSIX-first** for OS interactions (initial hosted baseline), while still
  supporting freestanding/embedded builds via a smaller “core” subset.

See also:


## Core Areas (Initial)

These are the minimum required areas for the initial standard library
distribution:

- `std::buffer` — typed, width-oriented buffer utilities built on top of
- `std::strings` — UTF-8 text utilities and owned string building.
- `std::math` — linear algebra utilities (vectors/matrices) for graphics and
- `std::crypto` — cryptography primitives (hosted baseline via libsodium; see
- `std::uuid` — UUID primitives (v1/v3/v4/v5/v6/v7/v8) with parsing/formatting
- `std::semver` — Semantic Versioning (SemVer 2.0.0) parsing and precedence
- `std::json` — JSON parsing and stringifying (borrowed and owned DOM parsing;
- `std::toml` — TOML parsing (borrowed and owned DOM parsing;
- `std::memory` — allocation interfaces and low-level memory utilities.
- `std::arrays` — slice/view types and helpers for fixed arrays.
- `std::bits` — bit manipulation helpers (byte swaps, rotates, bit counts; see
- `std::vector` — typed growable vectors (`Vector(T)`), used broadly across
- `std::map` — associative containers (hash maps and ordered maps; see
- `std::set` — set containers (hash sets and ordered sets; see
- `std::algorithms` — common algorithms over slices/collections.
- `std::temporal` — `Instant`/`Duration` utilities and calendar/time helpers.
- `std::readline` — interactive line editor for CLI programs (TTY mode) built on
- `std::io` — basic I/O (readers/writers, formatting, stdout/stderr).
- `std::fmt` — shared formatting layer used by `std::io` and string builders.
- `std::fs` — filesystem access (POSIX baseline).
- `std::net` — networking primitives (POSIX baseline).
- `std::http` — HTTP/1.1 parsing + blocking client/server on top of `std::net`
- `std::https` — HTTPS (HTTP over TLS) on top of `std::tls` + `std::net`
- `std::websocket` — RFC 6455 WebSocket (handshake + framing) on top of `std::net`
- `std::tls` — TLS client/server primitives (POSIX baseline via mbedTLS; see
- `std::ssh2` — SSH2 client primitives (POSIX baseline via libssh2; see
- `std::sqlite` — SQLite database primitives (POSIX baseline via SQLite; see
- `std::interfaces` — shared std interface contracts (“protocols”) such as
- `std::formal` — reusable Formal Silk theories (“standard lemmas”) used by

corresponding language doc). The exact shapes of types and functions will
evolve as the language and backend grow; these docs are the source of truth for
the intended `std::` surface.

==============================================================================
DOCS: Web IDL (`std::idl::web`) (std/idl-web)
URL: /silk/docs/?p=std/idl-web
==============================================================================

# Web IDL (`std::idl::web`)


This module provides a Web IDL parser plus an ergonomic, query-oriented API for
inspecting the parsed document.

The long-term goal is to support bidirectional binding generation:

- **Web IDL → Silk**: generate Silk APIs for DOM / JavaScript environments (for
  example when targeting WASM and calling out to JavaScript host APIs).
- **Silk → JS bindings**: generate JavaScript glue for Silk-defined interfaces
  (when embedding Silk/WASM in JS runtimes).

This first slice focuses on a stable, testable parsing substrate that can be
grown as `silk bindgen` work lands.

## Design Goals

- **Lossless enough for bindgen**: preserve source spans for identifiers and
  raw values so downstream tools can generate bindings and diagnostics.
- **Ergonomic queries**: parse once, then ask the document for interfaces,
  members, argument lists, and types via IDs and ranges (no recursion required
  for common workflows).
- **Compact storage**: avoid heavyweight allocation patterns; store
  parsed data in compact slot vectors (`std::vector::Vector(i64)`).

## High-Level API

- `std::idl::web::parse(source: string) -> Result(Document, ParseError)`
- `std::idl::web::parse_owned(source: std::strings::String) -> Result(Document, ParseError)`
- `Document` owns the (copied or moved) source text and stores all parsed spans
  as offsets into that owned source.

## Parse Errors

`ParseError` reports:

- `code: int` (stable kind code), and `kind() -> ParseErrorKind` / `message() -> string`,
- `offset: i64` (byte offset), `line: i64` / `column: i64` (1-based),
- `requested: i64` (non-zero only for `OutOfMemory`).

The `Document` API exposes:

- definition iteration (`def_count`, `def_kind`, `def_name`, `def_members`, …)
- member inspection (`member_kind`, `member_name`, `member_type`, …)
- type inspection (`type_kind`, `type_name`, `type_children`, …)
- extended attributes (`extattr_name`, `extattr_value`, …)

All names and raw values are represented as `SpanId`s that can be rendered to
`string` views via `Document.span_text(span_id)`.

## Current Grammar Coverage (Initial)

Designed as a **lenient** parser that can preserve and skip unknown
constructs:

- Extended attributes: `[Attr, Attr=Value, Attr(Args)]` (value captured as a raw span)
- Top-level definitions:
  - `interface`, `partial interface`, `interface mixin`
  - `dictionary`, `partial dictionary`
  - `enum`
  - `typedef`
  - `callback` (function form) and `callback interface`
  - `includes` statements (`A includes B;`)
  - unknown definitions are preserved as `DefKind::Unknown`
- Members (within interfaces/dictionaries/namespaces):
  - attributes, operations, constructors, constants
  - dictionary fields (`required` + default values captured as raw spans)
  - unknown members are preserved as `MemberKind::Unknown`
- Types:
  - identifier types (including common multi-token builtins like `unsigned long`)
  - generic types (`Foo<Bar, Baz>`)
  - union types (`(A or B or C)?`)
  - nullable types via `?`

The grammar coverage will expand as the bindgen pipeline becomes concrete.

## Notes For Bindgen

The parser intentionally preserves:

- definition/member/argument extended attributes,
- raw spans for constant/default values,
- enough structural information (member kinds, argument lists, type AST) to map
  Web platform APIs to a generated Silk surface and to synthesize JS host glue.

==============================================================================
DOCS: WebAssembly Runtime (`std::wasm`) (std/wasm)
URL: /silk/docs/?p=std/wasm
==============================================================================

# WebAssembly Runtime (`std::wasm`)


`std::wasm` is the standard library surface for **executing WebAssembly (WASM)
modules** from Silk.

This module is about *running* wasm. It is not the Silk compiler’s wasm output

## Goals

- Provide a portable API for:
  - loading/validating wasm bytes,
  - instantiating modules (including imports),
  - calling exported functions,
  - interacting with exported linear memory.
- Keep the module swappable, like the rest of `std::`: embedders may provide an
  alternate implementation (for example a wasm engine binding) while preserving
  the same public API.
- Record a clear path to a full native runtime and JIT in later phases (no
  dependency on external language toolchains).

## High-Level API

The public Silk surface is centered around:

- `Engine` — a runtime context and configuration (currently minimal).
- `Module` — a validated module (owned bytes + parsed metadata).
- `Instance` — an instantiated module (module + runtime state).
- `Func` — an exported function handle for calling.
- `Imports` — host-provided imports used during instantiation.
- linear memory access via `Instance.memory_bytes()` (returns `None` when the module has no memory; otherwise `Some(ByteSlice)`, possibly length 0).
- `Val` / `ValType` — a small tagged value representation for wasm values
  (currently used for results).

## Host Imports (MVP)

`Module.instantiate_with_imports(imports: Imports)` uses `Imports` to resolve
wasm imports (functions, globals, memory, table).

### Imported Functions

Imported functions are dispatched through a single host callback:

- `Imports.func_call: HostCall`

`HostCall` uses a scalar-only calling convention so it can be stored as a
first-class value and passed around in Silk:

```silk
type fn HostCall = fn (import_index: i64,
                    args_ptr: u64, args_len: i64,
                    mem_ptr: u64,  mem_len: i64,
                    out_bits_ptr: u64) -> int;
```

Semantics:

- `import_index` is 0-based in the order declared by the wasm module.
- `(args_ptr, args_len)` describes a `u64` slice of raw argument bits (i32 uses
  the low 32 bits; f32 also uses the low 32 bits).
- `(mem_ptr, mem_len)` describes the instance linear memory as a raw byte view
  (or `(0, 0)` when the module has no memory).
- When the imported function returns `i32`, `i64`, `f32`, or `f64`, the host
  writes the raw result bits to `out_bits_ptr` (at offset 0, as a `u64`).
  - `i32`/`f32` use the low 32 bits.
  - `i64`/`f64` use the full 64 bits.
- The return value is 0 on success; non-zero values are treated as
  `WASMError.code` (with `offset = -1`).

### Named Imported Functions

For embedders that want **named** host functions (instead of a single
index-based dispatcher), `std::wasm` also provides a helper that links imported
functions by `(module_name, import_name)` using `std::map`:

- `export struct ImportFuncName { module_name: string, name: string }`
- `export fn hash_import_func_name (k: ImportFuncName) -> u64;`
- `export fn eq_import_func_name (a: ImportFuncName, b: ImportFuncName) -> bool;`
- `Module.instantiate_with_named_func_imports(imports: Imports, func_imports: &std::map::HashMap(ImportFuncName, HostCall))`

Semantics:

- Every imported function in the module must have a corresponding entry in
  `func_imports`, otherwise instantiation fails with `LinkError`.
- Extra entries in `func_imports` are ignored.
- The linked callbacks are stored in a per-instance dispatch table so the map
  itself does not need to outlive instantiation.

Example:

```silk
import std::map;
import std::wasm;

type ImportMap = std::map::HashMap(std::wasm::ImportFuncName, std::wasm::HostCall);

fn main () -> int {
  let r = ImportMap.init(8, std::wasm::hash_import_func_name, std::wasm::eq_import_func_name);
  if r.is_err() { return 1; }
  let mut m: ImportMap = match (r) {
    Ok(v) => v,
    Err(_) => ImportMap.empty(std::wasm::hash_import_func_name, std::wasm::eq_import_func_name),
  };

  // Link the wasm import `(import "env" "add1" ...)` to a host callback.
  let _ = (mut m).put(std::wasm::ImportFuncName{ module_name: "env", name: "add1" }, host_call);

  let inst_r = (mut module).instantiate_with_named_func_imports(imports, &m);
  (mut m).drop();
  // ...
  return 0;
}
```

### Imported Globals

Imported globals are provided as raw bits:

- `Imports.global_bits: Slice(u64)`

Semantics:

- The slice length must equal the number of imported globals in the module.
- Globals are ordered by the wasm module’s import order (0-based).
- For imported `i32` globals, only the low 32 bits are used.
- For imported `i64` globals, the full 64 bits are used.
- For imported `f32` globals, only the low 32 bits are used (raw IEEE bits).
- For imported `f64` globals, the full 64 bits are used (raw IEEE bits).

### Imported Memory/Table

`Imports` can configure the initial sizes of imported memory/table:

- `Imports.memory_pages: i64` (for imported memory)
- `Imports.table_size: i64` (for imported table)

Semantics:

- `-1` means “use the module minimum”.
- Any other value must satisfy the module’s declared limits.

## Error Model

`std::wasm` uses a single typed error:

- `WASMError { code, offset, requested, trap }`

Where:

- `code` is a stable kind code.
- `offset` is a byte offset into the wasm input when known (otherwise `-1`).
- `requested` is used for allocation failures (otherwise `0`).
- `trap` is a stable trap-kind code when `code == Trap` (otherwise `0`).

`WASMError.kind()` and `WASMError.message()` provide a semantic view over the
stable integer codes.

## Supported Features (MVP)

The implementation is a **pure Silk interpreter** intended to be:

- self-contained (no external dependencies),
- correct for the WebAssembly 1.0 MVP semantics it supports,
- explicit about unsupported extensions (returns `Unsupported`).

### Targets

- Only **wasm32** modules are supported.
- The module must be a valid wasm binary module (magic + version 1).

### Sections

Supported:

- custom sections are ignored,
- core sections: `type`, `import`, `function`, `table`, `memory`, `global`,
  `export`, `start`, `element`, `code`, `data`.

Notes / current constraints (MVP):

- At most one table and one memory are supported (MVP constraint).
- `start` is executed automatically during `Module.instantiate` after
  instantiation initialization.
  - the start function must have signature `[] -> []` (no parameters, no results).
- `data_count` and all non-MVP extensions are rejected as `Unsupported`.

### Values and Function Calls

- Supported `ValType`: `I32`, `I64`, `F32`, `F64`.
- Supported function signatures: any number of `i32`/`i64`/`f32`/`f64`
  parameters and 0–1 `i32`/`i64`/`f32`/`f64` results.
- Calls pass arguments as raw bits (`std::arrays::Slice(u64)`):
  - for `i32`/`f32` parameters, only the low 32 bits are used,
  - for `i64`/`f64` parameters, the full 64 bits are used.
- Calls return 0–1 results as `Val?`.

### Instructions

The interpreter supports a practical wasm32 subset sufficient for “real” wasm
code (including `f32`/`f64`):

- control/parametric/variable: `unreachable`, `nop`, `block`, `loop`, `if`,
  `else`, `end`, `br`, `br_if`, `br_table`, `return`, `call`, `call_indirect`,
  `drop`, `select` (with block results for `i32`/`i64`/`f32`/`f64`)
- memory: all MVP loads/stores (including sign/zero-ext forms), `memory.size`,
  `memory.grow`
- numerics: `i32`/`i64`/`f32`/`f64` operators and conversions (including
  float↔int conversions and bit reinterpret ops).
  - Float→int truncation traps on `NaN` and out-of-range inputs
    (`WASMTrapKind::InvalidConversionToInteger`).

Unsupported opcodes/extensions are rejected as `Unsupported` with an `offset`
pointing at the opcode.

## Ownership Rules

- A `Module` owns the wasm bytes and parsed metadata.
- An `Instance` owns its own runtime state and takes ownership of the module’s
  owned allocations during instantiation.
  - `Module.instantiate(mut self: &Module)` consumes the module by moving its
    owned allocations into the returned `Instance`.
  - after a successful call, the original `Module` is left in an empty, inert
    state.
  - if instantiation fails (including start traps), no instance is produced and
    the original `Module` remains intact.
- `Func` is a lightweight view into an `Instance`, and memory is accessed by
  calling `Instance.memory_bytes()` when present.

## Example

```silk
import std::wasm;
import std::arrays;
import std::buffer;

using Engine = std::wasm::Engine;
using EngineResult = std::wasm::EngineResult;
using Module = std::wasm::Module;
using ModuleResult = std::wasm::ModuleResult;
using Instance = std::wasm::Instance;
using InstanceResult = std::wasm::InstanceResult;
using Func = std::wasm::Func;
using Val = std::wasm::Val;
using CallResult = std::wasm::CallResult;
using ByteSlice = std::arrays::ByteSlice;
using BufferU8 = std::buffer::BufferU8;
using U64Slice = std::arrays::Slice(u64);

fn main () -> int {

  let r: EngineResult = Engine.init_default();
  if r.is_err() { return 1; }
  let engine: Engine = match (r) {
    Ok(v) => v,
    Err(_) => Engine{ max_stack: 0, max_call_depth: 0, max_memory_pages: 0 },
  };

  // Minimal wasm module:
  // (module
  //   (func (export "answer") (result i32)
  //     i32.const 7))
  // Note: `u8[N]` arrays use the scalar-slot memory model (not packed bytes).
  // Build a packed `ByteSlice` via `BufferU8` when supplying raw wasm bytes.
  let wasm_bytes: u8[39] = [
    0, 97, 115, 109, 1, 0, 0, 0,
    1, 5, 1, 96, 0, 1, 127,
    3, 2, 1, 0,
    7, 10, 1, 6, 97, 110, 115, 119, 101, 114, 0, 0,
    10, 6, 1, 4, 0, 65, 7, 11
  ];

  let buf_r = BufferU8.init(39);
  if buf_r.is_err() { return 2; }
  let mut buf: BufferU8 = match (buf_r) {
    Ok(v) => v,
    Err(_) => BufferU8.empty(),
  };
  var i: i64 = 0;
  while i < 39 {
    let push_err = (mut buf).push(wasm_bytes[i]);
    if push_err != None {
      (mut buf).drop();
      return 2;
    }
    i = i + 1;
  }
  let bytes: ByteSlice = buf.as_bytes();

  let m_r: ModuleResult = engine.compile(bytes);
  (mut buf).drop();
  if m_r.is_err() { return 2; }
  let mut m: Module = match (m_r) {
    Ok(v) => v,
    Err(_) => Module.empty(),
  };

  let inst_r: InstanceResult = (mut m).instantiate();
  if inst_r.is_err() { return 3; }
  let mut inst: Instance = match (inst_r) {
    Ok(v) => v,
    Err(_) => Instance.empty(),
  };

  let f_opt: Func? = inst.export_func("answer");
  if f_opt == None { return 4; }
  let f: Func = f_opt ?? Func{ index: 0 };

  let args: U64Slice = { ptr: 0, len: 0 };
  let call_r: CallResult = (mut inst).call(f, args);
  if call_r.is_err() { return 5; }

  let out_opt: Val? = match (call_r) {
    Ok(v) => v,
    Err(_) => None,
  };
  if out_opt == None { return 6; }
  let out: Val = out_opt ?? Val.i32(0);

  let got_opt: i32? = out.as_i32();
  if got_opt == None { return 7; }
  if (got_opt ?? 0) != 7 { return 8; }

  return 0;
}
```

## Future Work

- A stable, ergonomic host import resolver API (beyond the MVP `Imports` list).
- WASI bindings and host library shims.
- Post-MVP proposals: bulk memory, reference types, SIMD (`v128`), threads, multi-value.
- A native runtime/JIT implementation for performance.

==============================================================================
DOCS: CLI usage examples (usage/cli-examples)
URL: /silk/docs/?p=usage/cli-examples
==============================================================================

# CLI usage examples

This page is a grab bag of practical workflows for the `silk` toolchain. It focuses on *how people actually use the CLI*:
quick feedback (`check`), tests that integrate with CI (`test`), and explicit build outputs (`build`).

For the conceptual model, read: [CLI and toolchain](?p=guides/cli).

For flag-by-flag reference, use the manpages (sidebar → man).

## Minimal loop: check → test → build

Create `hello.slk`:

```silk
import std::io::println;

fn main () -> int {
  println("hello {s}", "world");
  return 0;
}
```

Then:

```bash
silk check hello.slk
silk test hello.slk
silk build hello.slk -o build/hello
```

This loop is intentionally boring: each command has one job, and it scales from a single file to large packages.

## Explicit module sets (multiple files)

Passing multiple files defines the module set explicitly:

```bash
silk check src/main.slk src/util.slk
silk test  src/main.slk src/util.slk
silk build src/main.slk src/util.slk -o build/app
```

If you’re just starting a project, this is a great way to keep things simple before introducing manifests and named build
targets.

## Package builds (`silk.toml`)

For larger projects, you typically describe the module set in `silk.toml` and ask the CLI to load it:

```bash
silk check --package .
silk test --package .
silk build --package .
```

Why this model is valuable:

- “what gets compiled” is explicit and reproducible
- tooling can reason about packages without executing code
- named targets let you build multiple artifacts from one codebase

## Build kinds: executable, object, static, shared

`silk build` makes the output kind explicit:

```bash
# Executable (default)
silk build src/main.slk -o build/app

# Object file
silk build src/lib.slk --kind object -o build/lib.o

# Static library
silk build src/lib.slk --kind static -o build/libfoo.a

# Shared library
silk build src/lib.slk --kind shared -o build/libfoo.so
```

### Emitting C headers for exports

When building libraries for C consumers, emit a header for exported symbols:

```bash
silk build src/lib.slk --kind static -o build/libmylib.a --c-header build/mylib.h
```

This is a practical bridge between “Silk as a language” and “Silk as a component inside another system”.

## Target selection

Cross compilation and alternate backends are selected explicitly:

```bash
silk build src/main.slk --target x86_64-linux-gnu -o build/app
silk build src/main.slk --arch wasm32 --kind executable -o build/app.wasm
```

Explicit targets keep builds readable: you can tell from the command line what you’re producing.

## Standard library selection (`--std-root`, `--nostd`, `--std-lib`)

When a module imports `std::...`, the CLI resolves the standard library from its configured stdlib root.

Common customizations:

```bash
# Point at an alternate stdlib root (for custom std distributions or runtimes)
silk check --std-root ./path/to/std src/main.slk
silk build --std-root ./path/to/std src/main.slk -o build/app

# Disable std auto-loading (useful for sandboxed embedding flows)
silk check --nostd src/main.slk
```

On hosted targets where stdlib archives are used, `--std-lib` selects the archive to link.

Reference: [Custom stdlib root](?p=usage/howto-custom-stdlib-root)

## Docs and manpages from source

Silk can extract documentation from doc comments:

```bash
silk doc src/main.slk -o build/api.md
```

And render a man-style view of a symbol/module/concept:

```bash
silk man std::io
```

## Embedding workflows (C)

Two common embedding shapes:

1. **Build a library for a C program to link against** (object/static/shared + optional C header).
2. **Embed the compiler itself** (`libsilk`) inside another program.

When you’re in the “call a C compiler” world, `silk cc` is a convenience wrapper:

```bash
silk cc -std=c99 -Wall -Wextra my_program.c -o build/my_program
```

Reference: `libsilk` (sidebar → man → `libsilk` (7)).

==============================================================================
DOCS: coc.nvim Integration for Silk (usage/editor-coc-nvim)
URL: /silk/docs/?p=usage/editor-coc-nvim
==============================================================================

# coc.nvim Integration for Silk

This document describes the coc.nvim extension shipped in this repository under `coc/`.


## Location and Layout

- `coc/` contains the full coc.nvim extension.
- `coc/src/index.ts` wires `silk-lsp` into coc.nvim.
- `coc/src/snippets.json` provides a small set of Silk snippets.

## Requirements

- Neovim with `coc.nvim` (engine version `^0.0.80`).
- `silk-lsp` on your `PATH` or a configured absolute path.
- `filetype=silk` for `*.slk` and `*.silk` buffers (including `build.silk`; use the Vim plugin under `vim/` or your own filetype setup).

## Install (local, from this repo)

1. Build the language server:

   ```sh
   cd /path/to/silk/compiler
   zig build
   ```

2. Build the extension:

   ```sh
   cd /path/to/silk/compiler/coc
   npm install
   npm run build
   ```

3. Symlink into Coc’s extensions directory:

   ```sh
   mkdir -p ~/.config/coc/extensions/node_modules
   ln -s /path/to/silk/compiler/coc ~/.config/coc/extensions/node_modules/coc-silk
   ```

4. Restart Neovim.

## Configuration

Add settings to your `coc-settings.json`:

```json
{
  "silk.enabled": true,
  "silk.startUpMessage": true,
  "silk.path": "silk-lsp",
  "silk.args": [],
  "silk.env": {},
  "silk.stdRoot": "",
  "silk.noStd": false,
  "silk.filetypes": ["silk"],
  "silk.rootPatterns": [
    "build.silk",
    "silk.toml",
    "build.zig",
    "build.zig.zon",
    ".git"
  ],
  "silk.outputChannel": "Silk Language Server"
}
```

`silk.stdRoot` maps to `silk-lsp --std-root <path>` and `silk.noStd` maps to `silk-lsp --nostd`. You can also use `silk.args` or `silk.env.SILK_STD_ROOT` for custom setups.

## Commands

Use `:CocCommand` for server lifecycle management:

- `silk.start` — start the language server.
- `silk.stop` — stop the language server.
- `silk.restart` — restart the language server.

## Features

The extension exposes the capabilities currently implemented by `silk-lsp`:

- diagnostics from the Silk lexer, parser, and type checker,
- hover with approximate type hints for identifiers and struct fields,
- heuristic go-to-definition across the module set (functions, lets, structs, struct fields, and impl methods), including local `let` bindings and parameters,
- keyword/identifier completion with symbol-aware details and struct member suggestions,
- struct-literal field suggestions in `Type { ... }` expressions,
- signature help while typing function and method calls,
- top-level document symbols for `fn`, `let`, `struct`, `enum`, `error`, `interface`, `ext`, and `impl` declarations.

Reference: [LSP protocol and server](?p=compiler/lsp-silk).

## Notes and Troubleshooting

- If diagnostics are missing, check that `:set filetype?` reports `silk`.
- If `silk-lsp` cannot be found, set `silk.path` to the full path of your `silk-lsp` binary.
- Use `:CocList outputs` and open the `Silk Language Server` channel for logs.

==============================================================================
DOCS: Getting Started (Repo Workflow) (usage/getting-started)
URL: /silk/docs/?p=usage/getting-started
==============================================================================

# Getting Started (Repo Workflow)

This document is a practical starting point for working with the Silk compiler
repository: building the `silk` CLI, running a minimal program, and finding the
right documentation for deeper language and ABI details.



## Build `silk`

This repository is built with Zig.

From the repo root:

```sh
make build
```

If you want to fetch/build the pinned vendored crypto/TLS dependencies
(libsodium + mbedTLS) for `linux/x86_64`, run:

```sh
make deps
```


This produces:

- `zig-out/bin/silk` (the compiler CLI)
- `zig-out/lib/libsilk.a` (the C99 static library)
- `zig-out/lib/libsilk_std.a` (a stdlib archive for supported targets)

You can also run the Zig build directly:

```sh
zig build
```

## Run a Minimal Program

Create a file `hello.slk`:

```silk
fn main () -> int {
  return 0;
}
```

Then:

```sh
./zig-out/bin/silk check hello.slk
./zig-out/bin/silk build hello.slk -o hello
./hello
```

For more CLI examples (including stdlib use, wasm outputs, and library/object


## Supported behavior vs Full Design

The language docs describe both:

- the full language design, and
- the current implemented subset.

For “supported behavior”:

  unsupported features.

## Run Tests

From the repo root:

```sh
make test
```

This runs:

- Zig unit tests (`zig build test`)

## Where To Go Next

==============================================================================
DOCS: GitHub Linguist Support (usage/github-linguist)
URL: /silk/docs/?p=usage/github-linguist
==============================================================================

# GitHub Linguist Support

This repository includes a `.gitattributes` file that tags `*.slk` files as Silk sources for GitHub Linguist.

## What This Does

- Ensures `*.slk` files are classified as Silk in GitHub’s language breakdown.
- Helps GitHub apply the correct syntax highlighting when a TextMate grammar is available.

## Reuse in Other Repositories

If you maintain downstream Silk projects, copy the `.gitattributes` entry:

```
*.slk linguist-language=Silk
*.slk linguist-detectable=true
```

Adjust or extend the entries if you use additional Silk-related file extensions.

==============================================================================
DOCS: How-To: Run `wasm32-wasi` Output in Node.js (usage/howto-run-wasi-node)
URL: /silk/docs/?p=usage/howto-run-wasi-node
==============================================================================

# How-To: Run `wasm32-wasi` Output in Node.js

This guide shows how to:

- compile a Silk program to `wasm32-wasi`, and
- run it under Node’s built-in WASI runtime (`node:wasi`).

The `wasm32-wasi` backend emits a `_start () -> void` entrypoint that calls Silk
`fn main () -> int` and then calls `wasi_snapshot_preview1.proc_exit(exit_code)`.

## 1) Build a WASI Module

Create `main.slk`:

```silk
import std::io;

fn main () -> int {
  std::io::println("hello from silk wasm wasi");
  return 7;
}
```

Build:

```sh
silk build main.slk --target wasm32-wasi -o out.wasm
```

## 2) Run it with `node:wasi`

Create `run.js`:

```js
const fs = require('node:fs');
const { WASI } = require('node:wasi');

async function main() {
  const wasmPath = process.argv[2];
  const wasi = new WASI({ version: 'preview1', args: [wasmPath], env: {}, preopens: {} });
  const bytes = fs.readFileSync(wasmPath);
  const { instance } = await WebAssembly.instantiate(bytes, wasi.getImportObject());

  try {
    wasi.start(instance);
  } catch (err) {
    // Some Node versions throw on proc_exit; the exit code is still available.
  }

  const exitSym = Object.getOwnPropertySymbols(wasi).find((s) => s.toString() === 'Symbol(kExitCode)');
  const code = (exitSym && typeof wasi[exitSym] === 'number') ? wasi[exitSym] : (process.exitCode ?? 0);
  process.exit(code);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
```

Run:

```sh
node --no-warnings run.js out.wasm
echo $?
```

Expected output:

- stdout contains `hello from silk wasm wasi`
- exit code is `7`

## Troubleshooting

- If you see missing-import errors mentioning `wasi_snapshot_preview1`, confirm
  you built with `--target wasm32-wasi` (not `wasm32-unknown-unknown`).
- If your program relies on OS-specific APIs (filesystem, processes): WASI is a constrained environment. Prefer
  stdlib APIs that are designed for WASI, or build for a hosted target.
- For deeper backend details and entrypoint behavior, see: [WASM backend](?p=compiler/backend-wasm).

==============================================================================
DOCS: How-To: Use a Custom Stdlib Root (and Runtime) (usage/howto-custom-stdlib-root)
URL: /silk/docs/?p=usage/howto-custom-stdlib-root
==============================================================================

# How-To: Use a Custom Stdlib Root (and Runtime)

The `std::...` modules are loaded from a *stdlib root* (a directory containing a
`std/` tree). Because `std::runtime` is part of that source tree, selecting a
different stdlib root is also how you select a different runtime implementation
underneath `std::fs`, `std::io`, `std::task`, and `std::sync`.

Reference: `std::runtime` (see the sidebar under “Standard library”).

## Use a Custom Std Root (CLI)

Point the compiler at an alternate stdlib root:

```sh
silk build --std-root /path/to/my-stdlib-root my_program.slk -o my_program
```

You can also set an environment variable:

```sh
export SILK_STD_ROOT=/path/to/my-stdlib-root
silk build my_program.slk -o my_program
```

Notes:

- `--nostd` disables auto-loading of `import std::...;` modules, but it does not
  prevent `from "std/..."` file imports from resolving relative to the selected
  std root. See: [CLI and toolchain](?p=guides/cli).

## Provide a Prebuilt Std Archive

On hosted targets where std archives are supported, you can also provide a prebuilt std archive:

```sh
silk build --std-root /path/to/my-stdlib-root --std-lib /path/to/libsilk_std.a my_program.slk -o my_program
```

Or via environment variable:

```sh
export SILK_STD_LIB=/path/to/libsilk_std.a
```

If no suitable archive is provided, the compiler may fall back to compiling
reachable std sources as part of the build on supported targets.

## Implementing a Custom Runtime

To reuse the shipped high-level `std::...` modules while changing the OS
integration, provide compatible `std::runtime::...` modules in your stdlib root.

Example (hosted POSIX baseline):

- `std/runtime/fs.slk` delegates to `std/runtime/posix/fs.slk`,
- `std/runtime/posix/fs.slk` implements primitives using `ext` (e.g. `open`,
  `read`, `close`).

For a new environment (for example Windows), the intent is to provide
`std/runtime/windows/fs.slk` and have `std/runtime/fs.slk` delegate to it in that
stdlib distribution.

Keep the stable contract at the `std::runtime::...` signature level, not at the
`ext` spelling level. Higher-level ergonomics belong in `std::...` modules.

==============================================================================
DOCS: TextMate Grammar (tmLanguage) (usage/editor-textmate)
URL: /silk/docs/?p=usage/editor-textmate
==============================================================================

# TextMate Grammar (tmLanguage)


## Scope and File Extension

- Scope: `source.silk`
- File extensions: `.slk` and `.silk` (including build scripts like `build.silk`)

## TextMate (macOS)

1. Copy `textmate/silk.tmLanguage.json` to:
   - `~/Library/Application Support/TextMate/Bundles/Silk.tmbundle/Syntaxes/silk.tmLanguage.json`
2. Restart TextMate.
3. Open an `.slk` (or `.silk`) file and confirm it is recognized as `Silk`.

## VS Code

==============================================================================
DOCS: Tutorial 1: your first program (usage/tutorials/01-first-program)
URL: /silk/docs/?p=usage/tutorials/01-first-program
==============================================================================

# Tutorial 1: your first program

This tutorial gets you from “a file” to “a runnable program” with the smallest useful workflow:

- `silk check` to validate code quickly
- `silk build` to produce an executable
- (optionally) `silk test` to run language-level tests

## 1) Create a minimal program

Create `hello.slk`:

```silk
import std::io::println;

fn main () -> int {
  println("hello from silk");
  return 0;
}
```

## 2) Check it

```bash
silk check hello.slk
```

`check` is meant to be cheap: it answers “does this module set parse and type-check?”

## 3) Build and run

```bash
silk build hello.slk -o build/hello
./build/hello
```

On hosted platforms, `main` returns a conventional process exit code (`0` means success).

## 4) Add a tiny test (optional)

Add this to the same file:

```silk
import std::test::expect_equal;

fn add (a: int, b: int) -> int { return a + b; }

test "add returns the sum" {
  expect_equal(3, add(1, 2));
}
```

Run:

```bash
silk test hello.slk
```

## Next

- More workflows: [CLI examples](?p=usage/cli-examples)
- Tutorial 2: [Structs and `impl`](?p=usage/tutorials/02-structs-and-impls)

==============================================================================
DOCS: Tutorial 2: structs and `impl` (usage/tutorials/02-structs-and-impls)
URL: /silk/docs/?p=usage/tutorials/02-structs-and-impls
==============================================================================

# Tutorial 2: structs and `impl`

This tutorial covers:

- defining a `struct` (data layout)
- attaching behavior with `impl` blocks
- calling methods with explicit receivers (`self: &Self`, `mut self: &Self`)

Reference: `Structs, impls, layout` (see the sidebar under “Language”).

## 1) Define a struct

```silk
struct Packet {
  sequence: u32,
  size: u16,
  is_urgent: u8,
}
```

Structs define *shape*: fields and layout. Behavior lives in `impl` blocks.

## 2) Add behavior with an `impl` block

```silk
impl Packet {
  public fn mark_urgent (mut self: &Self) -> void {
    self.is_urgent = 1;
  }

  public fn is_large (self: &Self) -> bool {
    return self.size > 1024;
  }
}
```

Two important ideas:

- Methods are functions with an explicit receiver parameter (`self`).
- `mut self: &Self` means the method needs to mutate the value.

## 3) Use it (a complete program)

Create `packet.slk`:

```silk
import std::io::println;

struct Packet {
  sequence: u32,
  size: u16,
  is_urgent: u8,
}

impl Packet {
  public fn mark_urgent (mut self: &Self) -> void {
    self.is_urgent = 1;
  }

  public fn is_large (self: &Self) -> bool {
    return self.size > 1024;
  }
}

fn main () -> int {
  let mut p = Packet{ sequence: 1, size: 2048, is_urgent: 0 };

  if p.is_large() {
    (mut p).mark_urgent();
  }

  println("seq={d} urgent={d}", p.sequence as int, p.is_urgent as int);
  return 0;
}
```

Then:

```bash
silk check packet.slk
silk build packet.slk -o build/packet
./build/packet
```

## Optional: constructor overloads and `new`

Silk supports a conventional pattern for heap allocation: `new Type(...)` selects a `constructor` overload in an `impl`
block.

```silk
impl Packet {
  fn constructor (mut self: &Self, seq: u32, size: u16) -> void {
    self.sequence = seq;
    self.size = size;
    self.is_urgent = 0;
  }
}
```

This keeps construction explicit (you can read the initializer logic) without inventing a second “class system”.

## Next

- Tutorial 3: [Arrays and slices](?p=usage/tutorials/03-arrays-and-slices)

==============================================================================
DOCS: Tutorial 3: Arrays and Slices (usage/tutorials/03-arrays-and-slices)
URL: /silk/docs/?p=usage/tutorials/03-arrays-and-slices
==============================================================================

# Tutorial 3: Arrays and Slices

This tutorial covers:

- fixed arrays `T[N]`,
- slices `T[]`,
- array literals `[a, b, c]` and empty literals `[]` with expected types,
- indexing (`xs[i]`) and indexed assignment (`xs[i] = v`, `xs[i] += v`).

For the precise rules, see:

- `Aggregate literals (arrays and structs)` (sidebar → language),
- `Types` (sidebar → language).

## 1) Fixed arrays (`T[N]`)

```silk
fn main () -> int {
  let mut xs: int[3] = [1, 2, 3];

  xs[1] = 9;
  xs[1] += 1;

  if xs[1] != 10 { return 1; }
  return 0;
}
```

Notes:

- Array lengths are part of the type: `int[3]` is distinct from `int[4]`.
- Indexing is explicit (`xs[i]`). Keep indices in range; out-of-bounds behavior is not something you want to depend on.

## 2) Slices (`T[]`)

Slices are a “view” type: `T[]` represents a sequence of `T` values without baking a fixed length into the type.

```silk
fn main () -> int {
  let mut s: int[] = [10, 20, 30];
  s[2] = 5;
  if s[2] != 5 { return 1; }
  return 0;
}
```

## 3) Empty literals (with expected types)

Empty array literals require an expected type:

```silk
struct HasSlice {
  xs: int[],
}

fn main () -> int {
  let empty_fixed: int[0] = [];
  let empty_slice: int[] = [];
  let _hs = HasSlice{ xs: [] };
  return 0;
}
```

This rule keeps `[]` unambiguous: the compiler needs to know what element type you meant.

==============================================================================
DOCS: Tutorial 4: filesystem basics (`std::fs`) (usage/tutorials/04-filesystem)
URL: /silk/docs/?p=usage/tutorials/04-filesystem
==============================================================================

# Tutorial 4: filesystem basics (`std::fs`)

This tutorial demonstrates a very common “systems script” pattern:

1. create a directory
2. write a file
3. read it back
4. clean up

Reference: `std::fs` (sidebar → standard library).

## Program: write and read back a small file

Create `fs_roundtrip.slk`:

```silk
import std::fs;
import std::io::println;

fn main () -> int {
  // 493 == 0o755 on POSIX.
  if std::fs::mkdir_all("tmp", 493) != None {
    println("mkdir failed");
    return 1;
  }

  let path: string = "tmp/tutorial_fs_roundtrip.txt";
  std::fs::unlink(path); // ignore errors; we just want the file gone

  // 420 == 0o644 on POSIX.
  match (std::fs::write_file_string(path, "hello\\n", 420)) {
    Ok(_) => {},
    Err(_) => {
      println("write failed");
      std::fs::unlink(path);
      return 2;
    },
  }

  match (std::fs::read_file_string(path)) {
    Ok(s) => {
      println("read: {s}", s.as_string());
      std::fs::unlink(path);
      return 0;
    },
    Err(_) => {
      println("read failed");
      std::fs::unlink(path);
      return 3;
    },
  }
}
```

Build and run:

```bash
silk check fs_roundtrip.slk
silk build fs_roundtrip.slk -o build/fs_roundtrip
./build/fs_roundtrip
```

## What to take away

- `std::fs` uses explicit return shapes (`Result(...)` or optional errors) so failure handling stays visible.
- Whole-file helpers (`read_file_string`, `write_file_string`) are the easiest way to get real work done early.
- For deeper control (streaming I/O, seeking, file handles), `std::fs::File` exposes a lower-level handle API.

## Next

- Tutorial 5: [Concurrency basics](?p=usage/tutorials/05-concurrency)

==============================================================================
DOCS: Tutorial 5: concurrency basics (`async`, `task`, `yield`, `await`) (usage/tutorials/05-concurrency)
URL: /silk/docs/?p=usage/tutorials/05-concurrency
==============================================================================

# Tutorial 5: concurrency basics (`async`, `task`, `yield`, `await`)

Silk’s concurrency model is built from two orthogonal modifiers:

- `async` — “this function can be awaited” (concurrency / pausable execution)
- `task` — “this function can run as a task” (parallel work / worker execution)

Calling a concurrency-marked function produces a **handle**:

- calling a `task fn ... -> T` produces a `Task(T)`
- calling an `async fn ... -> T` produces a `Promise(T)`

You then use:

- `yield` to receive values from tasks (and to send values from inside a task)
- `await` to unwrap promises

Reference: [Concurrency](?p=language/concurrency).

## 1) A minimal task + receiver

Create `concurrency_basic.slk`:

```silk
task fn add (a: int, b: int) -> int {
  return a + b;
}

async fn main () -> int {
  let h = add(1, 2); // h: Task(int)

  // `task { ... }` establishes a task context so `yield` is available.
  task {
    let v: int = yield h;
    if v != 3 { return 1; }
    return 0;
  }
}
```

Build and run:

```bash
silk check concurrency_basic.slk
silk build concurrency_basic.slk -o build/concurrency_basic
./build/concurrency_basic
```

What to notice:

- Calling `add(1, 2)` does not immediately give you an `int`; it gives you a handle.
- `yield h` receives the task’s produced value.
- The task/async split keeps “what can block” explicit in the code.

## 2) A minimal promise + `await`

Promises are the `async` counterpart:

```silk
async fn answer () -> int { return 42; }

async fn main () -> int {
  let p = answer();     // p: Promise(int)
  let v: int = await p; // unwrap the promise
  if v != 42 { return 1; }
  return 0;
}
```

## Why this model is valuable

Silk’s concurrency keywords are intentionally explicit because they communicate “shape”:

- If a function is `async`, callers know they’re getting a promise-like handle.
- If a function is `task`, callers know they’re spawning work that must be joined/drained.
- `yield`/`await` make synchronization points visible in code review (no hidden “maybe blocks here”).

## Next

- Reference: `std::task` and `std::sync` (sidebar → standard library)

==============================================================================
DOCS: Universal Ctags Support (usage/editor-ctags)
URL: /silk/docs/?p=usage/editor-ctags
==============================================================================

# Universal Ctags Support

This repository ships a Universal Ctags configuration for Silk at the repo root in `.ctags`.

## What It Tags

The bundled rules recognize:

- `fn` declarations (including `export fn`, `export default fn` when named, and `async`/`task`-modified functions),
- `let` and `var` bindings (including `export let`, `export var`, and `let mut`),
- `ext` declarations (including `export ext`),
- `struct`, `enum`, `error`, `interface`, and `impl` declarations,
- `package` declarations.

These tags are regex-based and intentionally conservative; they do not perform semantic resolution or scope analysis.

## Usage (Project-Local)

From the repository root:

```sh
ctags -R
```

Universal Ctags will read `.ctags` automatically and tag `*.slk` files as Silk.

If your `ctags` binary is not Universal Ctags, install it first; Exuberant/etags do not support the same configuration format.

## Usage (Global)

To use the Silk rules across multiple projects:

1. Copy `.ctags` to `~/.ctags.d/silk.ctags`.
2. Run `ctags -R` in any Silk project.

If you already maintain a global ctags configuration, merge the Silk rules into it instead.

==============================================================================
DOCS: Vim Integration for Silk (usage/editor-vim)
URL: /silk/docs/?p=usage/editor-vim
==============================================================================

# Vim Integration for Silk

This document describes the built-in Vim support for the Silk language shipped with this repository.

The goal of the Vim plugin is to provide a lightweight, spec-aligned editing experience that:

- recognizes Silk source files by extension,
- respects this repository’s indentation and comment style guidelines.

## Files and Layout

The Vim plugin lives under the top-level `vim/` directory:

- `vim/plugin/silk.vim` – plugin entrypoint (sources the ftdetect script even if `:filetype on` is not enabled).
- `vim/ftdetect/silk.vim` – filetype detection for Silk source files.
- `vim/syntax/silk.vim` – core syntax highlighting rules for Silk.
- `vim/ftplugin/silk.vim` – filetype-specific editor defaults for Silk buffers.
- `vim/indent/silk.vim` – indentation rules for Silk buffers.

These files follow Vim’s standard runtime layout and can be copied into a user’s `~/.vim` (or Neovim) configuration or used directly from this repository via the `runtimepath`.

## Filetype Detection

- The plugin defines `filetype=silk` for `*.slk` and `*.silk` buffers (including `build.silk`).

## Syntax Highlighting

The `vim/syntax/silk.vim` file is derived from:

- the current token and keyword tables in `src/token.zig`.

It currently highlights:

- lexer keywords (as currently implemented by the keyword table in `src/token.zig`): `package`, `module`, `import`, `from`, `export`, `public`, `private`, `default`, `const`, `let`, `var`, `mut`, `fn`, `test`, `theory`, `struct`, `enum`, `type`, `error`, `interface`, `impl`, `as`, `raw`, `extends`, `if`, `else`, `loop`, `while`, `for`, `in`, `match`, `return`, `panic`, `break`, `continue`, `assert`, `await`, `yield`, `pure`, `async`, `task`, `region`, `with`, `new`, `sizeof`, `ext`, `None`/`none`/`null`, `Some`, `true`/`false`;
- testing and assertion keywords: `test`, `assert`;
- builtin types and type-like names: `bool`, integer and float types (`u8`, `i8`, …, `u64`, `i64`, `int`, `f32`, `f64`), `char`, `string`, `void`, `Instant`, `Duration`, `Task`, `Promise`, `map`, `Option`, `Buffer`, and other core names drawn from the spec;
- literal forms: boolean literals (`true`, `false`), `None`/`Some`, numeric literals (decimal integers and floats) and duration literals with unit suffixes (e.g. `10ns`, `250us`, `5ms`, `2s`, `5min`, `1h`, `7d`), character and string literals;
- compiler/runtime intrinsics: identifiers matching `__silk_*` (internal ABI surface);
- special method names: `constructor` and `drop` (both have language-defined meaning in Silk);
- well-known package prefixes such as `std::`, so that standard library imports and qualified names stand out from ordinary identifiers;
- Formal Silk annotations: `#const`, `#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`, `#theory` (including whitespace forms like `#  require`) are treated as preprocessor-style constructs;
- comments: both `//` line comments and `/* ... */` block comments (excluding doc-comment forms), consistent with the current lexer behavior in `src/lexer.zig`.


## Editor Defaults

The `vim/ftplugin/silk.vim` file configures:

- indentation defaults:
  - by default, Silk buffers inherit your Vim tab settings,
  - if Vim is using its built-in defaults (`tabstop=8`, `shiftwidth=8`, `softtabstop=0`, `noexpandtab`), Silk buffers will use the repository’s preferred indentation (2 spaces with `expandtab`),
  - override via `g:silk_indent_style` (`'auto'`, `'inherit'`, `'repo'`),
- a line comment style of `//` via `commentstring=// %s`,
- C-style block comment metadata via `'comments'` / `'formatoptions'` so that
  doc-style comments like:

  ```silk
  /**
   * This is a comment
   */
  ```

  are indented and continued automatically when you press `<CR>` on a comment
  line (mirroring typical C-style comment editing behavior in Vim).

The `vim/indent/silk.vim` file provides a simple, block-oriented indent
expression that:

- indents by `&shiftwidth` across Silk buffers,
- indents lines that follow opening `{`, `(`, or `[` characters,
- outdents lines that begin with closing `}`, `)`, or `]`.

These settings mirror the mandatory style documented in `AGENTS.md` for code
indentation and align the editor experience with the language’s comment
syntax.

Additional Silk-specific editor behaviors (such as formatting commands or motion/textobject helpers) can be layered on in future iterations once the language and CLI stabilize further.

## Snippets (Tab Expansion)

The Vim plugin includes a tiny built-in snippet expander (no external snippet
plugin required). In Silk buffers, pressing `<Tab>` will expand a small set of
common constructs **only** when the trigger word is the only non-whitespace
text on the line.

Supported triggers include:

- `fn` → function skeleton
- `export fn` → exported function skeleton
- `async fn` / `task fn` / `async task fn` → concurrency-flavored function skeletons
- `let` / `export let` → binding skeletons
- `import` / `package` → statement skeletons
- `import from` → file import skeleton (`import { ... } from "file.slk";`)
- `ext` / `export ext` → external declaration skeletons
- `while` / `for` / `if` / `ife` → block skeletons (`ife` includes an `else`)
- `match` → match skeleton with `Some`/`None` cases
- `struct` / `enum` → type skeletons
- `interface` / `impl` → declaration skeletons
- `/**` → doc comment block skeleton

## Installation Examples

### Option A: Install This Repo as a Vim Plugin (Recommended)

If you install the repository root as a Vim plugin (common with plugin managers), `plugin/silk.vim` will automatically add `vim/` to `'runtimepath'`, so Vim can discover the Silk runtime files without extra configuration.

### Option B: Install Only the `vim/` Subdirectory

If you want to distribute or install the `vim/` directory as a standalone Vim plugin, keep the `vim/` directory structure intact (it is a valid plugin root), including `vim/plugin/silk.vim`.

### Option C: Add `vim/` to `runtimepath` Manually

You can use the plugin directly from this repository by adding `vim/` to Vim’s `runtimepath`, for example:

```vim
set runtimepath^=/path/to/silk/compiler/vim
```

If you prefer to copy the files into your own configuration:

- copy `vim/ftdetect/silk.vim` into `~/.vim/ftdetect/`,
- copy `vim/syntax/silk.vim` into `~/.vim/syntax/`,
- copy `vim/ftplugin/silk.vim` into `~/.vim/ftplugin/`,
- copy `vim/indent/silk.vim` into `~/.vim/indent/`,
- copy `vim/autoload/silk/snippets.vim` into `~/.vim/autoload/silk/snippets.vim` (if you want the built-in snippets),
- copy `vim/plugin/silk.vim` into `~/.vim/plugin/` (only needed if you want `.slk` filetype detection without enabling `:filetype on`).

For Neovim, use the equivalent `~/.config/nvim/` directories or a plugin manager that can add this repository as a plugin source.

## LSP Integration (Silk Language Server)

For a richer editing experience (on top of syntax highlighting), you can pair the Vim/Neovim plugin with the `silk-lsp` language server:

- `silk-lsp` implements the Language Server Protocol over stdin/stdout.
- It currently supports:
  - full-document text synchronization,
  - diagnostics driven by the parser and type checker,
  - hover with approximate type hints for identifiers and struct fields,
  - heuristic go-to-definition across the module set (functions, lets, structs, struct fields, and impl methods), including local `let` bindings and parameters,
  - keyword/identifier completion with symbol-aware details and struct member suggestions,
  - struct-literal field suggestions in `Type { ... }` expressions,
  - signature help while typing function and method calls,
  - top-level document symbols for `fn`, `let`, `struct`, `enum`, `error`, `interface`, `ext`, and `impl`.
- It does **not yet** provide semantic tokens, code actions, or full scope-aware navigation for match-expression binders or references; these will be added later as the compiler and LSP spec evolve.

### Example: Neovim Built-in LSP

With Neovim’s built-in LSP client (and `nvim-lspconfig` or a custom setup), a minimal configuration might look like:

```lua
-- In your Neovim config (e.g., init.lua)
local lspconfig = require('lspconfig')

lspconfig.silk_ls = {
  cmd = { 'silk-lsp' },
  filetypes = { 'silk' },
  root_dir = lspconfig.util.root_pattern('.git', '.'),
}
```

To override the stdlib root for the language server, add `--std-root <path>` to the `cmd` list (or set `SILK_STD_ROOT`). Use `--nostd` to disable stdlib integration entirely.

This assumes:

- `silk-lsp` is on your `PATH` (for example, after running `zig build install` or equivalent),
- the Vim filetype detection is in place so that `*.slk` buffers have `filetype=silk`.

### Example: Generic LSP Client Configuration

For other editors or LSP frontends, the configuration is conceptually similar:

- **command**: `["silk-lsp"]`
- **transport**: stdio
- **filetypes / selectors**: Silk source files (typically `*.slk`)
- **capabilities**: no need to advertise advanced features; the server’s `initialize` response drives what is supported.

==============================================================================
DOCS: `silk` CLI (compiler/cli-silk)
URL: /silk/docs/?p=compiler/cli-silk
==============================================================================

# `silk` CLI

This document describes the command-line interface of the `silk` compiler from the downstream user’s perspective.

## Binary

- Name: `silk`.
- Alias entrypoints:
  - `slc` — behaves like `silk build ...` (convenience wrapper),
  - `slcc` — behaves like `silk cc ...` (convenience wrapper).

## Core Responsibilities

At maturity, the `silk` CLI should:

- Compile Silk source files into:
  - executables,
  - static libraries (`.a`),
  - shared libraries (`.so` / `.dylib` / `.dll` as appropriate).
- Provide options to:
  - select target triple and optimization level,
  - choose build mode (debug / release),
  - control linkage to the default `std::` implementation or an alternative,
  - enable/disable or tune Formal Silk verification checks,
  - configure external and ABI-related behaviors where appropriate (e.g. visibility of `libsilk.a` symbols, header emission).
- Emit clear diagnostics with stable error codes and machine‑readable output when requested.

The initial implementation is intentionally smaller and focuses on:

- global options:
  - `--help` / `-h` — print global usage and exit,
  - `help` — print global usage and exit,
  - `help <command>` — print command-specific usage and exit,
  - `--version` — print the embedding ABI version and exit,
- `silk repl` — start an interactive “compile-and-run” REPL:
  - currently supported only on `linux/x86_64` (native ELF backend),
  - intended as a node-like default when `silk` is launched with no arguments
    and stdin is a TTY,
  - stateful by replay: each successful line is appended to a session program.
    When you enter runtime lines (statements/expressions), the session is
    re-executed from the start (so side effects may repeat). Import and
    declaration lines are validated by compilation only (not executed),
  - supports:
    - `.help` — show help,
    - `.clear` — reset session state,
    - `.cls` — clear the screen,
    - `.undo` — undo the last successful line,
    - `.exit` — exit the REPL,
  - history is loaded/saved to:
    - `$SILK_REPL_HISTORY` when set, otherwise
    - `$SILK_WORK_DIR/repl_history` (default: `.silk/repl_history` under the
      nearest package root or current directory),
- `silk check [--nostd] [--std-root <path>] [--z3-lib <path>] [--debug] [--package <dir|manifest>] <file> [<file> ...]` — parse and type-check one or more Silk source files as a unit, exiting with:
  - code `0` on success,
- `silk test [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--filter <pattern>] [--package <dir|manifest>] <file> [<file> ...]` — compile and run language-level `test` declarations found in the module set, emitting TAP output:
  - uses TAP version 13 formatting (`TAP version 13`, `1..N`, `ok`/`not ok` lines),
  - in the current implementation, each test runs in its own process so a failing `assert` (panic/abort) does not stop the whole suite,
  - the supported code generation subset matches `silk build` for the active target (initially `linux/x86_64`).
  - `--filter <pattern>` runs only tests whose display name contains `<pattern>` (substring match).
  - when `<file> ...` inputs are omitted and `--package` is also omitted, but `./silk.toml` exists, `silk test` behaves as if `--package .` was provided.
- when `--package` is provided:
  - input files must be omitted (the compiler loads the package module set from the manifest),
  - the manifest file is `silk.toml` (when a directory is provided, it is discovered in that directory),
- `silk doc` — generate documentation from Silkdoc comments (`/** ... */` and `/// ...`) attached to declarations:
  - Markdown mode: `silk doc [--all] <file> [<file> ...] [-o <output.md>]`
    - by default, includes exported `fn`/`let`/`ext` declarations and exported `impl` methods, plus all `struct` and `interface` declarations in the input modules,
    - `--all` includes non-exported functions, bindings, and methods,
    - when `-o` / `--out` is provided, writes the Markdown output to that path; otherwise writes to stdout.
  - Manpage mode: `silk doc --man [--package <dir|manifest>] [--std-root <path>] <query> [-o <output.man>]`
    - renders a single roff `man(7)` page to stdout (or to `-o` / `--out` when provided),
    - the page kind is derived from the documentation tags (`@cli` → section 1, `@misc` → section 7, otherwise section 3 for API pages),
    - when `<query>` is not `std::...`, the module set is loaded from `--package` when provided; otherwise the compiler searches the current working directory and its parents for `silk.toml` and uses the nearest match,
    - intended as a non-interactive complement to `silk man <query>`.
- `silk man <query>` — render and view a temporary manpage for a symbol/module/concept derived from source documentation:
  - `std::...` queries are resolved from the configured stdlib root (see “standard library import resolution” below),
  - other queries are resolved from `--package` when provided; otherwise the compiler searches the current working directory and its parents for `silk.toml` and uses the nearest match,
  - when no manifest is found, the compiler may also resolve the query from the package search path (`SILK_PACKAGE_PATH`).
- diagnostics (initial):
  - emits a single primary error diagnostic on error,
  - includes a stable error code for known error kinds,
  - includes a file/line/column location and caret snippet when available,
  - when stderr is a TTY, diagnostics are decorated with ANSI colors unless disabled via `NO_COLOR` or `TERM=dumb`,
- standard library import resolution (first slice):
  - when a module contains `import std::...;`, the CLI automatically loads the
    referenced `std::...` package modules from a configured stdlib root, so
    downstream users do **not** need to pass std source files explicitly on the
    command line,
  - when `--nostd` (or `-nostd`) is provided, this auto-loading is disabled and `import std::...;`
    must be satisfied by explicitly passing source files (or the build fails),
    - note: `--nostd` only affects `import std::...;` auto-loading; it does not disable std-root file imports (`from "std/<path>"`), which still resolve relative to the selected stdlib root,
  - the stdlib root is selected via:
    - `--std-root <path>` (or `--std <path>` / `-std <path>` when `<path>` does **not** end in `.a`) when provided, otherwise
    - `SILK_STD_ROOT` (environment variable) when set, otherwise
    - a `std/` directory in the current working directory (development default), otherwise
    - `../share/silk/std` relative to the `silk` executable (installed default), otherwise
    - walk upward from the `silk` executable’s directory to find a `std/` directory (developer build fallback).
  - package-to-path mapping is deterministic: `std::foo::bar` resolves to the
    file `<std_root>/foo/bar.slk`.
  - JS-style file imports may also target stdlib sources directly via
    `from "std/<path>"` (or `from "std/<path>.slk"`):
    - these specifiers are resolved relative to the selected stdlib root and
      treated as file imports,
    - when the `.slk` extension is omitted, it is appended during std-root
      resolution,
    - they always load and compile the referenced `.slk` source module (they do
      not rely on the prebuilt stdlib archive).
- package search path import resolution (non-`std::`):
  - when a module imports a bare package specifier (for example `import api from "my_api";`),
    the CLI may load that package from a search path configured by `SILK_PACKAGE_PATH`,
  - `SILK_PACKAGE_PATH` is PATH-like: a list of directories separated by `:` (POSIX),
  - package-to-path mapping is deterministic: `my_api::core` resolves to the candidate
    directory `<root>/my_api/core` and the manifest `<candidate>/silk.toml`,
  - qualified symbol imports resolve the longest package prefix that exists (for example
    `my_api::core::Thing` loads `my_api::core` if present, otherwise `my_api`),
  - the same search path is used when loading manifest dependencies that omit a `path`
- standard library archive linking (`linux/x86_64`, current archive layout):
  - `make stdlib` builds a target-specific static archive (`libsilk_std.a`)
    containing one ELF object per std module (development default:
    `zig-out/lib/libsilk_std.a`),
  - for supported `silk build --kind executable` builds, the compiler can treat
    auto-loaded `std::...` modules as **external** during code generation and
    resolve their exported functions from the archive when available (while
    still type-checking the std sources as part of the module set),
    - by default this archive-linking path is only used for `-O0` builds (when
      `-O` is omitted, this is usually the case only when `--debug` is enabled),
    - for `-O1`+ builds, `silk build` prefers compiling std sources into the
      executable so unreachable std code can be pruned,
    - `--std-lib` / `--std <path>.a` forces archive linking regardless of `-O`,
    - only std modules auto-loaded via `import std::...;` participate in this
      external/archive path; std modules imported by file path (including
      `from "std/<path>"`) are compiled into the build like ordinary file
      imports,
  - archive discovery (in order):
    - `--std-lib <path>` (or `--std <path>.a` / `-std <path>.a`) when provided, otherwise
    - `SILK_STD_LIB` when set, otherwise
    - `zig-out/lib/libsilk_std.a` when using the in-repo `std/` root, otherwise
    - `../lib/libsilk_std.a` relative to the `silk` executable, otherwise
    - common installed-layout heuristics derived from the selected stdlib root,
    - walk up from the current working directory to find `libsilk_std.a` or `lib/libsilk_std.a`,
  - when no suitable archive is found (or on unsupported targets), the compiler
    falls back to compiling the reachable std sources into the build,
  - `--nostd` disables stdlib auto-loading and avoids linking the default std
    archive (but users may still explicitly provide their own `std::...` inputs
    as ordinary source files),
- user-provided `package std::...;` modules continue to override the default
  std implementation for the same package names.
- `silk build [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--package <dir|manifest>] [--build-script] [--package-target <name> ...] <input> [<input> ...] -o <path> [--kind executable|object|static|shared] [--arch <arch>] [--target <triple>] [--c-header <path>] [--needed <soname> ...] [--runpath <path> ...] [--soname <soname>]` (or `--out <path>`) — for now:
  - inputs are classified by extension:
    - `.slk` — Silk source files (compiled as the module set),
    - `.o` — ELF relocatable objects linked into `--kind executable|shared` outputs (and included in `--kind static` archives),
    - `.a` — static archives; their `.o` members are treated like object inputs,
    - `.so` — shared libraries treated as dynamic dependencies (equivalent to `--needed <soname>` using the library’s basename),
    - `.c` — C sources compiled to objects via the host C compiler (see `silk cc` / `SILK_CC`) and then treated like `.o` inputs,
    - note: linking `.o`/`.a`/`.c` inputs is currently supported only for `linux/x86_64` outputs,
  - when multiple input files are provided, runs module-set front-end checks (package/import resolver + multi-module type checking that accounts for imported exported constants and imported `export fn` calls),
  - declaration-only exported function prototypes (`export fn name(...) -> T;`) are accepted as module exports for type-checking, but do not emit code; calls lower as link-time symbol references that must be satisfied by other Silk sources in the module set and/or non-`.slk` link inputs (`.o`/`.a`/`.c`),
  - when a single input file is provided, runs the existing single-module front-end checks,
  - when no input files are provided and `--package` / `--pkg` is omitted, but `./silk.toml` exists, the compiler behaves as if `--package .` was provided (package builds from the current directory by default),
  - when `--package` is provided:
    - `.slk` input files must be omitted (the module set is loaded from the manifest), but non-`.slk` link inputs (`.c`, `.o`, `.a`, `.so`) may still be provided,
    - `--build-script` runs `<package_root>/build.silk` and uses its stdout as
    - `--package-target <name>` selects one or more manifest `[[target]]` entries by name (repeatable; `--pkg-target` is accepted as an alias),
      - when omitted, the compiler builds every manifest `[[target]]` entry by default,
    - when building multiple targets (the default when `--package-target` is omitted, or when it is repeated), per-output flags are rejected:
      `-o/--out`, `--kind`, `--arch`, `--target`, `--c-header`, `--needed`, `--runpath`, `--soname`,
    - `-o/--out` is optional only when building a single target (defaults to the target’s `output` or a computed default under `build/`),
    - package dependencies are loaded from the manifest’s `[dependencies]` table,
  - when `-o/--out` or `--c-header` includes parent directories that do not exist yet, the compiler creates them (like `mkdir -p`),
  - multi-file builds are supported for `--kind executable` and for `--kind object`, `--kind static`, and `--kind shared`:
    - when multiple packages are present in a module set for a non-executable output, only exports from the *root package* (the package of the first input module) are emitted as globally-visible symbols; other packages are compiled as dependencies and their `export` declarations are treated as internal for that output,
  - for `--kind executable`:
    - when the module set defines a valid Silk entrypoint, enforces the executable entrypoint rule (exactly one `main` of either `fn main() -> int`, `async fn main() -> int`, or `fn main(argc: int, argv: u64) -> int`),
    - script-style entrypoints: when the **first** `.slk` input contains top-level *statements* (after the normal `package`/`module` header and `import` block) and does not define an explicit `main`, `silk build` treats those statements as a script body and synthesizes an implicit `fn main() -> int` that executes them and then returns `0`,
    - when the module set defines no valid Silk `main`, requires an object/archive-provided `main(argc: int, argv: u64) -> int` symbol (for example from a `.c`/`.o`/`.a` input) and emits an entry stub that forwards `argc`/`argv` to it,
    - note: for now, `--std-lib` / `--std <path>.a` is rejected when linking additional `.c`/`.o`/`.a` inputs into an executable (std sources are compiled into the build instead),
    - for `linux/x86_64` native executables, when the `argc`/`argv` form is used, the entry stub passes:
      - `argc`: the process argument count, and
      - `argv`: a raw pointer to the argv pointer list (a C-style `char**`, where `argv[0]` is at byte offset `0`, `argv[1]` at `8`, etc.),
    - other targets and backends may continue to require the parameterless `fn main() -> int` form until they implement argument passing,
- for `--kind object`, `--kind static`, and `--kind shared`, `main` is optional; the current backend emits supported `export fn` functions and supported exported constants (`export let`/`export const`; scalar exports require an explicit type annotation, and string exports may omit `: string` when the initializer is a string literal), plus a valid executable `main` when present, as globally-visible symbols,
    - it is valid for a non-executable output to contain no globally-visible symbols (for example, type-only or interface-only modules); in that case the build still succeeds and produces an “empty” object/archive/shared library,
  - `--debug` (or `-g`) enables a debug build mode for the supported `linux/x86_64` back-end subset:
    - failed `assert` prints a panic header + optional message + stack trace to stderr (via glibc `backtrace_symbols_fd`) before aborting, and
    - dynamically-linked executables export internal function symbols in `.dynsym` (similar to `-rdynamic`) so stack traces can be symbolized without external tooling,
    - compiled code can query build metadata at runtime via `std::runtime::build::{is_debug,kind,mode,version}()`,
  - `--noheap` disables heap allocation for the current compiler/runtime subset:
    - heap-backed `new` (outside a `with` region) is rejected with `E2027`,
    - `ext` bindings to libc heap primitives (`malloc`/`calloc`/`realloc`/`free`/etc) are rejected with `E2027` in non-stdlib modules,
    - `std::runtime::mem::{alloc,realloc,free}` traps when called without an active `with` region (no implicit heap fallback),
    - any use of `async`, `task`, `await`, `yield`, or capturing closures is rejected with `E2027`,
    - region-backed `new` inside `with` is still permitted,
    - `--noheap` is currently incompatible with `--debug` (debug panic traces require `malloc`/`free`),
  - by default, builds an executable (`--kind executable`),
  - when `--kind object`, `--kind static`, or `--kind shared` is provided:
    - on `linux/x86_64`, attempts to emit an ELF64 relocatable object, static library, or shared library (`.so`) for the same supported IR subset,
    - and otherwise exits non-zero with `E4001` (unsupported construct) or `E4002` (backend failure) diagnostics that explain the exact limitation,
  - attempts to emit an executable using:
    - for `--target linux-x86_64` (the default; also accepts common `x86_64-*-linux-*` triples such as `x86_64-linux-gnu`), an IR→ELF backend on `linux/x86_64` for a growing scalar subset, and a constant‑expression backend (with a tiny ELF64 stub) for purely constant `main` bodies,
    - for `--target wasm32-unknown-unknown`:
      - an IR→WASM backend for the current supported subset (multi-module builds, control flow, string/data segments, and `ext` imports),
      - exports `memory` plus `main` when present (embedder entry), or emits an **export-only** module (no `main`) that exports supported `export fn` declarations from the root package,
      - note: Silk `int` currently lowers to wasm `i64`, so wasm exports using `int` surface as `i64`,
    - for `--target wasm32-wasi`:
      - an IR→WASM backend that emits `memory` plus `_start () -> void`, imports `wasi_snapshot_preview1.proc_exit`, and calls Silk `fn main () -> int` (the `main(argc, argv)` entrypoint form is not supported yet for WASI),
      - also supports export-only modules for embedding (export-only modules do not include `_start`),
    - for both wasm targets, a smaller constant-only wasm backend remains as a fallback for programs that fit the constant subset,
  - the *constant* subset (available on `linux-x86_64` and the initial `wasm32` targets) consists of:
    - a single `fn main() -> int` whose body is:
      - zero or more `let` statements with constant integer initializers, followed by exactly one `return` of a constant integer expression, or
      - the same, with a final `if` whose condition is a compile‑time boolean literal (`true` / `false`) and whose branches each satisfy the “constant lets + return constant expression” rule, and
  - on `linux/x86_64`, a richer IR‑based backend is used first; for this backend, the currently supported (documented and tested) subset includes:
    - `fn main() -> int` and helper functions that:
      - take scalar parameters (defaulting to `int` when unannotated) drawn from `int`, `bool`, `char`, `f32`, `f64`, `Instant`, `Duration`, and the fixed-width integer types (`u8`/`i8` … `u64`/`i64`); helper functions return a scalar from the same set (while `main` remains `-> int`), or `void` (omitted result type or explicit `-> void`) when used only as standalone statements (`return;` and implicit fallthrough returns are supported for `void` helpers),
      - helpers may also accept and return `string` values at ABI boundaries (represented as `{ ptr: u64, len: i64 }` / `SilkString`; results return via `rax`/`rdx`),
      - use integer arithmetic (`+`, `-`, `*`, `/`, `%`, including unary `-x`), bitwise operators (`&`, `|`, `^`, `~`, `<<`, `>>`), integer comparisons (`==`, `!=`, `<`, `<=`, `>`, `>=`), and floating-point arithmetic/comparisons (`+`, `-`, `*`, `/`, `==`, `!=`, `<`, `<=`, `>`, `>=`, including unary `-x`) over `f32`/`f64`,
      - use `char` literals (UTF-8 or escaped) and `==` / `!=` comparisons over `char` values (lowered as `u32` scalars in IR),
      - use `bool` as a distinct surface type, with booleans represented as integer values at the IR level,
      - use `if` / `else` and `while` with conditions drawn from:
        - boolean literals,
        - comparisons over integer and floating-point expressions, and `==` / `!=`
          over boolean expressions,
        - calls to `bool`-returning helpers of this subset,
        - logical operators `!`, `&&`, and `||` composed over those expressions (`&&` / `||` are short‑circuiting),
        - and boolean locals (`let flag: bool = <bool expr>; if flag { ... }`),
      - in addition to conditions, boolean *value* positions (for example `let flag: bool = a && b;` and `return a || b;` in `bool`-returning helpers) support the same boolean expression subset and preserve short-circuit evaluation,
      - use `break;` and `continue;` inside `while` loops,
      - allow call expressions as standalone statements (discarding the returned value),
      - allow assignment and compound assignment to `let mut` locals by name (`x = expr;`, `x += y;`); in the current implementation the left-hand side must be an identifier, `=` is supported for all currently supported value types (including `string`, the supported `struct` subset, and optionals of those), and compound assignments are supported only for numeric scalar locals,
        - integer-like scalars (`bool` and integers) use up to 6 general-purpose registers (`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`),
        - `f32`/`f64` use up to 8 XMM registers (`xmm0`..`xmm7`),
        - remaining scalar arguments are spilled to the stack in order,
        - the caller maintains 16-byte stack alignment before `call` (padding by one 8-byte slot when needed), and
        - results return in registers for 0–2 scalar results (integer-like in `rax`/`rdx`, floats in `xmm0`/`xmm1`), and 3+ scalar results return indirectly via a hidden sret pointer passed in `rdi` (caller-allocated return buffer),
    - on `linux/x86_64`, the same backend also supports a limited `string` subset:
      - within function bodies, the compiler supports a small `string` expression subset: string literals, `let` bindings of `string`, `return` of a `string` value, direct calls to `string`-returning helpers, and `==`/`!=`/`<`/`<=`/`>`/`>=` comparisons over `string` values (producing `bool`); other string operations (concatenation, indexing, etc.) are not implemented yet,
      - string literals are embedded as rodata byte blobs and `.text`→rodata fixups are emitted/handled appropriately for each output kind (ELF relocations for object/static outputs; direct RIP-relative displacement patching for shared libraries and executables once the final `.text`/rodata layout is known),
    - for non-executable outputs, exported `string` constants (`export let`/`export const` with a string literal initializer; `: string` is optional) are emitted as `SilkString` data symbols for downstream C consumers, and exported functions of this subset may accept and return `string` values using the same `{ ptr: u64, len: i64 }` ABI.
    - on `linux/x86_64`, the current backend also supports a limited `struct` subset:
      - `struct` declarations with 0+ fields of supported value types:
        - scalar primitives (`int`/fixed-width ints, `bool`, `char`, `f32`, `f64`, `Instant`, `Duration`),
        - `string` (lowered as `{ ptr: u64, len: i64 }`),
        - nested (non-opaque) structs,
        - and optionals (`T?`) of supported payload types,
      - struct literals (`Type{ field: expr, ... }`) and field access (`value.field`) for those structs; in Silk, struct literals may omit fields and omitted fields are zero-initialized,
      - `==`/`!=` comparisons over values of those structs (deep/slot-wise equality, including embedded strings, nested structs, and optionals) producing `bool`,
      - passing and returning such structs by value in helper calls by lowering them to their scalar slots in order (“slot flattening”) and using the same System V AMD64 calling convention as scalar arguments/results,
      - at ABI boundaries for exported/FFI functions, structs must be ABI-safe: after slot flattening, all slots must be `i64`/`u64`/`f64` (for example `string` fields are ABI-safe, but `bool`, `char`, and `f32` fields are not).
    - on `linux/x86_64`, the current backend also supports a limited optional subset:
      - optionals of scalar payload types (`T?` where `T` is `bool`, `char`, `f32`, `f64`, `int`, `Instant`, `Duration`, or a fixed-width integer),
      - optionals of `string` payload type (`string?`), and optionals of the supported `struct` subset (`Type?` where `Type` is a supported 0+ field `struct`),
      - nested optionals (`T??`) for these payload types,
      - constructing optionals via `None` and `Some(<expr>)` for those payload types,
      - `==` / `!=` comparisons over those optionals (tag + payload equality; nested optionals compare recursively); `None` / `Some(...)` can be used directly in equality expressions when the other operand provides the optional type context (for example `opt == None` and `opt == Some(x)`),
      - accessing fields of optional structs via optional field access (`opt?.field`), producing an optional result of the field type (`FieldType?`),
      - matching on optionals via `match <scrutinee> { None => <expr>, Some(<name|_>) => <expr>, }` (exactly one `None` arm and one `Some(...)` arm; arm bodies are expressions in the current implementation),
      - unwrapping optionals via `??` with short-circuit evaluation of the fallback expression (including unwrapping `T??` to `T?`),
      - and passing/returning optionals between helpers at ABI boundaries as `(bool tag, payload0, payload1, ...)`, where the payload slots follow the lowering of the underlying non-optional type (for example `string?` is `(bool, u64 ptr, i64 len)`).
    - on `linux/x86_64`, the current backend also supports a limited external call subset:
      - top-level `ext` declarations of external functions (`ext name = fn (T, ...) -> R;`) may be called like normal functions from Silk code,
      - these calls are supported for all output kinds:
        - `--kind object` and `--kind static` emit relocations against undefined external symbols for downstream linkers, and
        - `--kind shared` emits dynamic imports and calls through the shared object’s GOT (symbols must be available at runtime),
        - `--kind executable` emits a dynamically-linked ELF64 executable and calls through the executable’s GOT (symbols must be available at runtime),
      - top-level `ext` declarations of external scalar variables (`ext name = T;`) may be read like normal values from Silk code:
        - `--kind object` and `--kind static` emit relocations against undefined external data symbols, and
        - `--kind shared` emits dynamic imports and loads through the shared object’s GOT (symbols must be available at runtime),
        - `--kind executable` emits a dynamically-linked ELF64 executable and loads through the executable’s GOT (symbols must be available at runtime),
      - writing to `ext` variables is not supported,
      - for executables and shared libraries, `silk build` supports declaring dynamic loader dependencies via `--needed <soname>` (repeatable), which are emitted as `DT_NEEDED` entries,
      - runtime search paths for those dependencies can be provided via `--runpath <path>` (repeatable), which is emitted as a single `DT_RUNPATH` entry (joined with ':'), and
      - for shared library outputs, the library soname can be set via `--soname <soname>` (emitted as `DT_SONAME`),
      - on `linux/x86_64` with the glibc dynamic loader (`ld-linux`), when an executable or shared library imports any external symbols, `silk` automatically adds `libc.so.6` as a `DT_NEEDED` dependency (so hosted `std::` modules do not require `--needed libc.so.6`),
      - on the same baseline, when libsodium-backed symbols are imported (for example via `import std::crypto;`), `silk` automatically adds `libsodium.so.23` as a `DT_NEEDED` dependency,
      - on the same baseline, when bundled runtime support symbols are imported (for example via `import std::regex;`, `import std::unicode;`, or `import std::number;`), `silk` statically links the bundled runtime support archive into the output (`libsilk_rt.a`, or `libsilk_rt_noheap.a` when building with `--noheap`); the produced executable/shared library does not depend on `libsilk_rt*.so` at runtime,
      - additional non-libc, non-libsodium dependencies still must be declared via `--needed <soname>` (or otherwise be available in the process global scope at load time, for example via `LD_PRELOAD`),
      - bundled runtime archive discovery:
        - the compiler locates `libsilk_rt.a` / `libsilk_rt_noheap.a` via (in order):
          - `SILK_RT_LIBDIR` (environment variable; a directory containing the runtime archives),
          - `zig-out/lib` in the current working directory (development default),
          - `../lib` relative to the `silk` executable (installed default).
    - `fn main()` itself may be:
      - a single function with structured control flow as above, or
      - a small program that calls one or more helpers (with the same scalar subset), all lowered into IR and compiled together into a single executable,
    - when multiple input files are provided, this executable build path operates on the entire module set and supports:
      - same-package helper calls across modules (functions in one module calling functions defined in another module of the same package), and
      - imported exported calls (`export fn`) across packages for the current scalar subset (both `foo()` and `pkg::foo()` call forms are accepted initially after `import pkg;`),
    - examples that are known to be supported and tested include:
      - straight‑line integer programs such as `fn main() -> int { return 1 + 2 * 3; }`,
      - programs with local and top‑level integer `let` bindings used in the final `return`,
      - programs that branch on comparison conditions at runtime, for example:

        ```silk
        fn main () -> int {
          if 1 < 2 {
            return 10;
          } else {
            return 20;
          }
        }
        ```

      - small loops expressed in terms of `while` and `break;` / `continue;`,
      - helper‑call programs such as:

        ```silk
        fn helper (x, y) -> int {
          if x < y {
            let one: int = 1;
            return x + one;
          } else {
            let two: int = 2;
            return y + two;
          }
        }

        fn main () -> int {
          return helper(1, 3);
        }
        ```

      - helpers that take many integer parameters (exercising both register and stack‑passed arguments) and are called from `main`,
      - programs that use boolean locals and conditions, for example:

        ```silk
        fn main () -> int {
          let x: int = 1;
          let y: int = 2;
          let flag: bool = x < y;

          if flag {
            return 3;
          } else {
            return 4;
          }
        }
        ```

      - and small helper programs with boolean locals and `if` / `else`, such as:

        ```silk
        fn helper (x) -> int {
          let flag: bool = x < 0;
          if flag {
            return 1;
          } else {
            return 2;
          }
        }

        fn main () -> int {
          return helper(1);
        }
        ```
  - for programs that type‑check but fall outside both the constant subset and the current IR‑based backend subset, `silk build` exits non‑zero with `E4001` diagnostics that point at the rejected construct (or `E4002` when the backend fails unexpectedly).

## High-Level Command Model (Initial Implementation)

The initial CLI implementation supports a small, well-defined subset of the eventual UX.

Top-level commands:

- `silk help [<command>]`:
  - Prints global usage when `<command>` is omitted.
  - Prints command-specific usage when `<command>` is provided.
  - Subcommands also accept `--help` / `-h` to print command-specific usage.
  - For `check` / `test` / `build` / `doc`, `--` ends option parsing (all remaining args are treated as file paths, even if they begin with `-`).
- `silk check [--nostd] [--std-root <path>] [--z3-lib <path>] [--debug] [--package <dir|manifest>] <file> [<file> ...]`:
  - Reads one or more input files, runs lexing, parsing, package/import resolution, and type checking.
  - Prints a success message on stdout for valid programs.
  - Prints a human-readable error on stderr and exits non-zero for invalid programs.
- `silk test [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--filter <pattern>] [--package <dir|manifest>] <file> [<file> ...]`:
  - Compiles and runs each test, emitting TAP version 13 output.
  - In the current implementation, each test runs in its own process so a failing `assert` (panic/abort) does not stop the whole suite.
  - Optimization:
    - `-O <0-3>` selects the optimization level (default: `-O2`; when `--debug` is set and `-O` is omitted, defaults to `-O0`).
    - In the current implementation, `-O1`+ prunes unused extern symbols before code generation (typically reducing output size and stdlib linkage).
    - For IR-backed native executable builds, `-O1`+ also prunes unreachable functions from the executable entrypoint (function-level dead-code elimination).
  - When `--filter <pattern>` is provided, only tests whose display name contains `<pattern>` are executed.
  - When `<file> ...` inputs are omitted and `--package` is also omitted, but `./silk.toml` exists, `silk test` behaves as if `--package .` was provided.
- `silk build [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--package <dir|manifest>] [--build-script] [--package-target <name> ...] <file> [<file> ...] -o <path> [--kind executable|object|static|shared] [--arch <arch>] [--target <triple>] [--c-header <path>] [--needed <soname> ...] [--runpath <path> ...] [--soname <soname>]` (or `--out <path>`):
  - Reads one or more input files, runs the same front-end pipeline as `check`.
  - Optimization:
    - `-O <0-3>` selects the optimization level (default: `-O2`; when `--debug` is set and `-O` is omitted, defaults to `-O0`).
    - In the current implementation, `-O1`+ prunes unused extern symbols before code generation.
    - For `--kind executable` builds, `-O1`+ also prunes unreachable functions from the executable entrypoint (function-level dead-code elimination), typically reducing output size.
  - When `--package` is provided:
    - input files must be omitted,
    - `--build-script` runs `<package_root>/build.silk` and uses its stdout as
    - `--package-target <name>` selects one or more manifest `[[target]]` entries by name (repeatable; `--pkg-target` is accepted as an alias),
      - when omitted, the compiler builds every manifest `[[target]]` entry by default,
    - when building multiple targets (the default when `--package-target` is omitted, or when it is repeated), per-output flags are rejected:
      `-o/--out`, `--kind`, `--arch`, `--target`, `--c-header`, `--needed`, `--runpath`, `--soname`,
    - when building a single target, `-o/--out` is optional (defaults to that target’s `output` or a computed default under `build/`).
  - Target selection:
    - `--arch <arch>` and `--target <triple>` are mutually exclusive; omit both to use the default target.
  - Entrypoint rules:
    - for `--kind executable` (the default), there must be exactly one `main`, using either `fn main() -> int`, `async fn main() -> int`, or `fn main(argc: int, argv: u64) -> int`,
    - for `--kind object`, `--kind static`, and `--kind shared`, `main` is not required; at least one supported `export fn`, supported `export let` constant, or a valid executable `main` must be present so the output contains one or more globally-visible symbols.
  - Multi-file builds are supported for `--kind executable` and for `--kind object`/`--kind static`/`--kind shared`:
    - for non-executable outputs, when multiple packages are present in a module set, only exports from the *root package* (the package of the first input module) are emitted as globally-visible symbols; other packages are compiled as dependencies and their `export` declarations are treated as internal for that output.
  - Output selection:
    - default: build an executable (`--kind executable`),
    - `--kind object`: build an ELF64 relocatable object (`.o`) on `linux/x86_64`,
    - `--kind static`: build a static library (`.a`) on `linux/x86_64`,
    - `--kind shared`: build a shared library (`.so`) on `linux/x86_64`.
  - Dynamic dependencies:
    - `--needed <soname>` adds a `DT_NEEDED` entry for executable and shared outputs; it may be repeated,
    - `--runpath <path>` (or `--rpath <path>`) adds a runpath element for executable and shared outputs; it may be repeated (joined with ':' into `DT_RUNPATH`),
    - `--soname <soname>` sets the shared library soname recorded as `DT_SONAME` for shared outputs (an empty string clears it),
    - for object and static library outputs, `--needed`, `--runpath`, and `--soname` are ignored.
    - on `linux/x86_64` with the glibc dynamic loader (`ld-linux`), `silk` automatically adds:
      - `libc.so.6` as a `DT_NEEDED` dependency when external symbols are present (so hosted `std::` modules do not require `--needed libc.so.6`), and
      - `libpthread.so.0` when `pthread_*` symbols are imported, and
      - `libsodium.so.23` when libsodium-backed symbols are imported (for example via `import std::crypto;`).
    - when bundled runtime support symbols are imported (for example via `import std::regex;`), `silk` statically links `libsilk_rt.a` (or `libsilk_rt_noheap.a` when building with `--noheap`) into the output; no runtime `DT_NEEDED` entry is emitted for `libsilk_rt*`.
    - `--needed` entries starting with `libsilk_rt` are rejected; the bundled runtime support layer is always linked from the static archives.
  - Debug builds:
    - `--debug` (or `-g`) enables runtime stack traces for failed `assert` statements on `linux/x86_64` by printing a stack trace to stderr before aborting, and preserves internal function symbols in `.dynsym` for better symbolization.
    - when Formal Silk verification fails, `--debug` also emits Z3 debugging output and writes an SMT-LIB2 reproduction script under `.silk/z3/` (or `$SILK_WORK_DIR/z3`).
  - Heap control ():
    - `--noheap` disables heap allocation for the :
      - heap-backed `new` (outside a `with` region) is rejected with `E2027`,
      - `ext` bindings to libc heap primitives (`malloc`/`calloc`/`realloc`/`free`/etc) are rejected with `E2027` in non-stdlib modules,
      - `std::runtime::mem::{alloc,realloc,free}` traps when called without an active `with` region (no implicit heap fallback),
      - any use of `async`, `task`, `await`, `yield`, or capturing closures is rejected with `E2027`,
      - region-backed `new` inside `with` is still permitted.
    - `--noheap` is currently incompatible with `--debug` (debug panic traces require `malloc`/`free`).
  - For the supported subset, emits the selected artifact at `<path>`.
  - C99 header emission (for downstream consumers of exported symbols):
    - `--c-header <path>` writes a generated C header at `<path>` that declares the root package’s exported symbols (`export fn` prototypes and `export let` extern declarations) for consumption from C/C++,
    - this option is only meaningful for non-executable outputs (`--kind object|static|shared`) and is rejected for `--kind executable`,
    - to keep the C ABI surface obvious and stable, `--c-header` requires the *root package* (the package of the first input module) to be the **global package** (i.e. omit `package ...;` in the exported library’s sources),
      - `string` values use `SilkString { ptr, len }` (from `silk.h`),
      - optionals and 3+ slot structs are lowered at call boundaries as multiple scalar parameters (so C prototypes for such parameters use flattened arguments rather than by-value C struct parameters).
  - For programs outside the supported subset that nonetheless type-check, exits non-zero with a clear `E4001` / `E4002` diagnostic (instead of a generic “code generation is not implemented yet” message).
- Formal Silk verification:
  - when Formal Silk syntax is present (for example `#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`, `#const`), `check` / `test` / `build` require proofs and fail the build when verification fails,
  - when `--debug` is set, failing proof obligations also emit Z3 debugging output and write an SMT-LIB2 reproduction script under `.silk/z3/` (or `$SILK_WORK_DIR/z3`),
  - `--z3-lib <path>` overrides the Z3 dynamic library used by the verifier (it also honors `SILK_Z3_LIB`).
- `silk doc`:
  - Markdown mode: `silk doc [--all] <file> [<file> ...] [-o <output.md>]`
    - Generates Markdown documentation from Silkdoc comments (`/** ... */` and `/// ...`) attached to declarations.
    - By default, includes exported `fn`/`let`/`ext` declarations and exported `impl` methods, plus all `struct` and `interface` declarations in the input modules.
    - `--all` includes non-exported functions, bindings, and methods.
    - When `-o` / `--out` is provided, writes the Markdown output to that path; otherwise writes to stdout.
  - Manpage mode: `silk doc --man [--package <dir|manifest>] [--std-root <path>] <query> [-o <output.man>]`
    - Renders a roff `man(7)` page derived from source docs (`@cli`/`@misc`/API docs) and writes it to stdout (or to `-o` / `--out`).
- `silk cc <cc args...>`:
  - Runs a host C compiler to build C99 (or C++) programs that embed or link against `libsilk.a`.
  - Selects the compiler executable via `SILK_CC` (when set), otherwise falls back to `cc`.
  - Automatically adds the include and library search paths adjacent to the installed `silk` binary (for example `../include` and `../lib`), plus `-lsilk`.
  - On `linux/x86_64`, also adds `-lstdc++ -lpthread -lm` (vendored Z3 is built as C++).
  - Passes through additional arguments verbatim to the underlying compiler (files, flags, `-o`, `-I`, `-L`, etc.).
  - Wrapper usage can be displayed via `silk help cc` (since `silk cc --help` is passed through to the underlying compiler).

Future commands (not yet implemented, but documented for roadmap clarity):

- `silk fmt <path>` — format Silk source files.
- `silk abi header` — emit `silk.h` and ABI descriptions for embedders.

## Documentation & Manpages

==============================================================================
DOCS: Build Scripts (`build.silk`) (compiler/build-scripts)
URL: /silk/docs/?p=compiler/build-scripts
==============================================================================

# Build Scripts (`build.silk`)

This document specifies Silk’s *build script* concept: a package-local Silk
program named `build.silk` that can generate a package build plan at build time.

Build scripts are intentionally *outside* the core language semantics (they are
a tooling/build feature). The language-level `package` / `import` / `export`

## Overview

A build script is an optional file:

- `build.silk` (in the package root directory)

When enabled, `silk` compiles and runs the build script and treats its stdout as
a TOML v1.0 package manifest in the same format as `silk.toml`

This allows packages to compute targets, outputs, and dependency paths
dynamically (for example from environment variables, host information, or local
filesystem probes) while keeping the compiler’s build execution model centered
on a concrete manifest.

## Invocation (CLI)

Build scripts are executed only when explicitly requested.

- `silk build --package <dir|manifest> --build-script`

Rules:

- The build script path is `<package_root>/build.silk`, where `<package_root>` is
  the directory containing the package.
- If `build.silk` does not exist, `silk build --build-script` fails.
- The build script is executed as a hosted native program on the build host.
  In the current implementation, this is supported only on `linux/x86_64`.
- The build script’s stdout is parsed as a manifest and used for the remainder
  of the build in place of reading `<package_root>/silk.toml`.
- The build script may write logs to stderr; they are forwarded by the driver.

## Script Contract

- The build script MUST exit with status code `0` on success.
- The build script MUST print a valid TOML v1.0 manifest to stdout.
- The build script SHOULD avoid printing non-manifest text to stdout (use stderr
  for logs).
- The build script output is subject to the same size cap as manifests:

The build script is invoked with one positional argument:

- `argv[1]` — the absolute package root directory.

## Security Model

Build scripts are arbitrary code execution.

For this reason:

- build scripts are **not** run implicitly by `silk build` in the current
  implementation; they require `--build-script`,
- downstream tooling (package managers, CI, editor integrations) MUST treat
  build scripts as untrusted inputs unless they are pinned and reviewed.

## Example

`build.silk` (prints a manifest that builds `src/main.slk` as an executable):

```silk
import std::io;

fn main (argc: int, argv: u64) -> int {
  _ = argc;
  _ = argv;

  std::io::print(`[package]
name = "hello"

[[target]]
name = "hello"
kind = "executable"
entry = "src/main.slk"
`);
  return 0;
}
```

==============================================================================
DOCS: C99 ABI and `libsilk.a` (compiler/abi-libsilk)
URL: /silk/docs/?p=compiler/abi-libsilk
==============================================================================

# C99 ABI and `libsilk.a`

This document defines the C99 ABI and the interface of the `libsilk.a` static library.

## Goals

- Provide a stable C ABI for embedders.
- Keep the ABI small, explicit, and well-documented.

## Library & Headers

- Static library: `libsilk.a`.
- Primary header: `include/silk.h`.

### Linking on `linux/x86_64` (vendored Z3)

On `linux/x86_64`, `libsilk.a` vendors Z3 (via `vendor/lib/x64-linux/libz3.a`) to
support Formal Silk verification. The vendored Z3 static library is built as
**C++**, so downstream embedders linking against `libsilk.a` MUST also link the
system C++ runtime and any required system libraries:

```sh
cc -std=c99 -Wall -Wextra \
   -I/path/to/include your_app.c \
   -L/path/to/lib -lsilk \
   -lstdc++ -lpthread -lm
```

The `silk cc` wrapper adds these flags automatically when linking on
`linux/x86_64`.

The header must define:

- Core bridged types (e.g. `SilkString`, and any other structs or enums used by the ABI).
- Opaque handle types (`SilkCompiler`, `SilkModule`, `SilkError`) and their lifetime rules.
- Entry points for:
  - initializing and shutting down compiler/runtime state,
  - configuring compilation (target triple, stdlib name, optimization level),
  - adding source buffers,
  - compiling Silk source to executables, libraries, or object files,
  - interacting with diagnostics and error reporting.

### Initial C Header Shape (`include/silk.h`)

The initial C header provided in this repository defines:

- `SilkString` mirroring the internal Silk `string` layout:
  - Note: `SilkString` is also the C ABI shape for Silk `regexp` values
    (bytecode-backed `{ ptr, len }`), but the bytes are opaque and not required
    to be null-terminated.

  ```c
  typedef struct SilkString {
      char   *ptr;
      int64_t len;
  } SilkString;
  ```

- `SilkBytes` for owned binary buffers returned by in-memory build APIs:

  ```c
  typedef struct SilkBytes {
      uint8_t *ptr;
      int64_t  len;
  } SilkBytes;
  ```

- 128-bit scalar primitives (`i128` / `u128` / `f128`) used by generated C
  headers for exported Silk interfaces:

  ```c
  typedef struct SilkU128 {
      uint64_t lo;
      uint64_t hi;
  } SilkU128;

  typedef struct SilkI128 {
      uint64_t lo;
      int64_t  hi;
  } SilkI128;

  typedef struct SilkF128 {
      uint64_t lo;
      uint64_t hi;
  } SilkF128;
  ```

  Notes:
  - `SilkF128` stores the IEEE‑754 binary128 bit pattern. It is not C `long double`.
  - These types are passed and returned as two integer-like 8-byte slots in the
    current `linux/x86_64` backend subset.

- Opaque handles:

  ```c
  typedef struct SilkCompiler SilkCompiler;
  typedef struct SilkModule   SilkModule;
  typedef struct SilkError    SilkError;
  ```

- An output-kind enum:

  ```c
  typedef enum SilkOutputKind {
      SILK_OUTPUT_EXECUTABLE = 0,
      SILK_OUTPUT_STATIC_LIBRARY = 1,
      SILK_OUTPUT_SHARED_LIBRARY = 2,
      SILK_OUTPUT_OBJECT = 3,
  } SilkOutputKind;
  ```

- ABI version query:

  ```c
  void silk_abi_get_version(int *out_major,
                            int *out_minor,
                            int *out_patch);
  ```

- Compiler lifecycle:

  ```c
  SilkCompiler *silk_compiler_create(void);
  void          silk_compiler_destroy(SilkCompiler *compiler);
  ```

- Configuration:

  ```c
  bool silk_compiler_set_stdlib(SilkCompiler *compiler, SilkString stdlib_name);
  bool silk_compiler_set_std_root(SilkCompiler *compiler, SilkString std_root);
  bool silk_compiler_set_nostd(SilkCompiler *compiler, bool nostd);
  bool silk_compiler_set_debug(SilkCompiler *compiler, bool debug);
  bool silk_compiler_set_noheap(SilkCompiler *compiler, bool noheap);
  bool silk_compiler_set_target(SilkCompiler *compiler, SilkString target_triple);
  bool silk_compiler_set_z3_lib(SilkCompiler *compiler, SilkString path);
  bool silk_compiler_set_std_archive(SilkCompiler *compiler, SilkString path);
  bool silk_compiler_add_needed_library(SilkCompiler *compiler, SilkString soname);
  bool silk_compiler_add_runpath(SilkCompiler *compiler, SilkString path);
  bool silk_compiler_set_soname(SilkCompiler *compiler, SilkString soname);
  bool silk_compiler_set_optimization_level(SilkCompiler *compiler, int level);
  bool silk_compiler_set_c_header(SilkCompiler *compiler, SilkString path);
  ```

  `silk_compiler_set_std_root` configures the filesystem stdlib root directory used
  to auto-load `std::...` packages when modules contain `import std::...;`. The
  `std_root` string is copied. When set, it overrides `SILK_STD_ROOT` and the
  working-directory/default search behavior described below.

  `silk_compiler_set_nostd` disables this stdlib auto-loading behavior when set
  to `true`. When `nostd` is enabled, `import std::...;` declarations must be
  satisfied by explicitly adding the corresponding std sources as modules (for
  example via `silk_compiler_add_source_buffer`); the compiler will not consult
  `SILK_STD_ROOT` or the filesystem std root search paths.

  `silk_compiler_set_debug` enables the same debug build mode as the CLI
  (`silk --debug`): debug-mode lowering for supported native outputs, and
  additional Z3 debug output plus `.smt2` reproduction scripts on failing Formal
  Silk obligations (written under `.silk/z3/` or `$SILK_WORK_DIR/z3`).

  `silk_compiler_set_noheap` enables the same no-heap mode as the CLI
  (`silk --noheap`): heap-backed allocation is disabled for the supported
  subset. `--noheap` is currently incompatible with `--debug`; the ABI rejects
  configurations that enable both.

  `silk_compiler_set_optimization_level` selects the optimization level (0-3),
  matching the CLI `-O` flag. The default is level 0 unless overridden. In the
  current implementation, level 1+ enables lowering-time pruning of unused
  extern symbols before code generation. For IR-backed native executable
  builds, it also prunes unreachable functions from the executable entrypoint
  (function-level dead-code elimination), typically reducing output size and
  over-linking when using the prebuilt `libsilk_std.a` archive to satisfy
  auto-loaded `import std::...;` modules.

  `silk_compiler_set_target` selects the code generation target. The
  `target_triple` string is copied. The initial implementation recognizes:

  - `linux-x86_64` (default), and common `x86_64-*-linux-*` triples such as
    `x86_64-linux-gnu` and `x86_64-unknown-linux-gnu`,
  - `wasm32-unknown-unknown`,
  - `wasm32-wasi` (and other `wasm32` triples containing `wasi`).

  For `wasm32` targets, only `SILK_OUTPUT_EXECUTABLE` is supported. The output
  bytes are a final WebAssembly module (`.wasm`) produced by the IR-backed wasm
  backend (`src/backend_wasm_ir.zig`), with a smaller constant-only fallback for
  programs that fit the constant subset.

  The wasm backend is still early-stage, but it is no longer limited
  to single-module constant programs:

  - Multi-module builds (packages + file imports) are supported.
  - `ext foo = fn (...) -> ...;` declarations become imported functions under
    `env.foo` for `wasm32-unknown-unknown`, analogous to `extern` symbols in C.
  - String and other constant data are emitted into wasm data segments.

  Entrypoint conventions:

  - `wasm32-unknown-unknown`:
    - when a valid executable `main` exists, it is exported as `main` for
      embedder use,
    - when no `main` exists, an export-only module is emitted that exports each
      supported `export fn` from the root package.
  - `wasm32-wasi`:
    - requires `fn main () -> int` (the `main(argc, argv)` form is not supported
      yet for WASI),
    - emits an exported `_start () -> void` wrapper that calls `main` and then
      imports/calls WASI `proc_exit`,
    - export-only modules are supported for embedding (export-only modules do
      not include `_start`).

  `silk_compiler_add_needed_library` records a dynamic loader dependency for
  executable and shared library outputs (emitted as `DT_NEEDED`). The `soname`
  string is copied; the function may be called multiple times (duplicates are
  ignored). For static library and object outputs, the value is ignored.
  `DT_NEEDED` entries starting with `libsilk_rt` are rejected: bundled runtime
  helpers are linked statically from `libsilk_rt.a` / `libsilk_rt_noheap.a` and
  must not become runtime loader dependencies.
  On `linux/x86_64` with the glibc dynamic loader (`ld-linux`), when an
  executable or shared library imports any external symbols, the compiler
  automatically adds `libc.so.6` as a `DT_NEEDED` dependency (so embedders do
  not need to manually add libc when using hosted `std::` modules like
  `std::io` and `std::fs`). Additional non-libc dependencies must still be
  declared via `silk_compiler_add_needed_library`.

  `silk_compiler_add_runpath` records a dynamic loader search path element for
  executable and shared library outputs (emitted as `DT_RUNPATH`). The `path`
  string is copied; the function may be called multiple times (duplicates are
  ignored) and the final `DT_RUNPATH` string is formed by joining all entries
  with ':'.

  `silk_compiler_set_soname` configures the shared library soname recorded as
  `DT_SONAME` for shared library outputs. The `soname` string is copied; passing
  an empty string clears the configured soname (no `DT_SONAME` entry). For
  executable, static library, and object outputs, the value is ignored.

  `silk_compiler_set_z3_lib` configures a Z3 dynamic library override for Formal
  Silk verification (equivalent to the CLI `--z3-lib <path>`). Passing an empty
  string clears the override and returns to the normal Z3 selection rules
  (including honoring `SILK_Z3_LIB`).

  `silk_compiler_set_std_archive` configures a stdlib archive override
  (equivalent to the CLI `--std-lib <path>`). Passing an empty string clears
  the override and returns to the normal stdlib archive selection rules
  (including honoring `SILK_STD_LIB`).

  `silk_compiler_set_c_header` configures C header generation for non-executable
  outputs (equivalent to the CLI `--c-header <path>`). The header is written
  when `silk_compiler_build` succeeds for `SILK_OUTPUT_OBJECT`,
  `SILK_OUTPUT_STATIC_LIBRARY`, or `SILK_OUTPUT_SHARED_LIBRARY`. C header
  generation is not supported for `silk_compiler_build_to_bytes`.

- Source management:

  ```c
  SilkModule *silk_compiler_add_source_buffer(SilkCompiler *compiler,
                                              SilkString    name,
                                              SilkString    contents);
  ```

- Building artifacts:

  ```c
  bool silk_compiler_build(SilkCompiler   *compiler,
                           SilkOutputKind  kind,
                           SilkString      output_path);
  ```

  For embedders that need filesystem-free compilation (for example sandboxed
  hosts or WASM-like environments), the ABI also provides an in-memory build
  API that returns an owned byte buffer:

  ```c
  bool silk_compiler_build_to_bytes(SilkCompiler   *compiler,
                                    SilkOutputKind  kind,
                                    SilkBytes      *out_bytes);

  void silk_bytes_free(SilkBytes *bytes);
  ```

  The returned bytes are target-specific: for example an ELF64 binary on
  `linux-x86_64`, or a `.wasm` module on `wasm32` targets.

  Ownership rules:

  - On success, `silk_compiler_build_to_bytes` fills `*out_bytes` with a pointer
    and length describing the produced artifact, and returns `true`.
  - The returned `out_bytes->ptr` is owned by `libsilk.a` and must be freed
    by calling `silk_bytes_free(&bytes)`. Callers must not free the pointer with
    `free()` (or any other allocator).
  - `silk_bytes_free` is a no-op when passed `NULL` or when `bytes->ptr` is
    `NULL`; it always clears the struct to `{ NULL, 0 }`.

  Note: the compiler may still consult the filesystem to auto-load `std::...`
  modules unless `silk_compiler_set_nostd(compiler, true)` has been set.

  At the current stage of implementation:

  - `silk_compiler_build` always performs full front‑end validation for all modules
    added via `silk_compiler_add_source_buffer`:
    - it lexes and parses each module into an internal representation,
    - it then type‑checks the *set* of modules as a unit, taking into account
      package/import relationships and exported constants, according to the
    - if Formal Silk syntax is present (for example `#require`, `#assure`,
      `#assert`, `#invariant`, `#variant`, `#monovariant`, `#const`), it also runs the Z3-backed verifier
      and fails the build if verification fails (`E3001`..`E3008`),
    - the verifier is currently skipped for stdlib modules (`std::...`),
    - on `linux/x86_64`, Z3 is linked from the vendored static archive
      `vendor/lib/x64-linux/libz3.a`,
    - the verifier honors `SILK_Z3_LIB` (environment variable) to override
      the Z3 dynamic library at runtime,
    - it fails fast on the first front‑end error.
    - when packages/imports are present:
      - `import` declarations must refer to packages that exist in the current
        module set (otherwise a resolver error is reported, such as
        `"unknown imported package"`),
      - exported `let` bindings with explicit type annotations in an imported
        package are treated as ordinary, unqualified names in the importing
        modules for type‑checking purposes (for example, `import util;` and
        `export let answer: int = 42;` in `util` allows `let x: int = answer;`
        in `app`),
      - imported exported functions (`export fn`) are callable across packages
        for the current scalar subset (both unqualified `foo()` and qualified
        `pkg::foo()` call forms are accepted initially), and functions in the
        same package share a call namespace across modules in the same module
        set,
      - duplicate exported names within a single package are reported as a
        resolver error (`"duplicate exported symbol"`).
    - standard library import resolution (first slice):
      - when a module contains `import std::...;`, the compiler will attempt to
        auto-load the referenced `std::...` package modules from a configured
        stdlib root so embedders do **not** need to provide std sources
        explicitly in the common case,
      - the stdlib root is selected via:
        - `silk_compiler_set_std_root` when set, otherwise
        - `SILK_STD_ROOT` (environment variable) when set, otherwise
        - a `std/` directory in the current working directory (development default), otherwise
        - `../share/silk/std` relative to the current executable (installed default).
      - package-to-path mapping is deterministic:
        - `std::foo::bar` resolves to the file `<std_root>/foo/bar.slk`,
      - if the embedder explicitly provides a `std::...` module via
        `silk_compiler_add_source_buffer`, that module is treated as authoritative
        for its package (auto-loading does not replace already-provided packages).
    - standard library archive linking (`linux/x86_64`, current archive layout):
      - the toolchain can build a target-specific stdlib static archive
        (`libsilk_std.a`) containing one ELF object per std module (for example
        via `make stdlib`),
      - for supported executable builds, the compiler treats *auto-loaded*
        `std::...` modules as external during code generation and resolves their
        exported functions from the archive when available (while still
        type-checking the std sources as part of the module set),
      - archive discovery (in order):
        - `SILK_STD_LIB` when set, otherwise
        - `zig-out/lib/libsilk_std.a` when using the in-repo `std/` root, otherwise
        - `../lib/libsilk_std.a` relative to the current executable, otherwise
        - common installed-layout heuristics derived from the selected stdlib root,
        - walk up from the current working directory to find `libsilk_std.a` or `lib/libsilk_std.a`,
      - when no suitable archive is found (or on unsupported targets), the
        compiler falls back to compiling the reachable std sources into the
        build as part of module-set code generation.
  - When a front‑end error occurs (e.g. parse error, type mismatch, invalid
    control‑flow such as `break`/`continue`/`return` in the wrong context, or
    other semantic violations), the call returns `false` and
    `silk_compiler_last_error`/`silk_error_format` provide a human‑readable
    description (such as `"unexpected token while parsing module"`,
    `"type mismatch"`, `"invalid break statement"`, `"invalid return statement"`,
    `"missing return statement"`,
    etc.).
  - For executable outputs (`kind == SILK_OUTPUT_EXECUTABLE`), the compiler also
    enforces an entrypoint precondition on the front‑end:
    - there MUST be exactly one top‑level function

      ```silk
      fn main() -> int { ... }
      ```

      with no parameters and a declared result type of `int`,
    - otherwise `silk_compiler_build` fails with an error message such as
      `"no valid main function for executable output"` or
      `"multiple main functions for executable output"`.
  - When all modules pass front‑end validation (including the executable
    entrypoint requirement, where applicable), code generation behavior depends
    on `kind`:
    - for non-executable outputs (`SILK_OUTPUT_OBJECT`, `SILK_OUTPUT_STATIC_LIBRARY`, `SILK_OUTPUT_SHARED_LIBRARY`):
      - `main` is optional, but when more than one valid executable `main` exists in the module set,
        `silk_compiler_build` fails with `"multiple main functions for non-executable output"`,
      - when multiple packages are present in the module set, only exports from the *root package*
        (the package of the first module added to the compiler via `silk_compiler_add_source_buffer`)
        are emitted as globally-visible symbols for that output; other packages are compiled as
        dependencies and their `export` declarations are treated as internal for that output.
      - within the current `linux/x86_64` IR subset, `string` and `regexp` values are supported at ABI boundaries in a C-friendly `SilkString { ptr, len }` layout:
        - `string`/`regexp` parameters lower to two integer-like scalars in order (`u64` pointer, then `i64` byte length) and consume the normal integer argument locations (registers then stack),
        - `string`/`regexp` results return as two integer-like scalars in `rax`/`rdx`,
        - within function bodies, the compiler supports a small `string`/`regexp` expression subset:
          - `string`: string literals, `let` bindings of `string`, `return` of a `string` value, direct calls to `string`-returning helpers, and `==`/`!=`/`<`/`<=`/`>`/`>=` comparisons over `string` values (producing `bool`),
          - `regexp`: regex literals (`/pattern/flags`), `let` bindings of `regexp`, `return` of a `regexp` value, and direct calls between helpers that accept/return `regexp`,
          - other string operations (concatenation, indexing, etc.) are not implemented yet; higher-level regex matching lives in `std::regex` and is routed through `ext` calls.
      - within the current `linux/x86_64` IR subset, `i128`/`u128`/`f128` values are supported at ABI boundaries using the stable C99 `{ lo, hi }` struct shapes:
        - parameters lower to two integer-like scalars (`u64 lo`, then `u64`/`i64 hi`) and consume integer argument locations,
        - results return as two integer-like scalars in `rax`/`rdx`,
        - `f128` values are transported as raw IEEE binary128 bits in the two lanes (not via SSE registers).
      - within the current `linux/x86_64` IR subset, a limited `struct` subset is supported at ABI boundaries:
        - within function bodies and internal helper calls, `struct` declarations with 0+ fields of supported value types are supported (scalar primitives, `string`, nested structs, and supported optionals),
        - at ABI boundaries for exported/FFI functions, only ABI-safe structs are currently supported: after slot-flattening, all scalar slots must be `i64`/`u64`/`f64` (until packed ABI mapping for smaller fields is implemented),
        - at the C ABI surface, exported function *parameters* support 1+ slot ABI-safe structs by lowering the struct to its scalar slots in order; downstream C callers should declare separate parameters for 3+ slot structs (by-value C struct parameters are ABI-compatible only for the 1–2 slot cases), while exported function *returns* support 1+ slot ABI-safe structs (3+ slot returns use the native backend’s sret return path and are ABI-compatible with returning an equivalent C struct by value),
        - in all cases, the compiler lowers a struct value into N scalar slots in field order and assigns argument/result locations according to System V AMD64 integer/SSE classification for those slots.
      - within the current `linux/x86_64` IR subset, optionals (`T?`) are supported at ABI boundaries for the supported payload subset (scalar payloads, `string?`, and optionals of ABI-safe structs):
        - an optional lowers to a `Bool` tag followed by the payload scalar slots: `(tag, payload0, payload1, ...)` with `tag=0` for `None` and `tag=1` for `Some(...)`,
        - nested optionals (`T??`) lower by treating the payload slots as the full inner optional representation (for example `int??` lowers as `(tag0, tag1, i64 payload)`),
        - optional parameters are passed as these scalar slots in order (so downstream C callers should declare separate parameters, treating `tag` as an integer-like 0/1 value),
        - optional results return as the same scalar slots (1–2 slots in registers; 3+ slots via a hidden sret pointer as described above).
    - for object outputs (`SILK_OUTPUT_OBJECT`):
      - on `linux/x86_64`, the compiler can emit an ELF64 relocatable object
        (`ET_REL`) for the supported IR subset, emitting supported functions
        (scalar-returning, `void`-returning, and a limited `string` subset) and supported exported constants
        (`export let`/`export const`; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit `: string` when the initializer is a string literal), and marking `export fn`
        declarations, supported exported constants, and a valid executable `main`
        (when present) as global symbols,
      - when the module set contains no supported globally-visible symbols (no
        supported `export fn`, no supported `export let` constants, and no valid
        executable `main`), `silk_compiler_build` still succeeds and writes a
        valid relocatable object with no globally-visible symbols,
      - for programs outside that subset (or on unsupported targets),
        `silk_compiler_build` returns `false` with an `E4001` / `E4002` formatted diagnostic (via `silk_compiler_last_error` / `silk_error_format`)
        and does not write an output file.
    - for static library outputs (`SILK_OUTPUT_STATIC_LIBRARY`):
      - on `linux/x86_64`, the compiler can emit a static library archive
        (`.a`) containing an object file for the supported IR subset, emitting
        supported functions (scalar-returning, `void`-returning, and a limited `string` subset) and supported
        exported constants (`export let`/`export const`; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit `: string` when the initializer is a string literal), and
        marking `export fn` declarations, supported exported constants, and a
        valid executable `main` (when present) as global symbols,
      - when the module set contains no supported globally-visible symbols (no
        supported `export fn`, no supported `export let` constants, and no valid
        executable `main`), `silk_compiler_build` still succeeds and writes a
        valid archive containing an object file with no globally-visible symbols,
      - for programs outside that subset (or on unsupported targets),
        `silk_compiler_build` returns `false` with an `E4001` / `E4002` formatted diagnostic (via `silk_compiler_last_error` / `silk_error_format`)
        and does not write an output file.
    - for shared library outputs (`SILK_OUTPUT_SHARED_LIBRARY`):
      - on `linux/x86_64`, the compiler can emit an ELF64 shared library
        (`ET_DYN`, typically with a `.so` filename) for the supported IR subset,
        emitting supported functions (scalar-returning, `void`-returning, and a limited `string` subset) and
        supported exported constants (`export let`/`export const`; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit `: string` when the initializer is a string literal), and
        marking `export fn` declarations, supported exported constants, and a
        valid executable `main` (when present) as dynamic global symbols,
      - when the module set contains no supported globally-visible symbols (no
        supported `export fn`, no supported `export let` constants, and no valid
        executable `main`), `silk_compiler_build` still succeeds and writes a
        valid shared library with an empty export set,
      - for programs outside that subset (or on unsupported targets),
        `silk_compiler_build` returns `false` with an `E4001` / `E4002` formatted diagnostic (via `silk_compiler_last_error` / `silk_error_format`)
        and does not write an output file.
    - for executable outputs (`SILK_OUTPUT_EXECUTABLE`):
      - the implementation supports a **minimal constant‑expression backend**:
        - the program must satisfy the entrypoint rule above,
        - the body of `main` must be one of the following shapes:
          - zero or more `let` statements whose initializers are constant
            integer expressions, followed by exactly one `return` statement
            that returns a *constant integer expression* built only from:
            - integer literals,
            - the arithmetic operators `+`, `-`, `*`, `/`, and `%`,
            - and references to immutable `let` bindings (top‑level or local
              to `main`, or imported exported scalar constants from imported
              packages) whose initializers are themselves constant integer
              expressions in this same sense (no side‑effecting operations);
              imported exported constants must be declared as `export let` or
              `export const` with the shape `export <binding> name: <scalar> =
              <literal>;` (explicit scalar type and literal initializer),
            - on `linux/x86_64`, direct calls to simple helper functions of
              the form

              ```silk
              fn helper (x, y) -> int {
                [let ...;]
                return <expr>;
              }
              ```

              where:
              - parameters may be annotated as scalar types (defaulting to
                `int` when unannotated),
              - arguments at each call site are drawn from the same
                scalar expression subset as `<expr>` (including `bool`,
                `char`, `Instant`, `Duration`, fixed-width integers, and
                `f32`/`f64` on `linux/x86_64`), with optionals (`T?`)
                supported for scalar
                payloads, `string?`, and optionals of the POD `struct`
                subset via `None` / `Some(...)` and `??`
                coalescing, and
              - in module-set builds, helper calls may target:
                - functions defined in the same package (across multiple
                  modules), and
                - imported exported functions (`export fn`) from any
                  packages imported by the module that contains `main`
                  (both `foo()` and `pkg::foo()` call forms are accepted
                  initially for imported exports),
              - the helper body either:
                - consists only of scalar `let` bindings and a final
                  `return`, or
                - ends in a simple `if` / `else` of the form:

                  ```silk
                  if <cond> {
                    [let ...;]
                    return <expr>;
                  } else {
                    [let ...;]
                    return <expr>;
                  }
                  ```

                  where `<cond>` is a boolean expression built from comparisons
                  over scalar expressions and boolean literals, and both
                  branches end in `return`;
              such calls are lowered to IR `Call` instructions and compiled
              to native code together with `main`, using the System V AMD64
              scalar calling convention on `linux/x86_64` (integer-like
              scalars in `rdi`..`r9`, `f32`/`f64` in `xmm0`..`xmm7`, with
              additional arguments spilled to the stack); helpers may have
              more than six integer parameters, and this path is exercised
          - a final `if` statement whose condition is a boolean expression:
            - for the purely constant subset, the condition is a
              **compile‑time boolean literal** (`true` or `false`) and each
              branch body itself satisfies the same “constant lets +
              `return` constant integer expression” rule, and
            - on `linux/x86_64`, a slightly richer branching `main` shape is
              also supported in which the body is exactly:

              ```silk
              fn main () -> int {
                if <cond> {
                  [let ...;]
                  return <expr>;
                } else {
                  [let ...;]
                  return <expr>;
                }
              }
              ```

              where `<cond>` is built from integer comparisons (`==`, `!=`,
              `<`, `<=`, `>`, `>=`) over integer expressions from the same
              constant subset; this shape is lowered to IR using `BrCond` and
              compiled to native code by the IR→ELF backend so that the
              condition is evaluated at runtime, or
          - one or more **trivial constant `while` loops** that appear before
            the final `return`, each of which has:
            - a condition that is a compile‑time boolean literal (`true` or
              `false`),
            - for `while false { ... }`, a body that is ignored by the
              constant backend, and
            - for `while true { ... }`, a body consisting of zero or more
              constant `let` statements followed by a `break;`, with no other
              control‑flow; loop invariants (`#invariant`) and variants
              (`#variant`) may be present but are treated as metadata and do
              not affect constant evaluation,
        - examples of supported forms include:

          ```silk
          fn main() -> int { return 0; }
          fn main() -> int { return 1; }
          fn main() -> int { return 1 + 2 * 3; }

          let answer: int = 21 * 2;

          fn main() -> int {
            return answer;
          }

          // Two-module imported constant example (module-set builds only):
          //
          // util.slk
          package util;
          export let answer: int = 42;
          //
          // app.slk
          package app;
          import util;
          fn main () -> int { return answer; }

          // Two-module imported function example (module-set builds only):
          //
          // util.slk
          package util;
          export fn add (x: int, y: int) -> int { return x + y; }
          //
          // app.slk
          package app;
          import util;
          fn main () -> int { return add(40, 2); }

          fn main () -> int {
            let a: int = 21;
            let b: int = a * 2;
            return b;
          }

          fn main () -> int {
            if true {
              return 0;
            } else {
              return 1;
            }
          }

          fn main () -> int {
            while true {
              break;
            }
            return 0;
          }
          ```

      - when these conditions hold and `output_path` names a valid path,
        `silk_compiler_build`:
        - evaluates the constant integer expression in the body of `main`,
        - emits a tiny native executable image directly using a Silk‑owned
          backend (no C stub, no external C compiler),
          - currently this backend writes a minimal ELF64 executable for
            `linux/x86_64` whose entrypoint immediately performs a
            `sys_exit(value)` system call,
        - returns `true` on success with no last error recorded.
      - when the program is front‑end valid but outside this subset
        (e.g. `main` contains non‑constant expressions, references to
        non‑constant values, or calls that fall outside the simple
        helper‑call subset described above),
        or when the backend cannot produce an executable for the current
        platform or output path, the call returns `false` and records either
        an `E4001` / `E4002` diagnostic (for unsupported constructs or backend failures) or
        a descriptive string for I/O/argument errors as the last error.

- Error reporting:

  ```c
  SilkError *silk_compiler_last_error(SilkCompiler *compiler);

  size_t silk_error_format(const SilkError *error,
                           char            *buffer,
                           size_t           buffer_len);
  ```

  - `silk_error_format` returns a human-readable diagnostic message. When the compiler can associate the error with a source span, the formatted message includes the module name/path plus line/column and a caret snippet.

Ownership, lifetime, and thread-safety guarantees for these APIs must be clearly documented and kept in sync with the implementation.

ABI rules:

- All exposed functions must be C99-compatible.
- Data layouts must be stable and match the Silk side.
- Ownership and lifetime of any pointers passed across the boundary must be explicitly documented.

In addition, the embedding ABI must clearly distinguish:

- functions that consume Silk‑owned values (e.g. `SilkString` whose storage is owned by the runtime) versus
- functions that take ownership of data supplied by the embedder (and are responsible for freeing it via documented APIs).


## See Also

- `libsilk` (7) — C99 ABI manpage for embedders.
- `silk.h` — public C header shipped with the library.

==============================================================================
DOCS: Compiler Architecture (compiler/architecture)
URL: /silk/docs/?p=compiler/architecture
==============================================================================

# Compiler Architecture

This document describes the intended architecture of the Silk compiler implemented in Zig.

Current hard implementation limits (file size caps, current maxima, etc.)

## High-Level Structure

The compiler is implemented in Zig and organized into three major layers:

- Front-end:
- Middle-end:
  - Optimizations that respect the language’s safety guarantees.
- Back-end:
  - Code generation for executables, static libraries, and shared libraries using an Silk-owned backend (IR + codegen), not by “transpiling to C”.
  - Emission of object files and archives that can be linked into executables and libraries.
  - C99 ABI mappings for interop with `libsilk.a`.

In terms of concrete targets and file formats, the back-end MUST eventually support:

- ELF for Unix-like systems:
  - initial implementation is `linux/x86_64` only (already prototyped for constant-expression `main`),
  - `linux/aarch64` (ARM64) is a required future target,
  - position-independent code and shared objects (`.so`) for dynamic libraries.
- Mach-O for macOS:
  - both Intel (`x86_64`) and Apple Silicon (`arm64`) MUST be supported,
  - dynamic libraries (`.dylib`) for loading Silk packages at runtime.
- PE/COFF for Windows:
  - initially `x86_64`, with other architectures considered later as needed,
  - DLLs for dynamic loading.

The current ELF-only constant-expression backend is a temporary first slice targeting `linux/x86_64`; Mach-O, PE/COFF, and additional architectures (notably ARM64 on Linux and macOS), as well as full object-file, archive (`.a`), and shared-library emission, are explicit future requirements and MUST be planned and implemented as the back-end matures.

An initial IR-driven, native backend is being prototyped alongside the existing constant-expression emitter:

- the front-end (parser + checker) produces `ast.Module` values,
- a lowering pass in `src/lower_ir.zig` translates a constrained subset of `fn main() -> int` programs into `ir.Function` graphs, using integer arithmetic, comparisons, and simple control flow (`Br` / `BrCond`),
- a target-independent IR interpreter in `src/ir_eval.zig` provides reference semantics for these IR functions,
- the existing ELF64 emitter in `src/backend_const.zig` still constructs the final executable image by writing a minimal ELF64 file for `linux/x86_64` whose entrypoint performs a `sys_exit(value)` system call,
- a dedicated IR→ELF backend module (`src/backend_ir_elf.zig`) will gradually assume responsibility for emitting native code directly from `ir.Function` graphs, starting with a single-function, integer-returning subset and expanding as more language features are lowered to IR.

### Packages, Modules, Imports, and Exports

Silk programs are organized into **packages** and **modules**:

- A *module* is a single source file and the natural unit of parsing and type checking.
- A *package* is a collection of modules that share a namespace and build configuration (e.g. the main package, `std::`, and third-party packages).
- Packages may:
  - **export** symbols (types, functions, constants) that are visible to importers,
  - **import** symbols from other packages via explicit imports.

The compiler MUST:

- represent packages and their dependency graph explicitly in the middle-end,
- implement an import resolver that:
  - maps import paths to source modules/packages,
  - enforces acyclic and well-formed package graphs,
- implement symbol visibility rules:
  - distinguish exported vs internal symbols within a package,
  - ensure only exported symbols are visible across package boundaries.

Front-end work (parser, checker, resolver) and back-end work (linkage, symbol emission) MUST be designed so that:

- importing and exporting package symbols is a first-class, well-specified feature,
- building advanced programs that span multiple modules and packages (including `std::` and user packages) is supported by both the CLI (`silk`) and the C ABI (`libsilk.a`).

The concrete surface syntax for packages, imports, and exports is specified in
incrementally in the front-end. Resolver and back-end integration will follow
that spec.


### Executable Entrypoint (Initial Rule)

For executable builds driven via the C ABI (`SILK_OUTPUT_EXECUTABLE`) and,
eventually, the `silk` CLI, the compiler enforces a simple, explicit entrypoint:

- there MUST be exactly one top-level function with the signature:

  ```silk
  fn main() -> int { ... }
  ```

- this function:
  - takes no parameters,
  - returns `int`,
  - serves as the process entrypoint when an executable is produced.

At the current implementation stage, this requirement is enforced by the
front-end (via `silk_compiler_build`) and a minimal back-end
that currently supports only constant integer `main` functions. This is a
temporary measure; the long-term back-end is a true Silk code generator, not
a C transpiler.

## Module Layout (Draft)

This is a draft module layout for the Zig implementation. Exact file names may change, but the layering should be preserved.

- `src/` (compiler implementation):
  - `src/driver.zig` — CLI entry points and high-level orchestration.
  - `src/lexer.zig` — tokenization and trivia handling.
  - `src/parser.zig` — AST construction.
  - `src/ast.zig` — AST node definitions.
  - `src/types.zig` — type system representation and operations.
  - `src/checker.zig` — type checking and semantic analysis.
  - `src/formal_silk.zig` — Formal Silk VC generation and verification (Z3-backed).
  - `src/z3_api.zig` — Z3 C API shim (static-by-default, optional dynamic override).
  - `src/ir.zig` — core intermediate representation.
  - `src/codegen.zig` — target-independent code generation logic.
  - `src/abi.zig` — C99 ABI and FFI glue for `libsilk.a`.
  - `src/std_integration.zig` — integration with the `std::` package and stdlib selection.
  - `src/cli/` (optional breakdown):
  - `src/cli/options.zig` — option parsing.
  - `src/cli/commands.zig` — `build`, `check`, `abi` subcommands.


Test code is expected to live alongside these modules (via Zig `test` blocks) and/or under dedicated test drivers.

## Test Layout (Draft)

Testing is incremental and must be developed alongside the implementation:

- Zig unit tests:
  - Each core module (`lexer.zig`, `parser.zig`, `checker.zig`, etc.) contains Zig `test` blocks that exercise its behavior.
- C99 tests:
    - link against `libsilk.a`,
    - use the C ABI (`silk.h`) to drive compilation/execution,
    - validate FFI and ABI behavior.

The build system (Zig build file and any supporting scripts) must be wired so that:

- running the Zig test suite exercises all relevant `test` blocks,
- running the C test suite builds and runs the C harnesses,
- both suites can be invoked easily during development and CI.

==============================================================================
DOCS: Compiler Diagnostics (compiler/diagnostics)
URL: /silk/docs/?p=compiler/diagnostics
==============================================================================

# Compiler Diagnostics

This document specifies the *human-readable* diagnostic format emitted by the Silk toolchain, including:

- the `silk` CLI (`silk check`, `silk build`),
- the embedding ABI (`libsilk.a` via `silk_compiler_last_error` / `silk_error_format`),
- and tooling that reuses the front-end (for example `silk-lsp`).

The goal is to provide diagnostics that are:

- precise (file + line + column + source span),
- stable (consistent wording and stable error codes for known error kinds),
- consumable by humans (caret snippets, notes/help where appropriate),
- easy to test (deterministic formatting; the canonical text contains no ANSI escapes).

## Terminology

- **Source span**: a byte range in the UTF‑8 source buffer (`offset`, `length`).
  - Displayed **line** and **column** numbers are **1-based**.
  - Columns are measured in **UTF‑8 bytes** (matching the lexer’s current `Token.column` behavior).
- **Primary label**: the main span where the error is reported (single span in the initial implementation).
- **Note / Help**: supplemental lines that explain context or suggest a fix.

## Text Format (CLI and ABI)

The standard human-readable diagnostic format is:

```
error[E<code>]: <message>
 --> <path>:<line>:<column>
  |
<line> | <source line text>
  | <caret underline>
  = note: <note text>        (optional, repeatable)
  = help: <help text>        (optional, repeatable)
```

Rules:

- The `error[...]` line always appears for known error kinds; `<code>` is stable for that error kind.
- For diagnostics with no usable location, the `--> ...` and snippet block may be omitted.
- The snippet block uses the 1-based line number and includes the full line text as it appears in the source.
- The caret underline is placed under the primary span:
  - for a zero-length span, print a single `^`,
  - otherwise print `^` repeated for the span length, clipped to the line end if needed.
- The canonical text format contains no ANSI color escapes.

## Manifest and Config Errors

The CLI uses the same caret diagnostic format for errors in tooling/config inputs,
including the package manifest `silk.toml` and build-script-generated manifests.
These diagnostics may not yet have stable error codes.

Example (missing `=` in `silk.toml`):

```
error: invalid TOML in package manifest
 --> silk.toml:2:6
  |
2 | name "app"
  |      ^ expected `=`
```

## ANSI Color (CLI)

The `silk` CLI may decorate the canonical diagnostic format with ANSI SGR escape codes
when writing to a terminal. The visible text (after stripping ANSI escapes) must still
match the canonical format.

Color is enabled only when:

- stderr is a TTY that supports ANSI escapes,
- `NO_COLOR` is not set,
- `TERM` is not `dumb`.

Color is never used for the embedding ABI (`silk_error_format` / `silk_compiler_last_error`),
and is not used when stderr is not a TTY (for example when piping diagnostics to a file).

## Suggestions and Help Text

Diagnostics may include one or more `= help:` lines that suggest concrete fixes.
These are heuristic and may be omitted when the compiler cannot compute a safe
suggestion.

Examples of help/suggestion content the compiler may emit:

- for unknown imports, a `"did you mean ...?"` suggestion based on nearby names,
- for file imports, a note about the *resolved* import path,
- reminders about enabling or configuring the standard library (`--nostd`,
  `--std-root`, `SILK_STD_ROOT`) when importing `std::...`,
- guidance to include additional modules in the build/module set when an import
  refers to a package or file that is not present.

## Error Codes (Initial Set)

The compiler assigns a stable code to each currently supported error kind.

### Parsing

- `E0001` — unexpected token / invalid top-level ordering.

### Import and Package Resolution

- `E1001` — unknown imported package.
- `E1002` — cyclic package imports.
- `E1003` — unknown imported file.
- `E1004` — cyclic file imports.
- `E1005` — duplicate exported symbol within a package.
- `E1006` — file imports require a module file path.

### Type Checking

- `E2001` — type mismatch.
- `E2002` — unsupported construct in Silk (the diagnostic detail may identify the rejected statement/expression form).
- `E2003` — unknown imported name.
- `E2004` — duplicate imported name.
- `E2005` — invalid assignment.
- `E2006` — invalid borrow.
- `E2007` — invalid `break`.
- `E2008` — invalid `continue`.
- `E2009` — invalid `return`.
- `E2010` — missing `return`.
- `E2011` — opaque struct used by value.
- `E2012` — cannot instantiate opaque struct.
- `E2013` — cannot access fields on opaque struct.
- `E2014` — formal Silk declaration used in runtime expression.
- `E2015` — `let` requires an initializer.
- `E2016` — unsupported generic form in Silk (for example const parameters / const type arguments).
- `E2017` — builtin `map(K, V)` type form was removed (use `std::map::{HashMap, TreeMap}` instead).
- `E2018` — namespace import is not callable.
- `E2019` — duplicate default export in a module.
- `E2020` — invalid `panic` statement.
- `E2021` — unknown error type.
- `E2022` — error not declared in function signature.
- `E2023` — error-producing call must be handled with `match`.
- `E2024` — match scrutinee is not an error-producing call.
- `E2025` — match is missing an arm.
- `E2026` — typed error-handling match arm must end with a terminal statement.
- `E2027` — heap allocation is disabled (`--noheap`) and heap-backed allocation is rejected (`new` outside `with`, libc allocator `ext`, concurrency keywords, capturing closures).
- `E2028` — unknown name.
- `E2029` — ambiguous implicit coercion.
- `E2030` — `await` requires an `async` function.
- `E2031` — `async { ... }` / `task { ... }` requires an `async` function.
- `E2032` — ambiguous constructor call.
- `E2033` — `await` requires a Promise operand.
- `E2034` — cannot copy a Task/Promise handle.
- `E2035` — Task/Promise handle used after `await`/`yield *`.
- `E2036` — cannot consume an outer Task/Promise handle inside a loop.
- `E2037` — `task fn` uses a non-task-safe type at a task boundary.
- `E2038` — `?` requires an error contract (`-> T | ErrorType...`).
- `E2039` — `?` requires a fallible call operand.
- `E2040` — propagated error is not declared in the function signature.
- `E2041` — `const` initializer is not compile-time evaluable.
- `E2042` — `pure fn` may not have a typed-error contract (`|` in return type).
- `E2043` — `pure fn` may not contain `panic` statements.
- `E2044` — `pure fn` may not have `mut` parameters.
- `E2045` — `pure fn` may not declare mutable locals (`var` or `let mut`).
- `E2046` — `pure fn` may not perform mutation via assignment.
- `E2047` — `pure fn` may not allocate (`new`).
- `E2048` — `pure fn` may not call impure functions.
- `E2049` — `pure fn` may not be combined with `task` or `async`.
- `E2050` — theories are not callable as runtime functions (use `#theory Name(...);`).
- `E2051` — module does not satisfy the declared interface (missing exported function).
- `E2052` — module does not satisfy the declared interface (signature mismatch).
- `E2053` — unknown re-export name.
- `E2054` — duplicate exported name.
- `E2055` — prototype implementation is missing required import of its prototype module.
- `E2056` — function expression may not have `&T` parameters.
- `E2057` — duplicate type alias name.
- `E2058` — type alias cycle.
- `E2059` — type alias kind mismatch.
- `E2060` — unknown `extends` base.
- `E2061` — invalid `extends` base.
- `E2062` — cyclic `extends` chain.
- `E2063` — derived struct redeclares an inherited field name.
- `E2064` — derived interface redeclares an inherited method name.
- `E2065` — opaque structs may not use `extends`.
- `E2066` — prototype and implementation signatures do not match.
- `E2067` — capturing closure is not allowed in `pure` code.
- `E2068` — capturing closure capture type is not supported in Silk.
- `E2069` — capturing closure may not capture a mutable binding in Silk.
- `E2070` — `yield` requires a `task` context.
- `E2071` — `yield` in value position requires a Task operand.
- `E2072` — `yield *` requires a Task operand.
- `E2073` — `yield` as a statement requires an enclosing task function.
- `E2074` — `await *` requires a Promise-array operand.
- `E2075` — duplicate type name.
- `E2076` — generic type arguments must be fully specified at the use site (missing a required, non-default type argument).
- `E2077` — invalid `region` declaration.
- `E2078` — `with` requires a region binding.
- `E2079` — invalid `with ... from` region slice.
- `E2080` — reserved (previously: indexing a slice cast from `u64` required an explicit length).
- `E2081` — slice-length cast suffix requires a `u64` pointer operand.
- `E2082` — `const fn` may not be `task` or `async`.
- `E2083` — `const fn` may not have a typed-error contract (`|` in return type).
- `E2084` — `const fn` parameter types must be compile-time value types.
- `E2085` — `const fn` result type must be a compile-time value type.
- `E2086` — `const fn` may not allocate (`new`).
- `E2087` — `const fn` may not call a non-`const fn`.
- `E2088` — `const fn` may not contain `panic` statements.
- `E2089` — unsupported construct in a `const fn` body (outside the current const-eval subset).
- `E2090` — `const fn` may be called only from compile-time contexts.
- `E2091` — generic function call type arguments could not be inferred at the call site.
- `E2092` — use of moved value.
- `E2093` — `move` requires a local binding name.
- `E2094` — slice borrow escapes its lexical scope.
- `E2095` — reference borrow escapes its lexical scope.
- `E2096` — unknown `using` target.
- `E2097` — `using` alias conflicts with an existing name.
- `E2098` — `using` target is ambiguous.
- `E2099` — `using` cannot import `constructor` in Silk.
- `E2100` — `using` may not import methods that require mutable `Self` borrows in Silk.
- `E2101` — `using` method reuse requires compatible struct layouts.
- `E2102` — cannot move value while it is borrowed.
- `E2103` — invalid regexp flags (unknown or duplicate).
- `E2104` — invalid regexp literal (pattern compile failed).
- `E2105` — method is private to its `impl` block (not visible from the call site).
- `E2106` — interface-required methods may not be declared `private`.
- `E2107` — destructuring requires a non-opaque struct value.
- `E2108` — cannot destructure opaque struct.
- `E2109` — destructuring pattern does not match the struct type (wrong arity, unknown field, or duplicate binder/field).
- `E2110` — array destructuring requires an array/slice value.
- `E2111` — array destructuring pattern does not match the array type (wrong arity for fixed arrays, or duplicate binder).
- `E2112` — enum destructuring requires an enum value.
- `E2113` — enum destructuring pattern does not match the enum type (unknown variant or wrong arity).
- `E2114` — reserved (previously: `u128` not supported in the subset).
- `E2115` — reserved (previously: `f128` not supported in the subset).

### Formal Silk Verification

- `E3001` — loop invariant may not hold.
- `E3002` — loop variant may be negative.
- `E3003` — loop variant may not decrease.
- `E3004` — postcondition may not hold.
- `E3005` — Formal Silk verification failed to initialize or encountered an unsupported construct.
- `E3006` — assertion may not hold (`#assert` and theory assertions).
- `E3007` — call precondition may not hold.
- `E3008` — loop monovariant may not be monotonic.

Notes:

- When `silk build --debug` or `silk test --debug` is used, failed Formal Silk
  checks emit additional Z3 debug output and write an SMT-LIB2 reproduction
  script under `.silk/z3/` in the current working directory (or `$SILK_WORK_DIR/z3`).

### Code Generation / Backend Lowering

- `E4001` — unsupported construct in Silk.
- `E4002` — code generation failed in the backend (unexpected backend error).

Notes:

- This error is reported when a program successfully parses and type-checks, but
  IR lowering or native code generation cannot yet handle a construct.
- The diagnostic detail names the rejected construct kind (statement /
  expression / function) and its surface form tag when available.

## Tooling Integration Notes

- `silk-lsp` should map the compiler’s primary source span to the LSP diagnostic range directly.
- When the compiler grows multi-span diagnostics (labels and secondary spans), the LSP implementation must be updated to surface them.

==============================================================================
DOCS: Compiler Limits (compiler/limits)
URL: /silk/docs/?p=compiler/limits
==============================================================================

# Compiler Limits

This document enumerates the current hard limits in the Silk compiler and its
tooling. These limits are **implementation guardrails** (primarily to keep
memory usage bounded when compiling untrusted inputs); they are not intended to
be permanent language constraints unless explicitly called out in the language

Where a language feature has an implementation cap that affects user code, the
cap is also documented in the relevant language document (for example

## Source and Manifest Size Limits

- **Silk source file max size (per file)**: **64 MiB**
  - Applies to:
    - the `silk` CLI (`src/driver.zig`),
    - the Zig wrapper API that loads sources from disk (`src/silk.zig`),
    - the C ABI entrypoints that load sources from disk (`src/abi.zig`),
    - the LSP server file loader (`src/lsp_main.zig`).
  - Rationale: avoid unbounded allocations while still allowing large modules.
- **Package manifest max size**: **1 MiB**
  - Applies to reading `silk.toml` (`src/package_manifest.zig`).

## Front-End (Type Checker) Structural Limits

The current checker uses fixed-capacity buffers for a number of intermediate
tables. Module-/package-scoped tables are heap-backed to avoid stack overflows
when compiling large module sets, while some per-function scratch state is
still stack-backed.

When these limits are exceeded, the current implementation typically reports
`E2002` (“unsupported expression in Silk”) because the checker
uses `CheckError.UnsupportedExpression` as a shared “not supported yet” / “hit
an internal cap” path. This will be refined into dedicated “limit exceeded”
diagnostics as the compiler matures.

Current caps (`src/checker.zig`):

- **Top-level bindings per module**: **16384**
- **Local bindings per function**: **1024**
- **Function-like bindings tracked in a module set** (functions, externs,
  imported callables, etc.): **16384**
- **Struct declarations tracked in a module set**: **16384**
- **Enum declarations tracked in a module set**: **16384**
- **Interface declarations tracked in a module set**: **16384**
- **Type aliases tracked in a module set**: **16384**
- **Methods tracked in a module set** (impl methods, coercions, etc.): **16384**
- **Fixed array type length cap** (`T[N]`): **4096**

## Varargs Pack Capacity

Varargs are implemented using an internal, fixed-size “pack struct” lowered as
a flattened scalar-slot struct value.

- **Varargs pack capacity** (`N`): **128**


## Lowering / IR Limits

Current caps (`src/lower_ir.zig`):

- **Lowering binding environment size (per function)**: **1024**
  - This is the maximum number of simultaneously in-scope bindings that the IR
    lowerer can track in the current implementation.
- **Type-alias resolution depth**: **256**
  - This bounds recursive/chain alias resolution during lowering to avoid
    runaway recursion in pathological cases.
- **Varargs pack capacity** (`N`): **128**

## Const Evaluator Limits

The current const-evaluator used for the `fn main() -> int` constant
program path builds a small environment of constant top-level `let` bindings
that `main` may reference.

- **Const-eval environment bindings**: **4096** (`src/backend_const.zig`)

If a module exceeds this, additional candidate bindings are ignored for the
purposes of const-evaluating `main` in that path.

==============================================================================
DOCS: Intermediate Representation (IR) – Overview (compiler/ir-overview)
URL: /silk/docs/?p=compiler/ir-overview
==============================================================================

# Intermediate Representation (IR) – Overview

This document introduces the initial intermediate representation (IR) used by
the Silk compiler. The IR is intentionally small and focused for now so that
we can start supporting more advanced programs while keeping the design
tractable.

The goals of the IR are:

- provide a target-independent representation of Silk programs,
- be simple enough to interpret or lower to multiple back-ends,
- make control flow and data flow explicit so optimizations are possible.

This document will evolve as the IR grows; it is not yet a complete spec.

## High-Level Shape

The IR is structured in three main layers:

- `IrProgram`
  - represents a collection of functions within a compilation unit,
  - owns an array of `IrFunction` values,
  - identifies a designated entry function by index.
- `IrFunction`
  - represents a single function,
  - owns a sequence of basic blocks,
  - has a designated entry block.
- `IrBlock`
  - represents a basic block:
    - a straight-line sequence of instructions,
    - terminated by a control-flow instruction (e.g. `Return` or branch).
- `IrInstr`
  - represents a single instruction:
    - scalar constants (integers and floats represented as raw bits),
    - integer and floating-point arithmetic and comparisons,
    - explicit control flow (branches and returns),
    - direct calls between functions in the same program,
    - calls to external functions declared in the program,
    - (later) memory operations, aggregates, etc.

Values are referenced by small integer IDs (`ValueId`). IR is not yet in full
SSA form, but the representation is compatible with an SSA-style design.

### Typed Values ()

Although the earliest experiments treated all values as untyped 64-bit
integers, the IR now carries an explicit scalar type for each value so that
front-end lowering, the interpreter, and native back-ends can agree on how
values are represented and passed.

For now, the scalar type universe focuses on booleans, fixed-width integers,
and IEEE-754 floating-point values:

- `Bool`
  - logical `true` / `false` values.
  - Encoded as integers in the IR (`0` = false, `1` = true) so that existing
    arithmetic and comparison machinery can be reused.
- `I8` / `U8`, `I16` / `U16`, `I32` / `U32`, `I64` / `U64`
  - fixed-width integer types with explicit signedness and width.
  - the current lowering and ELF backend primarily exercise `I64`
    (corresponding to the language’s `int` on `linux/x86_64`) plus `Bool` for
    conditions and boolean locals.
- `F32` / `F64`
  - IEEE-754 single- and double-precision floats.
  - Represented in the IR as raw IEEE bits stored in the same 8-byte slot as
    integer scalars:
    - `F64` uses all 64 bits,
    - `F32` uses the low 32 bits (the high 32 bits are canonicalized to 0).

Each `ValueId` is associated with exactly one scalar type; instructions know
both the type of their operands and the type of the value they produce. This
typed representation is used by:

- the lowering passes in `src/lower_ir.zig` to ensure that arithmetic,
  comparisons, and boolean expressions are mapped to the correct instruction
  shapes,
- the IR interpreter in `src/ir_eval.zig` to maintain a consistent runtime
  encoding (everything is stored in 8-byte slots, with `Bool` encoded as
  `0`/`1` and floats stored as raw IEEE bits), and
- the ELF backend in `src/backend_ir_elf.zig` to choose the appropriate
  register/stack conventions and any sign/zero-extension rules when
  additional integer widths are introduced.

In the current implementation, this type information is carried on each
`IrFunction` as:

- a function signature (`param_types` and `result_types`), and
- a `value_types` table that maps each `ValueId` slot to a scalar type.

Future revisions of this document will extend the IR beyond the current scalar
set to cover pointer-like types, address computations, and aggregates
(structs/tuples) along with their layout rules.

The design above is intentionally minimal but is the foundation on which
full language type coverage will be added.

### Multi-Scalar Boundaries (Current Extension)

Most IR functions return exactly one scalar value, but the IR can represent
small aggregate-like results at *function boundaries* by returning multiple
scalars in a fixed order.

Concretely:

- `IrFunction.result_types` is a slice of scalar result types (not a single
  scalar type).
- `Return` returns a slice of `ValueId`s whose length and element types must
  match `result_types`.
- `Call` has `dests` as a slice of `ValueId`s whose length and element types
  must match the callee’s `result_types`.

The first multi-scalar boundary use case is `string` at ABI boundaries,
represented as two scalars in order:

- `ptr: u64` (address of UTF-8 bytes)
- `len: i64` (byte length, excluding any trailing `\\0`)

Within the current back-end subset, this allows exported functions to accept
and return `string` values in a C-friendly `SilkString` layout without adding a
dedicated “string pointer” ABI.

## Minimal Instruction Set (Initial)

The initial IR supports only what is needed to model small scalar-returning
programs, with scalar values drawn from `Bool`, the fixed-width integer types,
and `F32`/`F64`.

In the current compiler, the surface `char` type is lowered into this IR as a
`U32` scalar holding the Unicode code point value.

## Multi-Scalar Values at ABI Boundaries (Initial)

While IR values are scalar, the compiler also supports a small set of
multi-scalar values at function ABI boundaries (parameters and results) by
lowering a single surface-language value into multiple scalar slots:

- `string` is lowered as `{ ptr: u64, len: i64 }` and returns via `rax`/`rdx` on
  a struct value is lowered as 1+ scalar slots in source field order. Each
  field may contribute one or more slots (for example, `string` contributes
  `(u64 ptr, i64 len)`), and nested structs are lowered by concatenating their
  slots. Calls assign each scalar slot to INTEGER/SSE argument slots as if
  passing independent scalars: integer-like slots consume GP argument slots,
  `f32`/`f64` slots consume XMM argument slots, and 1–2 slot results use
  `rax`/`rdx` for integer-like slots and `xmm0`/`xmm1` for float slots (mixed
  aggregates use both). For results with 3+ scalar slots, the native backend
  returns indirectly via a hidden sret pointer passed in `rdi`, storing each
  slot into the caller-provided buffer and returning that pointer in `rax`.

For optionals (`T?`) in Silk, an optional value is
lowered at IR boundaries as a `Bool` tag followed by the payload scalars:
`(Bool tag, payload0, payload1, ...)` where `tag=0` represents `None` and
`tag=1` represents `Some(...)`. The payload scalar slots follow the lowering of
the underlying non-optional type:

- scalar payloads lower as `(Bool tag, payload)`,
- `string?` lowers as `(Bool tag, u64 ptr, i64 len)`,
- and `struct?` lowers as `(Bool tag, slot0, slot1, ...)` for the current POD
  struct subset.

Nested optionals (`T??`) are lowered in this subset by treating the payload
slots as the full inner optional representation. For example, `int??` lowers
as `(Bool tag0, Bool tag1, i64 payload)`.

This keeps the IR scalar-only while allowing the surface language to express
optionals; it maps cleanly to the System V AMD64 ABI as independent scalar
arguments/results, with 3+ scalar results returning via a hidden sret pointer
as described above.

Semantically, most integer-producing instructions are defined in terms of the
destination `ScalarType`: after executing the operation in a larger machine
register, results are canonicalized (masked/truncated and sign-extended for
signed integers) to the destination type.

- `ConstInt`
  - create a constant scalar value; the raw payload is canonicalized to the
    destination `ScalarType`.
  - For floats, the payload is the raw IEEE bit pattern (`F32` uses the low
    32 bits).
- `ConstDataAddr`
  - materialize the address of a read-only data symbol emitted alongside the
    IR program (for example, an embedded string-literal byte blob).
  - `dest` must have scalar type `U64`.
  - Back-ends typically lower this to RIP-relative addressing and either:
    - emit relocations (for relocatable objects), or
    - patch displacements directly once the final `.text`/rodata layout is known.
- `LoadU8`
  - load a single byte from memory at address `base + offset`, zero-extending
    the result into the destination scalar slot.
  - `dest` must have scalar type `U8`, `base` must have scalar type `U64`, and
    `offset` must have scalar type `I64`.
  - The current compiler uses this instruction for bytewise `string` equality
    and ordered comparisons in the `linux/x86_64` IR→ELF backend subset; the IR
    interpreter currently treats it as unsupported.
- `StackAddr`
  - produce the address of the stack slot backing an existing `ValueId`.
  - `dest` must have scalar type `U64`.
  - This is a backend-facing operation used by the current compiler to lower
    borrowed references (`&T`) without requiring contiguous aggregate storage;
    the IR interpreter currently treats it as unsupported.
- `Load`
  - load an 8-byte scalar value from memory at address `ptr` into `dest`,
    canonicalizing the loaded raw bits according to the destination `ScalarType`.
  - `ptr` must have scalar type `U64`.
  - This is used by the current compiler for reading through borrowed references;
    the IR interpreter currently treats it as unsupported.
- `Store`
  - store an 8-byte scalar value from `src` to memory at address `ptr`.
  - `ptr` must have scalar type `U64`.
  - This is used by the current compiler for mutating through borrowed references;
    the IR interpreter currently treats it as unsupported.
- `Copy`
  - copy a scalar value from one `ValueId` to another (both IDs must have the
    same `ScalarType`); this is used by CFG-based boolean lowering to merge
    short-circuit `&&` / `||` paths into a single boolean value slot.
- `AddInt`, `SubInt`, `MulInt`, `DivInt`, `ModInt`
  - integer arithmetic operations on previously defined values of a single
    integer `ScalarType`; for `DivInt`/`ModInt`, signedness is determined by
    the operand type (`I*` vs `U*`), and results are canonicalized to the
    destination type.
- `BitAndInt`, `BitOrInt`, `BitXorInt`
  - bitwise AND/OR/XOR on previously defined integer values.
- `ShlInt`, `ShrInt`
  - shift-left and shift-right on previously defined integer values; `ShrInt`
    uses arithmetic shift-right for signed integer types (`I*`) and logical
    shift-right for unsigned integer types (`U*`).
- `CmpEqInt`, `CmpNeInt`, `CmpLtInt`, `CmpLeInt`, `CmpGtInt`, `CmpGeInt`
  - integer comparison operations on previously defined values, producing a
    result of type `Bool` that is encoded as `0` (false) or `1` (true) in the
    underlying integer storage; for ordered comparisons, signedness is
    determined by the operand type.
- `AddFloat`, `SubFloat`, `MulFloat`, `DivFloat`
  - floating-point arithmetic over `F32` or `F64` values, producing a result
    of the same float type (stored as raw IEEE bits in the destination slot).
- `CmpEqFloat`, `CmpNeFloat`, `CmpLtFloat`, `CmpLeFloat`, `CmpGtFloat`, `CmpGeFloat`
  - floating-point comparisons over `F32` or `F64` values, producing a `Bool`.
  - These follow IEEE-754 semantics: ordered comparisons (`<`, `<=`, `>`, `>=`)
    are false when either operand is `NaN`, and `NaN` compares unequal to
    everything (including itself).
- `Br`, `BrCond`
  - explicit intra-function control flow:
    - `Br` performs an unconditional branch to another basic block by index,
    - `BrCond` branches based on an integer condition value (`0` = false,
      non-zero = true) to either a "then" or "else" target block.
- `Return`
  - terminator that returns zero or more scalar values from the current
    function (matching the enclosing function’s `result_types`).

Additional instructions (memory operations and aggregates) will be added as we
lower richer subsets of the language. The `Call` instruction represents direct
calls between functions within the same `IrProgram`:

- `Call`
  - calls another IR function within the same `IrProgram`,
  - In Silk, calls are:
    - direct (identified by function index, not by name or pointer),
    - between functions that return one or more scalar results (most commonly a
      single integer-like scalar, `Bool`, or `F32`/`F64`, with limited multi-scalar
      boundary support as described above),
    - parameterized over a sequence of scalar arguments whose types must match
      the callee’s `param_types`,
  - semantically, a call:
    - evaluates each argument expression to a scalar value in the caller,
    - transfers control to the callee’s entry block with a fresh frame in
      which parameter value slots `0..N-1` are initialized from those
      arguments,
    - on `Return`, writes the callee’s returned scalars into the caller’s
      destination `ValueId`s (in order) and continues execution in the caller.

The IR also supports calls to external (linker-provided) functions via an
explicit external-function table and call instruction:

- `IrProgram.extern_functions`
  - a list of external functions referenced by the program, each with:
    - a symbol name (as it should appear to the linker),
    - a scalar `param_types` slice,
    - and a scalar `result_types` slice.
- `CallExtern`
  - calls an external function identified by index in `extern_functions`,
  - argument and destination value IDs must match the referenced signature,
  - on `linux/x86_64`, the ELF back-end lowers this in different ways depending
    on the selected output kind:
    - for relocatable object and static library outputs, emits a `.rela.text`
      relocation against an undefined function symbol so downstream linkers can
      resolve it,
    - for shared library and dynamically-linked executable outputs, emits a
      dynamic import and routes the call through a GOT slot that is relocated
      by the platform dynamic loader.

The IR also supports reading external (linker-provided) data symbols via an
explicit extern-data table and load instruction:

- `IrProgram.extern_data`
  - a list of external data symbols referenced by the program, each with:
    - a symbol name (as it should appear to the linker),
    - and the scalar type of the value loaded from that symbol.
- `LoadExtern`
  - loads the current value of an external data symbol identified by index in
    `extern_data` into a destination `ValueId`,
  - the destination’s `ScalarType` must match the referenced extern-data
    entry’s scalar type,
  - on `linux/x86_64`, the ELF back-end lowers this in different ways depending
    on the selected output kind:
    - for relocatable object and static library outputs, emits a `.rela.text`
      relocation against an undefined object symbol so downstream linkers can
      resolve it,
    - for shared library and dynamically-linked executable outputs, emits a
      dynamic import and routes the load through a GOT slot that is relocated
      by the platform dynamic loader.

## Relationship to Front-End and Back-End

Short term (current implementation):

- The IR is now part of the primary executable build path on `linux/x86_64`:
  - the front-end (parser + checker) produces an `ast.Module`,
  - `src/lower_ir.zig` lowers supported programs into `ir.Function` /
    `ir.Program` graphs,
  - `src/backend_ir_elf.zig` lowers those IR graphs directly to a minimal
    native ELF64 executable (no C stub, no external compiler).
- A constant-expression fallback remains in place for programs that type-check
  but are not yet handled by IR code generation:
  - `src/backend_ir_const.zig` attempts IR lowering + interpretation for
    constant-style `fn main() -> int` programs using `src/ir_eval.zig`,
  - if that fails, callers fall back to the legacy AST-based constant
    evaluator in `src/backend_const.zig`,
  - `src/backend_const.zig` emits the tiny ELF64 stub executable for this
    constant-only path.

Medium term:

- The front-end will gain a richer lowering pass that translates general
  (non-constant) Silk functions into `IrFunction` graphs, including:
  - boolean values and comparisons,
  - structured control flow for `if`/`else` and loops expressed as
    multiple basic blocks connected by `Br`/`BrCond`.
- The existing IR interpreter will remain the reference semantics for IR
  programs and will be extended to cover any new instruction kinds.
- Back-ends for ELF/Mach-O/PE will lower from IR to target-specific machine
  code or object files. The current constant-expression ELF64 emitter is a
  minimal slice of this design, not a separate “non-IR” path.

The IR is designed so that importing and exporting package symbols can be
modeled cleanly at the function and module level. Symbol visibility and
one of the layers that will carry that information down to the back-end.

## Lowering Structured Control Flow

Structured control flow in the surface language (`if` / `else` and `while`)
is lowered into explicit basic blocks and branches in IR. The design is:

- Conditions are lowered using a dedicated helper that produces an integer
  value interpreted as a boolean (`0` = false, non‑zero = true).
- `if` / `else` statements become:
  - an entry block that evaluates the condition and terminates in
    `BrCond(cond, then_block, else_block)`,
  - a `then` block containing the lowered then‑branch statements,
  - an `else` block (when present) containing the lowered else‑branch
    statements,
  - an optional join block that receives control when both branches fall
    through (that is, when neither branch unconditionally returns, breaks,
    or continues).
- `while` loops become:
  - a loop header block that evaluates the condition and terminates in
    `BrCond(cond, body_block, exit_block)`,
  - a body block that contains the lowered loop body and typically ends in
    a `Br` back to the header or a `Br` to the exit (for `break`),
  - an exit block that receives control when the loop condition is false.

Current implementation status:

- A narrow, constant‑oriented lowering in `src/lower_ir.zig` is wired into
  the compiler:
  - `lowerMainFunction` lowers constant‑style `fn main() -> int` functions
    into a single‑block `ir.Function` using integer literals, arithmetic,
    and a restricted control‑flow surface (constant `while` and terminating
    `if` with compile‑time boolean conditions).
  - `lowerBranchingMainFunction` lowers a specific branching
    `fn main() -> int` shape into a three‑block IR graph:
    - an entry block that evaluates a non‑constant boolean condition (using
      integer comparisons and boolean literals), followed by `BrCond`,
    - a then block that contains `let` bindings and a `Return`,
    - an else block that contains `let` bindings and a `Return`.
- More general lowering of `if`/`else` and `while` throughout function
  bodies will follow this block‑structured design:
  - nested control flow is expressed by nesting these patterns,
  - join blocks are introduced where multiple paths must converge before
    execution can continue,
  - the IR remains free of implicit control flow; all transfers are
    represented explicitly with `Br` / `BrCond` / `Return`.

## Multi-Function Programs and Calls

Multi-function programs are represented at the IR level using `IrProgram` and
the `Call` instruction:

- `IrProgram` groups a set of `IrFunction` values and identifies an entry
  function index that serves as the starting point when interpreting or
  executing the program.
- Functions within an `IrProgram` may call each other using `Call`:
  - the initial design targets simple scalar-returning helpers of the form
    `fn helper(x: int, y: u8, flag: bool, ...) -> u8` and `fn main() -> int`,
  - calls are direct: the instruction encodes the callee’s function index,
    and recursion is allowed at the IR level (subject to front-end limits),
  - each `IrFunction` records a `param_count` indicating how many parameters
    it expects; parameters are modeled as value IDs `0..N-1`
    that are initialized at function entry.
- The IR interpreter models calls using an explicit call stack:
  - each activation has its own value storage for the callee’s `ValueId`
    space,
  - `Return` instructions pop the current frame and resume the caller,
    writing the callee’s returned scalars into the caller’s destination
    `ValueId`s (in order).
- Native back-ends (starting with the existing ELF64 emitter) lower
  `Call` / `Return` to a concrete calling convention:
  - for `linux/x86_64`, the current implementation follows a simplified
    subset of the System V AMD64 ABI for scalar parameters:
    - integer-like scalars (`Bool` and integers) use the first six
      general-purpose registers (`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`),
    - floats (`F32`/`F64`) use up to 8 XMM registers (`xmm0`..`xmm7`),
    - any additional scalar arguments are spilled to the caller's stack in
      8-byte slots in source order,
    - the caller maintains 16-byte stack alignment before `call` (padding
      by one 8-byte slot below the stack arguments when an odd number of
      stack-passed arguments are present), and
    - results follow the same ABI-style shape as the IR signature:
      - `void` (0 results) returns no value in registers,
      - 1 scalar result returns in `rax` (integer-like) or `xmm0` (float),
      - 2 scalar results return in up to two registers per class (integer-like
        in `rax`/`rdx`, floats in `xmm0`/`xmm1`, assigned in order by class),
      - 3+ scalar results return indirectly via a hidden sret pointer passed
        in `rdi` (shifting integer-like argument registers by one); the caller
        allocates a return buffer and the callee stores returned 8-byte scalar
        slots sequentially into it, returning the same pointer in `rax`,
  - additional types and full ABI parity will be introduced as the language
    and ABI docs are extended.

These multi-function and call semantics are designed here so that IR,
interpreter, and back-ends can evolve in lockstep; the current codebase
still operates primarily on single-function programs, with calls introduced
incrementally in tests and then in the compiler’s lowering pipeline.

==============================================================================
DOCS: Package Manifests (`silk.toml`) (compiler/package-manifests)
URL: /silk/docs/?p=compiler/package-manifests
==============================================================================

# Package Manifests (`silk.toml`)

This document specifies Silk’s package manifest format and how the `silk`
compiler consumes it.

Manifests are a *build/package* concept (they are not part of the core language
syntax). The language-level `package` / `import` / `export` semantics remain

## Manifest Discovery

A package root directory MAY contain a manifest file with one of these names:

- `silk.toml`

Rules:

- When a manifest directory is provided (CLI via `--package <dir>`), the
  compiler looks for `silk.toml` in that directory.
- When a manifest path is explicitly provided (CLI via `--package <path>`), the
  compiler reads exactly that file (and it MUST be named `silk.toml`).

Manifests are encoded as TOML v1.0.

## Diagnostics

When a manifest is malformed (invalid TOML syntax or an invalid manifest shape),
the compiler reports a diagnostic with file, line, and column information and a
caret snippet pointing at the offending token when possible.

## Build Scripts (`build.silk`)

A package root directory MAY also contain a build script:

- `build.silk`

When a build script is enabled via the CLI, the compiler compiles and runs the
script and treats its stdout as a TOML manifest in this format (used in place
of reading `silk.toml` for the root package).


## Package Metadata (`[package]`)

Minimal manifest shape:

```toml
[package]
name = "my_app"
version = "0.1.0"
```

### `package.name` (required)

The package name used for package imports (e.g. `import ui from "ui";`) and as
the default package name for modules that omit an explicit `package ...;`
declaration.

In the current implementation, `name` MUST be a valid Silk package path:

- one or more identifiers separated by `::`
- each identifier matches `[A-Za-z_][A-Za-z0-9_]*`

Examples:

- `ui`
- `my_app`
- `my_app::core`

### `package.version` (optional)

Free-form version string (commonly `MAJOR.MINOR.PATCH`).

In the current implementation, when building from a package manifest, the
compiler surfaces this value to runtime code via `std::runtime::build::version()`
(otherwise it defaults to `"0.0.0"`).

Additional optional metadata fields MAY be present under `[package]` (for
example `description`, `license`, `authors`, `repository`), but the current
compiler only uses `name` and `version`.

## Source Layout (`[sources]`: `include` / `exclude`)

Packages may specify which `.slk` files belong to the package with glob patterns:

```toml
[sources]
include = ["src/**/*.slk"]
exclude = ["src/experimental/**"]
```

Rules:

- Patterns are evaluated against forward-slash (`/`) relative paths rooted at
  the manifest directory.
- Supported glob syntax (current implementation):
  - `*` matches any characters within a single path segment.
  - `**` matches zero or more path segments.
- If `include` is omitted, the default is to include all `**/*.slk` under the
  manifest directory.
- `exclude` patterns always remove files, even if they match an `include`.
- When building a target, the target’s `entry` file MUST be included after
  applying `include`/`exclude` (or the build fails).

## Dependencies (`[dependencies]`)

Dependencies are a table mapping dependency import names to dependency specs:

```toml
[dependencies]
ui = { path = "../libs/silk-ui", sha256 = "sha256:0123456789abcdef..." }
```

Fields:

- The dependency key (`ui` above) is the package import name used in source
  (`import ui from "ui";`). In the current implementation, this MUST match the
  dependency’s own manifest `package.name`.
- `path` (optional): local filesystem path to the dependency package root,
  resolved relative to the importing manifest directory when not absolute.
  When `path` is omitted, the dependency is resolved from the package search
  path (see “Dependency discovery via `SILK_PACKAGE_PATH`” below).
- `sha256` (required): integrity hash string.

Dependency `sha256` verification:

- The `sha256` value must be of the form `sha256:<64 hex digits>` (case-insensitive).
- The compiler verifies it by hashing the dependency package’s contents using a
  deterministic scheme:
  - The hash input starts with the ASCII prefix `silk-package-sha256-v1\0`.
  - Then the exact bytes of the dependency’s `silk.toml`, followed by `\0`.
  - Then, in sorted (lexicographic) order by relative path:
    - the file’s relative path bytes, then `\0`,
    - the file’s bytes, then `\0`.
  - Only files included by that dependency manifest’s `[sources]` include/exclude
    rules are hashed.

Limitations:

- Only local-path dependencies are supported (no remote fetch).

## Dependency discovery via `SILK_PACKAGE_PATH`

When a dependency entry omits `path`, the compiler resolves it by searching a
PATH-like list of package roots provided by `SILK_PACKAGE_PATH`.

Rules:

- `SILK_PACKAGE_PATH` is a list of directories separated by `:` (POSIX).
- For a dependency named `my_api::core`, each root directory contributes a
  candidate package root:
  - `<root>/my_api/core` (where `::` maps to `/`)
  - and the manifest is `<candidate>/silk.toml`.
- The compiler searches roots in order and uses the first candidate that exists.
- The discovered manifest MUST declare `package.name` exactly matching the
  dependency key, and the dependency is still subject to the `sha256`
  verification rules above.

Example:

```toml
[dependencies]
my_api = { sha256 = "sha256:0123456789abcdef..." }
```

## Build Targets (`[[target]]`)

A package may declare one or more build targets. Each target produces one
artifact (an executable, an object, a static library, a shared library, or a
wasm module).

Example:

```toml
[[target]]
name = "my_app"
kind = "executable"
entry = "src/main.slk"
output = "build/my_app"

[[target]]
name = "my_lib"
kind = "static"
entry = "src/lib.slk"
output = "build/libmy_lib.a"
c_header = "build/my_lib.h"
```

Fields:

- `name` (required): unique target name within the package.
- `kind` (required): one of `executable`, `object`, `static`, `shared`.
- `entry` (required): path to the entry module, relative to the manifest
  directory.
- `output` (optional): output path relative to the manifest directory.
  If omitted, the compiler chooses a default under `build/` based on `name` and
  `kind`:
  - `executable`: `build/<name>` (or `build/<name>.wasm` for wasm targets),
  - `object`: `build/<name>.o`,
  - `static`: `build/lib<name>.a`,
  - `shared`: `build/lib<name>.so` (current hosted baseline is `linux/x86_64`).
- `arch` / `target` (optional): default codegen target for this artifact.
  - `arch` is one of `x86_64`, `wasm32`, `wasm32-wasi` (same as `silk build --arch`).
  - `target` is a target triple string accepted by `silk build --target`
    (for example `linux-x86_64`, `wasm32-wasi`).
  - `arch` and `target` MUST NOT both be set for the same target.
- `c_header` (optional): emit a C header when building this target (only valid
  for `kind = object|static|shared`).
- Dynamic linkage fields (optional; passed through to the backend):
  - `needed = ["libc.so.6", "..."]` (repeatable `DT_NEEDED` entries),
  - `runpath = ["$ORIGIN", "..."]` (joined with `:` for `DT_RUNPATH`),
  - `soname = "libfoo.so"` (for shared libraries).
  - Note: `needed` entries starting with `libsilk_rt` are rejected; bundled runtime helpers are linked statically by `silk build` when referenced.

## Default Target (`[build]`)

When a package defines multiple `[[target]]` entries, `silk build --package`
needs to know which one to build.

```toml
[build]
default_target = "my_app"
```

Rules:

- If `build.default_target` is set, it MUST name an existing `[[target]]`.
- If `build.default_target` is not set:
  - if exactly one `[[target]]` exists, it is the default,
  - otherwise, `silk build --package` requires an explicit target selection

## Interaction With `package` Declarations

- If a module contains an explicit `package name;` declaration, that name is
  authoritative.
- If a module omits `package`, the compiler assigns it to the manifest
  `package.name` (for files under that package root).

This defaulting behavior exists to support small projects that do not want to
repeat `package ...;` in every file.

## Reserved Fields

The manifest reserves additional fields for future build integration:

- provenance / integrity metadata (`repo`, richer dependency sources),
- native build configuration (`sources`, `link`, `compile`),
- embedded targets / budgets.

==============================================================================
DOCS: Silk Language Server (LSP) (compiler/lsp-silk)
URL: /silk/docs/?p=compiler/lsp-silk
==============================================================================

# Silk Language Server (LSP)

This document specifies the initial Language Server Protocol (LSP) implementation for Silk.

The goal of the language server is to provide editor and IDE integrations (diagnostics, and eventually features like completion and hover) while remaining a thin, spec-driven wrapper around the existing compiler front-end.

## Overview

The Silk language server:

- is implemented in Zig and shipped as a separate executable (`silk-lsp`),
- speaks the Language Server Protocol over stdin/stdout using JSON-RPC 2.0 and `Content-Length` framing,
- reuses the existing lexer, parser, and type checker for semantics,
- does not change the language surface or ABI; it is a tooling layer on top of the existing compiler.


## Running the Server

The `silk-lsp` binary is built and installed alongside the `silk` CLI:

- `zig build install` (or the project’s preferred build wrapper) will install both `silk` and `silk-lsp` into the configured prefix.
- Editor and IDE integrations should launch `silk-lsp` as a stdio-based LSP server, without extra arguments, and then speak JSON-RPC 2.0 over its stdin/stdout.
- The server writes protocol messages to stdout and may emit diagnostic logs to stderr; LSP clients must not treat stderr as protocol traffic.
- Optional flags:
  - `--std-root <path>` overrides the stdlib root used for resolving `import std::...;`.
  - `--nostd` disables stdlib auto-loading entirely.

Typical client configurations (e.g., Vim/Neovim LSP, VS Code, or other LSP frontends) should:

- set the command to `["silk-lsp"]`,
- enable standard LSP text document synchronization,
- refrain from sending requests beyond the capabilities advertised in `initialize` (hover, diagnostics, shutdown/exit).

## Transport and Protocol

The language server:

- reads requests from standard input using the LSP message framing (`Content-Length: <n>\r\n\r\n<json>`),
- writes responses and server-initiated notifications to standard output using the same framing,
- implements JSON-RPC 2.0 semantics (`jsonrpc: "2.0"`, `id`, `method`, `params`, `result` / `error`).

The server does not depend on any external networking libraries; it uses Zig standard library I/O and JSON support.

Position handling note:

- The lexer tracks byte offsets and byte-based columns.
- The LSP layer maps between byte columns and LSP `utf-16` character positions.
- Clients should treat returned `line`/`character` values as LSP positions in UTF-16.
- If a request uses a character position beyond the end of a line, the server clamps it to the line end when locating tokens.

## Initialization

The server supports the standard LSP initialization sequence:

- `initialize` (request):
  - Advertised capabilities (initial version):
    - `positionEncoding`: `"utf-16"` (the server currently operates in UTF-16 positions for maximum client compatibility).
    - `textDocumentSync`:
      - `openClose: true`,
      - `change: 1` (Full document sync),
      - `save: { includeText: false }`.
    - `hoverProvider: true` (minimal lexical hover on literals and identifiers as described below).
    - `definitionProvider: true` (definition lookups backed by the module-set symbol index; see below).
    - `documentSymbolProvider: true` (top-level `fn`/`let`/`struct`/`enum`/`error`/`interface`/`ext`/`impl` symbols as described below).
    - `completionProvider`: a minimal completion provider that:
      - does not support resolve,
      - advertises trigger characters `.`, `:`, `{`, `,`, `"`, `` ` ``, and `/`,
      - offers keyword, identifier, and symbol-aware suggestions as described below.
    - `signatureHelpProvider`:
      - trigger characters `(` and `,`,
      - provides function and method signatures for the current call.
    - No references/rename, semantic tokens, or other advanced features are claimed in the initial implementation.
- The server uses `rootUri` (or `rootPath`) to help locate a stdlib root when no explicit `--std-root` or `SILK_STD_ROOT` is set.
- `initialized` (notification):
  - Accepted but does not currently trigger additional behavior.
- `shutdown` (request) and `exit` (notification) are honored as in the LSP spec.
- Requests received after `shutdown` (other than `exit`) are treated as invalid and answered with an error response.
- `$\/cancelRequest` notifications are accepted and ignored; the initial server does not track per-request cancellation state.

Any future capabilities (completion, hover, goto definition, etc.) must be documented here before being implemented.

## Hover (Initial Support)

The server provides a minimal implementation of `textDocument/hover`:

- Hover requests are handled for the current contents of an open document (as tracked in the server’s in-memory document table).
- The server computes hover information lexically, based on the token at the given position:
  - integer literals are reported as “int literal”,
  - floating-point literals as “float literal”,
  - boolean literals (`true`/`false`) as “bool literal”,
  - string and character literals as “string literal” and “char literal”,
  - identifiers are reported as `identifier 'name'`.
- Hover now includes lightweight semantic hints:
  - function identifiers show their `fn name (...) -> result` signature when available,
  - `let` bindings show the declared (or literal-inferred) type when available,
  - struct / enum / interface / error identifiers report `struct Name` / `enum Name` / `interface Name` / `error Name`,
  - `ext` declarations report `ext name: <type>` when available,
  - field and method accesses (`value.field`, `value.method`) report the field type or method signature when the receiver is a known struct,
  - imported names are resolved across the module set (package imports and `from "..."` imports, including named imports and namespace/default imports).
- When the resolved declaration has a doc comment, hover renders it as Markdown:
  - the first block is a `silk` code block containing the signature/header,
  - followed by the rendered doc comment body.
- The hover `range` returned to the client corresponds to the token span (same token line/column/length used for diagnostics); when no suitable token is found at the requested position, the server returns `null` as the hover result.

As the front-end grows richer (e.g. with symbol tables and more detailed type information), hover semantics may be extended to include resolved types and declaration summaries; such changes must be reflected here before being implemented.

## Go to Definition (Initial Support)

The server provides an initial implementation of `textDocument/definition`:

- Definition requests are handled for the current contents of an open document.
- The server first consults the module-set symbol index (open docs + resolved imports + std modules) to resolve:
  - exported or package-local `fn`, `let`, `ext`, `struct`, `enum`, `interface`, and `error` declarations,
  - methods declared in `impl` blocks when invoked as `value.method(...)`,
  - qualified names such as `std::pkg::name` and namespace-qualified names like `alias::name` when `alias` is a namespace import.
- Local scopes are then consulted to resolve:
  - function parameters,
  - block-scoped `let` bindings,
  - `match`-statement binders within the selected arm body.
- Member access (`value.field` / `value.method`) uses the heuristic receiver-type resolver:
  - when a method is found, the definition points at the `impl` method declaration,
  - when a struct field is found, the definition points at that field declaration,
  - otherwise the definition falls back to the receiver struct declaration.
- Constructor calls (`new Type(...)`) resolve to the `fn constructor` declaration when the constructor overload set is unambiguous; otherwise the server falls back to the `struct Type` declaration.
- If symbol resolution fails, the server falls back to a lexical scan of the current file for the first matching `let`/`fn`/`ext`/`struct`/`enum`/`interface`/`error` declaration.

Known limitations in this initial support:

- local block scopes and shadowing are only modeled for `let`-style bindings (not for match-expression binders),
- ambiguous names across multiple imports are not disambiguated; the first match wins,
- cross-file results are limited to declarations present in the current module set.

## Completion (Initial Support)

The server provides a minimal implementation of `textDocument/completion`:

- Completion items are offered for:
  - all language keywords defined in `src/token.zig` (via `keywordTable()`),
  - all distinct identifiers lexed from the current document (names that are not recognized as keywords),
  - symbol-aware suggestions from the current package and imported packages (functions, lets, ext, structs, enums, interfaces, errors),
  - imported names from module-specifier imports (`import { ... } from "...";` and `import alias from "...";`) when resolvable,
  - import specifier path completion inside `from "..."` strings:
    - file specifiers (`"./..."`, `"../..."`, and absolute paths) suggest `.slk` files and subdirectories,
    - std-root file specifiers (`"std/..."`) suggest stdlib paths (omitting the `.slk` extension),
  - namespace completions after `::` for known packages and namespace imports,
  - member completions for struct fields and methods after `.` when the receiver type is known (including locals with type annotations or struct-literal/cast inference),
  - struct-literal field suggestions in `Type { ... }` expressions when the cursor is in a field-name position (before the `:`).
- The current implementation:
  - returns completion items with `label`, `kind`, and `detail` populated when symbol data is available,
  - attaches a plaintext signature preview for functions and methods in completion documentation,
  - filters results by the identifier prefix immediately preceding the cursor position,
  - uses a heuristic symbol index built from the module set (open docs + imports + std modules).
- Scope precision is still limited:
  - receiver type inference is heuristic (it is not a full typechecker),
  - local scopes are only partially modeled for completion (not all binder forms and control-flow refinements are represented),
  - cross-file results are limited to declarations present in the current module set (open docs + the import closure).

As richer front-end support becomes available, completion may be extended to:

- filter suggestions by lexical/semantic scope,
- distinguish between functions, types, variables, and other symbol kinds,
- surface standard library symbols by consulting the resolver.

## Signature Help (Initial Support)

The server provides a minimal implementation of `textDocument/signatureHelp`:

- Signature help is computed for the innermost call expression at the cursor.
- The server supports:
  - direct calls to named functions (`foo(...)`),
  - qualified calls (`std::pkg::foo(...)` and `alias::foo(...)` for namespace imports),
  - method calls (`value.method(...)`) when the receiver resolves to a known struct type.
- constructor calls via heap allocation syntax (`new Type(...)`), which resolves to the `constructor` overload set defined in `impl Type { ... }`.
- calls via named imports and default-imported default exports (`import { f as g } from "..."; g(...)`, `import g from "./mod.slk"; g(...)`) when resolvable.
- Active parameter selection is based on comma counting in the current call.
- Signature labels follow the Silk surface syntax (e.g. `fn foo (a: int, b: int) -> int`).
- When doc comments are available:
  - `SignatureInformation.documentation` is populated with rendered Markdown from the doc comment,
  - `SignatureParameter.documentation` is populated from `@param` entries when present.

For constructor overload sets, the server returns multiple signatures and selects an active signature using argument-count heuristics. The implicit receiver parameter (`mut self: &Type`) is not shown in the signature parameters for `new Type(...)`.

Signature help is heuristic and will become richer as the front-end’s symbol tables evolve. Some clients may request signature help even before `(` is typed; the server will attempt to resolve the identifier under the cursor as a callee in that case.

## Document Symbols (Initial Support)

The server provides a minimal implementation of `textDocument/documentSymbol`:

- Document symbols are derived lexically from the source text:
  - top-level `fn` declarations are reported as function symbols,
  - top-level `let` bindings are reported as variable symbols.
  - top-level `struct`, `enum`, `error`, `interface`, `ext`, and `impl` declarations are also reported.
- Implementation details:
  - symbols are inferred from `fn name`, `let name`, `struct Name`, `enum Name`, `error Name`, `interface Name`, `ext name`, and `impl Name` patterns in the token stream,
  - the implementation tracks `{ ... }` brace depth and only reports declarations at brace depth 0,
  - the symbol `range` and `selectionRange` both correspond to the identifier token span,
  - nested or block-local declarations are not yet surfaced.
- Symbol kinds:
  - functions are reported using the LSP `Function` kind (numeric value `12`),
  - `let` bindings are reported using the `Variable` kind (numeric value `13`),
  - `struct` declarations use `Struct` (numeric value `23`),
  - `enum` declarations use `Enum` (numeric value `10`),
  - `error` declarations use `Struct` (numeric value `23`),
  - `interface` declarations use `Interface` (numeric value `11`),
  - `ext` declarations use `Function` (numeric value `12`),
  - `impl` declarations use `Namespace` (numeric value `3`).

Future extensions may:

- organize symbols hierarchically (for example nesting methods under an `impl`),
- add additional declaration kinds (imports and interface members).

## Text Document Lifetime and Diagnostics

The server maintains an in-memory table of open documents, keyed by URI:

- `textDocument/didOpen`:
  - stores the full text of the document,
  - rebuilds a lightweight workspace cache (module set + symbol index + export table) used for hover/definition/completion/signature help,
  - publishes diagnostics via `textDocument/publishDiagnostics` for the opened URI by parsing the opened document and type-checking it against the cached module set (imports + std modules).
- `textDocument/didChange` (full sync):
  - replaces the stored text with the new full contents,
  - parses the changed document and type-checks it against the cached module set (imports + std modules),
  - publishes updated diagnostics for the changed URI.
- `textDocument/didSave`:
  - rebuilds the module set from all open documents,
  - resolves imports across the module set (packages + file imports) and loads standard library modules when configured,
  - type-checks the module set,
  - publishes diagnostics via `textDocument/publishDiagnostics` for any affected module URI (including imports).
- `textDocument/didClose`:
  - removes the document entry,
  - publishes an empty diagnostics list for the closed URI,
  - rebuilds the workspace cache for the remaining open documents.

For responsiveness, the server caches parsed modules (AST + lightweight module info) per open document revision and reuses them across hover/definition/completion/signatureHelp requests until the document changes.

### Standard Library Integration

By default, the language server will load standard library packages referenced by `import std::...` when a stdlib root is available. The stdlib root is selected using the same rules as the compiler, with an additional workspace-root fallback:

- `--std-root <path>` passed to `silk-lsp` (highest priority),
- `SILK_STD_ROOT` when set,
- `./std` when present (development default),
- an executable-relative fallback (`../share/silk/std`) when installed,
- walk upward from the `silk-lsp` executable’s directory to find `std/` (developer build fallback),
- if none of the above are available and the LSP client provides `rootUri`/`rootPath`, walk upward from that workspace root to find a `std/` directory.

You can disable stdlib integration entirely with `--nostd`, which is useful for sandboxed editor setups or custom stdlib forks.

### Diagnostics Source and Limitations (Initial)

Diagnostics are derived from the existing compiler front-end:


For responsiveness while typing:

- `didChange` diagnostics are computed for the changed document by parsing it and type-checking it against the cached module set (imports + std modules). The cache is not rebuilt on every change.
- A full module-set parse + resolve + type-check (including imports) is performed on `didSave`, and diagnostics are published for all affected modules.

The current front-end exposes errors as simple error codes (e.g. `UnexpectedToken`, `TypeMismatch`) without rich spans. The initial LSP implementation therefore follows these rules:

- Parse errors:
  - reported at the location of the unexpected token using the token’s line/column and length,
  - message text describes the unexpected token and that parsing failed.
- Type-checking errors:
  - reported at an approximate source location associated with the expression or statement that triggered the error (for example, the initializer expression for a mismatched `let` binding or the `break` / `continue` / `return` keyword),
  - message text distinguishes between known error kinds (e.g. `TypeMismatch`, `InvalidReturn`) and carries the span reported by the type checker when available; if no span is available, diagnostics fall back to a coarse location.

As the compiler evolves to carry richer diagnostic information (spans, notes, labels), this document and the LSP implementation must be updated so that:

- diagnostics map directly to the front-end’s structured error data,
- positions and ranges reflect the exact source spans of the underlying errors.

## Non-Goals (Initial Version)

The initial `silk-lsp` implementation explicitly does **not** provide:

- full semantic completions with scope-precise filtering and type inference (beyond the current heuristic symbol index),
- cross-file go-to-definition / references,
- semantic tokens or inlay hints,
- code actions or formatting.

These features are intended as future extensions and must be:

- backed by the underlying compiler front-end and/or standard library,
- covered by tests (Zig and, where appropriate, C) before being advertised as supported capabilities.

## Relationship to Other Tooling

The language server is part of the broader tooling story described in:


The `tmp/zls/` directory in this repository contains a vendored copy of the Zig Language Server (ZLS) for inspiration and experimentation only:

- it is **not** part of the supported Silk toolchain,
- it must not be treated as authoritative for Silk semantics,

==============================================================================
DOCS: Standard Library Integration (compiler/stdlib-integration)
URL: /silk/docs/?p=compiler/stdlib-integration
==============================================================================

# Standard Library Integration

This document describes how the `std::` package integrates with the compiler and the CLI.

Key requirements:

- `std::` is a distinct package:
  - linked by default by `silk`,
  - replaceable with an alternative implementation via CLI or configuration.
- The default `std::` assumes POSIX semantics for OS-facing components.

Compiler responsibilities:

- Provide mechanisms for:
  - linking the default stdlib,
  - specifying an alternate stdlib,
  - ensuring FFI and ABI remain stable regardless of the stdlib implementation.

==============================================================================
DOCS: Testing Strategy (Zig + C99 + Silk) (compiler/testing-strategy)
URL: /silk/docs/?p=compiler/testing-strategy
==============================================================================

# Testing Strategy (Zig + C99 + Silk)

This document defines how we validate the compiler, ABI, and standard library.

## Goals

- Provide confidence in language features, FFI, and standard library behavior.
- Make testing incremental and continuous: **every new feature or module must land with tests**, not as a separate phase.

## Zig Tests

- For each compiler subsystem (lexer, parser, type checker, verifier, codegen), add Zig tests **as the subsystem is implemented**:
  - Unit tests for lexer, parser, type checker, and verifier.
- Prefer placing tests close to the code they exercise (e.g. Zig `test` blocks in the same modules, plus higher-level integration suites where needed).

## C99 Tests

- For ABI and FFI boundaries, add C99 tests in lockstep with the implementation:
  - Tests that link against `libsilk.a` and invoke compiled Silk code through the C ABI.
  - Tests that exercise FFI boundaries (strings, structs, arrays, closures, error paths).
  - Tests that validate ABI stability across builds (e.g. struct layouts, calling conventions).
- When building and running these tests:
  - it is expected that the build system uses a C99 compiler (for example `cc`) **only** to compile the C test harnesses and embedder examples that link against `libsilk.a`,
  - the Silk compiler itself MUST NOT generate C or invoke `cc` as part of its own code generation pipeline; using a C compiler here is strictly for exercising the public C ABI from C code, not for compiling Silk programs.

## Parity & Regression

- For critical features (especially FFI and ABI), maintain **parallel test cases in Zig and C**:
  - Zig tests verify language semantics and internal representations.
  - C tests verify ABI conformance and interop.
- When a bug is found:
  - add a regression test in Zig and, where relevant, in C,

## Silk Tests

In addition to Zig and C99 tests, we maintain **Silk-written test programs**:

- Location:
  - They are regular Silk modules and are intended to be readable examples of language features.
- Categories:
    - must parse and type-check successfully,
    - are exercised from Zig tests via the compiler front-end and CLI helpers.
    - are expected to fail type checking (many fixtures only assert “fails”, with targeted tests asserting specific error kinds such as `TypeMismatch` / `InvalidBreak` when stability matters),
    - must parse and type-check successfully,
    - are expected to fail Formal Silk verification with stable diagnostic codes (`E3001`..`E3008`),
    - are used to validate verifier behavior independently of the type checker.
    - are fixtures imported by other tests,
    - are not executed directly by the harness as standalone “tests”.
    - are multi-module package/import fixtures that require running `silk check` on an explicit module set,
    - include both expected-success and expected-error scenarios (for example, duplicate exports across modules in the same package).
- Execution:
  - Zig tests in `src/tests.zig`:
      - for `pass_*.slk`, call `driver.runCheck` and require success,
      - for `fail_*.slk`, parse and type-check and require that type checking fails (most fixtures only assert “fails”, with targeted tests asserting specific `CheckError` values),
    - run `verify_fail_*.slk` fixtures through the Formal Silk verifier and assert stable diagnostic codes,
    - run `pkg_*.slk` fixtures via explicit `silk check` module-set invocations (some are expected to fail),
    - for a growing subset of `pass_*.slk` programs whose `main` fits the current constant-expression backend (e.g. `pass_let_locals.slk`, `pass_top_level_let.slk`), invoke the `silk` CLI to `build` them to native executables and run those executables, asserting on their exit codes; this keeps Silk-written tests participating in both front-end and back-end validation as code generation matures.
  - As the backend matures, additional Silk tests will be added that:
    - build and run executables beyond the constant-expression subset,
    - exercise libraries and FFI,
    - validate behavior across targets (ELF/Mach-O/PE) and architectures.

==============================================================================
DOCS: Vendored Dependencies (compiler/vendored-deps)
URL: /silk/docs/?p=compiler/vendored-deps
==============================================================================

# Vendored Dependencies

Silk aims to be buildable with minimal reliance on system-installed
cryptography/TLS libraries. For the hosted POSIX baseline, Silk vendors:

- libsodium (`jedisct1/libsodium`) at tag `1.0.20-RELEASE`
- mbedTLS (`Mbed-TLS/mbedtls`) at tag `mbedtls-4.0.0`
- libssh2 (`libssh2/libssh2`) at tag `libssh2-1.11.1`
- SQLite amalgamation at version `3510200` (downloaded from sqlite.org)
- ggml (`ggml-org/ggml`) at tag `v0.9.5`

These dependencies are fetched as shallow clones (`--depth 1`) and built as
static libraries for `linux/x86_64`.

Note: the current deps workflow builds libssh2 with the OpenSSL
backend, so building libssh2 requires system OpenSSL headers and libraries
(`libssl`/`libcrypto`).

## Fetch + Build

From the repo root:

```sh
make deps
```

Or directly:

```sh
zig build deps
```

This populates:

- `vendor/deps/` — git checkouts of the pinned tags
- `vendor/build/` — build directories (`libsodium` via autotools; `mbedTLS` via CMake)
- `vendor/lib/x64-linux/` — built static archives:
  - `libsodium.a`
  - `libmbedtls.a`
  - `libmbedx509.a`
  - `libmbedcrypto.a`
  - `libssh2.a`
  - `libsqlite3.a`
  - `libggml.a`
  - `libggml-base.a`
  - `libggml-cpu.a`
  - `libsilk_ggml_shims.a` (ABI-safe Silk wrappers for by-value ggml APIs)

These directories and generated `.a` files are ignored by git.

## Bundling Into `libsilk.a`

When the vendored archives are present, the Zig build can bundle them into
`libsilk.a` so C embedders do not have to link libsodium/mbedTLS separately.

To require that the vendored archives are present (and fail the build if they
are missing), pass:

```sh
zig build -Drequire-vendored-crypto=true
```

## Notes

- Vendoring is currently wired up only for `linux/x86_64`.
- Some std modules are currently wired to system shared libraries
  during the hosted `linux/x86_64` phase (for example `std::tls` and
  `std::ssh2`); the vendored static archives produced by `zig build deps` are
  used for embedding and future bundling into `libsilk.a`.
- `mbedTLS` uses git submodules (`framework`, `tf-psa-crypto`); `zig build deps` initializes them automatically.
- `zig build deps` configures `mbedTLS` with `ENABLE_TESTING=OFF` and `ENABLE_PROGRAMS=OFF` (we only need the static libraries).
- The `deps` step requires `git`, `cmake`, `perl`, and a working C build toolchain (`make` + a C compiler).
- Building libssh2 currently requires system OpenSSL development files (headers + libraries) due to the OpenSSL backend configuration.
- `mbedTLS`/TF-PSA-Crypto generation requires `python3` with `jinja2` available; `jsonschema` is optional (validation is skipped when it is missing).

==============================================================================
DOCS: WebAssembly Back-End (`wasm32` / `wasm64`) (compiler/backend-wasm)
URL: /silk/docs/?p=compiler/backend-wasm
==============================================================================

# WebAssembly Back-End (`wasm32` / `wasm64`)


This document records the initial design and constraints for targeting
WebAssembly from the Silk compiler back-end. It is intended to guide future
implementation work and keep the compiler architecture spec-driven.

## Current Implementation (Phase 1, IR-backed wasm32)

The repository now includes an initial `wasm32` back-end capable of emitting a
final `.wasm` module from the compiler’s IR (CFG-based lowering for the current
subset), plus a smaller constant-only fallback:

- Implementations:
  - IR→WASM backend: `src/backend_wasm_ir.zig` (primary path),
  - constant-only emitter: `src/backend_wasm.zig` (fallback path).
- Supported targets:
  - `wasm32-unknown-unknown`:
    - emits a `.wasm` module exporting `memory` plus exported functions,
    - when a valid `main` exists, exports `main` for embedder use.
  - `wasm32-wasi`:
    - emits a `.wasm` module exporting `memory` and `_start () -> void`,
    - imports `wasi_snapshot_preview1.proc_exit (exit_code: i32) -> void`,
    - `_start` calls Silk `main` and then calls `proc_exit` with the wrapped exit code.
- Export-only modules (no `main`):
  - emit a `.wasm` module exporting `memory` plus each supported `export fn` in
    the root package (suitable for JS/Node-style embedding).
- FFI mapping (WASM):
  - `ext foo = fn (...) -> ...;` becomes an imported function `env.foo`,
  - `ext bar = T;` becomes an imported global `env.bar` (scalar `T`).
- Current capabilities (prototype quality):
  - supports multi-module builds (packages + file imports),
  - emits static data into the wasm data section (string/byte blobs and other
    lowered constants),
  - supports structured control flow (if/while/break/continue) for the current
    IR subset.
  - does not yet support the concurrency runtime on wasm targets (no `task` /
    `async` lowering to a wasm-native scheduler); programs using concurrency
    constructs may fail code generation with a “not implemented yet” error.

The CLI exposes these targets via `silk build --target ...` and the shorthand

## Goals

- Support emitting WebAssembly modules for:
  - `wasm32` (32-bit linear-memory addressing),
  - `wasm64` (64-bit linear-memory addressing; future-facing).
- Support both:
  - a hosted environment (`wasm32-wasi`), and
  - an embedder-driven environment (`wasm32-unknown-unknown`, typically JS).
- Preserve Silk’s “native compiler” principle: this is Silk-owned codegen (no C
  transpilation).

## Non-Goals (for initial implementation)

- A full WASM toolchain replacement (linker, LTO, debug formats) on day one.
- A single “portable” stdlib archive usable across all WASM environments
  (WASI vs JS embedder differ in available imports and conventions).
- Universal ABI compatibility with arbitrary third-party wasm linkers before we
  have a stable Silk ↔ WASM ABI specification.

## Output Model

### Module kinds

The initial back-end should emit a *final* `.wasm` module (not a relocatable
object) for the supported subset, analogous to the current `linux/x86_64`
“emit a final ELF image” approach.

Future work may add “wasm object” emission, but it requires relocation sections
and a defined link model.

### Entry points

We need two distinct entrypoint conventions:

- `wasm32-wasi`:
  - emit a `_start` function (no parameters, no results),
  - `_start` calls Silk `fn main () -> int` and then imports/calls WASI
    `proc_exit(exit_code)`.
- `wasm32-unknown-unknown`:
  - export an Silk `main` function for embedder use.
    - Silk `int` is currently lowered as wasm `i64`, so `main`’s return type is
      `i64` unless a wrapper is introduced in the future.

The CLI/ABI must document which convention is used for each target.

### Export-only modules (embedder mode)

For embedder-driven environments (especially `wasm32-unknown-unknown` / JS),
the toolchain also supports emitting a wasm module with **no entry point**
(`main` / `_start`) when the root package contains exported functions.

In this mode, the compiler emits a `.wasm` module that exports each supported
`export fn` declaration from the root package as a wasm export (with parameters
and results lowered according to the current scalar ABI).

Notes:

- For `wasm32-wasi`, export-only modules are intended for embedding; they do
  **not** include an `_start` wrapper and are not directly runnable as WASI
  executables.

## Types, Layout, and Memory

### Integer and float types

- `int` maps to:
  - `i64` in wasm32/wasm64 backends (matching current compiler semantics).
- Fixed-width ints map to their obvious wasm integer types:
  - `u8`/`i8`/`u16`/`i16`/`u32`/`i32` lower to `i32` values (with masking/sign
    rules applied in codegen),
  - `u64`/`i64` lower to `i64` values.
- `f32` and `f64` map to wasm `f32`/`f64`.
- `bool` maps to `i32` (0/1).

### Pointers and `string`

Silk’s current back-end assumes 64-bit pointers (`u64`). For WASM, pointer width
depends on the target:

- `wasm32`: pointers are `u32` byte offsets into linear memory.
- `wasm64`: pointers are `u64` byte offsets into linear memory.

`string` is currently represented as `(ptr, len)` and, at the C ABI boundary,
as `SilkString { ptr, len }`. For WASM:

- In `wasm32`, the natural representation is `(u32 ptr, i64 len)` (or `(u32,u32)`
  if we later choose a fully-32-bit ABI for wasm-only code).
- In `wasm64`, `(u64 ptr, i64 len)` matches the existing layout.

The chosen WASM ABI for strings must be documented and kept stable.

### Static data

- String literals and other constant data should be emitted into the wasm data
  section and referenced by linear-memory offsets.
- The compiler must define a deterministic data layout (alignment rules) so
  field access and pointer arithmetic remain correct.

## Calls, Imports, and FFI

### Internal calls

For the initial subset, internal calls should be direct wasm calls using wasm’s
native calling convention (stack machine with typed locals), with the compiler
responsible for lowering Silk IR values into the wasm value stack.

### `ext` declarations

`ext` declarations should map to wasm imports:

- Each `ext foo = fn (...) -> ...;` becomes an imported function with a stable
  module/name convention (for example `env.foo` by default).
- Each `ext bar = T;` (external global) becomes an imported global when the
  environment supports it, or a function-based accessor in environments that do
  not.

The module/name convention and supported import surface must be documented in

### WASI integration

For `wasm32-wasi`, stdlib facilities like `std::io` and `std::fs` should
eventually target WASI syscalls rather than libc symbols. This implies:

- The “hosted” stdlib for WASI is a separate std distribution from the POSIX
  `std/` currently used for `linux/x86_64`.
- The stdlib archive must be target-specific (one archive per target ABI), and
  swapping stdlib roots should remain supported (`--std` / `--nostd` etc.).

## Tooling and Testing Strategy

- Add a small set of WASM end-to-end tests once codegen exists:
  - compile a program to `.wasm`,
  - run it with a runtime appropriate to the target (`wasmtime` for WASI, a JS
    harness for unknown-unknown),
  - assert exit code or exported return value.
- Keep tests target-scoped and avoid requiring network access.

## Roadmap (Suggested Phases)

1. **Minimal wasm32 module**: emit a module that exports `main` returning `i32`
   for `fn main () -> int` (constant subset first).
2. **Data and strings**: support string literals and `string` values backed by
   linear-memory data segments.
3. **Control flow and helpers**: lower the existing IR CFG into wasm blocks,
   loops, branches, and calls.
4. **WASI `_start`**: add the `_start` wrapper and `proc_exit` import for
   `wasm32-wasi`.
5. **wasm64 exploration**: validate pointer-width changes and ABI decisions.

==============================================================================
DOCS: Zig Embedding API (Programmatic Compilation) (compiler/zig-api)
URL: /silk/docs/?p=compiler/zig-api
==============================================================================

# Zig Embedding API (Programmatic Compilation)

This document specifies the Zig-facing embedding API for using the Silk
compiler programmatically from Zig code.

It complements (and is intentionally aligned with) the C99 embedding API

## Goals

- Allow Zig programs to compile Silk sources into:
  - native executables,
  - ELF relocatable objects (`.o`),
  - static libraries (`.a`),
  - shared libraries (`.so`),
  using the same implementation as the `silk` CLI and `libsilk.a`.
- Support filesystem-free embedding flows by building artifacts into owned
  in-memory byte buffers (and by allowing stdlib auto-loading to be disabled).
- Provide a Zig-friendly wrapper (slices, enums, error unions) over the
  existing embedding surface, while keeping the error semantics consistent.
- Keep the API small and stable: for feature gaps, return an error and surface
  details via the same “last error” mechanism as the C API.

## Relationship to the C ABI

The Zig embedding API is a thin wrapper over the same implementation that backs
`libsilk.a`.

Practical implications:

- The supported language subset and backend constraints are the same as the
  CLI and C API for a given build of this repo.
- When an operation fails, the compiler records a human-readable last error.
  Zig callers can retrieve it via `Compiler.lastErrorAlloc`.
- The Zig API does not require `@cImport`; it reuses the Zig implementation
  directly.

## Public Module

This repository exports a Zig module named `silk` from `build.zig` for
downstream dependencies.

Downstream build snippet (illustrative):

```zig
const silk = b.dependency("silk", .{ .target = target, .optimize = optimize });
exe.root_module.addImport("silk", silk.module("silk"));
exe.root_module.link_libc = true;
```

Notes:

- The compiler implementation uses libc for filesystem and process I/O in the
  current prototype; downstream artifacts that import the `silk` module should
  link libc.
- The module is source-based: depending on it compiles the compiler into your
  Zig program (this is intended for embedding).

## `Compiler` API

The `silk` module exposes a `Compiler` type for constructing a compilation:

```zig
const silk = @import("silk");

var compiler = try silk.Compiler.init();
defer compiler.deinit();

try compiler.setStdRoot("./std");
try compiler.addSourceBuffer("main.slk", "fn main () -> int { return 0; }");
try compiler.build(.SILK_OUTPUT_EXECUTABLE, "out/hello");
```

For filesystem-free output, use `buildToBytes`:

```zig
var exe_bytes = try compiler.buildToBytes(.SILK_OUTPUT_EXECUTABLE);
defer exe_bytes.deinit();
```

### Configuration

The wrapper mirrors the existing embedding knobs:

- stdlib selection:
  - `setStdRoot(path)` to select the root for `import std::...;` resolution,
  - `setStdlib(name)` to select the stdlib package name (default `std`).
- stdlib auto-loading can be disabled (for sandboxed/WASM-like embedding) via:
  - `setNoStd(true)`.
- target selection: `setTargetTriple(triple)` (currently only a narrow subset
  of targets is implemented by the backend).
- optimization level: `setOptimizationLevel(0..3)`.
- dynamic linking metadata for outputs that support it:
  - `addNeededLibrary(soname)`,
  - `addRunpath(path)`,
  - `setSoname(soname)`.

### Error handling

Most operations return `error.Failed` on error, with details available via:

- `lastErrorAlloc(allocator) -> ?[]u8` (returns an owned UTF-8 message slice).

The last error is overwritten by subsequent operations, matching the C API.

## Stability and scope

The Zig embedding API is intended to remain stable in lockstep with the C ABI

- this document,
- and add/adjust Zig tests that exercise the affected surface.

==============================================================================
DOCS: `libsilk` (7) — C99 ABI for the Silk Compiler (man/libsilk.7)
URL: /silk/docs/?p=man/libsilk.7
==============================================================================

# `libsilk` (7) — C99 ABI for the Silk Compiler

> NOTE: This is the Markdown source for a man 7 page describing the C99 embedding ABI exposed by `libsilk.a`. The roff-formatted manpage should be generated from this content.

## Name

`libsilk` — C99-compatible embedding ABI for the Silk compiler.

## Synopsis

```c
#include "silk.h"

/* Core types */
typedef struct SilkString   SilkString;
typedef struct SilkBytes    SilkBytes;
typedef struct SilkCompiler SilkCompiler;
typedef struct SilkModule   SilkModule;
typedef struct SilkError    SilkError;

typedef enum SilkOutputKind SilkOutputKind;

/* Version */
void silk_abi_get_version(int *out_major,
                          int *out_minor,
                          int *out_patch);

/* Lifecycle */
SilkCompiler *silk_compiler_create(void);
void          silk_compiler_destroy(SilkCompiler *compiler);

/* Configuration */
bool silk_compiler_set_stdlib(SilkCompiler *compiler,
                              SilkString    stdlib_name);
bool silk_compiler_set_std_root(SilkCompiler *compiler,
                                SilkString    std_root);
bool silk_compiler_set_nostd(SilkCompiler *compiler,
                             bool          nostd);
bool silk_compiler_set_debug(SilkCompiler *compiler,
                             bool          debug);
bool silk_compiler_set_noheap(SilkCompiler *compiler,
                              bool          noheap);
bool silk_compiler_set_target(SilkCompiler *compiler,
                              SilkString    target_triple);
bool silk_compiler_set_z3_lib(SilkCompiler *compiler,
                              SilkString    path);
bool silk_compiler_set_std_archive(SilkCompiler *compiler,
                                   SilkString    path);
bool silk_compiler_add_needed_library(SilkCompiler *compiler,
                                      SilkString    soname);
bool silk_compiler_add_runpath(SilkCompiler *compiler,
                               SilkString    path);
bool silk_compiler_set_soname(SilkCompiler *compiler,
                              SilkString    soname);
bool silk_compiler_set_optimization_level(SilkCompiler *compiler,
                                          int           level);
bool silk_compiler_set_c_header(SilkCompiler *compiler,
                                SilkString    path);

/* Sources */
SilkModule *silk_compiler_add_source_buffer(SilkCompiler *compiler,
                                            SilkString    name,
                                            SilkString    contents);

/* Build */
bool silk_compiler_build(SilkCompiler   *compiler,
                         SilkOutputKind  kind,
                         SilkString      output_path);
bool silk_compiler_build_to_bytes(SilkCompiler   *compiler,
                                  SilkOutputKind  kind,
                                  SilkBytes      *out_bytes);
void silk_bytes_free(SilkBytes *bytes);

/* Errors */
SilkError *silk_compiler_last_error(SilkCompiler *compiler);
size_t     silk_error_format(const SilkError *error,
                             char            *buffer,
                             size_t           buffer_len);
```

Link with (on `linux/x86_64`, `libsilk.a` vendors Z3 which is built as C++):

```sh
cc -std=c99 -Wall -Wextra \
   -I/path/to/include \
   your_app.c \
   -L/path/to/lib -lsilk \
   -lstdc++ -lpthread -lm
```

## Description

`libsilk.a` exposes a stable C99 ABI for embedding the Silk compiler inside C (or C++) applications. The ABI is designed to be:

- simple and explicit,
- versioned independently of the compiler implementation,
- usable from plain C99 without extensions.

Embedders are expected to:

- include the public header `silk.h`,
- link against `libsilk.a`,
- drive compilation by creating a `SilkCompiler` handle, adding source buffers, and invoking `silk_compiler_build`,
- inspect error details via `silk_compiler_last_error` and `silk_error_format`.


## Types

### `SilkString`

```c
typedef struct SilkString {
  char   *ptr;
  int64_t len;
} SilkString;
```

- Represents a UTF‑8 string as a pointer plus a length.
- `ptr` may be `NULL` when `len == 0`.
- Unless explicitly documented otherwise for a given API:
  - functions taking `SilkString` do **not** take ownership of `ptr`,
  - the caller is responsible for the lifetime of the underlying storage.

### `SilkBytes`

```c
typedef struct SilkBytes {
  uint8_t *ptr;
  int64_t  len;
} SilkBytes;
```

- Represents an *owned* byte buffer as a pointer plus a length.
- `ptr` may be `NULL` when `len == 0`.
- Buffers returned by `silk_compiler_build_to_bytes` must be freed with
  `silk_bytes_free`.

### Opaque handles

```c
typedef struct SilkCompiler SilkCompiler;
typedef struct SilkModule   SilkModule;
typedef struct SilkError    SilkError;
```

- `SilkCompiler` represents a compiler instance and owns configuration, modules, and internal error state.
- `SilkModule` is an opaque handle returned when a source buffer is registered; its layout is not exposed.
- `SilkError` represents a diagnostic object owned by a `SilkCompiler`.

Callers must **never** allocate, free, or dereference these types directly. They are managed exclusively through the ABI functions.

### `SilkOutputKind`

```c
typedef enum SilkOutputKind {
  SILK_OUTPUT_EXECUTABLE     = 0,
  SILK_OUTPUT_STATIC_LIBRARY = 1,
  SILK_OUTPUT_SHARED_LIBRARY = 2,
  SILK_OUTPUT_OBJECT         = 3,
} SilkOutputKind;
```

Selects the kind of build artifact requested by `silk_compiler_build`. At the current stage of implementation, all kinds perform full front‑end validation; code generation is implemented only for a small, constant‑expression subset of executable builds on `linux/x86_64` (see **Build behavior**).

## Versioning

The header defines:

```c
#define SILK_ABI_VERSION_MAJOR 0
#define SILK_ABI_VERSION_MINOR 2
#define SILK_ABI_VERSION_PATCH 0
```

and the function:

```c
void silk_abi_get_version(int *out_major,
                          int *out_minor,
                          int *out_patch);
```

Callers should:

- compare the runtime version returned by `silk_abi_get_version` with the compile‑time macros,
- reject or warn on mismatches as appropriate for their integration.

The ABI is versioned so that future incompatible changes can be detected at runtime.

## Lifecycle

### `silk_compiler_create` / `silk_compiler_destroy`

```c
SilkCompiler *silk_compiler_create(void);
void          silk_compiler_destroy(SilkCompiler *compiler);
```

- `silk_compiler_create`:
  - returns a new compiler handle on success,
  - returns `NULL` on allocation error.
- `silk_compiler_destroy`:
  - may be called with `NULL` (it is a no‑op),
  - must be called exactly once for each non‑`NULL` handle from `silk_compiler_create`,
  - releases all modules and errors owned by the compiler.

A single `SilkCompiler` instance is not currently specified as thread-safe; callers should either confine it to one thread or synchronize access.

## Configuration

### Standard library selection

```c
bool silk_compiler_set_stdlib(SilkCompiler *compiler,
                              SilkString    stdlib_name);
```

- Sets the name of the standard library package (for example `"std"`).
- The function:
  - copies the name internally,
  - returns `true` on success,
  - returns `false` on error and records an error in the compiler.


### Standard library root

```c
bool silk_compiler_set_std_root(SilkCompiler *compiler,
                                SilkString    std_root);
```

- Sets the filesystem stdlib root directory used to resolve `import std::...;` declarations.
- This overrides `SILK_STD_ROOT` (environment variable) and the `std/` working-directory default.
- The function:
  - validates that the directory exists,
  - copies the path internally,
  - returns `true` on success,
  - returns `false` on error and records an error in the compiler.

### Disable stdlib auto-loading (`nostd`)

```c
bool silk_compiler_set_nostd(SilkCompiler *compiler,
                             bool          nostd);
```

- When `nostd` is `true`, the compiler disables filesystem-based stdlib
  auto-loading for `import std::...;`.
- In this mode, any `std::...` packages must be provided explicitly by adding
  the corresponding sources as modules (for example via
  `silk_compiler_add_source_buffer`).

### Debug build mode (`debug`)

```c
bool silk_compiler_set_debug(SilkCompiler *compiler,
                             bool          debug);
```

- Enables the same debug build mode as the CLI (`silk --debug` / `-g`) for the
  supported subset:
  - debug-mode lowering for supported native outputs (e.g. stack traces on
    failed `assert` for `linux/x86_64`),
  - additional Z3 debug output and `.smt2` dump emission on failing Formal Silk
- `--debug` is currently incompatible with `--noheap`.

### No-heap build mode (`noheap`)

```c
bool silk_compiler_set_noheap(SilkCompiler *compiler,
                              bool          noheap);
```

- Enables the same no-heap build mode as the CLI (`silk --noheap`), disabling
  heap-backed allocation for the supported subset.
- `--noheap` is currently incompatible with `--debug`.

### Target triple

```c
bool silk_compiler_set_target(SilkCompiler *compiler,
                              SilkString    target_triple);
```

- Sets the code generation target triple (for example `"x86_64-linux-gnu"`).
- The triple is copied; errors are recorded in the compiler’s last‑error state.
- Supported targets (initial implementation):
  - `linux-x86_64` (default), plus common `x86_64-*-linux-*` triples such as `x86_64-linux-gnu` and `x86_64-unknown-linux-gnu`,
- `wasm32-unknown-unknown` (IR-backed wasm32 mode; emits a final `.wasm` module exporting `memory` and exported functions, including `main` when present; `ext` declarations become imports under `env.<name>`; also supports export-only modules with no `main` for JS/Node-style embedding),
  - `wasm32-wasi` (IR-backed wasm32 WASI mode; emits `memory` and `_start () -> void`, imports `wasi_snapshot_preview1.proc_exit`, and calls Silk `fn main () -> int`; also supports export-only modules for embedding, which do not include `_start`).
- Note: for `wasm32` targets, only `SILK_OUTPUT_EXECUTABLE` is supported. `wasm32-wasi` currently supports only `fn main () -> int` (no argv).

### Z3 dynamic library override (`z3_lib`)

```c
bool silk_compiler_set_z3_lib(SilkCompiler *compiler,
                              SilkString    path);
```

- Configures a Z3 dynamic library override for Formal Silk verification
  (equivalent to `silk --z3-lib <path>`).
- Passing an empty string clears the override and returns to normal Z3
  resolution (including honoring `SILK_Z3_LIB`).

### Stdlib archive override (`std_archive`)

```c
bool silk_compiler_set_std_archive(SilkCompiler *compiler,
                                   SilkString    path);
```

- Configures a stdlib archive override for native builds (equivalent to
  `silk --std-lib <path>`).
- Passing an empty string clears the override and returns to normal stdlib
  archive resolution (including honoring `SILK_STD_LIB`).

### Dynamic linker metadata

These configuration functions affect dynamic metadata emitted for executable and
shared library outputs on platforms/backends that support dynamic linking (the
current implementation: `linux/x86_64`).

#### `silk_compiler_add_needed_library`

```c
bool silk_compiler_add_needed_library(SilkCompiler *compiler,
                                      SilkString    soname);
```

- Adds a dynamic loader dependency for executable and shared outputs by emitting
  a `DT_NEEDED` entry.
- The `soname` string is copied; the function may be called multiple times
  (duplicates are ignored).
- Ignored for static library and object outputs.
- On `linux/x86_64` with the glibc dynamic loader (`ld-linux`), when an
  executable or shared library imports any external symbols, the compiler
  automatically adds `libc.so.6` as a `DT_NEEDED` dependency (so hosted `std::`
  modules like `std::io` and `std::fs` do not require manually adding libc).
  Additional non-libc dependencies still require explicit `DT_NEEDED` entries
  via this API.
- `DT_NEEDED` entries starting with `libsilk_rt` are rejected: bundled runtime
  helpers are linked statically from `libsilk_rt.a` / `libsilk_rt_noheap.a` and
  must not become runtime loader dependencies.

#### `silk_compiler_add_runpath`

```c
bool silk_compiler_add_runpath(SilkCompiler *compiler,
                               SilkString    path);
```

- Adds a runtime search path element for executable and shared outputs by
  emitting a `DT_RUNPATH` entry.
- The `path` string is copied; the function may be called multiple times
  (duplicates are ignored) and the final `DT_RUNPATH` string is formed by
  joining entries with `:`.
- Ignored for static library and object outputs.

#### `silk_compiler_set_soname`

```c
bool silk_compiler_set_soname(SilkCompiler *compiler,
                              SilkString    soname);
```

- Sets the shared library soname recorded as `DT_SONAME` for shared outputs.
- The `soname` string is copied; passing an empty string clears the configured
  soname (no `DT_SONAME` entry).
- Ignored for executable, static library, and object outputs.

### Optimization level

```c
bool silk_compiler_set_optimization_level(SilkCompiler *compiler,
                                          int           level);
```

- `level` must be in the range `[0, 3]`:
  - `0` — no optimization (fastest compile),
  - `1` — light optimization,
  - `2` — balanced optimization,
  - `3` — aggressive optimization.
- The default optimization level is `0` unless overridden.
- In the current implementation, `level >= 1` enables lowering-time pruning of
  unused extern symbols before code generation. This typically reduces output
  size and over-linking when using the prebuilt stdlib archive (`libsilk_std.a`)
  to satisfy auto-loaded `import std::...;` modules.
- Returns:
  - `true` on success,
  - `false` and records an error (e.g. `"invalid optimization level (expected 0-3)"`) when the value is invalid.

### C header generation (`c_header`)

```c
bool silk_compiler_set_c_header(SilkCompiler *compiler,
                                SilkString    path);
```

- Configures C header generation for non-executable outputs (equivalent to the
  CLI `--c-header <path>`).
- Passing an empty string clears the configured header output path.
- The header is written when `silk_compiler_build` succeeds for:
  - `SILK_OUTPUT_OBJECT`,
  - `SILK_OUTPUT_STATIC_LIBRARY`,
  - `SILK_OUTPUT_SHARED_LIBRARY`.
- C header generation is not supported for `silk_compiler_build_to_bytes`.

## Source buffers

### `silk_compiler_add_source_buffer`

```c
  SilkModule *silk_compiler_add_source_buffer(SilkCompiler *compiler,
                                              SilkString    name,
                                              SilkString    contents);
```

- Registers a source buffer with the compiler:
  - `name` is a logical module name used in diagnostics (e.g. `"main.slk"` or `"<memory>"`),
  - `contents` is the UTF‑8 Silk source.
- On success:
  - returns a non‑`NULL` `SilkModule *`,
  - copies both `name` and `contents` into memory owned by the compiler.
- On error:
  - returns `NULL`,
  - records an error describing the cause.

The returned `SilkModule *` must not be freed by the caller and remains valid until the compiler is destroyed.

## Build behavior

### `silk_compiler_build`

```c
bool silk_compiler_build(SilkCompiler   *compiler,
                         SilkOutputKind  kind,
                         SilkString      output_path);
```

- Performs a build for all modules added to the compiler:
  - lexes and parses each module,
  - type‑checks statements and expressions according to the language spec,
  - enforces additional front‑end constraints (see below),
  - stops on the first error.
- `output_path`:
  - is the requested output location for the artifact,
  - for executable outputs (`SILK_OUTPUT_EXECUTABLE`) in the supported subset
    (see below), it is used as the path of the native executable that is
    produced,
  - for other output kinds, it is used as the output file path in supported
    backend subsets; for unsupported programs/targets, no output is written.

Return value:

- On any front‑end error, returns `false` and records a descriptive error string. Examples include:
  - `"unexpected token while parsing module"`,
  - `"type mismatch"`,
  - `"invalid break statement"`,
  - `"invalid continue statement"`,
  - `"invalid return statement"`.
- On success of front‑end validation:
  - for non‑executable outputs (`SILK_OUTPUT_STATIC_LIBRARY`,
    `SILK_OUTPUT_SHARED_LIBRARY`, `SILK_OUTPUT_OBJECT`):
    - on supported targets/backends (currently `linux/x86_64`), the compiler
      attempts code generation for the documented backend subset and returns
      `true` after writing the requested artifact on success,
    - for front‑end valid programs outside that subset (or on unsupported
      targets), the call returns `false` and records either an `E4001` / `E4002`
      formatted diagnostic (unsupported construct / backend failure) or a more
      direct descriptive error string (for example invalid arguments), and does
      not write output.
  - for executable outputs (`SILK_OUTPUT_EXECUTABLE`):
    - if the program satisfies the executable entrypoint rule (below) and
      `main` returns a constant integer expression in the supported subset:
      - the body of `main` must be one of the following:
        - zero or more `let` statements with constant integer initializers
          followed by exactly one `return` of a constant expression built from
          integer literals, `+`, `-`, `*`, `/`, `%`, and references to
          immutable `let` bindings whose initializers are themselves constant
          integer expressions, or
        - a final `if` statement whose condition is a compile‑time boolean
          literal (`true` or `false`) and whose branches each satisfy the same
          “constant lets + `return` constant expression” rule, or
        - one or more trivial constant `while` loops that appear before the
          final `return`, each of which has:
          - a condition that is a compile‑time boolean literal (`true` or
            `false`),
          - for `while false { ... }`, a body that is ignored by the constant
            backend, and
          - for `while true { ... }`, a body consisting of zero or more
            constant `let` statements followed by a `break;`, with no other
            control flow; loop invariants (`#invariant`), variants (`#variant`),
            and monovariants (`#monovariant`) may be present but are treated as
            metadata and do not affect constant evaluation,
      - then `silk_compiler_build`:
        - evaluates the constant integer expression determined by `main`,
        - emits a tiny native executable image *directly* using an Silk‑owned
          backend (no C stub, no external C compiler):
          - currently this backend writes a minimal ELF64 executable for
            `linux/x86_64` whose entrypoint immediately calls
            `sys_exit(value)`,
        - returns `true` on success and leaves the last error unset,
    - if the program is front‑end valid but outside this subset (for example,
      `main` contains non‑constant expressions, references to non‑constant
      values, function calls, or unsupported control flow), or if the backend
      cannot produce an executable for the current platform or output path,
      the call returns `false` and typically records either `"code generation
      is not implemented yet"` or `"failed to build executable output"` as the
      last error.

#### Executable entrypoint rule

For executable builds (`kind == SILK_OUTPUT_EXECUTABLE`), the ABI currently enforces a simple entrypoint rule:

- there MUST be exactly one top‑level function with the signature:

  ```silk
  fn main() -> int { ... }
  ```

  - name: `main`,
  - zero parameters,
  - result type: `int`.

If this condition is not met:

- `silk_compiler_build` returns `false`,
- records an error message such as:
  - `"no valid main function for executable output"`, or
  - `"multiple main functions for executable output"`.

This rule is enforced before code generation exists so that embedders and tests can rely on a stable definition of an “executable module”.

For other `SilkOutputKind` values (static/shared libraries, object files), no `main` entrypoint is required by the current front‑end.

### `silk_compiler_build_to_bytes`

```c
bool silk_compiler_build_to_bytes(SilkCompiler   *compiler,
                                  SilkOutputKind  kind,
                                  SilkBytes      *out_bytes);
```

Builds the requested artifact as an owned in-memory byte buffer instead of
writing to a filesystem path.

- Behavior and supported subsets match `silk_compiler_build` for the same
  `kind` (front‑end validation is always performed; code generation exists only
  for documented target/backend subsets).
- On success:
  - returns `true`,
  - fills `*out_bytes` with `(ptr, len)` describing the produced artifact,
  - leaves the last error unset.
- On error:
  - returns `false`,
  - records an error message retrievable via `silk_compiler_last_error`,
  - and sets `out_bytes` to `{ NULL, 0 }`.

The returned buffer must be freed with:

```c
void silk_bytes_free(SilkBytes *bytes);
```

When `bytes->ptr` is `NULL`, `silk_bytes_free` is a no-op. After freeing, it
clears the struct to `{ NULL, 0 }`.

## Error handling

### `silk_compiler_last_error`

```c
SilkError *silk_compiler_last_error(SilkCompiler *compiler);
```

- Returns a pointer to the last error object produced by operations on `compiler`, or `NULL` if no error is recorded.
- Ownership and lifetime:
  - the pointer is owned by the compiler,
  - it remains valid until:
    - the compiler is destroyed, or
    - a subsequent operation overwrites the last‑error state.
  - callers must not attempt to free it.

### `silk_error_format`

```c
size_t silk_error_format(const SilkError *error,
                         char            *buffer,
                         size_t           buffer_len);
```

- Formats a human‑readable error message into the caller‑provided `buffer`.
- Behavior:
  - writes up to `buffer_len - 1` bytes of UTF‑8 into `buffer`,
  - always NUL‑terminates if `buffer_len > 0`,
  - returns the number of bytes that would be required to format the full message, **excluding** the terminating NUL.
- If the return value is greater than or equal to `buffer_len`, the message was truncated.

Callers can use a two‑step pattern:

1. Call with `buffer = NULL`, `buffer_len = 0` to discover the required size.
2. Allocate a buffer of that size plus one and call again to retrieve the full message.

## Build and link integration

Typical integration in a C99 project:

1. Install or vendor:
  - `include/silk.h`,
   - `libsilk.a`.
2. Include the header from your C source:

   ```c
  #include "silk.h"
   ```

3. Link against the static library:

   ```sh
   cc -std=c99 -Wall -Wextra \
      -I/path/to/include \
      your_app.c \
      -L/path/to/lib -lsilk \
      -lstdc++ -lpthread -lm
   ```

4. Create and drive a compiler instance:

   ```c
   SilkCompiler *compiler = silk_compiler_create();
   if (!compiler) { /* handle allocation error */ }

   silk_compiler_set_stdlib(compiler, make_string("std"));
   silk_compiler_set_target(compiler, make_string("x86_64-linux-gnu"));
   silk_compiler_set_optimization_level(compiler, 2);

   silk_compiler_add_source_buffer(
     compiler,
     make_string("main.slk"),
     make_string("fn main() -> int { return 0; }"));

   if (!silk_compiler_build(compiler, SILK_OUTPUT_EXECUTABLE, make_string("out.exe"))) {
     SilkError *err = silk_compiler_last_error(compiler);
     char buf[256];
     size_t n = silk_error_format(err, buf, sizeof buf);
     /* handle error message in buf */
   }

   silk_compiler_destroy(compiler);
   ```

At this stage, successful builds are limited to the backends implemented by the
compiler:

- On `linux/x86_64`, the compiler can emit native ELF64 executables, objects,
  static libraries, and shared libraries for the current IR subset documented
  limited `string`/`struct`/optional support, and a limited FFI subset).
- On `wasm32-unknown-unknown` and `wasm32-wasi`, executable builds emit `.wasm`
  modules for the current IR-backed wasm32 subset documented in
  modules, and `ext` imports under `env.<name>`).
- On other targets, no code generation backend is available yet.
- For well‑typed programs outside these subsets, `silk_compiler_build` fails
  with `E4001` / `E4002` diagnostics (or a more specific build error) until the
  back‑end is extended.

When Formal Silk verification syntax is present (for example `#require`,
`#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`, `#const`), `libsilk` runs the Z3-backed
Formal Silk verifier and fails the build if verification conditions cannot be
proven. The verifier is currently skipped for `std::...` modules until it
covers the full std surface.

## Environment

- `SILK_STD_ROOT` — path to the stdlib root directory used to resolve
  `import std::...;` declarations when the embedder has not called
  `silk_compiler_set_std_root`.
- `SILK_STD_LIB` — path to a target-specific stdlib static archive
  (`libsilk_std.a`). When present, supported executable builds treat auto-loaded
  `std::...` modules as external and resolve their exported functions from this
  archive.
- `SILK_Z3_LIB` — path to a dynamic Z3 library used by the Formal Silk verifier.
  When set, it overrides the default vendored Z3 linkage for verification.

## See Also

- `silk` (1) — Silk language compiler CLI.
- `silk_abi_get_version` (3), `silk_compiler` (3), `silk_error` (3), `silk_bytes` (3)
- `silk` (7)
- `silk.h` — C99 ABI header in the source tree.

==============================================================================
DOCS: `silk-build` (1) — Build Silk Artifacts (man/silk-build.1)
URL: /silk/docs/?p=man/silk-build.1
==============================================================================

# `silk-build` (1) — Build Silk Artifacts

> NOTE: This is the Markdown source for the eventual man 1 page for `silk build`. The roff-formatted manpage should be generated from this content.

## Name

`silk-build` — build an executable, object, static library, or shared library from Silk sources and link inputs (or a `silk.toml` package).

## Synopsis

- `silk build [options] <input> [<input> ...] -o <output>`
- `silk build [options] --package <dir|manifest> [--build-script] [--package-target <name> ...]`
- `silk build [options]` (when `./silk.toml` exists, behaves as if `--package .` was provided)

## Description

`silk build` compiles a module set and emits an output artifact. You can build:

- explicit inputs (`<input> ...`), or
- a package module set from a manifest (`silk.toml`) using `--package` / `--pkg`.


When explicit input files are used (no `--package`), the `silk` CLI may load additional packages into the module set by resolving bare-specifier package imports (for example `import util from "util";`) from the package search path (`SILK_PACKAGE_PATH`).

Input kinds (by extension):

- `.slk` — Silk source file (part of the module set being compiled).
- `.o` — ELF relocatable object file linked into `--kind executable|shared` outputs (and included in `--kind static` archives).
- `.a` — static archive; its `.o` members are linked like object inputs (or included in a combined `--kind static` output).
- `.so` — shared library; treated as a dynamic dependency (equivalent to `--needed <soname>` using the library’s basename).
- `.c` — C source file; compiled to an object via the host C compiler (see `silk-cc` (1) / `SILK_CC`) and then treated like a `.o` input.

Package builds: when `--package` is provided, `.slk` inputs must be omitted, but non-`.slk` link inputs (`.c`, `.o`, `.a`, `.so`) may still be provided.

Notes:

- `.o`/`.a`/`.c` link inputs are currently supported only for `linux/x86_64` outputs.
- `.so` inputs only affect executable/shared outputs (static archives cannot record dynamic dependencies).
- script-style entrypoints: when building an executable, if the **first** `.slk` input contains top-level statements (after the normal `package`/`module` header and `import` block) and does not define an explicit `main`, `silk build` synthesizes an implicit `fn main() -> int` that executes those statements and then returns `0`.
- for `--kind executable`, `--std-lib` / `--std <path>.a` is currently rejected when linking additional `.c`/`.o`/`.a` inputs (std sources are compiled into the build instead).

## Options

- `--help`, `-h` — show command help and exit.
- `--nostd`, `-nostd` — disable stdlib auto-loading for `import std::...;`.
- `--std-root <path>` — override the stdlib root directory used to resolve `import std::...;`.
- `--std-lib <path>` — select a stdlib archive path for linking hosted builds.
- `--std <path>` — alias of `--std-root` when `<path>` does not end in `.a`.
- `--std <path>.a` — alias of `--std-lib`.
- `--z3-lib <path>` — override the Z3 dynamic library used for Formal Silk verification (also honors `SILK_Z3_LIB`).
- `--debug`, `-g` — enable debug build mode (also enables extra Formal Silk debug output when verification fails).
- `-O <0-3>` — set optimization level (default: `-O2`; when `--debug` is set and `-O` is omitted, defaults to `-O0`). `-O1`+ prunes unused extern symbols before code generation and prunes unreachable functions in executable builds (typically reducing output size).

Output selection:

- `-o <path>`, `--out <path>` — output path. If parent directories do not exist, `silk` creates them.
- `--kind executable|object|static|shared` — output kind.

Target selection:

- `--arch <arch>` — shorthand target selector (mutually exclusive with `--target`).
- `--target <triple>` — target triple (mutually exclusive with `--arch`).

Linker metadata (executable/shared only):

- `--needed <soname>` — add a `DT_NEEDED` entry (repeatable).
- `--runpath <path>` — add a `DT_RUNPATH` entry (repeatable).
- `--rpath <path>` — alias of `--runpath`.
- `--soname <soname>` — set `DT_SONAME` (shared only).

C header emission:

- `--c-header <path>` — write a C header declaring exported symbols (valid only for `--kind object|static|shared`).

Package builds:

- `--package <dir|manifest>`, `--pkg <dir|manifest>` — load the module set from a `silk.toml` manifest instead of explicit input files.
- `--build-script` — compile and run `<package_root>/build.silk` and use its stdout as the manifest.
- `--package-target <name>` — select one or more manifest `[[target]]` entries by name (repeatable; `--pkg-target` is accepted as an alias).
  - when omitted, `silk build --package ...` builds every manifest `[[target]]` entry by default.
  - when building multiple targets, per-output flags are rejected (`-o/--out`, `--kind`, `--arch`, `--target`, `--c-header`, `--needed`, `--runpath`, `--soname`).

Argument parsing:

- `--` — end of options; treat following args as file paths (even if they begin with `-`).

## Examples

```sh
# Build an executable from a single file.
silk build src/main.slk -o build/app

# Build an object file (and emit a C header for exported symbols).
silk build src/lib.slk --kind object -o build/lib.o --c-header build/lib.h

# Link an extra C object into a Silk executable.
cc -std=c99 -c -o build/extra.o src/extra.c
silk build src/main.slk build/extra.o -o build/app

# Build the current directory as a package (when ./silk.toml exists).
silk build

# Build a specific target from a manifest.
silk build --package . --package-target app
```

## Environment

- `SILK_PACKAGE_PATH` — PATH-like list of package root directories used to resolve bare-specifier package imports (entries separated by `:` on POSIX).
- `SILK_CC` — host C compiler used by `silk cc` (also used when compiling `.c` inputs passed to `silk build`).

## Exit status

- `0` on success.
- non-zero on error.

## See Also

- `silk` (1), `silk-check` (1), `silk-test` (1)

==============================================================================
DOCS: `silk-cc` (1) — C Compiler Wrapper for `libsilk` (man/silk-cc.1)
URL: /silk/docs/?p=man/silk-cc.1
==============================================================================

# `silk-cc` (1) — C Compiler Wrapper for `libsilk`

> NOTE: This is the Markdown source for the eventual man 1 page for `silk cc`. The roff-formatted manpage should be generated from this content.

## Name

`silk-cc` — run a host C compiler with default include and link flags for `libsilk.a`.

## Synopsis

- `silk cc <cc args...>`

## Description

`silk cc` is a convenience wrapper for building C/C++ programs that embed or link against `libsilk.a`.

It selects the underlying compiler via `SILK_CC` (default: `cc`) and:

- adds `-I <install>/include` automatically,
- unless you pass `-c`/`-E`/`-S`/`-M`/`-MM`, also adds `-L <install>/lib -lsilk`,
- on `linux/x86_64`, also adds `-lstdc++ -lpthread -lm` (vendored Z3 is built as C++).

## Environment

- `SILK_CC` — host C compiler executable (default: `cc`).

## Examples

```sh
# Build an embedder (assumes `silk` is installed).
silk cc -std=c99 -Wall -Wextra your_app.c -o your_app
```

## Exit status

- the exit status of the underlying compiler.

## See Also

- `silk` (1)
- `libsilk` (7)
- `include/silk.h`

==============================================================================
DOCS: `silk-check` (1) — Parse and Type-Check (man/silk-check.1)
URL: /silk/docs/?p=man/silk-check.1
==============================================================================

# `silk-check` (1) — Parse and Type-Check

> NOTE: This is the Markdown source for the eventual man 1 page for `silk check`. The roff-formatted manpage should be generated from this content.

## Name

`silk-check` — parse and type-check a Silk module set.

## Synopsis

- `silk check [options] <file> [<file> ...]`
- `silk check [options] --package <dir|manifest>`

## Description

`silk check` parses and type-checks a module set and reports any diagnostics. It does not emit an output artifact.

To check a package manifest (`silk.toml`), pass `--package` / `--pkg` and omit explicit input files.

When explicit input files are used (no `--package`), the `silk` CLI may load additional packages into the module set by resolving bare-specifier package imports (for example `import util from "util";`) from the package search path (`SILK_PACKAGE_PATH`).

## Options

- `--help`, `-h` — show command help and exit.
- `--nostd`, `-nostd` — disable stdlib auto-loading for `import std::...;`.
- `--std-root <path>` — override the stdlib root directory used to resolve `import std::...;`.
- `--std <path>` — alias of `--std-root` when `<path>` does not end in `.a`.
- `--std-lib <path>` — accepted for consistency; ignored by `check`.
- `--std <path>.a` — accepted for consistency; ignored by `check`.
- `--z3-lib <path>` — override the Z3 dynamic library used for Formal Silk verification (also honors `SILK_Z3_LIB`).
- `--debug`, `-g` — emit Z3 debug output and write `.smt2` dumps for failing Formal Silk obligations.
- `--package <dir|manifest>`, `--pkg <dir|manifest>` — load the module set from a `silk.toml` manifest instead of explicit input files.
- `--` — end of options; treat following args as file paths (even if they begin with `-`).

## Examples

```sh
# Check a single-file program.
silk check main.slk

# Check a module set.
silk check src/main.slk src/util.slk

# Check the current directory as a package (explicit).
silk check --package .
```

## Environment

- `SILK_PACKAGE_PATH` — PATH-like list of package root directories used to resolve bare-specifier package imports (entries separated by `:` on POSIX).

## Exit status

- `0` on success.
- non-zero on error.

## See Also

- `silk` (1), `silk-build` (1)

==============================================================================
DOCS: `silk-doc` (1) — Generate Documentation (Markdown or Manpages) (man/silk-doc.1)
URL: /silk/docs/?p=man/silk-doc.1
==============================================================================

# `silk-doc` (1) — Generate Documentation (Markdown or Manpages)

> NOTE: This is the Markdown source for the eventual man 1 page for `silk doc`. The roff-formatted manpage should be generated from this content.

## Name

`silk-doc` — generate documentation from doc comments in Silk sources.

## Synopsis

- `silk doc [options] <file> [<file> ...]`
- `silk doc --man [options] <query>`

## Description

`silk doc` reads Silk sources and renders documentation from Silkdoc comments (`/** ... */` and `/// ...`) attached to declarations.

It supports two modes:

- Markdown mode (default): emits Markdown documentation for one or more input files.
- Manpage mode (`--man`): renders a single roff `man(7)` page derived from doc comments and displays or writes it.

In Markdown mode, by default `silk doc` includes exported values and types, plus all `struct` and `interface` declarations. Use `--all` to include non-exported declarations.

In manpage mode, the rendered manpage section is derived from doc tags:

- `@cli` → section 1
- `@misc` → section 7
- otherwise API docs → section 3


## Options

- `--help`, `-h` — show command help and exit.
- `-o <path>`, `--out <path>` — write output to `<path>` (default: stdout).

Markdown mode:

- `--all` — include non-exported functions, bindings, and methods.
- `--` — end of options; treat following args as file paths (even if they begin with `-`).

Manpage mode:

- `--man` — render a roff manpage instead of Markdown.
- `--package <dir|manifest>`, `--pkg <dir|manifest>` — load a module set from a package manifest (`silk.toml`) rooted at the provided directory (or from the provided manifest path).
- `--std-root <path>` — override the stdlib root directory used for resolving `std::...` queries.

## Examples

```sh
# Generate docs for a module set.
silk doc src/main.slk src/util.slk -o api.md

# Include non-exported declarations.
silk doc --all src/main.slk -o api.md

# Render a roff manpage for a stdlib module.
silk doc --man std::flag -o std_flag.3
```

## Exit status

- `0` on success.
- non-zero on error.

## See Also

- `silk` (1)
- `silk-man` (1)

==============================================================================
DOCS: `silk-lsp` (1) — Language Server Protocol (LSP) Server (man/silk-lsp.1)
URL: /silk/docs/?p=man/silk-lsp.1
==============================================================================

# `silk-lsp` (1) — Language Server Protocol (LSP) Server

> NOTE: This is the Markdown source for the eventual man 1 page for `silk-lsp`. The roff-formatted manpage should be generated from this content.

## Name

`silk-lsp` — Language Server Protocol server for Silk.

## Synopsis

- `silk-lsp [--nostd] [--std-root <path>]`

## Description

`silk-lsp` speaks the Language Server Protocol over stdin/stdout for editor integrations.


## Options

- `--nostd` — disable stdlib integration.
- `--std-root <path>` — override the stdlib root used for stdlib integration (also respects `SILK_STD_ROOT`).

## Environment

- `SILK_STD_ROOT` — default stdlib root (used when `--std-root` is not provided).

## See Also

- `silk` (1)

==============================================================================
DOCS: `silk-man` (1) — View Manpages Derived from Source Docs (man/silk-man.1)
URL: /silk/docs/?p=man/silk-man.1
==============================================================================

# `silk-man` (1) — View Manpages Derived from Source Docs

> NOTE: This is the Markdown source for the eventual man 1 page for `silk man`. The roff-formatted manpage should be generated from this content.

## Name

`silk-man` — render and view a temporary manpage for a symbol, module, package, or conceptual topic.

## Synopsis

- `silk man [options] <query>`

## Description

`silk man` is an interactive documentation viewer. It parses Silk source files and renders a temporary manpage derived from doc comments, then displays it using the user’s pager.

`silk man` recognizes:

- conceptual pages defined by doc blocks tagged with `@misc <label>` (intended for man section 7),
- CLI pages defined by doc blocks tagged with `@cli` (intended for man section 1),
- API pages derived from declaration docs (intended for man section 3).


## Options

- `--help`, `-h` — show command help and exit.
- `--package <dir|manifest>`, `--pkg <dir|manifest>` — load a module set from a package manifest (`silk.toml`) rooted at the provided directory (or from the provided manifest path).
  - when omitted, and the query is not `std::...`, `silk man` searches the current working directory and its parent directories for `silk.toml` and uses the nearest match.
  - when no manifest is discoverable, `silk man` may also resolve the query from the package search path (`SILK_PACKAGE_PATH`).
- `--std-root <path>` — override the stdlib root directory used for resolving `std::...` queries.

## Environment

- `MANPAGER` / `PAGER` — controls the pager used to display the rendered output (when `man -l` is unavailable).
- `SILK_PACKAGE_PATH` — PATH-like list of package root directories used to resolve non-`std::` queries when no package manifest is selected or discoverable.

## Examples

```sh
# View docs for a stdlib module.
silk man std::flag

# View docs for a stdlib symbol.
silk man std::sqlite::Database

# View a conceptual page labeled via @misc.
silk man std::result::design
```

## Exit status

- `0` on success.
- non-zero on error (unknown query, parse errors, or pager failures).

## See Also

- `silk` (1), `silk-doc` (1)

==============================================================================
DOCS: `silk-test` (1) — Run Language-Level Tests (man/silk-test.1)
URL: /silk/docs/?p=man/silk-test.1
==============================================================================

# `silk-test` (1) — Run Language-Level Tests

> NOTE: This is the Markdown source for the eventual man 1 page for `silk test`. The roff-formatted manpage should be generated from this content.

## Name

`silk-test` — discover and run language-level `test` declarations.

## Synopsis

- `silk test [options] <file> [<file> ...]`
- `silk test [options] --package <dir|manifest>`
- `silk test [options]` (when `./silk.toml` exists, behaves as if `--package .` was provided)

## Description

`silk test` discovers `test` declarations in the loaded module set and runs them, emitting TAP version 13 output.

When explicit input files are used (no `--package`), the `silk` CLI may load additional packages into the module set by resolving bare-specifier package imports (for example `import util from "util";`) from the package search path (`SILK_PACKAGE_PATH`).

## Options

- `--help`, `-h` — show command help and exit.
- `--nostd`, `-nostd` — disable stdlib auto-loading for `import std::...;`.
- `--std-root <path>` — override the stdlib root directory used to resolve `import std::...;`.
- `--std-lib <path>` — select a stdlib archive path for linking hosted builds.
- `--std <path>` — alias of `--std-root` when `<path>` does not end in `.a`.
- `--std <path>.a` — alias of `--std-lib`.
- `--z3-lib <path>` — override the Z3 dynamic library used for Formal Silk verification (also honors `SILK_Z3_LIB`).
- `--debug`, `-g` — enable debug build mode (also enables extra Formal Silk debug output when verification fails).
- `-O <0-3>` — set optimization level (default: `-O2`; when `--debug` is set and `-O` is omitted, defaults to `-O0`). `-O1`+ prunes unused extern symbols before code generation and prunes unreachable functions in executable builds (typically reducing output size).
- `--noheap` — reject heap allocation in the supported subset.
- `--filter <pattern>` — run only tests whose display name contains `<pattern>` (substring match).
- `--package <dir|manifest>`, `--pkg <dir|manifest>` — load the module set from a `silk.toml` manifest instead of explicit input files. When `<file> ...` inputs are omitted and `--package` / `--pkg` is also omitted, but `./silk.toml` exists, `silk test` behaves as if `--package .` was provided.
- `--` — end of options; treat following args as file paths (even if they begin with `-`).

## Examples

```sh
# Run tests in an explicit module set.
silk test src/main.slk src/util.slk

# Run package tests from the current directory manifest (implicit --package .).
silk test

# Run package tests from the current directory manifest.
silk test --package .

# Run only tests whose name contains "url".
silk test --package . --filter url
```

## Environment

- `SILK_PACKAGE_PATH` — PATH-like list of package root directories used to resolve bare-specifier package imports (entries separated by `:` on POSIX).

## Exit status

- `0` when all tests pass.
- non-zero when any test fails or the module set is invalid.

## See Also

- `silk` (1), `silk-build` (1)

==============================================================================
DOCS: `silk_abi_get_version` (3) — Query the `libsilk` ABI Version (man/silk_abi_get_version.3)
URL: /silk/docs/?p=man/silk_abi_get_version.3
==============================================================================

# `silk_abi_get_version` (3) — Query the `libsilk` ABI Version

> NOTE: This is the Markdown source for the eventual man 3 page for `silk_abi_get_version`. The roff-formatted manpage should be generated from this content.

## Name

`silk_abi_get_version` — query the runtime embedding ABI version of `libsilk.a`.

## Synopsis

```c
#include "silk.h"

void silk_abi_get_version(int *out_major,
                          int *out_minor,
                          int *out_patch);
```

## Description

`silk_abi_get_version` reports the semantic version of the `libsilk` embedding ABI as `MAJOR.MINOR.PATCH`.

Embedders should compare the runtime version returned by this function with the compile-time ABI version macros in `include/silk.h`:

```c
#define SILK_ABI_VERSION_MAJOR ...
#define SILK_ABI_VERSION_MINOR ...
#define SILK_ABI_VERSION_PATCH ...
```

## Parameters

- `out_major`, `out_minor`, `out_patch` — output pointers written on success. The current implementation tolerates `NULL` pointers and skips writing those components.

## Return value

None.

## See Also

- `libsilk` (7)

==============================================================================
DOCS: `silk_bytes` (3) — Manage Owned Build Output Buffers (man/silk_bytes.3)
URL: /silk/docs/?p=man/silk_bytes.3
==============================================================================

# `silk_bytes` (3) — Manage Owned Build Output Buffers

> NOTE: This is the Markdown source for the eventual man 3 page for `SilkBytes` output buffers. The roff-formatted manpage should be generated from this content.

## Name

`silk_bytes` — manage owned `SilkBytes` buffers returned by `libsilk` build APIs.

## Synopsis

```c
#include "silk.h"

typedef struct SilkBytes {
  uint8_t *ptr;
  int64_t  len;
} SilkBytes;

bool silk_compiler_build_to_bytes(SilkCompiler   *compiler,
                                  SilkOutputKind  kind,
                                  SilkBytes      *out_bytes);

void silk_bytes_free(SilkBytes *bytes);
```

## Description

`silk_compiler_build_to_bytes` returns an owned artifact buffer in `SilkBytes` (for example for sandboxed or filesystem-free embedding scenarios).

The buffer memory is owned by `libsilk.a` and must be released with `silk_bytes_free`.

## `silk_bytes_free`

`silk_bytes_free` frees a buffer returned by `silk_compiler_build_to_bytes`.

- It is safe to call this with `NULL`.
- It is safe to call this with a `SilkBytes` whose `ptr` is `NULL`.
- After freeing, the buffer contents must not be accessed.

## See Also

- `silk_compiler` (3)
- `libsilk` (7)

==============================================================================
DOCS: `silk_compiler` (3) — Embed the Silk Compiler (man/silk_compiler.3)
URL: /silk/docs/?p=man/silk_compiler.3
==============================================================================

# `silk_compiler` (3) — Embed the Silk Compiler

> NOTE: This is the Markdown source for the eventual man 3 page for the `SilkCompiler` embedding API. The roff-formatted manpage should be generated from this content.

## Name

`silk_compiler` — C99 embedding API for compiling Silk sources via `libsilk.a`.

## Synopsis

```c
#include "silk.h"

typedef struct SilkCompiler SilkCompiler;
typedef struct SilkModule   SilkModule;
typedef enum SilkOutputKind SilkOutputKind;

SilkCompiler *silk_compiler_create(void);
void          silk_compiler_destroy(SilkCompiler *compiler);

bool silk_compiler_set_stdlib(SilkCompiler *compiler, SilkString stdlib_name);
bool silk_compiler_set_std_root(SilkCompiler *compiler, SilkString std_root);
bool silk_compiler_set_nostd(SilkCompiler *compiler, bool nostd);
bool silk_compiler_set_target(SilkCompiler *compiler, SilkString target_triple);
bool silk_compiler_add_needed_library(SilkCompiler *compiler, SilkString soname);
bool silk_compiler_add_runpath(SilkCompiler *compiler, SilkString path);
bool silk_compiler_set_soname(SilkCompiler *compiler, SilkString soname);
bool silk_compiler_set_optimization_level(SilkCompiler *compiler, int level);

SilkModule *silk_compiler_add_source_buffer(SilkCompiler *compiler,
                                            SilkString    name,
                                            SilkString    contents);

bool silk_compiler_build(SilkCompiler   *compiler,
                         SilkOutputKind  kind,
                         SilkString      output_path);

bool silk_compiler_build_to_bytes(SilkCompiler   *compiler,
                                  SilkOutputKind  kind,
                                  SilkBytes      *out_bytes);
```

## Description

The `SilkCompiler` API embeds the Silk compiler in C or C++ programs.

Typical workflow:

1. Create a compiler: `silk_compiler_create`.
2. Optionally configure it (stdlib selection, target triple, etc).
3. Add one or more source buffers with `silk_compiler_add_source_buffer`.
4. Build an artifact with `silk_compiler_build` (filesystem) or `silk_compiler_build_to_bytes` (in-memory).
5. On error, retrieve diagnostics via `silk_compiler_last_error` and `silk_error_format` (see `silk_error` (3)).
6. Destroy the compiler with `silk_compiler_destroy`.


## Configuration

All configuration functions return `true` on success and `false` on failure. On failure, the compiler records an error retrievable via `silk_compiler_last_error`.

Stdlib configuration:

- `silk_compiler_set_stdlib` selects the stdlib package name (for example `"std"`).
- `silk_compiler_set_std_root` selects the filesystem root used to resolve `import std::...;`.
- `silk_compiler_set_nostd(true)` disables filesystem-based stdlib auto-loading.

Target and linkage:

- `silk_compiler_set_target` selects the code generation target triple.
- `silk_compiler_add_needed_library` / `silk_compiler_add_runpath` / `silk_compiler_set_soname` configure dynamic linker metadata for ELF outputs (when applicable).

Optimization:

- `silk_compiler_set_optimization_level` accepts an integer level in the range documented by `include/silk.h`. The default is level 0 unless overridden.
- In the current implementation, level 1+ enables lowering-time pruning of unused extern symbols before code generation (typically reducing output size and over-linking when using the prebuilt `libsilk_std.a` archive for auto-loaded `import std::...;` modules).

## Sources

`silk_compiler_add_source_buffer` registers a module as an in-memory UTF-8 source buffer. The returned `SilkModule*` is owned by the compiler; embedders must not free it.

The `name` parameter is used for diagnostics and does not need to correspond to an on-disk file path.

## Building

`silk_compiler_build` writes an artifact to `output_path`. Unlike the CLI, this ABI call does not create parent directories; the output directory must exist.

`silk_compiler_build_to_bytes` returns an in-memory artifact via `SilkBytes`. On success, the caller must free the buffer with `silk_bytes_free` (see `silk_bytes` (3)).

## Thread safety

The `SilkCompiler` object is not currently specified as thread-safe. Confine it to one thread or synchronize access.

## See Also

- `silk_error` (3), `silk_bytes` (3), `silk_abi_get_version` (3)
- `libsilk` (7)

==============================================================================
DOCS: `silk_error` (3) — Retrieve and Format Compiler Errors (man/silk_error.3)
URL: /silk/docs/?p=man/silk_error.3
==============================================================================

# `silk_error` (3) — Retrieve and Format Compiler Errors

> NOTE: This is the Markdown source for the eventual man 3 page for `SilkError` formatting and retrieval. The roff-formatted manpage should be generated from this content.

## Name

`silk_error` — retrieve the last compiler error and format it as text.

## Synopsis

```c
#include "silk.h"

typedef struct SilkCompiler SilkCompiler;
typedef struct SilkError    SilkError;

SilkError *silk_compiler_last_error(SilkCompiler *compiler);

size_t silk_error_format(const SilkError *error,
                         char            *buffer,
                         size_t           buffer_len);
```

## Description

When a `SilkCompiler` API call fails, it records a last-error object. Embedders can access it with `silk_compiler_last_error` and format it with `silk_error_format`.

### Lifetime

The `SilkError*` returned by `silk_compiler_last_error` is owned by the compiler and remains valid until:

- the compiler is destroyed, or
- a subsequent operation overwrites the compiler’s last-error state.

Embedders must not free or dereference the `SilkError` object directly.

### Formatting

`silk_error_format` writes a UTF-8 diagnostic message into a caller-provided buffer.

- If `buffer_len > 0`, the message is always NUL-terminated.
- The return value is the number of bytes required to format the full message, excluding the terminating NUL.
- If the return value is `>= buffer_len`, the message was truncated.

## See Also

- `silk_compiler` (3)
- `libsilk` (7)

==============================================================================
DOCS: `silk` (1) — Silk Language Compiler (man/silk.1)
URL: /silk/docs/?p=man/silk.1
==============================================================================

# `silk` (1) — Silk Language Compiler

> NOTE: This is the Markdown source for the eventual man 1 page for `silk`. The roff-formatted manpage should be generated from this content.

## Name

`silk` — compile Silk source code and packages.

## Synopsis

- `silk [--help|-h] [--version]`
- `silk <command> [options] [args...]`
- `silk help [<command>]`
- `silk repl`
- `silk check [--nostd] [--std-root <path>] [--z3-lib <path>] [--debug] [--package <dir|manifest>] <file> [<file> ...]`
- `silk test [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--filter <pattern>] [--package <dir|manifest>] <file> [<file> ...]`
- `silk build [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--package <dir|manifest>] [--build-script] [--package-target <name> ...] <input> [<input> ...] -o <path> [--kind executable|object|static|shared] [--arch <arch>] [--target <triple>] [--c-header <path>] [--needed <soname> ...] [--runpath <path> ...] [--soname <soname>]`
- `silk doc [--all] <file> [<file> ...] [-o <path>]`
- `silk doc --man [--package <dir|manifest>] [--std-root <path>] <query> [-o <path>]`
- `silk man <query>`
- `silk cc <cc args...>`

## Description

`silk` is the command-line compiler for the Silk language. It reads Silk source files, performs parsing and type checking, and (in the initial implementation) can build simple executable programs for a small, documented subset of the language. As the compiler matures, `silk` will grow to support full code generation for executables, static libraries, and shared libraries.


Convenience entrypoints:

- `slc` — behaves like `silk build ...`.
- `slcc` — behaves like `silk cc ...`.

When invoked with no command and stdin is a TTY, `silk` enters the interactive
REPL (equivalent to running `silk repl`).

## Diagnostics

On error, `silk` prints a human-readable diagnostic to stderr and exits with a non-zero status. Diagnostics include a stable error code for known error kinds and, when available, a file/line/column location plus a caret snippet highlighting the primary span.

When stderr is a TTY, `silk` may decorate diagnostics with ANSI colors. Set `NO_COLOR` (or use `TERM=dumb`) to disable color output.


## Options

For the initial implementation, the supported options are:

- **Global options:**
  - `--help` / `-h` — show global usage and exit.
  - `help` — show global usage and exit.
  - `help <command>` — show command-specific usage and exit.
  - `--version` — show the embedding ABI version (queried via `silk_abi_get_version`) and exit.

- **REPL command:**
  - `silk repl` starts an interactive “compile-and-run” REPL.
  - Currently supported only on `linux/x86_64` (native ELF backend).
  - Stateful by replay: each successful line is appended to a session program.
    When you enter runtime lines (statements/expressions), the session is
    re-executed from the start (so side effects may repeat). Import and
    declaration lines are validated by compilation only (not executed).
  - Built-in commands:
    - `.help` — show help
    - `.clear` — reset session state
    - `.cls` — clear the screen
    - `.undo` — undo the last successful line
    - `.exit` — exit the REPL
  - History is loaded/saved to:
    - `$SILK_REPL_HISTORY` when set, otherwise
    - `$SILK_WORK_DIR/repl_history` (default: `.silk/repl_history`).

- **Check command:**
  - `silk check [--nostd] [--std-root <path>] [--z3-lib <path>] [--debug] [--package <dir|manifest>] <file> [<file> ...]`:
    - `--help`, `-h` — show `check` usage and exit.
    - `--nostd`, `-nostd` — disable stdlib auto-loading; `import std::...;` must be satisfied by explicitly passing source files.
    - `--std-root <path>` (or `--std <path>` / `-std <path>` when `<path>` does **not** end in `.a`) — override the stdlib root directory used to resolve `import std::...;` and std-root file imports (`from "std/<path>"` / `from "std/<path>.slk"`).
    - `--std-lib <path>` (or `--std <path>.a` / `-std <path>.a`) — select a stdlib archive path for linking auto-loaded `std::...` modules during builds (ignored by `check`).
    - `--z3-lib <path>` — override the Z3 dynamic library used for Formal Silk verification (also honors `SILK_Z3_LIB`).
    - `--debug`, `-g` — when Formal Silk verification fails, emit Z3 debugging output and write an SMT-LIB2 reproduction script under `.silk/z3/` (or `$SILK_WORK_DIR/z3`).
    - `--package <dir|manifest>` (or `--pkg`) — load the module set from a package manifest (`silk.toml`) instead of explicit input files. When `--package` is provided, `<file> ...` inputs must be omitted.
    - `--` — end of options; treat remaining args as file paths (even if they begin with `-`).

- **Test command:**
  - `silk test [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--filter <pattern>] [--package <dir|manifest>] <file> [<file> ...]`:
    - `--help`, `-h` — show `test` usage and exit.
    - compiles and runs each test, emitting TAP version 13 output,
    - in the current implementation, each test runs in its own process so a failing `assert` (panic/abort) does not stop the whole suite.
    - `-O <0-3>` — set optimization level (default: `-O2`; when `--debug` is set and `-O` is omitted, defaults to `-O0`). `-O1`+ prunes unused extern symbols before code generation and prunes unreachable functions in executable builds (typically reducing output size).
    - `--filter <pattern>` — run only tests whose display name contains `<pattern>` (substring match).
    - `--package <dir|manifest>` (or `--pkg`) — load the module set from a package manifest (`silk.toml`) instead of explicit input files. When `--package` is provided:
      - `<file> ...` inputs must be omitted.
      - When `<file> ...` inputs are omitted and `--package` / `--pkg` is also omitted, but `./silk.toml` exists, `silk test` behaves as if `--package .` was provided.
    - `--z3-lib <path>` — override the Z3 dynamic library used for Formal Silk verification (also honors `SILK_Z3_LIB`).
    - `--` — end of options; treat remaining args as file paths (even if they begin with `-`).

- **Build command:**
  - `silk build [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--package <dir|manifest>] [--build-script] [--package-target <name> ...] <input> [<input> ...] -o <path> [--kind executable|object|static|shared] [--arch <arch>] [--target <triple>] [--c-header <path>] [--needed <soname> ...] [--runpath <path> ...] [--soname <soname>]`:
    - `--help`, `-h` — show `build` usage and exit.
    - `-o <path>`, `--out <path>` — write the generated output to `<path>`.
      - if the parent directories of `<path>` do not exist, the compiler creates them (like `mkdir -p`).
    - `--package <dir|manifest>` (or `--pkg`) — load the module set from a package manifest (`silk.toml`) instead of explicit input files. When `--package` is provided:
      - `<file> ...` inputs must be omitted.
      - When `<file> ...` inputs are omitted and `--package` / `--pkg` is also omitted, but `./silk.toml` exists, `silk build` behaves as if `--package .` was provided.
    - `--package-target <name>` — select one or more manifest `[[target]]` entries by name (repeatable; `--pkg-target` is accepted as an alias).
      - when omitted, `silk build --package ...` builds every manifest `[[target]]` entry by default.
      - when building multiple targets, per-output flags are rejected (`-o/--out`, `--kind`, `--arch`, `--target`, `--c-header`, `--needed`, `--runpath`, `--soname`).
    - `--` — end of options; treat remaining args as file paths (even if they begin with `-`).
    - `--debug`, `-g` — enable debug build mode (supported subset, `linux/x86_64`):
      - failed `assert` prints a panic header + optional message + stack trace to stderr (via glibc `backtrace_symbols_fd`) before aborting, and
      - dynamically-linked executables preserve internal function symbols in `.dynsym` (similar to `-rdynamic`) for stack trace symbolization.
      - when Formal Silk verification fails, `--debug` also emits Z3 debugging output and writes an SMT-LIB2 reproduction script under `.silk/z3/` (or `$SILK_WORK_DIR/z3`).
      - compiled code can query this mode at runtime via `std::runtime::build::is_debug()`.
    - `-O <0-3>` — set optimization level (default: `-O2`; when `--debug` is set and `-O` is omitted, defaults to `-O0`). `-O1`+ prunes unused extern symbols before code generation and prunes unreachable functions in executable builds (typically reducing output size).
    - `--noheap` — disable heap allocation for the :
      - heap-backed `new` (outside a `with` region) is rejected with `E2027`,
      - `ext` bindings to libc heap primitives (`malloc`/`calloc`/`realloc`/`free`/etc) are rejected with `E2027` in non-stdlib modules,
      - `std::runtime::mem::{alloc,realloc,free}` traps when called without an active `with` region (no implicit heap fallback),
      - any use of `async`, `task`, `await`, `yield`, or capturing closures is rejected with `E2027`,
      - region-backed `new` inside `with` is still permitted,
      - `--noheap` is currently incompatible with `--debug` (debug panic traces require `malloc`/`free`).
    - `--z3-lib <path>` — override the Z3 dynamic library used for Formal Silk verification (also honors `SILK_Z3_LIB`).
    - `--kind <kind>` — select the output kind:
      - `executable` (default)
      - `object` (ELF64 relocatable object on `linux/x86_64`)
      - `static` (static library archive on `linux/x86_64`)
      - `shared` (shared library on `linux/x86_64`)
    - `--arch <arch>` — shorthand for selecting a known target:
      - `x86_64` / `amd64` → `linux-x86_64`,
      - `wasm32` → `wasm32-unknown-unknown`,
      - `wasm32-wasi` → `wasm32-wasi`,
      - for convenience, `--arch` also accepts full target triples recognized by `--target`.
    - `--target <triple>` — select the compilation target (initial implementation):
      - `linux-x86_64` (default; emits ELF64 binaries as described below),
      - common `x86_64-*-linux-*` triples such as `x86_64-linux-gnu` are accepted as aliases for `linux-x86_64`,
      - `wasm32-unknown-unknown` (IR-backed wasm32 mode; emits a `.wasm` module exporting `memory` and exported functions, including `main` when present; `ext` declarations become imports under `env.<name>`; also supports export-only modules with no `main` for JS/Node-style embedding),
      - `wasm32-wasi` (IR-backed wasm32 WASI mode; emits `memory` and `_start () -> void`, imports `wasi_snapshot_preview1.proc_exit`, and calls Silk `fn main () -> int`; also supports export-only modules for embedding, which do not include `_start`),
      - unknown or unsupported triples currently cause `silk build` to fail with a “target not implemented” error.
      - Note: wasm targets are only supported for `--kind executable` in the current implementation.
    - `--arch` and `--target` are mutually exclusive; passing both is an error.
    - `--c-header <path>` — emit a generated C header declaring the root package’s exported symbols (C ABI consumption):
      - writes prototypes for `export fn` and `extern const` declarations for supported `export let` constants,
      - if the parent directories of `<path>` do not exist, the compiler creates them (like `mkdir -p`),
      - only supported for `--kind object|static|shared` (rejected for `--kind executable`),
      - requires the root package (the first input module’s package) to be the global package (omit `package ...;` in exported library sources).
    - `--needed <soname>` — add a dynamic loader dependency (emitted as `DT_NEEDED`) for executable and shared outputs; may be repeated.
    - `--runpath <path>`, `--rpath <path>` — add a runtime search path element (emitted as `DT_RUNPATH`) for executable and shared outputs; may be repeated (joined with ':').
    - `--soname <soname>` — set the shared library soname recorded as `DT_SONAME` for shared outputs (an empty string clears it).
    - `--nostd`, `-nostd` — disable stdlib auto-loading; `import std::...;` must be satisfied by explicitly passing source files.
    - `--std-root <path>` (or `--std <path>` / `-std <path>` when `<path>` does **not** end in `.a`) — override the stdlib root directory used to resolve `import std::...;`.
    - `--std-lib <path>` (or `--std <path>.a` / `-std <path>.a`) — select a stdlib archive path for linking auto-loaded `std::...` modules during executable builds.
    - The build currently:
      - runs front-end checks,
        - when multiple input files are provided, performs module-set validation (package/import resolution + multi-module type checking that accounts for imported exported constants and imported `export fn` calls for the current scalar subset),
      - resolves `std::...` imports by loading stdlib source files from a configured stdlib root (see **Environment** below),
      - for `--kind executable` (the default):
        - when the module set defines a valid Silk entrypoint, enforces the executable entrypoint rule (exactly one `main` of either `fn main() -> int`, `async fn main() -> int`, or `fn main(argc: int, argv: u64) -> int`),
        - script-style entrypoints: when the **first** `.slk` input contains top-level statements (after the normal `package`/`module` header and `import` block) and does not define an explicit `main`, `silk build` synthesizes an implicit `fn main() -> int` that executes those statements and then returns `0`,
        - when the module set defines no valid Silk `main`, requires an object/archive-provided `main(argc: int, argv: u64) -> int` symbol (for example from a `.c`/`.o`/`.a` input) and emits an entry stub that forwards `argc`/`argv` to it,
        - note: for now, `--std-lib` / `--std <path>.a` is rejected when linking additional `.c`/`.o`/`.a` inputs into an executable (std sources are compiled into the build instead),
        - on `linux/x86_64` native executables, when the `argc`/`argv` form is used, `argv` is a raw pointer to the argv pointer list (a C-style `char**`, where `argv[0]` is at byte offset `0`, `argv[1]` at `8`, etc.),
      - for `--kind object`, `--kind static`, and `--kind shared`, `main` is optional; the current backend emits supported `export fn` functions and supported exported constants (`export let` with an explicit type annotation and a literal initializer; currently scalar types and `string`), plus a valid executable `main` when present, as global symbols,
        - it is valid for a non-executable output to contain no globally-visible symbols (for example, type-only or interface-only modules); in that case the build still succeeds and produces an “empty” object/archive/shared library,
        - declaration-only exported function prototypes (`export fn name(...) -> T;`) are accepted as module exports for type-checking, but do not emit code; calls lower as link-time symbol references that must be satisfied by other Silk sources in the module set and/or `.c`/`.o`/`.a` inputs,
      - on `linux/x86_64`, the current backend also supports a limited `string` subset (SilkString `{ ptr, len }` ABI, string literals + `let`/`return` + calls to `string`-returning helpers + `==`/`!=`/`<`/`<=`/`>`/`>=` comparisons; exported `string` constants are supported for non-executable outputs),
      - on `linux/x86_64`, the current backend also supports a limited FFI call subset:
        - top-level `ext` declarations of external functions (`ext name = fn (T, ...) -> R;`) may be called like normal functions from Silk code,
        - supported for:
          - `--kind object` and `--kind static` (relocations are emitted against undefined external symbols for downstream linkers), and
          - `--kind shared` (dynamic imports emitted and calls go through the shared object’s GOT; symbols must be available at runtime),
          - `--kind executable` (a dynamically-linked ELF64 executable is emitted and calls go through the executable’s GOT; symbols must be available at runtime),
        - top-level `ext` declarations of external scalar variables (`ext name = T;`) may be read like normal values from Silk code:
          - `--kind object` and `--kind static` (relocations are emitted against undefined external data symbols), and
          - `--kind shared` (dynamic imports emitted and loads go through the shared object’s GOT; symbols must be available at runtime),
          - `--kind executable` (a dynamically-linked ELF64 executable is emitted and loads go through the executable’s GOT; symbols must be available at runtime),
        - writing to `ext` variables is not supported,
        - for executables and shared libraries, dynamic dependencies can be declared via `--needed <soname>` (emitted as `DT_NEEDED`) and runtime search paths can be declared via `--runpath <path>` (emitted as `DT_RUNPATH`); for shared outputs, the library soname can be set via `--soname <soname>` (emitted as `DT_SONAME`).
          - on `linux/x86_64` with the glibc dynamic loader (`ld-linux`), `silk` automatically adds:
            - `libc.so.6` when external symbols are present,
            - `libpthread.so.0` when `pthread_*` symbols are imported,
            - `libsodium.so.23` when libsodium-backed symbols are imported (for example via `import std::crypto;`),
          - when bundled runtime helpers are imported (for example via `import std::{regex,unicode,number};`), `silk` statically links the bundled runtime archive (`libsilk_rt.a`, or `libsilk_rt_noheap.a` when `--noheap`) into the output, and does not emit a runtime `DT_NEEDED` dependency on `libsilk_rt*`,
          - `--needed` entries starting with `libsilk_rt` are rejected; the bundled runtime support layer is always linked from the static archives,
          - additional dependencies must be declared via `--needed` (or be available in the process global scope at load time, for example via `LD_PRELOAD`),
      - multi-file builds are supported for `--kind executable` and for `--kind object`, `--kind static`, and `--kind shared`:
        - when multiple packages are present in a module set for a non-executable output, only exports from the *root package* (the package of the first input module) are emitted as globally-visible symbols; other packages are compiled as dependencies and their `export` declarations are treated as internal for that output,
      - attempts to emit a native executable using:
        - a constant-expression backend for a small, fully constant subset of `main` bodies on platforms that support the minimal ELF64 stub, and
      - when `--kind object`, `--kind static`, or `--kind shared` is selected, the build attempts the IR→ELF backend on `linux/x86_64` for the same subset and emits `E4001` / `E4002` diagnostics for programs outside that subset,
      - the constant subset consists of:
        - a single `fn main() -> int` with:
          - zero or more `let` statements with constant integer initializers followed by exactly one `return` of a constant integer expression (literals, `+`, `-`, `*`, `/`, `%`, and references to constant `let` bindings), or
          - the same, with a final `if` whose condition is a compile-time boolean literal (`true` / `false`) and whose branches each satisfy the “constant lets + return constant expression” rule, and
          - optionally, one or more trivial constant `while` loops before the final `return`, with constant boolean conditions and bodies of constant `let` bindings followed by `break;`, with verification directives treated as metadata,
        - on `linux/x86_64`, the IR→ELF backend supports a broader subset in which:
        - `fn main() -> int` and helper functions:
          - use only scalar parameters (defaulting to `int` when unannotated) drawn from `int`, `bool`, `char`, `f32`, `f64`, `Instant`, `Duration`, and the fixed-width integer types (`u8`/`i8` … `u64`/`i64`); helper functions return a scalar from the same set (while `main` remains `-> int`), or `void` (omitted result type or explicit `-> void`) when used only as standalone statements (`return;` and implicit fallthrough returns are supported for `void` helpers),
          - helpers may also accept and return `string` values at ABI boundaries (represented as `{ ptr: u64, len: i64 }` / `SilkString`; results return via `rax`/`rdx`),
          - use integer arithmetic (including unary `-x`), bitwise operators (including unary `~x`), and comparisons, plus floating-point arithmetic/comparisons over `f32`/`f64` (including unary `-x`),
          - use `char` literals (UTF-8 or escaped) and `==` / `!=` comparisons over `char` values,
          - use `bool` as a surface type (lowered to integer 0/1 in IR),
          - use structured control flow (`if` / `else`, `while`, `break;`, `continue;`) with conditions built from boolean literals, comparisons, calls to `bool`-returning helpers, logical operators `!` / `&&` / `||` (with `&&` / `||` short-circuiting), and boolean locals,
          - use boolean expressions in `let` initializers and `bool` return statements, including short-circuit `&&` / `||` (for example `let flag: bool = a && b;`),
          - allow call expressions as standalone statements (discarding the returned value),
          - allow assignment and compound assignment to `let mut` locals by name (`x = expr;`, `x += y;`); `=` is supported for all currently supported value types (including `string`, the supported `struct` subset, and optionals of those), and compound assignments are supported only for numeric scalar locals,
          - for a limited subset of structs (slot-flattened structs with 0+ fields of supported value types), supports `struct` declarations, struct literals (`Type{ field: expr, ... }`, including partial initialization), field access (`value.field`, including nested access), `==` / `!=` comparisons (deep/slot-wise), and passing/returning such structs by value using the System V AMD64 convention (one ABI “eightbyte” per slot). For non-executable outputs, exported functions accept only ABI-safe structs whose flattened scalar slots are restricted to `i64`/`u64`/`f64`; downstream C callers should declare separate parameters for 3+ slot structs,
          - and, for helpers, use direct calls between functions that fit this subset, following the System V AMD64 scalar calling convention (`rdi`..`r9` for integer-like args, `xmm0`..`xmm7` for `f32`/`f64`, stack spill for remaining args, and `rax`/`xmm0` results), and
        - `main` may either be a single structured function or call such helpers; the compiler lowers these programs into an IR program and compiles them to a single ELF64 executable,
        - when multiple input files are provided, helper calls may target:
          - functions defined in the same package across modules, and
          - imported exported functions (`export fn`) from any packages imported by the module that contains `main` (both `foo()` and `pkg::foo()` call forms are accepted initially),
      - examples known to be supported and tested include:
        - straight-line integer programs such as `fn main() -> int { return 1 + 2 * 3; }`,
        - programs with local and top-level integer `let` bindings in the final `return`,
        - programs that branch on comparison conditions evaluated at runtime,
        - small loops using `while` with `break;` / `continue;`,
        - helper-call programs equivalent to:

          ```silk
          fn helper (x, y) -> int {
            if x < y {
              let one: int = 1;
              return x + one;
            } else {
              let two: int = 2;
              return y + two;
            }
          }

          fn main () -> int {
            return helper(1, 3);
          }
          ```

        - helpers with many integer parameters (exercising both register and stack-passed arguments),
        - and programs that use boolean locals in conditions, such as:

          ```silk
          fn main () -> int {
            let x: int = 1;
            let y: int = 2;
            let flag: bool = x < y;
            if flag {
              return 3;
            } else {
              return 4;
            }
          }
          ```
      - for programs that type-check but are outside both the constant subset and the current IR-based subset, `silk build` exits non-zero with `E4001` / `E4002` diagnostics describing the backend limitation.

- **Doc command:**
  - Markdown mode: `silk doc [--all] <file> [<file> ...] [-o <path>]`:
    - Generates Markdown documentation from Silkdoc comments (`/** ... */` and `/// ...`) attached to declarations.
    - By default, includes exported `fn`/`let`/`ext` declarations and exported `impl` methods, plus all `struct` and `interface` declarations in the input modules.
    - `--help`, `-h` — show `doc` usage and exit.
    - `--all` includes non-exported functions, bindings, and methods.
    - `-o <path>`, `--out <path>` writes the Markdown output to `<path>`; when omitted, output is written to stdout.
    - `--` — end of options; treat remaining args as file paths (even if they begin with `-`).
  - Manpage mode: `silk doc --man [--package <dir|manifest>] [--std-root <path>] <query> [-o <path>]`:
    - Renders a single roff `man(7)` page to stdout (or to `-o` / `--out` when provided).
    - The manpage kind is derived from documentation tags (`@cli` → section 1, `@misc` → section 7, otherwise section 3 for API pages).

- **C compiler wrapper:**
  - `silk cc <cc args...>`:
    - runs a host C compiler to build programs that embed or link against `libsilk.a`,
    - selects the compiler executable via `SILK_CC` (when set), otherwise falls back to `cc`,
    - automatically adds include and library search paths adjacent to the installed `silk` binary (for example `../include` and `../lib`), plus `-lsilk`,
    - on `linux/x86_64`, also adds `-lstdc++ -lpthread -lm` (vendored Z3 is built as C++),
    - passes through additional arguments verbatim to the underlying compiler (files, flags, `-o`, `-I`, `-L`, etc.); use `silk help cc` for wrapper usage.


## Environment

- `SILK_STD_ROOT` — path to the stdlib root directory used to resolve
  `import std::...;` declarations when `--std`/`--std-root` is not provided. When neither
  is set (and `--nostd` is not set), `silk` searches for:
  - a `std/` directory in the current working directory (development default), otherwise
  - `../share/silk/std` relative to the `silk` executable (installed default).
- `SILK_WORK_DIR` — base directory for compiler-generated scratch/debug artifacts (defaults to `.silk`).
  - For example, Formal Silk Z3 dumps are written under `$SILK_WORK_DIR/z3` and `silk man` may write temporary roff output under `$SILK_WORK_DIR/man`.
- `SILK_STD_LIB` — path to a target-specific stdlib static archive (`libsilk_std.a`).
  When present, supported executable builds treat auto-loaded `std::...` modules as
  external and resolve their exported functions from this archive.
- `SILK_PACKAGE_PATH` — PATH-like list of package root directories used to resolve
  bare-specifier package imports (non-`std::`) in file-list workflows (when `--package`
  is not used). Entries are separated by `:` (POSIX).
  - A package like `my_api::core` maps to the candidate manifest
    `<root>/my_api/core/silk.toml` (where `::` maps to `/`).
  - When `SILK_PACKAGE_PATH` is not set, `silk` also checks `./packages` when it exists
    (development convenience).
- `SILK_Z3_LIB` — path to a dynamic Z3 library used by the Formal Silk verifier. When `--z3-lib` is not provided, the verifier will use this value when set.
- `SILK_CC` — the host C compiler executable used by `silk cc` (defaults to `cc` when unset).

## See Also

- `silk-build` (1), `silk-check` (1), `silk-test` (1), `silk-doc` (1), `silk-man` (1), `silk-cc` (1), `silk-lsp` (1)
- `silk` (7)
- `libsilk` (7)

==============================================================================
DOCS: `silk` (7) — Silk Toolchain Overview (man/silk.7)
URL: /silk/docs/?p=man/silk.7
==============================================================================

# `silk` (7) — Silk Toolchain Overview

> NOTE: This is the Markdown source for the eventual man 7 page for Silk. The roff-formatted manpage should be generated from this content.

## Name

`silk` — overview of the Silk language toolchain, documentation, and conventions.

## Description

Silk is a native compiler toolchain with:

- a CLI entrypoint (`silk` (1)),
- an embedding API (`libsilk` (7) and the `silk_*` functions documented in section 3),



## Current Backend Subset

The compiler currently supports full parsing and type checking, but code
generation is implemented only for a subset of the language. When a program
type-checks but uses a construct outside this subset, builds fail with
`E4001` diagnostics that point at the rejected construct and name its kind.

The supported subset is documented in:

- `silk` (1) (see the `build` command and its notes),

## Source Layout

- Silk source files use the `.slk` extension.
- The default stdlib implementation is a directory tree rooted at `std/` and is imported via `import std::...;`.

## Standard Library

The `std::` package namespace is the primary stdlib surface. The compiler can auto-load `std::...` modules from a configured stdlib root, and hosted builds may link a prebuilt stdlib archive.

See:


## Formal Silk

Formal Silk verification is an optional part of the toolchain. The verifier uses Z3 and can be configured via CLI flags or environment variables.

See:


## See Also

- `silk` (1)
- `silk-build` (1), `silk-check` (1), `silk-test` (1), `silk-doc` (1), `silk-man` (1), `silk-cc` (1)
- `silk_compiler` (3), `silk_error` (3), `silk_bytes` (3), `silk_abi_get_version` (3)
- `libsilk` (7)

==============================================================================
DOCS: `slc` (1) — Alias of `silk build` (man/slc.1)
URL: /silk/docs/?p=man/slc.1
==============================================================================

# `slc` (1) — Alias of `silk build`

> NOTE: This is the Markdown source for the eventual man 1 page for `slc`. The roff-formatted manpage should be generated from this content.

## Name

`slc` — convenience entrypoint for `silk build`.

## Synopsis

- `slc [options] <file> [<file> ...] -o <output>`
- `slc [options] --package <dir|manifest> [--build-script] [--package-target <name> ...]`

## Description

`slc` is an argv0-based alias of `silk build`. It behaves the same as running:

```sh
silk build <args...>
```

See `silk-build` (1) for full documentation of options, arguments, and behavior.

## See Also

- `silk` (1), `silk-build` (1)

==============================================================================
DOCS: `slcc` (1) — Alias of `silk cc` (man/slcc.1)
URL: /silk/docs/?p=man/slcc.1
==============================================================================

# `slcc` (1) — Alias of `silk cc`

> NOTE: This is the Markdown source for the eventual man 1 page for `slcc`. The roff-formatted manpage should be generated from this content.

## Name

`slcc` — convenience entrypoint for `silk cc`.

## Synopsis

- `slcc <cc args...>`

## Description

`slcc` is an argv0-based alias of `silk cc`. It behaves the same as running:

```sh
silk cc <cc args...>
```

See `silk-cc` (1) for details, including the default `-I`/`-L`/`-lsilk` flags.

## See Also

- `silk` (1), `silk-cc` (1)

==============================================================================
DOCS: Silk Specification (2026) (spec/2026)
URL: /silk/spec/2026/
==============================================================================

<!--
This file is generated. Do not edit it by hand.
-->

# Silk Specification (2026)

This is the single-file edition of the Silk language specification for 2026.

---
## Language Cheat Sheet

This document summarizes the key syntax and concepts from the Silk language in a condensed form. It is meant as a quick reference; detailed semantics live in the other `this specification` files.

### Types (Surface Forms)

- Booleans: `bool` — `true`, `false`.
- Integers: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `int`.
- Floats: `f32`, `f64`.
- Char: `char`.
- String: `string`.
- Time: `Instant`, `Duration`.
- Optional: `T?` (sugar for `Option(T)`).
- References: `&T`.
- Arrays / slices: `T[]`, `T[N]`.
- Maps / dictionaries: `std::map::{HashMap, TreeMap}` (standard library).
- Function types: `fn(params) -> R` (discipline modifiers apply to function
  declarations; function types are unmodified in Silk).
- Function expressions (non-capturing, inferred `pure`):
  - expression body: `fn (x: int, y: int) -> x + y`
  - block body: `fn (x: int, y: int) -> int { return x + y; }`
  - capturing closures are supported as a subset; see `Types`.
- Structs / enums / interfaces:
  - `struct Name { ... }`, `struct Name extends Base { ... }`
  - `enum Name { ... }`
  - `interface Name { ... }`, `interface Name extends Base { ... }`

### Literals

- Integers: `0`, `42`, with base/suffixes as per the spec.
- Floats: `3.14`, `1.0e-9`.
- Booleans: `true`, `false`.
- Chars: `'A'`, escape sequences.
- Strings:
  - single-line: `"hello"`,
  - multi-line: multi-line quoted forms.
- Durations: numeric + unit, e.g. `10ms`, `2s`, `5min`.
- Aggregates:
  - arrays: `[1, 2, 3]`,
  - structs: `Point { x: 1, y: 2 }`.

### Operators

- Arithmetic: `+`, `-`, `*`, `/`, `%`.
- Bitwise: `&`, `|`, `^`, `~`, `<<`, `>>`.
- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`.
- Logical: `!`, `&&`, `||`.
- Assignment: `=`, `+=`, `-=`, `*=`, `/=`.
- Increment/decrement: `++`, `--` (statement-like `void`).
- Optional / nullability:
  - optional chaining: `?.`,
  - coalescing: `??`.
- Member/scope: `.`, `::`.
- Ranges: `..`, `..=`, `...`.
- Other punctuation: `,`, `;`, `:`, `->`, `=>`.

Operator precedence and associativity follow the rules in `Operators`.

### Flow Control

- `if cond { ... } else { ... }` (statement form)
- `let v = if cond { a } else { b };` (`if` expression)
- `loop { ... }` (infinite loop; exits via `break`/`return`).
- `while (cond) { ... }`
- `for pattern in iterable { ... }` (ranges, builtin arrays/slices).
- `for (init; cond; step) { ... }` (C-style loop header).
- `async loop { ... }` / `task loop { ... }` (loop forms in async context).
- `match value { ... }` — pattern matching.
- `return expr;`
- `assert expr;` or `assert(expr, "message");`
- `break;`
- `continue;`
- Blocks: `{ stmt* }`.
- Expression statements: `expr;` (where allowed).

See `the relevant chapters of this specification` for details.

Executable entrypoint (initial rule):

- A minimal executable module defines exactly one top-level function:

  ```silk
  fn main() -> int {
    return 0;
  }
  ```

- This `main` function takes no parameters and returns `int`. The front-end
  enforces this shape for executable builds before code generation.

### Optionals & Mutability

- Declare optionals: `let x: T? = None;` or `let x: Option(T) = None;`.
- Create values: `None`, `Some(value)`.
- Use:
  - `user.profile?.email` — optional chaining.
  - `email ?? "default@example.com"` — coalescing.

Mutability:

- Parameters and references are immutable by default.
- Grant mutation via `mut`:
  - in function definition: `fn reset(mut r: &Runner) { ... }`,
  - at call site (syntax per spec).

### Structs, Impl Blocks, Interfaces

- Structs: `struct Packet { seq: u32, size: u16, flag: u8 }`
  - pure data, well-defined layout.
- Impl blocks: `impl Packet { fn size_bits(self: &Packet) -> u32 { ... } }`
- Interfaces:

  ```silk
  interface Element {
    fn onclick(event: &Event) -> void;
  }

  impl Button as Element {
    fn onclick(self: &Button, event: &Event) -> void { ... }
  }
  ```

See `Structs, Impl Blocks, and Memory Layout` and `Interfaces` for details.

### Regions & Buffers

- Regions (fixed-size allocation context):
  - declare: `const region arena: u8[1024];`
  - use: `with arena { let p: &Packet = new Packet{ ... }; }`
  - anonymous: `with 1024 { let p: &Packet = new Packet{ ... }; }`
- Buffers:
  - intrinsic `Buffer(T)` with `(ptr, capacity)`,
  - unsafe primitive underpinning higher-level collections.
- Allocation:
  - `new` uses the active region inside `with` (see `Regions`).

### Concurrency

- Function modifiers:
  - `fn` — normal.
  - `async fn` — `await`-able; calling yields `Promise(T)`.
  - `task fn` — runs in parallel on a worker thread; calling yields `Task(T)`.
  - `async task fn` — `async` + `task`; calling yields `Promise(Task(T))`.
- Structured block:

	  ```silk
	  async fn get_dashboard_data() -> Dashboard {
	    // Note: the scheduler-backed `async { ... }` semantics are still design work,
	    // but the compiler implements `Task(T)`/`Promise(T)` handles, `yield`, and `await`.
	    let mut user: User;
	    let mut orders: Order[];

	    async {
	      let user_promise = fetch_user_profile(123);
	      let orders_promise = fetch_recent_orders(123);
	      user = await user_promise;
	      orders = await orders_promise;
	    }

	    return Dashboard(user, orders);
	  }
	  ```

  To receive task values, use `yield` inside a task context (`task { ... }` or `task fn`):

  ```silk
  task fn worker () -> int { return 42; }

  async fn main () -> int {
    let h = worker();
    task {
      let value: int = yield h;
      return value;
    }
  }
  ```

See `Concurrency` for deeper semantics.

### Formal Silk

- `#const` — formal Silk declarations used inside specifications (not available at runtime).
- `#require` — preconditions.
- `#assure` — postconditions.
- `#assert` — block-local proof obligations.
- `#invariant` — invariants.
- `#variant` — termination measures.
- `#monovariant` — monotonic measures.
- `theory` / `#theory` — reusable proof obligations.

`#require` / `#assure` appear before functions; `#invariant` / `#variant` / `#monovariant` appear before loops; `#const` and `#assert` appear inside blocks. See `Formal Silk`.

### External Declarations & ABI (Quick View)

- Declare external bindings:

  ```silk
  ext foo = fn (string) -> void;
  ext bar = u32;
  ```

- Strings:
  - Silk `string` is internally `{ ptr, len }`,
  - C side uses `SilkString { char *ptr; int64_t len; }` for embedding,
  - `ext` calls to typical C APIs may pass `const char *` derived from `string` where appropriate.

See `External Declarations (`ext`)` and `C99 ABI and `libsilk.a`` for full details.

## Silk Syntax Tour (Soup to Nuts)

This document is an example-driven tour of Silk’s **surface syntax**, from a
single-file “hello world” through modules/packages, declarations, statements,
expressions, and the Formal Silk verification directives.

This guide complements (not replaces):

- `Formal Grammar Spec` (the exact grammar the parser accepts),
- the concept documents under `this specification` (semantics and checker rules),
- `the implementation status` (what works end-to-end today),
- and `Compiler Diagnostics` (error codes for unsupported forms).

### 0. Minimal Executable Module

The smallest executable is a module with a `main` function:

```silk
fn main () -> int {
  return 0;
}
```

Notes:

- Most statements end with `;`.
- Blocks are `{ stmt* }`.
- The entrypoint for an executable build is `main` returning `int` (see
  ``silk` CLI` for the CLI rules and supported targets).

### 1. Lexical Basics

#### Whitespace and comments

Whitespace (spaces, tabs, newlines) is generally allowed between tokens.

Comments:

```silk
// Line comment
/* Block comment (non-nesting) */
```

Doc comments (tooling-only; see `Silkdoc (Documentation Comments)`):

```silk
/// Line doc comment
/**
 * Block doc comment
 *
 * @example silk
 * fn main () -> int { return 0; }
 */
fn main () -> int {
  return 0;
}
```

#### Identifiers and qualified names

Names are often qualified with `::`:

```silk
package my_app::core;

import std::strings;

fn main () -> int {
  let s: string = std::strings::trim(" hi ");
  return 0;
}
```

#### Formal Silk directive tokens (`#...`)

Formal Silk directives like `#require` and `#invariant` are **not comments**.
They are real tokens and are parsed as part of the language (see
`Formal Silk`).

```silk
#require x >= 0;
#assure result == x + 1;
fn inc (x: int) -> int {
  return x + 1;
}
```

### 2. Source File Structure: `package`/`module`, `import`, then declarations

Top-level ordering is enforced (see `Packages, Imports, and Exports`):

1. Optional `package ...;` **or** `module ...;`
2. Zero or more `import ...;` declarations as a contiguous block
3. All other top-level declarations (`fn`, `let`, `struct`, `enum`, `impl`, …)

#### `package`

```silk
// app/main.slk
package app;

fn main () -> int {
  return 0;
}
```

#### `module` (compile-time-only module values)

```silk
// crypto/sha256.slk
module crypto::sha256;
```

Modules can declare interface conformance (design surface is implemented):

```silk
// drivers/uart.slk
module drivers::uart as Device;
```

### 3. Imports and Exports

See `Packages, Imports, and Exports` for the full import/export model.

#### Package imports

```silk
package app;

import std::strings;

fn main () -> int {
  let s: string = trim(" hi "); // may be visible unqualified in the 
  let t: string = std::strings::trim(" hi ");
  return 0;
}
```

#### File imports (`from "..."`)

Named import:

```silk
// main.slk
import { answer as the_answer } from "./util.slk";

fn main () -> int {
  return the_answer;
}
```

Default import (binds a default export if present, otherwise a namespace):

```silk
// module.slk
export default fn () -> int {
  return 3;
}
```

```silk
// main.slk
import foo from "./module.slk";

fn main () -> int {
  return foo();
}
```

#### Named exports and re-exports

Export a declaration directly:

```silk
// util.slk
export let answer: int = 42;

export fn add1 (x: int) -> int {
  return x + 1;
}
```

Re-export an in-scope name:

```silk
// api.slk
import { answer } from "./util.slk";
export { answer as the_answer };
```

### 4. Top-Level Declarations (Overview + Examples)

This section shows the core top-level declaration forms:

- bindings: `const`, `let`, `var`
- functions: `fn` (plus `pure`/`async`/`task`)
- type aliases: `type`
- types: `struct`, `enum`, `interface`, `impl`, `error`
- external declarations: `ext`
- tests: `test`
- Formal Silk: `theory` (and `#...` directives)

#### 4.1 Bindings: `const`, `let`, `let mut`, `var`

Example ( requires initializers; see `E2015`):

```silk
fn main () -> int {
  const answer: int = 42;
  let x: int = answer;
  let mut y: int = 0;
  var z: int = 1; // `var` is an alias for `let mut` ()

  y = y + 1;
  z += 2;
  return x + y + z;
}
```

Notes:

- `const` initializers must be compile-time evaluable in Silk
  (see `E2041`).
- Only `let mut`/`var` bindings are assignable lvalues (see
  `Mutability` and `Operators`).
- Destructuring `let` bindings are supported for struct values:

  ```silk
  struct User { id: u64, name: string }
  let (id, name) = User{ id: 123, name: "alice" };

  struct Record { id: u64, data: string }
  let { data as d, id as i } = Record{ id: 456, data: "other" };
  ```

  Array destructuring is also supported:

  ```silk
  let records: Record[] = [{ id: 123, data: "a" }, { id: 456, data: "b" }];
  let [a, b] = records;
  ```

#### 4.2 Functions: `fn` (plus `pure`, `async`, `task`)

Basic function declaration:

```silk
fn add (x: int, y: int) -> int {
  return x + y;
}
```

`pure fn` (restricted subset; see `Function Disciplines (`pure`, `task`, `async`)`):

```silk
pure fn inc (x: int) -> int {
  return x + 1;
}
```

`async fn` / `task fn` / `async task fn` (handles; see `Concurrency`):

```silk
task fn worker () -> int {
  return 7;
}

async fn main () -> int {
  task {
    let t = worker(); // Task(int)
    let value: int = yield t;
    return value;
  }
}
```

##### Parameters: `mut`, defaults, and varargs

Mutable reference parameters require `mut` both in the signature and at the
call site (see `Mutability`):

```silk
struct Pair { a: int, b: int }

fn bump_a (mut p: &Pair) -> void {
  p.a += 1;
}

fn main () -> int {
  let mut p: Pair = Pair{ a: 1, b: 2 };
  bump_a(mut p);
  return p.a;
}
```

Default arguments ( restricts default expressions to a constant/literal subset):

```silk
fn add2 (x: int, y: int = 2) -> int {
  return x + y;
}
```

Varargs (final parameter prefixed by `...`; see `Varargs (Variable Arguments)`):

```silk
fn log (fmt: string, ...args: std::fmt::Arg) -> void {
  std::io::println(fmt, args);
}
```

##### Generic function parameter split (`;`) (Design, parsed but rejected)

Generic functions use `;` to separate compile-time parameters from value parameters:

```silk
// Design (currently rejected with `E2016`).
fn get_first(T, N: int; xs: &T[N]) -> T {
  return xs[0];
}
```

#### 4.3 Function expressions (lambdas)

Example (non-capturing expression body):

```silk
fn main () -> int {
  let add = fn (x: int, y: int) -> x + y;
  return add(1, 2);
}
```

Example (block body with explicit return type):

```silk
fn main () -> int {
  let add = fn (x: int, y: int) -> int {
    return x + y;
  };
  return add(1, 2);
}
```

Capturing closures are supported as a restricted subset; see `Types`
and `Memory Model (Stack, Heap, and Moves)`.

#### 4.4 Type aliases: `type`

Basic alias:

```silk
type I = int;
```

Optional kind tags (validated by the checker; see `Types`):

```silk
type struct UserId = int;
type fn IntAdder = fn(int, int) -> int;
type pure fn PureIntAdder = fn(int, int) -> int;
```

#### 4.5 Structs: `struct` and `impl`

Struct declarations (fields use `name: Type`, optional default with `=`):

```silk
struct Point {
  x: int = 0,
  y: int = 0,
}
```

Struct literals:

```silk
fn main () -> int {
  let p1: Point = Point{ x: 1, y: 2 };
  let x = p1.x;

  // Shorthand field init (`x` means `x: x`):
  let y: int = 3;
  let p2: Point = Point{ x, y };

  return x + p2.y;
}
```

Inferred struct literals require an expected struct type context:

```silk
fn main () -> int {
  let p: Point = { x: 1, y: 2 };
  return p.x + p.y;
}
```

Heap allocation (`new`) produces a `&Struct` reference in Silk:

```silk
struct Boxed { value: int }

fn main () -> int {
  let b: &Boxed = new Boxed{ value: 7 };
  return b.value;
}
```

Attach methods with `impl` (see `Structs, Impl Blocks, and Memory Layout`):

```silk
impl Point {
  public fn sum (self: &Point) -> int {
    return self.x + self.y;
  }
}

fn main () -> int {
  let p: Point = Point{ x: 1, y: 2 };
  return p.sum();
}
```

Single inheritance (current surface is implemented; see `Structs, Impl Blocks, and Memory Layout`):

```silk
// Design shape (field/layout rules and  limits are documented).
struct Base { x: int = 0 }
struct Derived extends Base { y: int = 0 }
```

#### 4.6 Enums: `enum` + `match` expression

```silk
enum Color {
  Red,
  Rgb(u8, u8, u8),
}

fn to_int (c: Color) -> int {
  return match c {
    Color::Red => 0,
    Color::Rgb(r, g, b) => (r as int) + (g as int) + (b as int),
  };
}
```

See ``enum` Types` and ``match` Expression`.

#### 4.7 Interfaces and `impl ... as ...`

```silk
interface Counter {
  fn inc() -> void;
  fn get() -> int;
}

struct Cell { value: int = 0 }

impl Cell as Counter {
  fn inc (mut self: &Cell) -> void {
    self.value += 1;
  }

  fn get (self: &Cell) -> int {
    return self.value;
  }
}
```

See `Interfaces`.

#### 4.8 Typed errors: `error`, `panic`, `T | ErrorType...`, `match` statement, `?`

Error type declaration:

```silk
error OutOfBounds {
  index: int,
  len: int
}
```

Error-producing signatures use `|`:

```silk
fn get_at (xs: &u8[], index: int) -> u8 | OutOfBounds {
  if index < 0 || index >= std::length(xs) {
    panic OutOfBounds { index: index, len: std::length(xs) };
  }
  return xs[index];
}
```

Handling typed errors uses the `match` **statement** form:

```silk
fn main () -> int {
  match (get_at([1, 2, 3], 10)) {
    value => {
      return value as int;
    },
    err: OutOfBounds => {
      std::abort();
    }
  }
}
```

Propagating errors from calls uses postfix `?`:

```silk
// Example when `main` declares a compatible error set.
fn main () -> int | OutOfBounds {
  let x: u8 = get_at([1, 2, 3], 0)?;
  return x as int;
}
```

See `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`.

#### 4.9 External declarations: `ext`

External function binding (symbol name optional; see `External Declarations (`ext`)`):

```silk
export ext puts = fn(string) -> int;
export ext c_abort "abort" = fn() -> void;
export ext errno "errno" = int;
```

Note: C variadics (`printf`-style `...`) via `ext` are not implemented yet; see
`Varargs (Variable Arguments)` and `External Declarations (`ext`)`.

See also: `C99 ABI and `libsilk.a`` (C ABI) and `include/silk.h`.

#### 4.10 Tests: `test`

```silk
test "addition works" {
  if (1 + 2) != 3 {
    std::abort();
  }
}
```

See `Testing` and run with `silk test`.

#### 4.11 Formal Silk theories: `theory`

Top-level theory (exportable/importable):

```silk
export theory nonzero (x: int) {
  #require x != 0;
}
```

Apply a theory inside a function:

```silk
import { nonzero } from "./theories.slk";

fn main () -> int {
  let x: int = 1;
  #theory nonzero(x);
  return 0;
}
```

Inline (block-local) theories use the same `#theory` token and are
disambiguated from theory use by `{ ... }` (inline declaration) vs `;` (use):

```silk
fn main (x: int, y: int) -> int {
  #theory local_sum_nonzero (x: int, y: int) {
    #const z = x + y;
    #assure z != 0;
  }

  #theory local_sum_nonzero(x, y);
  return 0;
}
```

See `Formal Silk`.

### 5. Types (Surface Forms)

See `Types` for full details and implementation limits.

#### Primitive types

```text
bool, i8/u8, i16/u16, i32/u32, i64/u64, int, f32/f64, char, string, void, Instant, Duration
```

#### Optional types

```silk
fn main () -> int {
  let a: int? = None;
  let b: int? = Some(7);
  let c: int = b ?? 0;
  return c;
}
```

Nested optionals use `??` in type position (`T??` means “optional of optional”):

```silk
fn main () -> int {
  let x: int?? = Some(Some(1));
  let y: int? = x ?? None;
  return (y ?? 0);
}
```

Optional `match` expressions are the explicit form of optional consumption:

```silk
fn main () -> int {
  let x: int? = Some(7);
  let y: int = match x {
    None => 0,
    Some(v) => v,
  };
  return y;
}
```

#### References

```silk
fn sum (p: &Point) -> int {
  return p.x + p.y;
}
```

#### Arrays and slices

```silk
fn main () -> int {
  let xs: int[] = [1, 2, 3];
  return xs[0];
}
```

Fixed-length arrays use `T[N]`:

```silk
fn main () -> int {
  let xs: int[3] = [1, 2, 3];
  return xs[2];
}
```

#### Function types

```silk
type IntBinOp = fn(int, int) -> int;

fn main () -> int {
  let add: IntBinOp = fn (x: int, y: int) -> x + y;
  return add(1, 2);
}
```

#### Applied types and generics

Generic parameter lists on `struct`/`interface`/`impl` are implemented:

```silk
struct Box(T) { value: T }

fn main () -> int {
  let b: Box(int) = { value: 1 };
  return b.value;
}
```

See `Generics (Monomorphized)` for  limits (notably `E2016` for
const parameters/arguments and generic functions).

### 6. Statements (Inside Blocks)

The statement grammar is summarized in `Formal Grammar Spec` and detailed
in `the relevant chapters of this specification`.

#### `if` / `else`

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  } else {
    return 1;
  }
}
```

#### `loop`, `while`, `for`

```silk
fn main () -> int {
  let mut i: int = 0;
  while i < 3 {
    i += 1;
  }
  return i;
}
```

`for` over a range form (special-cased surface; see ``for` Loop`):

```silk
fn main () -> int {
  let mut sum: int = 0;
  for i in 0 .. 5 {
    sum += i;
  }
  return sum;
}
```

C-style `for` header:

```silk
fn main () -> int {
  let mut sum: int = 0;
  for (let mut i: int = 0; i < 5; i += 1) {
    sum += i;
  }
  return sum;
}
```

#### `break`, `continue`, `return`

```silk
fn main () -> int {
  let mut i: int = 0;
  loop {
    i += 1;
    if i < 3 {
      continue;
    }
    break;
  }
  return i;
}
```

#### `assert` and `panic`

```silk
fn main () -> int {
  assert 1 + 2 == 3;
  assert(2 + 2 == 4, "math is broken");
  return 0;
}
```

`panic` is used for typed errors (see `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`):

```silk
panic OutOfBounds { index: 1, len: 0 };
```

#### `match` statement (typed errors)

See `Typed Errors (`error`, `panic`, and `T | ErrorType...`)` for the Terminal Arm Rule and the supported
pattern forms.

#### `async { ... }` and `task { ... }`

Structured blocks (implemented as lexical blocks in Silk; see
`Concurrency`):

```silk
async fn main () -> int {
  async {
    // async region
  }
  task {
    // task region
  }
  return 0;
}
```

#### Concurrency operators: `await`, `await *`, `yield`, `yield *`

`await` unwraps `Promise(T)` values inside `async fn`:

```silk
async fn add2 (x: int) -> int {
  return x + 2;
}

async fn main () -> int {
  let p = add2(1); // Promise(int)
  let v: int = await p;
  return v;
}
```

`await *` awaits a collection of promises and yields a collected `T[]`:

```silk
async fn add1 (x: int) -> int {
  return x + 1;
}

async fn main () -> int {
  let values: int[] = await * [add1(1), add1(2), add1(3)];
  return values[0] + values[1] + values[2];
}
```

`yield` / `yield *` interact with `Task(T)` values (used inside `task` regions in
the ):

```silk
task fn producer (n: int) -> int {
  var i: int = 0;
  while i < n {
    yield i;
    i += 1;
  }
  return n;
}

async fn main () -> int {
  task {
    let t = producer(2); // Task(int)
    let values: int[] = yield * t;
    return values[0] + values[1] + values[2];
  }
}
```

### 7. Expressions (Precedence + Demonstrations)

Silk expressions follow a conventional precedence hierarchy. For the exact
productions, see `Formal Grammar Spec`.

#### Literals and other primary expressions

See the `the relevant chapters of this specification` concept documents for precise rules.

```silk
fn main () -> int {
  // Booleans.
  let b: bool = true;

  // Integers and floats.
  let i: int = 42;
  let u: u8 = 0xFF;
  let f: f64 = 3.14;

  // Characters and strings.
  let ch: char = 'A';
  let s1: string = "hello";
  let s2: string = `raw \n no escapes`;

  // Durations.
  let d: Duration = 10ms;

  // Optionals.
  let opt: int? = Some(i);
  let x: int = opt ?? 0;

  // Arrays.
  let xs: int[] = [1, 2, 3];

  assert b;
  assert x == 42;
  assert xs[0] == 1;
  assert u == 0xFF;
  assert s1 == "hello";
  assert s2 == `raw \n no escapes`;
  assert ch == 'A';
  assert (f as int) == 3;
  assert (d as int) == (d as int);

  // `d` exists to demonstrate duration literal syntax. See `Duration Literals`.
  return 0;
}
```

#### Postfix forms: calls, fields, indexing, casts, `?`, `++/--`

```silk
struct Point { x: int, y: int }

fn main () -> int {
  let xs: int[] = [10, 20, 30];
  let a: int = xs[0];
  let b: int = (a + 1) as int;
  let c: int = Point{ x: 1, y: 2 }.x;
  return b + c;
}
```

#### `as` and `as raw`

`as` performs explicit numeric/shape casts and `as raw` performs raw bit casts
for scalar types (see `Operators`).

```silk
fn main () -> int {
  let bits: u64 = (1.0 as f32) as raw u64;
  let f: f32 = bits as raw f32;
  return f as int;
}
```

#### Unary forms: `!`, `~`, `-`, `new`, `await`, `yield`, `mut`, `++/--`

```silk
fn main () -> int {
  let mut x: int = 0;
  ++x;
  x++;
  if !(x == 2) {
    return 1;
  }
  return 0;
}
```

`mut <expr>` is permitted only where a mutable borrow is required (most
commonly, in call arguments and method receivers):

```silk
struct Pair { a: int, b: int }

fn bump (mut p: &Pair) -> void {
  p.a += 1;
}

fn main () -> int {
  let mut p: Pair = Pair{ a: 0, b: 0 };
  bump(mut p);
  return p.a;
}
```

#### Arithmetic, bitwise, comparisons, and boolean operators

```silk
fn main () -> int {
  let a: int = 1 + 2 * 3;
  let b: int = (a << 1) | 1;
  if (b >= 0) && (b != 0) {
    return b;
  }
  return 0;
}
```

#### Optional operators: `?.` and `??`

```silk
struct User { email: string }

fn main () -> int {
  let user: User? = Some(User{ email: "a@b.c" });
  let email: string = user?.email ?? "unknown";
  if email == "a@b.c" {
    return 0;
  }
  return 1;
}
```

#### Typed error propagation: postfix `?` on calls

```silk
fn main () -> int | OutOfBounds {
  let x: u8 = get_at([1, 2, 3], 0)?;
  return x as int;
}
```

### 8. Formal Silk (Verification) Syntax

Formal Silk is Silk’s compile-time verification surface (Z3-backed). It uses
directive tokens that attach to functions and loops:

- function contracts: `#require`, `#assure`, `#theory`
- loop contracts: `#invariant`, `#variant`, `#monovariant`
- formal Silk declarations: `#const`
- block-local proof obligations: `#assert`
- reusable proof bundles: `theory` / `#theory`

See `Formal Silk` for the exact verifier model and
current restrictions.

#### Contracts on functions

```silk
#require x >= 0;
#assure result == x + 1;
fn inc (x: int) -> int {
  return x + 1;
}
```

#### Loop invariants, variants, and monovariants

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  #monovariant i;
  while i < limit {
    i += 1;
  }
  return 0;
}
```

#### Theories (`theory` / `#theory`)

```silk
export theory add_commutes (x: int, y: int) {
  #assure (x + y) == (y + x);
}

#theory add_commutes(x, y);
fn add (x: int, y: int) -> int {
  return x + y;
}
```

### 9. Next References

If you want more detail on a specific construct, jump to:

- Syntax: `Formal Grammar Spec`
- Types: `Types`, `Generics (Monomorphized)`
- Operators: `Operators`
- Flow control: `Flow Control Overview` and `the relevant chapters of this specification`
- Modules/imports/exports: `Packages, Imports, and Exports`
- Optionals: `Optional`
- Typed errors: `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`
- Concurrency: `Concurrency`
- Formal verification: `Formal Silk`

## Formal Grammar Spec

This document contains the formal grammar and lexical specification for Silk as used by the compiler implementation.

### Lexical Structure (Overview)

The lexer operates over:

- Whitespace and comments (trivia):
  - spaces, tabs, newlines;
  - line comments starting with `//` and continuing to the end of the line;
    doc line comments start with `///` and follow the same lexical rules;
  - block comments starting with `/*` and ending with the next `*/` (non‑nesting);
    doc block comments start with `/**` and also end at the next `*/`.

    Both doc-comment forms are still **trivia** for the parser (they do not
    affect the syntax tree), but tooling may preserve and parse their text for
    documentation generation as specified in `Silkdoc (Documentation Comments)`.
- Identifiers:
  - sequences of Unicode letters, digits, and `_`, with language-specific rules for leading characters.
  - Keywords:
  - packages and imports: `package`, `module`, `import`,
    file imports: `from`,
  - control flow: `if`, `else`, `loop`, `while`, `for`, `in`, `match`, `return`, `panic`, `break`, `continue`, `assert`, `await`, `yield`,
  - declarations and mutability: `export`, `public`, `private`, `default`, `const`, `let`, `var`, `mut`, `fn`, `test`, `theory`, `type`,
  - types and declarations: `struct`, `enum`, `error`, `interface`, `impl`, `as`, `raw`, `extends`, `pure`, `task`, `async`,
  - memory and regions: `move`, `region`, `with`, `new`,
  - other operators: `sizeof`, `alignof`, `offsetof`, `typename`,
  - optionals and literals: `None`/`none`, `Some`, `true`, `false`, `null`,
  - verification and external declarations: `ext`, and Formal Silk directives `#const`, `#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`, `#theory`,
  - other keywords as listed in the spec.

  Keywords are lexed as distinct tokens, but in name positions (for example
  qualified-name segments like `std::test`, function/method names, and member
  access like `value.test`) the parser accepts keywords anywhere an
  identifier is expected.

  The `#require` / `#assure` / `#assert` / `#invariant` / `#variant` / `#monovariant` / `#const` / `#theory` forms are
  **not** comments; they are first-class lexical tokens that participate in the
  normal expression grammar and are handled by the verifier. A directive token
  begins with `#` followed by optional horizontal whitespace and the directive
  name (so `#require` and `#  require` are equivalent spellings). When these
  sequences appear inside a `//` line comment or anywhere inside a `/* ... */`
  block comment, the surrounding comment is treated as trivia and the directive
  spellings are ignored by the lexer.
- Literals:
  - numeric, duration, boolean, character, string, regexp, aggregate (see `*literals-*.md`).
  - String literals have two surface forms:
    - `"..."` (escape sequences),
    - `` `...` `` (raw/no-escape).
  - Regular expression literals have a JavaScript-style surface form:
    - `/pattern/flags` (see `Regular Expression Literals`).
    - Disambiguation is context-sensitive (like JavaScript): the parser only
      recognizes a regex literal in expression-start positions where a
      `Primary` expression may begin; otherwise `/` is parsed as the division
      operator.
    - Because `//` starts a line comment, an empty regex literal `//` is not a
      valid token sequence; use `/(?:)/` for an explicit empty pattern.
- Operators and delimiters:
  - as listed in `Operators` (assignment, arithmetic, logical, bitwise, ranges, `?.`, `??`, `::`, `->`, `=>`, etc.).

The lexer must implement longest-token rules for ambiguous prefixes (e.g. `...` vs `..=` vs `..`).

#### Lexical Grammar for Whitespace and Comments

For the purposes of the grammar, whitespace and comments are treated as **trivia**
that may appear between any two tokens and are ignored by the parser:

- `Trivia       ::= (Whitespace | LineComment | BlockComment)+`
- `Whitespace   ::= ' ' | '\t' | '\r' | '\n'`
- `LineComment  ::= '//' LineCommentChar* Newline?`
- `LineCommentChar ::= any character except '\n'`
- `Newline      ::= '\n'`
- `BlockComment ::= '/*' BlockCommentChar* '*/'`
- `BlockCommentChar ::= any character except the end of input`

Block comments are **not nesting**: a `/*` sequence inside an existing
`BlockComment` has no special meaning and is treated as part of the comment
text until the first following `*/`. Doc-style comments such as `/** ... */`
are just syntactic sugar for `BlockComment` at the lexical level.

### High-Level Grammar Skeleton

At a high level, the language can be structured as:

- Compilation unit:

  - `Module ::= (PackageDecl | ModuleDecl)? ImportDecl* TopLevelDecl*`

- Top-level declarations:

  - `TopLevelDecl ::= PackageDecl | ModuleDecl | ImportDecl | InlineModuleDecl | UsingDecl | ReExportDecl | DefaultExportDecl | ExportableDecl | TestDecl`
  - `ExportableDecl ::= FnDecl | LetDecl | TypeDecl | StructDecl | EnumDecl | InterfaceDecl | ImplDecl | ExtDecl | ...`

- Packages and imports:

  The surface syntax for packages, imports, and exports is specified in detail in
  `Packages, Imports, and Exports`. The grammar in this file mirrors
  the currently implemented subset:

  - `PackageDecl ::= 'package' PackagePath ';'`
  - `ModuleDecl ::= 'module' PackagePath ModuleAsOpt ';'`
  - `InlineModuleDecl ::= ExportModifier 'module' NameToken '{' InlineModuleItem* '}'`
  - `InlineModuleItem ::= InlineModuleDecl | UsingDecl | ExportableDecl`
  - `NameToken ::= Identifier | Keyword`
  - `PackagePath ::= NameToken ('::' NameToken)*`
  - `ModuleAsOpt ::= ('as' QualifiedName TypeArgListOpt) | ε`

  - `ImportDecl ::= 'import' ImportSpec ';'`
  - `ImportSpec ::= ImportPath | FileImportSpec | FileDefaultImportSpec`
  - `ImportPath ::= ('::')? NameToken ('::' NameToken)*`
  - `ImportFrom ::= StringLiteral | PackagePath`
  - `FileImportSpec ::= '{' ImportBindingListOpt '}' 'from' ImportFrom`
  - `FileDefaultImportSpec ::= NameToken 'from' ImportFrom`
  - `ImportBindingListOpt ::= ImportBindingList | ε`
  - `ImportBindingList ::= ImportBinding (',' ImportBinding)* ','?`
  - `ImportBinding ::= NameToken ('as' NameToken)?`

  - `ReExportDecl ::= 'export' '{' ReExportBindingListOpt '}' ';'`
  - `ReExportBindingListOpt ::= ReExportBindingList | ε`
  - `ReExportBindingList ::= ReExportBinding (',' ReExportBinding)* ','?`
  - `ReExportBinding ::= NameToken ('as' NameToken)?`

  - `DefaultExportDecl ::= 'export' 'default' NameToken ';'`

  - `UsingDecl ::= 'using' Identifier '=' QualifiedName ';' | 'using' QualifiedName UsingAsOpt ';'`
  - `UsingAsOpt ::= ('as' Identifier) | ε`

  - `ExportModifier ::= 'export'?`
  - `FnExportModifier ::= ('export' ('default')?)?`

  For top-level declarations that can be exported, the `ExportModifier`
  appears before the declaration keyword (currently `fn`, `let`, `ext`, `type`,
  `struct`, `enum`, `theory`, `error`, and `interface`):

  - `FnDecl ::= FnSpecs FnExportModifier FnModifierOpt 'fn' FnGenericParamListOpt FnNameOpt FnSignature Block`
  - `FnModifierOpt ::= FnModifier*`
  - `FnModifier ::= 'const' | 'pure' | 'task' | 'async'`
  - `FnGenericParamListOpt ::= GenericParamList | ε`
  - `FnNameOpt ::= NameToken | ε`
  - `FnSpecs ::= (FnPrecondition | FnPostcondition | FnContractTheory)*`
  - `FnPrecondition ::= '#require' Expr ';'`
  - `FnPostcondition ::= '#assure' Expr ';'`
  - `FnContractTheory ::= '#theory' Identifier '(' ArgListOpt ')' ';'`

  Formal Silk theories may be declared either at top level (exportable) or
  inline inside blocks (non-exportable):

  - `TheoryDecl ::= TheorySpecs ExportModifier 'theory' Identifier '(' TheoryParamsOpt ')' '{' TheoryBodyItem* '}'`
  - `TheorySpecs ::= (TheoryPrecondition | TheoryPostcondition)*`
  - `TheoryPrecondition ::= '#require' Expr ';'`
  - `TheoryPostcondition ::= '#assure' Expr ';'`
  - `TheoryParamsOpt ::= TheoryParams | ε`
  - `TheoryParams ::= TheoryParam (',' TheoryParam)* ','?`
  - `TheoryParam ::= Identifier ':' Type`
  - `TheoryBodyItem ::= SpecConstStmt | SpecTheoryStmt | TheoryRequires | TheoryInvariant | TheoryEnsures | TheoryVariant`
  - `TheoryRequires ::= '#require' Expr ';'`
  - `TheoryInvariant ::= '#invariant' Expr ';'`
  - `TheoryEnsures ::= '#assure' Expr ';'`
  - `TheoryVariant ::= '#variant' Expr ';'`

  - `FnSignature ::= '(' FnParamsOpt ')' ResultTypeOpt`
  - `FnParamsOpt ::= FnParams | ε`
  - `FnParams ::= GenericParamSectionOpt ';' ParamListOpt | ParamList`
  - `GenericParamSectionOpt ::= GenericParamSection | ε`
  - `GenericParamSection ::= GenericParam (',' GenericParam)* ','?`
  - `ParamListOpt ::= ParamList | ε`
  - `ParamList ::= Param (',' Param)*`
  - `Param ::= VarArgsOpt MutOpt Identifier TypeAnnotationOpt DefaultArgOpt`
  - `VarArgsOpt ::= '...' | ε`
  - `DefaultArgOpt ::= ('=' Expr) | ε`
  - `ResultTypeOpt ::= ('->' TypeNoPipe TypedErrorTypesOpt)?`
  - `TypedErrorTypesOpt ::= ('|' TypeNoPipe)+ | ε`

  Notes:

  - When a top-level `;` appears inside the function parameter list, it splits
    **compile-time** parameters (type/const parameters) from **run-time** value
    parameters.
  - The compile-time side uses `GenericParam` syntax (`T` and `N: int`) and does
    not permit `mut`.
  - `FnNameOpt` is currently permitted only for default-exported functions
    (`export default fn (...) { ... }`). For non-default functions, the `fn`
    identifier is required.
  - Default export statements (`export default Name;`) always name an existing
    symbol; they do not permit anonymous exports.
  - The run-time side uses ordinary `Param` syntax (`mut x: T` or `x: T`, with
    the type annotation optional in Silk).
  - If there is no `;`, the entire list is treated as run-time parameters.
  - Default arguments are supported in function parameter lists:
    - any parameter may provide a default expression (`x: int = 1`),
    - defaulted parameters must be **trailing** (once a parameter has a
      default, all subsequent parameters must also have defaults) because
      call syntax is positional-only in the current language subset,
    - and in the current implementation, default expressions are restricted to
      a constant/literal expression subset (no name references), so they can be
      inlined at call sites during lowering.
    - a parameter declared as `T?` with a default has two effective behaviors
      in the current implementation subset:
      - if the default expression has type `T`, the parameter has effective
        type `T` (the argument may be omitted at call sites, but the callee
        sees a non‑optional value),
      - if the default expression is `None`/`Null`, the parameter remains `T?`
        (the argument may be omitted, and callers may still pass optional
        values explicitly).

  - Varargs parameters are supported:
    - a varargs parameter is declared by prefixing the final parameter with
      `...` (for example `fn f(x: int, ...rest: int) { ... }`),
    - only one varargs parameter is permitted per function and it must be
      **final**,
    - In Silk, varargs parameters:
      - must have an explicit type annotation,
      - may not be `mut`,
      - and may not have a default expression.

  - The `from` string literal is a *module specifier* (either `"..."` or `` `...` ``):
    - strings starting with `./`, `../`, or an absolute path are treated as
      file specifiers and resolve to a module by file path,
    - strings starting with `std/` are treated as std-root file specifiers and
      resolve to a module by file path under the configured stdlib root,
    - other strings are treated as package specifiers and resolve to a package
      by name (see `Packages, Imports, and Exports`).

  - `BindingDecl ::= ('const' | 'let' MutOpt | 'var') Identifier TypeAnnotationOpt InitializerOpt ';'`
  - `LetDecl ::= ExportModifier BindingDecl`
  - `TypeAnnotationOpt ::= (':' Type)?`
  - `InitializerOpt ::= ('=' Expr)?`

  Type aliases are supported:

  - `TypeDecl ::= ExportModifier 'type' TypeDeclKindOpt Identifier '=' Type ';'`
  - `TypeDeclKindOpt ::= TypeDeclKind | ε`
  - `TypeDeclKind ::= 'struct' | 'enum' | 'error' | 'interface' | 'fn' | 'pure' 'fn'`

  `test` declarations are supported as Zig-inspired top-level test blocks:

  - `TestDecl ::= 'test' StringLiteral? Block`

  FFI declarations are also part of the language grammar:

  - `ExtDecl ::= ExportModifier 'ext' NameToken ExtExternNameOpt '=' Type ';'`
  - `ExtExternNameOpt ::= StringLiteral | ε`

  When `ExtExternNameOpt` is present, it sets the linked external symbol name.
  This allows Silk code to bind a local name that differs from the C/FFI symbol
  name (for example to avoid name collisions in wrapper modules).

  The current compiler implementation supports external declarations (`ext`) whose type
  is either:

  - a `FunctionType` (external functions, callable from Silk), or
  - a supported scalar type (external variables, readable as values in Silk).

  the compiler **requires an initializer** for runtime bindings
  (`let`/`var`) and for compile-time constant bindings (`const`). Uninitialized
  declarations like `let x: int;` / `const x: int;` are parsed but rejected by
  the checker (see `Compiler Diagnostics`, `E2015`).

  Additionally, `const` initializers must be compile-time evaluable; otherwise
  the compiler reports an error (see `Compiler Diagnostics`, `E2041`).

  In practice, prefer:

  - `let x: int = 0;` for a zero value, or
  - `let x: T? = None;` for an “empty” optional.

  Struct declarations are also accepted by the current parser:

  - `StructDecl ::= ExportModifier 'struct' Identifier GenericParamListOpt StructExtendsOpt ';' | ExportModifier 'struct' Identifier GenericParamListOpt StructExtendsOpt '{' StructFieldListOpt '}'`
  - `StructExtendsOpt ::= ('extends' QualifiedName) | ε`
  - `GenericParamListOpt ::= GenericParamList | ε`
  - `GenericParamList ::= '(' GenericParamListInnerOpt ')'`
  - `GenericParamListInnerOpt ::= GenericParamListInner | ε`
  - `GenericParamListInner ::= GenericParam (',' GenericParam)* ','?`
  - `GenericParam ::= Identifier (':' Type)? ('=' Type)?`
  - `StructFieldListOpt ::= StructFieldList | ε`
  - `StructFieldList ::= StructField (',' StructField)* ','?`
  - `StructField ::= Identifier ':' Type StructFieldDefaultOpt`
  - `StructFieldDefaultOpt ::= ('=' Expr) | ε`

  Enum declarations are part of the core language design. They are specified in
  ``enum` Types`.

  - `EnumDecl ::= ExportModifier 'enum' Identifier GenericParamListOpt '{' EnumVariantListOpt '}'`
  - `EnumVariantListOpt ::= EnumVariantList | ε`
  - `EnumVariantList ::= EnumVariant (',' EnumVariant)* ','?`
  - `EnumVariant ::= Identifier EnumVariantPayloadOpt`
  - `EnumVariantPayloadOpt ::= ('(' TypeListOpt ')') | ε`

  Interface and impl declarations are part of the language design and are
  parsed by the front-end as the syntax is implemented:

  - `InterfaceDecl ::= ExportModifier 'interface' Identifier GenericParamListOpt InterfaceExtendsOpt '{' InterfaceItem* '}'`
  - `InterfaceExtendsOpt ::= ('extends' QualifiedName) | ε`
  - `InterfaceMethodDecl ::= 'fn' NameToken FnSignature ';'`
  - `InterfaceItem ::= InterfaceMethodDecl | UsingDecl`

  - `ImplDecl ::= 'impl' QualifiedName GenericParamListOpt ImplAsOpt '{' ImplMemberDecl* '}'`
  - `ImplAsOpt ::= ('as' QualifiedName TypeArgListOpt) | ε`
  - `ImplMemberDecl ::= FnDecl | UsingDecl` (within an `impl` block, `export` is
    reserved for static members with no `self` receiver; instance method
    visibility uses `public`/`private`)

  Note: const-parameter-style generics (`N: int` parameters and integer literal
  type arguments like `Foo(u8, 1024)`) remain tracked work; the front-end parses
  these surface forms but the current implementation focuses on type parameters
  and monomorphization for type arguments.

  Exception: the nominal optional form `Option(T)` is recognized as sugar for
  `T?` and is accepted in Silk.

- Types:

  - `Type ::= UnionType`
  - `UnionType ::= TypeNoPipe ('|' TypeNoPipe)*`
  - `TypeNoPipe ::= BaseType TypeSuffix`
  - `TypeSuffix ::= TypeSuffixElem TypeSuffix | ε`
  - `TypeSuffixElem ::= OptionalTypeSuffix | ArrayTypeSuffix`
  - `OptionalTypeSuffix ::= '?' | '??'`
  - `ArrayTypeSuffix ::= '[' ']' | '[' ArrayLen ']'`
  - `ArrayLen ::= IntLiteral | Identifier`
  - `BaseType ::= ReferenceType | FunctionType | '(' Type ')' | SimpleType`
  - `ReferenceType ::= '&' BaseType`
  - `FunctionType ::= 'fn' '(' TypeListOpt ')' ResultTypeOpt`
  - `TypeListOpt ::= TypeList | ε`
  - `TypeList ::= Type (',' Type)*`
  - `SimpleType ::= PrimitiveType | NamedType`
  - `PrimitiveType ::= 'bool' | 'i8' | 'u8' | 'i16' | 'u16' | 'i32' | 'u32' | 'i64' | 'u64' | 'int' | 'f32' | 'f64' | 'char' | 'string' | 'void' | 'Instant' | 'Duration'`
  - `NamedType ::= QualifiedName TypeArgListOpt`
  - `TypeArgListOpt ::= ('(' TypeArgListInnerOpt ')') | ε`
  - `TypeArgListInnerOpt ::= TypeArgListInner | ε`
  - `TypeArgListInner ::= TypeArg (',' TypeArg)* ','?`
  - `TypeArg ::= Type | IntLiteral`

  This means that type annotations such as `string?` or `int??` are parsed
  into nested optional types. For simple nominal optionals, the parser also
  recognizes `Option(T)` and desugars it to the same internal representation
  as `T?`. Borrowed reference types (`&T`) are now parsed in type annotations.
  Array/slice types (`T[]`, `T[N]`) are
  parsed and type-checked in Silk (with element-type
  restrictions), and are part of the implemented expression grammar via array
  literals (`[a, b, c]`) and indexing (`xs[i]`). Function types
  (`fn (T, ...) -> R`) are parsed as part of the `Type` grammar, and function
  values are supported in the current lowering subset (including capturing
  closures as a restricted scalar-only subset; see `Types` and
  `Memory Model (Stack, Heap, and Moves)`).

- Statements:

  - `Stmt ::= LetStmt | SpecConstStmt | SpecAssertStmt | SpecTheoryDeclStmt | SpecTheoryStmt | AsyncBlockStmt | TaskBlockStmt | ExprStmt | IfStmt | LoopStmt | WhileStmt | ForStmt | MatchStmt | ReturnStmt | PanicStmt | AssertStmt | BreakStmt | ContinueStmt`

  - `LetStmt ::= ('const' | 'let' MutOpt | 'var') LetBinder TypeAnnotationOpt InitializerOpt ';'`
  - `LetBinder ::= Identifier | '_' | LetTupleBinder | LetStructBinder | LetArrayBinder`
  - `LetTupleBinder ::= '(' LetTupleBinderItemsOpt ')'`
  - `LetTupleBinderItemsOpt ::= LetTupleBinderItem (',' LetTupleBinderItem)* ','? | ε`
  - `LetTupleBinderItem ::= Identifier | '_'`
  - `LetStructBinder ::= '{' LetStructBinderItemsOpt '}'`
  - `LetStructBinderItemsOpt ::= LetStructBinderItem (',' LetStructBinderItem)* ','? | ε`
  - `LetStructBinderItem ::= Identifier ('as' (Identifier | '_'))?`
  - `LetArrayBinder ::= '[' LetArrayBinderItemsOpt ']'`
  - `LetArrayBinderItemsOpt ::= LetArrayBinderItem (',' LetArrayBinderItem)* ','? | ε`
  - `LetArrayBinderItem ::= Identifier | '_'`
  - `SpecConstStmt ::= '#const' Identifier '=' Expr ';'`
  - `SpecAssertStmt ::= '#assert' Expr ';'`
  - `SpecTheoryDeclStmt ::= '#theory' Identifier '(' TheoryParamsOpt ')' '{' TheoryBodyItem* '}'`
  - `SpecTheoryStmt ::= '#theory' Identifier '(' ArgListOpt ')' ';'`
  - `AsyncBlockStmt ::= 'async' Block`
  - `TaskBlockStmt ::= 'task' Block`
  - `MutOpt ::= 'mut' | ε`
  - `ExprStmt ::= Expr ';'`
  - `IfStmt ::= 'if' Expr Block ('else' (IfStmt | Block))?`
  - `LoopStmt ::= LoopPrefixOpt 'loop' Block`
  - `LoopPrefixOpt ::= 'async' | 'task' | ε`
  - `WhileStmt ::= WhileSpecs 'while' Expr Block`
  - `WhileSpecs ::= (LoopInvariant | LoopVariant | LoopMonovariant)*`
  - `LoopInvariant ::= '#invariant' Expr ';'`
  - `LoopVariant ::= '#variant' Expr ';'`
  - `LoopMonovariant ::= '#monovariant' Expr ';'`
  - `ForStmt ::= ForInStmt | ForCStmt`
  - `ForInStmt ::= 'for' ForBinder 'in' Expr (RangeOp Expr)? Block`
  - `ForCStmt ::= 'for' '(' ForInit ';' Expr ';' Expr ')' Block`
  - `ForInit ::= ('const' | 'let' MutOpt | 'var') Identifier TypeAnnotationOpt '=' Expr`
  - `ForBinder ::= Identifier | '_'`
  - `RangeOp ::= '..' | '..='`
  - `BlockStmt ::= Block`
  - `Block ::= '{' Stmt* '}'`
  - `ReturnStmt ::= 'return' ExprOpt ';'`
  - `ExprOpt ::= Expr?`
  - `PanicStmt ::= 'panic' QualifiedName StructLiteralSuffixOpt ';'`
  - `AssertStmt ::= 'assert' Expr ';' | 'assert' '(' Expr (',' Expr)? ')' ';'`
  - `BreakStmt ::= 'break' ';'`
  - `ContinueStmt ::= 'continue' ';'`
  - `WithStmt ::= 'with' Identifier Block
                | 'with' WithBytes Block
                | 'with' WithBytes 'from' Identifier WithFromSliceOpt Block`
  - `WithBytes ::= IntLiteral | '(' IntLiteral ')'`
  - `WithFromSliceOpt ::= '[' IntLiteral '..' IntLiteralOpt ']' | ε`
  - `IntLiteralOpt ::= IntLiteral | ε`
  - `MatchStmt ::= 'match' Expr '{' MatchStmtArmListOpt '}'`
  - `MatchStmtArmListOpt ::= MatchStmtArmList | ε`
  - `MatchStmtArmList ::= MatchStmtArm (',' MatchStmtArm)* ','?`
  - `MatchStmtArm ::= MatchStmtPattern '=>' Block`
  - `OptionalPattern ::= 'None'
                      | 'Some' '(' (Identifier | '_') ')'`

  - `MatchStmtPattern ::= OptionalPattern
                        | '_'
                        | Identifier
                        | (Identifier | '_') ':' QualifiedName`
  - `StructLiteralSuffixOpt ::= StructLiteralSuffix | ε`

  Region declarations and `with` blocks are specified in `Regions`.

  `match` is implemented in two separate forms:

  - `match` as an expression (arms are expressions; see `MatchExpr` below),
  - `match` as a statement (arms are blocks), used for typed errors as
    specified in `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`.

  In the current implementation, the `match` statement form is restricted to a
  call-expression scrutinee and the patterns listed above.

- Expressions:

  Expressions follow a conventional precedence hierarchy, as implemented in
  `the implementation`:

  - `Expr ::= Assign`
  - `Assign ::= Coalesce (AssignOp Assign)?`
  - `AssignOp ::= '=' | '+=' | '-=' | '*=' | '/='`
  - `Coalesce ::= LogicalOr ('??' Coalesce)?`
  - `LogicalOr ::= LogicalAnd ('||' LogicalAnd)*`
  - `LogicalAnd ::= BitOr ('&&' BitOr)*`
  - `BitOr ::= BitXor ('|' BitXor)*`
  - `BitXor ::= BitAnd ('^' BitAnd)*`
  - `BitAnd ::= Equality ('&' Equality)*`
  - `Equality ::= TypeTest (('==' | '!=') TypeTest)*`
  - `TypeTest ::= Relational ('is' Type)?`
  - `Relational ::= Shift (('<' | '<=' | '>' | '>=') Shift)*`
  - `Shift ::= AddSub (('<<' | '>>') AddSub)*`
  - `AddSub ::= MulDiv (('+' | '-') MulDiv)*`
  - `MulDiv ::= Unary (('*' | '/' | '%') Unary)*`
  - `Unary ::= ('!' | '~' | '-' | 'mut' | 'move' | 'new' | 'await' | 'yield' | 'sizeof' | 'alignof' | 'offsetof' | 'typename' | '&' | '*' | '++' | '--') Unary | Postfix`
  - `Postfix ::= Primary PostfixSuffix*`
  - `PostfixSuffix ::= CallSuffix | FieldSuffix | OptionalFieldSuffix | StructLiteralSuffix | IndexSuffix | SliceSuffix | CastSuffix | TrySuffix | IncDecSuffix`
  - `CallSuffix ::= '(' CallArgsOpt ')'`
  - `FieldSuffix ::= '.' NameToken`
  - `OptionalFieldSuffix ::= '?.' NameToken`
  - `StructLiteralSuffix ::= '{' StructInitListOpt '}'`
  - `IndexSuffix ::= '[' Expr ']'`
  - `SliceSuffix ::= '[' SliceBoundOpt '..' SliceBoundOpt ']'`
  - `SliceBoundOpt ::= Expr | ε`
  - `CastSuffix ::= 'as' RawOpt Type CastSliceLenOpt`
  - `CastSliceLenOpt ::= '(' Expr ')' | ε`
  - `RawOpt ::= 'raw' | ε`
  - `TrySuffix ::= '?'`
  - `IncDecSuffix ::= '++' | '--'`
  - `StructInitListOpt ::= StructInitList | ε`
  - `StructInitList ::= StructInit (',' StructInit)* ','?`
  - `StructInit ::= NameToken (':' Expr)?`

  - `CallArgsOpt ::= CallArgs | ε`
  - `CallArgs ::= GenericArgListOpt ';' ArgListOpt | ArgList`
  - `GenericArgListOpt ::= GenericArgList | ε`
  - `GenericArgList ::= GenericArg (',' GenericArg)* ','?`
  - `GenericArg ::= Type | IntLiteral`

  - `ArgListOpt ::= ArgList | ε`
  - `ArgList ::= Expr (',' Expr)*`

  Note: the parser treats `mut <expr>`, `new <expr>`, `await <expr>`, `await * <expr>`,
  `yield <expr>`, `yield * <expr>`, `sizeof <expr>`, `alignof <expr>`, `offsetof(Type, field_path)`,
  `typename <expr>`, and prefix `++<expr>` / `--<expr>` as unary expressions.

  Note: `CastSliceLenOpt` is permitted only when `Type` is a slice type (`T[]`)
  and `RawOpt` is `ε` (it is used by unsafe pointer→slice casts like
  `ptr as u8[](len)`).

  - The type checker currently permits `mut <expr>` only in call arguments (and
    method receivers) when the corresponding parameter is declared `mut` and is:
    - a borrowed reference type (`mut r: &T`), or
    - a slice type (`mut s: T[]`).
  - The `move <expr>` unary form is used for explicit ownership transfer; in the
     it is restricted to `move <name>` where `<name>` is a local
    binding.
  - The type checker currently permits `new <expr>` only when it can determine a
    concrete reference result type of the form `&Struct`. In the current
    implementation this happens either:
    - from an expected `&Struct` type context (for example `let x: &Packet = new
      Packet{ ... };` or as a call argument whose parameter type is `&Struct`)
    - from the operand itself when it names the struct type (for example `let x
      = new Packet{ ... };` or `let x = new Packet(...);`)
    `new` is supported only in function bodies (not in top-level `let`
    initializers).

  - `Primary ::= IntegerLiteral
               | DurationLiteral
               | FloatLiteral
               | StringLiteral
               | RegexpLiteral
               | CharLiteral
               | 'true'
               | 'false'
               | 'None'
               | 'null'
               | 'Some' '(' Expr ')'
               | ArrayLiteral
               | IfExpr
               | MatchExpr
               | FnExpr
               | '(' Expr ')'
               | InferredStructLiteral
               | QualifiedName`

  - `RegexpLiteral ::= '/' RegexpBody '/' RegexpFlagsOpt`
  - `RegexpFlagsOpt ::= Identifier | ε`

  Notes:
  - `RegexpBody` is scanned by the parser (not the lexer): it is the byte span
    between the opening and closing `/`, where the closing delimiter is the
    first unescaped `/` that is not inside a character class (`[...]`).

  - `ArrayLiteral ::= '[' ExprListOpt ']'`
  - `ExprListOpt ::= ExprList | ε`
  - `ExprList ::= Expr (',' Expr)* ','?`

  - `QualifiedName ::= GlobalPrefixOpt NameToken ('::' NameToken)*`
  - `GlobalPrefixOpt ::= '::' | ε`

  - `InferredStructLiteral ::= '{' StructInitListOpt '}'`

  - `FnExpr ::= 'fn' '(' LambdaParamListOpt ')' '->' LambdaBody`
  - `LambdaParamListOpt ::= LambdaParamList | ε`
  - `LambdaParamList ::= LambdaParam (',' LambdaParam)* ','?`
  - `LambdaParam ::= Identifier ':' Type`
  - `LambdaBody ::= Type Block | Expr`

  Disambiguation rule (current parser):

  - `fn (...) -> Type Block` is treated as the block-body form only when the
    return type is followed immediately by `{` (starting the block).
  - Otherwise, `fn (...) -> Expr` is treated as an expression-body function
    expression and its result type is inferred by the checker.

  Notes:

  - `InferredStructLiteral` has the same token-level shape as
    `StructLiteralSuffix` (used for `Type{ ... }`), but appears as a `Primary`
    expression with **no explicit type name**. The type checker requires an
    expected struct type context to resolve the literal’s target type.
  - To avoid ambiguity with statement blocks, the parser only recognizes
    `InferredStructLiteral` when the `{ ... }` contents look like a struct
    initializer list (or are `{}`): either the first token after `{` is `}` or
    it is an `Identifier` followed by `:` (explicit initializer) or followed by
    `,` / `}` (shorthand initializer).

  - `MatchExpr ::= 'match' Expr '{' MatchArmListOpt '}'`
  - `MatchArmListOpt ::= MatchArmList | ε`
  - `MatchArmList ::= MatchArm (',' MatchArm)* ','?`
  - `MatchArm ::= MatchExprPattern '=>' Expr`
  - `MatchExprPattern ::= OptionalPattern | EnumVariantPattern | ResultPattern`

  - `IfExpr ::= 'if' Expr IfExprBlock 'else' (IfExpr | IfExprBlock)`
  - `IfExprBlock ::= '{' Expr '}'`

  - `ResultPattern ::= ('Ok' | 'Err') '(' (Identifier | '_') ')'`

  - `EnumVariantPattern ::= EnumVariantName EnumVariantBinderListOpt`
  - `EnumVariantName ::= ('::')? Identifier '::' Identifier ('::' Identifier)*`
  - `EnumVariantBinderListOpt ::= ('(' EnumVariantBinderListInnerOpt ')') | ε`
  - `EnumVariantBinderListInnerOpt ::= EnumVariantBinderList | ε`
  - `EnumVariantBinderList ::= EnumVariantBinder (',' EnumVariantBinder)* ','?`
  - `EnumVariantBinder ::= Identifier | '_'`

- Declarations:

  - `Decl ::= ... | ErrorDecl`
  - `ErrorDecl ::= ExportModifier 'error' Identifier '{' StructFieldListOpt '}'`

  This matches the current AST and checker:

  - `Primary` constructs `Literal` or `Name` expressions (or a parenthesized `Expr`),
  - unary expressions are represented as `UnaryExpr` with a token kind indicating the
    operator,
  - binary expressions are represented as `BinaryExpr` with a token kind indicating
    the operator,
  - identifiers and qualified names are stored as `NameExpr` with the full
    slice of source text (e.g. `util::answer`),
  - simple function calls such as `helper()` or `util::helper(1, 2)` are
    parsed as call expressions using the `Postfix`/`CallSuffix` productions;
    the current implementation supports calls to named functions, but the type checker
    and back-end currently restrict which value types can appear at call boundaries;
    see ``silk` CLI` for the exact supported subset.

Further expression forms (ranges, etc.) are described in other
language concept documents and in `Operators`. The current
parser now accepts `?.` optional field access (`opt?.field`) and the initial
`match` expression form as part of the implemented optional subset, but other
expression forms will be added here as they are implemented.

### Role of This File

This document serves as the reference for:

- lexer implementation (token categories and reserved words),
- parser implementation (production rules and precedence),
- pretty-printer or formatter behavior.

As the parser and lexer are implemented, this file must be updated with:

- the exact grammar that the compiler accepts (including any temporary limitations),
- clarifications or corrections discovered during implementation (recorded here so this file remains canonical),
- notes about desugaring and how surface constructs map into the internal AST,
- clear indication of which productions are implemented today vs. planned
  future work, so that downstream users can see both the full language
  design and the currently supported subset.

## Types

This document specifies the Silk type system used by the compiler front-end and type checker.

Implementation status (current compiler subset):

- Supported end-to-end: primitives, nominal `struct` types, optionals (`T?`),
  `&Struct` references (in function parameter types and as local values
  produced by `new` / calls that return `&Struct`), and array/slice types
  (`T[N]`, `T[]`) over element types that lower to a fixed scalar-slot sequence
  In Silk (including array literals, indexing reads, and
  iterable `for` loops). Indexed assignment targets (`xs[i] = v`) are supported
  for these element types; compound index ops require numeric scalar element
  types in Silk.
  - Parameterized nominal types (monomorphized): generic `struct` and
    `interface` declarations with **type parameters**, plus applied types in
    type positions (`Name(u8)`, `Name(string)`) for those declarations.
- Reserved intrinsics: the compiler currently exposes reserved, stdlib
  bring-up intrinsics for working with the `string` ABI (`__silk_string_ptr`,
  `__silk_string_len`, and `__silk_string_from_ptr_len`); these are not yet a
  stable user API and exist primarily to unblock `std::fmt`, `std::io`, and
  `std::args` while slice/iterator features are still evolving.
- Special-case: the nominal optional form `Option(T)` is accepted and desugared
  to `T?` in type annotations (it is not a general generics feature).
- Parsed but rejected by the current checker: const parameters and integer
  literal type arguments (`Foo(N: int)`, `Foo(u8, 1024)`) (`Compiler Diagnostics`, `E2016`),
  and the removed builtin map type form (`map(K, V)`) (`E2017`; use
  `std::map::{HashMap, TreeMap}` instead).
- Typed errors (`error`, `panic`, and `T | ErrorType...`) are specified in
  `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`. The current compiler models typed error
  contracts as an effect on function return types and expressions.
  - Separately, type unions (`T1 | T2 | ...`) are supported in type annotations
    as described in `Type Unions (`T1 | T2 | ...`)`. In function declaration
    return types, union returns must be parenthesized (`-> (A | B)`) because
    unparenthesized `|` after `->` is reserved for typed-error contracts.

### Quick Reference

The core categories are:

- Booleans: `bool`
  - Examples: `true`, `false`.
  - Notes: logical values.
- Integers (fixed width): `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`
  - Examples: `let n: i32 = 42;`.
  - Notes: signed/unsigned bit-widths.
- Integer (platform): `int`
  - Examples: `let n: int = 1;`.
  - Notes: implementation/default integer.
- Pointer-width integers: `usize`, `size`
  - Examples: `let n: usize = 1;`, `let n: size = -1;`.
  - Notes: unsigned/signed integer types whose width matches the target
    architecture pointer width (for example 64-bit on `linux/x86_64`).
  - Compatibility: `isize` is accepted as an alias for `size`.
- Floats: `f32`, `f64`
  - Examples: `let x: f64 = 3.14;`.
  - Notes: IEEE‑754.
- Char: `char`
  - Examples: `'A'`.
  - Notes: Unicode scalar.
- String: `string`
  - Examples: `"hello"`.
  - Notes: immutable text; multi‑line strings supported.
- Regexp: `regexp`
  - Examples: `/hello/i`.
  - Notes: compiled regular expression bytecode; a non-owning `{ ptr, len }`
    view analogous to `string`. Regex literals compile at compile time; runtime
    compilation and matching helpers live in `std::regex` (see `std::regex`).
- Region handle: `Region`
  - Examples: `fn f (r: Region) -> int { with r { ... } }`.
  - Notes: a first-class region allocation context handle; see `Regions`.
- Void / Unit: `void`
  - Examples: `fn foo () -> void {}`.
  - Notes: functions that return nothing.
- Time Types: `Instant`, `Duration`
  - Examples: `let i: Instant = std::now();`.
  - Notes: specialized `i64`-based types for time measurement.
- Optional: `T?`
  - Examples: `User?`, `i32?`.
  - Notes: `None` / `none` is the canonical empty value; `null` may also be
    used when an optional type is expected and coerces to `None`. Use `match`,
    `?.`, `??`.
- None (value):
  - Examples: `None` / `none` (represented as `None` in code samples).
  - Notes: the distinguished empty value; typed as `T?`. The `null` literal is
    a distinct literal that can coerce to `None` when an optional type is
    expected (see `Optional`).
- Reference (borrow): `&T`
  - Examples: `&User`.
  - Notes: reference type; in Silk, `&Struct` may appear in
    parameter types and as local values when produced by `new` or by calls that
    return `&Struct`. Mutability follows the `mut` borrow contract and per-call
    aliasing rules described in `Mutability`.
- Arrays / Slices: `T[]`, `T[N]`
  - Examples: `i32[]`, `byte[32]`.
  - Notes: dynamic slice vs fixed length (compile‑time `N`). In the current
    compiler/backend subset, arrays/slices are supported only when the element
    type lowers to a fixed scalar slot sequence in the current scalar-slot
    memory model (for example primitive scalars, `string`, and supported
    `regexp`, supported non-opaque structs, and enums). See `Structs, Impl Blocks, and Memory Layout` for the
    current scalar-slot memory model. in Silk, fixed array
    lengths are limited to `N <= 4096`. Indexing `xs[i]` traps when `i` is out
    of bounds in Silk.
- Function Types: `fn(params) -> R`
  - Examples: `fn(i32) -> i32`.
  - Notes: function types are part of the type grammar and function-typed
    values are supported as function values (including capturing closures) in
    the compiler.
    Concurrency disciplines (`task` / `async`) are implemented on function
    *declarations* (see `Concurrency`); function types in type
    positions do not currently include discipline modifiers.
- Capturing Closures:
  - Notes: capturing closures are supported as function values with an
    environment; see “Function Types and Closures” below for 
    restrictions.
- Structs (nominal):
  - Surface: `struct Name { ... }` then `Name(...)`.
  - Examples: `Point`, `Option(T)`.
  - Notes: user‑defined records; may be parameterized.
- Enums (sum types):
  - Surface: `enum Name { ... }`.
  - Notes: nominal tagged unions as described in the spec.
- Type unions:
  - Surface: `T1 | T2 | ...` (type annotations).
  - Notes: a tagged “one-of-these-types” type for a small, explicitly defined
    subset; see `Type Unions (`T1 | T2 | ...`)`.

The compiler must represent these types faithfully in its internal type system and in the C99 ABI mappings, and it must follow the exact surface syntaxes indicated above when parsing and printing types.

### Type Aliases (`type`)

Silk supports compile-time-only type aliases via `type` declarations.

Syntax examples:

```silk
type Int32 = i32;
type struct Bar = Foo;
type fn IntAdder = fn(int, int) -> int;
type pure fn PureIntAdder = fn(int, int) -> int;
export type struct PublicBar = Foo;
```

Semantics (current compiler subset):

- A type alias introduces a new name for an existing type; it does **not**
  introduce a distinct nominal type.
- The type checker MUST treat uses of the alias name as equivalent to the alias
  target type (the alias is transparent).
- Type aliases may be used anywhere a type is expected (parameter/result types,
  local annotations, struct fields, `as` casts, etc.).
- Cycles in type aliases are rejected (`E2058`).

Kind tags:

- A `type` declaration may optionally specify a kind tag, for example
  `type struct Name = Foo;` or `type pure fn Name = fn(...) -> ...;`.
- When present, the compiler MUST validate that the resolved alias target
  matches the declared kind (`E2059`).

Import/export:

- `type` aliases may be exported (`export type ...;`) and imported as type names
  via named file imports (see `Packages, Imports, and Exports`).

### Implicit Call-Argument Coercions ()

In Silk, Silk supports a small, **opt-in** implicit
coercion mechanism for function call arguments. This exists to keep the
current standard library ergonomic while generics and richer overload
systems are still evolving.

There are two related mechanisms:

1. **Coercion to a nominal `struct` value** `T` (by-value parameters and
   varargs elements) via exported static ctor-like methods.
2. **Coercion to a borrowed reference** `&T` (read-only `&T` parameters) via a
   `constructor` method that initializes a compiler-generated stack temporary.

#### 1) Coercion to `T` via exported static ctor-like methods

Rule (informal):

- When a function call argument type does not match a parameter type, and the
  parameter is a nominal `struct` type `T`, the compiler may rewrite the
  argument to a call of an exported, static ctor-like method on `T`.
- This also applies to varargs elements (`...args: T`).

Supported ctor-like method names (destination type opts in by defining these):

- `T.int(value: int) -> T`
- `T.u64(value: u64) -> T`
- `T.f64(value: f64) -> T`
- `T.bool(value: bool) -> T`
- `T.char(value: char) -> T`
- `T.string(value: string) -> T`
- `T.regexp(value: regexp) -> T`
- `T.Region(value: Region) -> T`

Selection (source type → constructor):

- Signed integer primitives (`i8/i16/i32/i64/int/size/isize/Instant/Duration`) → `int`
- Unsigned integer primitives (`u8/u16/u32/u64/usize`) → `u64`
- Float primitives (`f32/f64`) → `f64`
- `bool` → `bool`
- `char` → `char`
- `string` → `string`
- `regexp` → `regexp`
- `Region` → `Region`

Integer width:

- When the source argument is a fixed-width integer, the compiler inserts an
  implicit integer cast to match the ctor parameter type before calling the
  ctor.
- When the source argument is `f32` and the selected ctor parameter type is
  `f64`, the compiler inserts an implicit float cast (`f32 -> f64`) before
  calling the ctor.

Example:

```silk
struct Counter {
  value: int,
}

impl Counter {
  public fn int (value: int) -> Counter {
    return Counter{ value: value };
  }
}

fn takes (c: Counter) -> int {
  return c.value;
}

fn main () -> int {
  let x: i32 = 7;
  return takes(x); // coerces via `Counter.int`
}
```

Notes:

- Coercions are only attempted when the destination type provides the matching
  exported static ctor method.
- Today this primarily exists to support `std::fmt::Arg` and ergonomic
  `std::io::print/println` calls without requiring explicit `Arg.*`
  wrappers everywhere.

#### 2) Coercion to `&T` via `constructor` (stack temporary)

Rule (informal):

- When a call argument does not match a parameter type, and the parameter is a
  **read-only borrowed reference** `&T` to a nominal `struct` type `T`, the
  compiler may create an implicit stack temporary `tmp: T`, initialize it by
  invoking `tmp.constructor(...)`, and pass `&tmp` to the callee.

This is intentionally a *stack* construction mechanism:

- it does **not** allocate on the heap,
- it is compatible with `silk build --noheap`,
- and the temporary’s lifetime is the duration of the call (similar to how C++
  binds temporaries to `const&` parameters).

Eligibility requirements ():

- The parameter must be `&T` (not `mut &T`).
- The destination type `T` must provide a visible `constructor` overload with:
  - receiver `mut self: &T`,
  - exactly **one** non-receiver parameter (`value: U`),
  - return type `void`.
- The call argument type must match the selected overload’s `U` parameter type.
- If multiple overloads are viable for a given argument, the coercion is
  ambiguous and rejected (the call must be written with an explicit
  construction).

Example:

```silk
struct User {
  name: string,
}

impl User {
  fn constructor (mut self: &Self, name: string) -> void {
    self.name = name;
  }
}

fn print_user (user: &User) -> void {
  std::io::println("user.name = {}", user.name);
}

fn main () -> int {
  // Implicitly constructs a temporary `User` from a `string` for this call.
  print_user("alice");
  return 0;
}
```

Notes:

- This is an opt-in mechanism: types must provide the matching `constructor`.
- If the coercion is ambiguous (multiple viable conversion paths), the compiler
  rejects the call and requires an explicit construction.
- Because this coercion participates in ordinary call argument checking, it can
  make additional overloads applicable (for example a copy-constructor
  `constructor(mut self: &Self, other: &Self)` can accept a `string` argument by
  first constructing a temporary `Self` from `string`). Overload resolution
  prefers overloads that match without requiring such coercions.

### Explicit Casts (`as`)

Silk supports explicit casts using the postfix `as` operator:

```silk
let x: f64 = 3.14;
let n: int = x as int;
```

This operator is intended for explicit, potentially lossy primitive numeric
conversions. in Silk it also supports explicit conversions via
`std::interfaces::Serialize(T)` by lowering `expr as T` to `expr.serialize()`
when the operand type provides a matching `serialize` method.
For structured conversions, it also supports `std::interfaces::Deserialize(S)`
by lowering `expr as T` to `T.deserialize(expr)` when the target type provides
a matching static `deserialize` method.

The supported conversions and semantics for the compiler are
specified in `Operators` (“Casts (`as`)”).

Notes:

- `as` is explicit. It does not introduce new implicit coercions.
- For call-argument ergonomics, see the separate opt-in coercion mechanism
  described above (“Implicit Call-Argument Coercions”).

### Nominal & Parameterized Types

Nominal types are introduced by declarations (e.g. `struct`, `enum`, `interface`) and are equal only to themselves. Parameterized types are constructed by applying a type constructor to type arguments.

The compiler must:

- Treat nominal types as distinct even if their field layout is identical.
- In the full language design, support parameterized types in all contexts
  where the spec permits them. in Silk, **type-parameter**
  generics are supported for nominal declarations (`struct` / `interface`) and
  for applied types in type positions (`Name(u8)`).
  - Const parameters and integer-literal type arguments (`Name(N: int)`,
    `Name(u8, 1024)`) remain tracked work and are rejected (`E2016`).
  - The `Option(T)` optional sugar described above remains supported for
    the .

#### Parameterized type syntax (initial surface form)

The initial surface syntax for applying type arguments is:

- `TypeApply ::= TypeName '(' TypeArgListOpt ')'`
- `TypeName ::= Identifier ('::' Identifier)*`
- `TypeArgListOpt ::= TypeArgList | ε`
- `TypeArgList ::= TypeArg (',' TypeArg)* ','?`
- `TypeArg ::= Type | IntLiteral`

Examples:

```silk
Foo(int, 1024)
Mutex(Account)
Result(int, string)
```

Notes:

- A `TypeArg` may be a type (e.g. `int`, `&Foo`, `Option(string)`) or a
  compile-time integer literal for const-parameter-style arguments.
- The full semantics (declaring generic parameters, constraint checking, and
  monomorphization) are still evolving; the key requirement is that the
  compiler preserves the argument structure in the AST/type system so later
  stages can enforce and lower it.

### Reference Types

Reference types describe access to values rather than owning them (e.g. references, borrowed views, or other non-owning handles as specified in this document and related language docs).

Key requirements:

- Distinguish owning vs. non-owning types in the type system.
- Preserve aliasing and lifetime constraints so that regions, buffers, and FFI safety rules can be enforced.

Current implementation notes:

- `&Struct` is supported in function parameter types and as local values when
  produced by heap allocation (`new`) or by calls that return `&Struct`.
- Borrowed `&Struct` references may also be created from stack values:
  - via the borrow operator `&expr` on borrowable lvalues, and
  - via implicit borrow coercions in contexts that expect `&T`
    (for example `let r: &Pair = pair;`).
  These borrows are checked with conservative lexical lifetime rules (they may
  not escape the scope of the borrowed stack storage).
- Mutable reference parameters use the two-part `mut` contract and conservative
  per-call aliasing rules; see `Mutability`.

### Function Types and Closures (Implementation Status)

the compiler:

- Parses function types in type positions (most notably for `ext` declarations).
- Implements function expressions (lambdas) in expression positions:
  - expression body form: `fn (x: int, y: int) -> x + y`
  - block body form: `fn (x: int, y: int) -> int { return x + y; }`
- Function expressions may not declare `&T` parameters in Silk.
- Function expressions are inferred as `pure` when they are **non-capturing**:
  - they may call only `pure` functions,
  - they may not mutate (`let mut`/`var`, assignment),
  - they may not allocate (`new`),
  - they may not use typed error contracts or `panic`.
- The checker also supports purity inference (“auto-pure”) for ordinary function
  declarations and `impl` methods. When inferred, these functions/methods are
  treated as `pure` for call checking and are callable from `pure` code.
- Capturing closures are implemented as a subset of function values:
  - a function expression body may reference **immutable** locals/parameters
    from an enclosing scope; those values are captured by value into a heap
    environment,
  - In Silk, only **scalar** captures are supported (`int`, fixed
    width ints, `bool`, `char`, `f32`, `f64`, `Instant`, `Duration`),
  - capturing closures are not `pure` (they have an environment) and are
    rejected in `pure` code in Silk.
- Function values are supported end-to-end for this subset (non-capturing and
  capturing):
  - they may be passed as arguments, returned from functions, stored in
    structs/arrays, and called indirectly.
  - the runtime representation is a pair `{ func_ptr, env_ptr }` as specified
    in `Memory Model (Stack, Heap, and Moves)`.
- Discipline modifiers for function declarations (`pure` / `task` / `async`) are
  implemented. Function types in type positions do not currently include
  discipline modifiers.

## Literals Overview

This document provides a high-level overview of literals in Silk, with details split into dedicated documents for each category.

For first-time readers, a good path is:

1. `Types` (primitive types like `int`, `f64`, `bool`, `string`),
2. this overview (what literal categories exist),
3. the specific literal docs below (syntax, semantics, and supported behavior).

Returning readers typically want the “Implementation Status” section near the top
of each literal concept doc, plus the “Relevant Tests” links for runnable
examples.

### Literal Categories

Silk includes the following literal categories:

- Numeric literals
- Duration literals
- Boolean literals
- Character literals
- String literals
- Regular expression literals
- Aggregate literals (arrays, structs)

Each literal form has well-defined syntax and type inference rules that the compiler must implement.

See:

- `Numeric Literals`
- `Duration Literals`
- `Boolean Literals`
- `Character Literals`
- `String Literals`
- `Regular Expression Literals`
- `Aggregate Literals`

## Numeric Literals

Numeric literals produce integer (`int`, `u8`, `i64`, …) and floating-point
(`f32`, `f64`) values.

In Silk, the sign is an operator: `-1` is a unary `-` expression applied to the
integer literal token `1`, not a distinct “negative literal” token.

### Quick Reference

```silk
fn main () -> int {
  let a = 42;        // int
  let b: u8 = 42;    // u8 (typed by context)

  let x: f64 = 1.5;  // f64
  let y: f32 = 1.5;  // f32 (typed by context)

  let d: Duration = 5ms;
  let t0: Instant = 0;

  return 0;
}
```

### Surface Syntax (Current Lexer)

In the current implementation, numeric literal tokens are recognized as:

- **Integer literal**:
  - decimal digits (`[0-9]+`),
  - binary prefix: `0b` / `0B` followed by binary digits (`[01]+`),
  - octal prefix: `0o` / `0O` followed by octal digits (`[0-7]+`),
  - hex prefix: `0x` / `0X` followed by hex digits (`[0-9a-fA-F]+`),
  - legacy octal: `0[0-7]+` (for example `017`).
- **Float literal**: digits, `.`, digits (`[0-9]+ '.' [0-9]+`)

Notes:

- A float literal must have digits on both sides of the `.`:
  - `1.0` is a float literal.
  - `1.` is not a float literal in the current lexer.
  - `.5` is not a float literal; write `0.5`.
- Numeric literals must start with a digit in the current lexer.
- The `-` sign is not part of the literal token:
  - `-1` parses as unary `-` applied to the integer literal `1`.
  - `-1.5` parses as unary `-` applied to the float literal `1.5`.
- A numeric token immediately followed by a duration unit suffix (e.g. `1s`,
  `500ms`, `1.5s`) is a single `Duration` literal token, not a number token
  followed by an identifier.
- A numeric literal token may not be immediately followed by an identifier
  start character or an ASCII digit (unless the identifier characters are part
  of a duration unit suffix). For example:
  - `3in` is a lexical error (write `3 in` or `3 * in` as intended),
  - `0b102` is a lexical error (invalid binary digit),
  - `08` is a lexical error in Silk because multi-digit literals starting with
    `0` are legacy octal (use `0o10` for octal 8, or write `8` for decimal).

### Type Rules ()

See `Types` for the primitive type names used below.

#### Integer literals

- Without an expected type, an integer literal has type `int`.
- When a context provides an expected type that is:
  - an integer type (`u8`, `i64`, `int`, …), or
  - a time type (`Duration`, `Instant`),
  then the integer literal adopts that expected type.

Example: parameter context and “adopt the expected type”

```silk
fn id_u8 (x: u8) -> u8 {
  return x;
}

fn main () -> int {
  // `255` is contextually typed as `u8` because `id_u8` expects `u8`.
  let v: u8 = id_u8(255);
  if v != 255 {
    return 1;
  }
  return 0;
}
```

Example: time types share an `i64`-based representation in Silk
(``Duration` & `Instant``), so integer literals can be used as
`Instant`/`Duration` values via context:

```silk
fn main () -> int {
  let t0: Instant = 0;
  let d: Duration = 1s;
  let t1: Instant = t0 + d;

  let diff: Duration = t1 - t0;
  if diff != d {
    return 1;
  }
  return 0;
}
```

#### Float literals

- Without an expected type, a float literal has type `f64`.
- When a context provides an expected float type (`f32` or `f64`), the literal
  adopts that expected type.

```silk
fn id_f32 (x: f32) -> f32 {
  return x;
}

fn main () -> int {
  // `1.5` is contextually typed as `f32` because `id_f32` expects `f32`.
  let v: f32 = id_f32(1.5);
  if v != 1.5 {
    return 1;
  }
  return 0;
}
```

### Common Pitfalls

- **Trying to use suffixes**: `42u8` / `1.5f32` are not supported. Use type
  annotations (`let x: u8 = 42;`) or casts (`42 as u8`).
- **Using digit separators**: `1_000` is not supported yet.
- **Using exponent notation**: `1e6` is not supported yet.
- **Writing incomplete floats**: write `1.0` (not `1.`) and `0.5` (not `.5`).
- **Mixing integers and floats implicitly**: use `as` casts (`Operators`)
  to convert explicitly when you need to combine integer and float values.

### Related Documents

- `Duration Literals` (duration literals like `5ms`, `1.5s`)
- ``Duration` & `Instant`` (time types and operators)
- `Operators` (unary `-`, arithmetic, and `as` casts)
- `Types` (primitive numeric type names)

### Relevant Tests

- Integer literal contextual typing (`u8` parameters):
  - `the runnable fixtures`
- Integer wrap behavior in arithmetic:
  - `the runnable fixtures`
  - `the runnable fixtures`
- Float literal contextual typing (`f32` parameters):
  - `the runnable fixtures`
- Float literal default type (`f64`):
  - `the runnable fixtures`
- Float arithmetic and comparisons:
  - `the runnable fixtures`
  - `the runnable fixtures`
- Duration literals (numeric + unit suffix):
  - `the runnable fixtures`
- Integer literal base prefixes and legacy octal:
  - `the runnable fixtures`

## String Literals

String literals represent `string` values: immutable, length-tracked sequences of
bytes that are typically interpreted as UTF-8 text.

Use strings for:

- filenames and paths,
- user-visible messages,
- structured formats (JSON, CSV, etc),
- and general “text” data.

If you need a single Unicode scalar value, use `char` literals
(`Character Literals`).

### Semantics

- The value of a string literal is a sequence of bytes.
- By convention and by intent, `string` values represent UTF-8 text, but some
  escape forms (notably `\xNN`) can construct byte sequences that are not valid
  UTF-8. Avoid this unless you are intentionally working with raw bytes.
- String literals are immutable.
- Unless otherwise specified for a particular FFI surface, string literals do
  not implicitly include a trailing `\0` byte; length is carried explicitly.

### Single-Line Strings

Single-line string literals:

- Use standard quote-delimited syntax.
- Support escape sequences as described below.

### Raw Strings (Backtick)

Raw string literals are delimited by backticks:

- `` `...` ``
- They may include newlines directly.
- They do **not** process escape sequences: `\n` is two bytes (`'\'` and `'n'`).
- They still normalize embedded `\r\n` / `\r` in the source text to `\n`.

### Escape Sequences

Double-quoted string literals support the same escape spellings as character
literals:

- `\\` (backslash)
- `\"` (double quote)
- `\'` (single quote)
- `\n` (newline, U+000A)
- `\r` (carriage return, U+000D)
- `\t` (tab, U+0009)
- `\0` (NUL byte, U+0000)
- `\xNN` (byte escape, two hex digits)
- `\u{...}` (Unicode scalar value escape, 1–6 hex digits)

When decoding `\u{...}` escapes, the compiler must reject non-scalar Unicode
values (for example surrogate code points).

### Multi-Line Strings

Multi-line strings:

- Allow embedding newlines directly in the literal.
- Must be represented and encoded identically to `string` values produced at runtime.

### Line Ending Normalization

When decoding string literals, the compiler must normalize:

- `\r\n` to `\n`
- `\r` to `\n`

This applies both to embedded newlines in multi-line literals and to escaped
forms such as `\r`.

Note: a sequence of two escapes like `"\r\n"` is still two escapes. In the
current implementation, `\r` escapes become `\n`, so `"\r\n"` produces two line
feed bytes (`"\n\n"`).

### Examples

#### Basic string literal

```silk
fn main () -> int {
  let s: string = "hello";
  if s == "hello" {
    return 0;
  }
  return 1;
}
```

#### Escapes and byte escapes

```silk
fn main () -> int {
  // Quote and backslash escapes.
  if "\"" != "\x22" { return 1; }
  if "\\" != "\u{005C}" { return 2; }

  // Control escapes.
  if "\t" != "\x09" { return 3; }
  if "\n" != "\x0A" { return 4; }
  if "\r" != "\n" { return 5; } // `\r` is normalized to `\n` in the .

  // NUL bytes are permitted; strings are length-tracked (not NUL-terminated).
  if "\0" != "\x00" { return 6; }

  // Unicode escapes insert UTF-8 bytes for that scalar.
  if "é" != "\u{00E9}" { return 7; }

  return 0;
}
```

#### Multi-line string literal (embedded newline)

```silk
fn main () -> int {
  let multi: string = "a
b";

  // Equivalent to using a `\n` escape.
  if multi != "a\nb" {
    return 1;
  }

  return 0;
}
```

#### Raw multiline string literal (backticks)

```silk
fn main () -> int {
  let multi: string = `a
b`;
  if multi != "a\nb" {
    return 1;
  }

  // Backslashes are literal bytes in raw strings.
  if `a\nb` != "a\\nb" { return 2; }

  return 0;
}
```

### Common Pitfalls

- **Expecting NUL termination**: `"hi"` does not include an implicit `\0`.
  Use `\0` explicitly when you need it, and prefer APIs that are length-aware.
- **Using `\xNN` for non-ASCII characters**: `\xNN` inserts a raw byte, not a
  Unicode scalar. Use `\u{...}` for text.
- **Assuming multi-line indentation stripping**: multi-line strings include all
  bytes between the quotes, including indentation spaces.

### Related Documents

- `Types` (primitive `string` and `char`)
- `Character Literals` (shared escape spellings)
- `C99 ABI and `libsilk.a`` (C ABI string representation)

### Relevant Tests

- Core string equality and ordering:
  - `the runnable fixtures`
  - `the runnable fixtures`
- Escape coverage:
  - `the runnable fixtures`
- Raw/backtick coverage:
  - `the runnable fixtures`

The compiler must:

- Implement lexing and parsing for both `"..."` and `` `...` ``.
- Normalize line endings and escapes according to the spec.
- Ensure compatibility with the FFI `SilkString` representation.

## Regular Expression Literals

Regular expression literals represent `regexp` values: compiled regular
expression bytecode that can be used by `std::regex` helpers.

The regex literal syntax is modeled after JavaScript:

- `/pattern/flags`

### Syntax

#### Delimiters and scanning

Regex literals are scanned by the parser (not the lexer):

- the opening delimiter is a single `/`,
- the closing delimiter is the first unescaped `/` that is **not** inside a
  character class (`[...]`),
- after the closing delimiter, the parser consumes ASCII letters as flags.

The parser does not interpret regex escapes: backslash sequences are preserved
as bytes for the regex engine.

#### Empty patterns and `//`

Because `//` introduces a line comment, an empty regex literal `//` is not a
valid token sequence. Use an explicit empty pattern, for example `/(?:)/`.

### Flags

The supported flag set is intentionally small in Silk:

- `g` — global (recorded; does not change `std::regex::matches` semantics)
- `i` — ignore case
- `m` — multiline
- `s` — dotAll
- `y` — sticky
- `d` — indices (recorded; not surfaced by `std::regex` helpers)

The type checker rejects:

- unknown flags,
- duplicate flags (for example `/a/ii`).

### Semantics

- A regex literal’s value is a non-owning `{ ptr, len }` view (`regexp`) into
  compiled bytecode embedded in read-only data.
- The bytecode format is owned by the runtime regex engine; `regexp` values are
  opaque and must be consumed via `std::regex`.
- In Silk, matching is defined over the raw bytes of the input
  `string`, and match indices are byte offsets.

### Examples

#### Basic `test`

```silk
import std::regex;

fn main () -> int {
  if std::regex::matches(/hello/, "hello world") {
    return 0;
  }
  return 1;
}
```

### Related Documents

- `Types` (`regexp`)
- `Formal Grammar Spec` (regexp literal grammar)
- `std::regex` (runtime regex API)

## Character Literals

Character literals represent Unicode scalar values (code points) and have type
`char` (`Types`).

Use `char` for:

- single-character markers and delimiters (e.g. `','`, `':'`),
- working with code points when interfacing with parsing/lexing logic,
- representing control characters (`'\n'`, `'\t'`, `'\0'`).

If you need multiple characters, use `string` literals (`String Literals`).

### Surface Syntax

Character literals are delimited by single quotes:

```silk
let a: char = 'x';
```

Rules:

- The contents must represent **exactly one Unicode scalar value**.
- A character literal must not span multiple lines.
- The source file is interpreted as UTF-8.

### Escapes

Inside a character literal, `\` introduces an escape sequence.

Supported escapes in the current implementation:

- `\n` — U+000A (line feed)
- `\r` — U+000D (carriage return)
- `\t` — U+0009 (tab)
- `\0` — U+0000 (NUL)
- `\\` — backslash
- `\'` — single quote
- `\"` — double quote
- `\xNN` — a code point given as exactly two hex digits
- `\u{...}` — a code point given as 1–6 hex digits

Unicode rules:

- The decoded code point must be a Unicode scalar value:
  - range `0x0000..=0x10FFFF`, excluding the surrogate range
    `0xD800..=0xDFFF`.
- For `\u{...}`, values outside that range are rejected.

### Semantics

Evaluating a character literal produces a `char` value whose numeric value is
the decoded Unicode code point.

In Silk, that code point is carried as a `u32` scalar.
This is an implementation detail; the language-level rule is “a `char` is a
Unicode scalar value”.

### Examples

#### ASCII and punctuation

```silk
fn main () -> int {
  let comma: char = ',';
  if comma == ',' {
    return 0;
  }
  return 1;
}
```

#### Unicode: literal UTF-8 vs `\u{...}`

```silk
fn main () -> int {
  let a: char = 'é';
  let b: char = '\u{00E9}';
  if a == b {
    return 0;
  }
  return 1;
}
```

#### Escape sequences

```silk
fn main () -> int {
  if '\n' != '\x0A' { return 1; }
  if '\r' != '\x0D' { return 2; }
  if '\t' != '\x09' { return 3; }
  if '\0' != '\x00' { return 4; }
  if '\\' != '\u{005C}' { return 5; }
  if '\'' != '\x27' { return 6; }
  if '\"' != '"' { return 7; }
  return 0;
}
```

### Common Pitfalls

- **Using double quotes**: `"x"` is a `string`, not a `char`. Use `'x'`.
- **Writing more than one character**: `'ab'` is invalid; use `"ab"`.
- **Source encoding surprises**: prefer `\u{...}` for non-ASCII characters when
  you want the source spelling to be stable across editors/fonts.
- **Confusing `\xNN` between `char` and `string`**:
  - for `char`, `\xNN` denotes a code point value,
  - for `string`, `\xNN` denotes a raw byte (`String Literals`).

### Related Documents

- `Types` (primitive `char` and `string`)
- `String Literals` (string literals and escape sequences)
- `Operators` (`as` casts for int-like types, including `char`)

### Relevant Tests

- Unicode char equality and `\u{...}` escape:
  - `the runnable fixtures`
- Returning and comparing `char` values:
  - `the runnable fixtures`
- Escape coverage:
  - `the runnable fixtures`

## Aggregate Literals

Aggregate literals cover arrays and structs.

### Array Literals

Array literals construct fixed-size array values from a list of elements.

#### Surface Syntax

An array literal is written using square brackets:

```silk
let xs = [1, 2, 3];
let ys = [1, 2, 3,]; // trailing comma allowed
```

Empty array literals are permitted only when an expected array type is
available from context (so the compiler knows the element type and, for
fixed-size arrays, the required length):

```silk
let empty: i32[0] = [];
let empty_slice: i32[] = [];
```

#### Typing

- A non-empty array literal has type `T[N]` where `N` is the number of
  elements and `T` is inferred from the elements (or from an expected type
  when present).
- When an expected type is present and it is `T[N]`, the literal must contain
  exactly `N` elements.
- When an expected type is present and it is `T[]`, the literal’s elements are
  type-checked against `T` and the resulting value has type `T[]`.
  - In Silk, this slice form is lowered as a non-owning
    view over a compiler-generated backing array.
  - The current implementation does not yet enforce lifetime rules for such
    slices; do not allow a slice derived from a stack-backed array literal to
    outlive the scope where it was created.

Compiler requirements:

- Infer element type when possible, or require explicit annotation where
  ambiguity exists.
- Validate that all elements are convertible to the target element type.
- Enforce current-subset restrictions on which element types are supported for
  array lowering/codegen (see `Types` and
  `Structs, Impl Blocks, and Memory Layout`).

### Struct Literals

Struct literals construct values of `struct` types by specifying field names and values.

#### Surface Syntax

A struct literal may be written in two forms:

- An **explicit** struct literal begins with a struct type name followed by a
  brace-enclosed field initializer list.
- A **contextual (inferred)** struct literal omits the type name and consists
  only of the brace-enclosed field initializer list. This form is only valid
  when an expected struct type is available from context (for example a
  function argument position or an explicit type annotation).

An explicit struct literal looks like:

```silk
struct Pair {
  a: int,
  b: int,
}

fn make () -> Pair {
  return Pair { a: 1, b: 2 };
}
```

An inferred struct literal looks like:

```silk
struct User {
  name: string,
}

fn print_user (user: User) -> void {
  std::println("user.name = {}", user.name);
}

fn main () -> int {
  // Equivalent to: `print_user(User{ name: "user name" });`
  print_user({ name: "user name" });
  return 0;
}
```

Initializers are written as either:

- `field_name: <expr>` (explicit initializer), or
- `field_name` (shorthand initializer, equivalent to `field_name: field_name`).

Initializers are separated by commas and an optional trailing comma is
permitted.

Example (shorthand):

```silk
struct User {
  name: string,
}

fn main () -> int {
  let name: string = "alice";
  let user = User{ name }; // equivalent to `User{ name: name }`
  if (user.name != "alice") { return 1; }
  return 0;
}
```

#### Field defaults (struct declarations)

A `struct` field declaration may include a default value expression:

```silk
struct Beep {
  value: string = "boop",
}
```

When a struct literal omits a field, the compiler uses the field default
expression when present; otherwise it falls back to zero-initialization in the
current backend subset. This means the empty literal form is useful when all
fields have defaults:

```silk
let b = Beep {};
```

Important notes:

- Inferred struct literals are a **value** construction mechanism. They do not
  imply heap allocation. The compiler will not infer `&T` from `{ ... }`; use
  `new` for heap allocation explicitly.
- The parser only treats `{ ... }` as an inferred struct literal when it
  contains a struct-style initializer list (or is `{}`); blocks (`{ Stmt* }`)
  remain statement syntax (there is no general “block expression” in the current
  subset).

Compiler requirements:

- Enforce that field names are valid and that each field is initialized at most once.
- Define the behavior for omitted fields (in Silk, omitted fields
  are default-initialized).
- Respect struct lowering/layout rules from `Structs, Impl Blocks, and Memory Layout`.

#### Details

The current compiler implementation supports struct literals only for the
limited struct subset described in `Structs, Impl Blocks, and Memory Layout`:

- structs with 0+ fields of supported value types (scalar primitives, `string`,
  nested structs, and supported optionals),
- literals may omit fields:
  - omitted fields that have a field default (`field: T = <expr>`) use that
    default expression,
  - otherwise, omitted fields are **zero-initialized** in the current backend
    subset,
- no duplicate field initializers are permitted,
- field order is not semantically significant.

## Boolean Literals

Boolean literals are the two built-in logical values:

- `true`
- `false`

They have type `bool` (`Types`).

### Examples

#### Basic control flow

```silk
fn main () -> int {
  let ready: bool = true;
  if ready {
    return 0;
  } else {
    return 1;
  }
}
```

#### Short-circuit evaluation

```silk
fn returns_false () -> bool {
  return false;
}

fn main () -> int {
  // Because the left operand is `true`, the right operand is evaluated.
  let a: bool = true && returns_false();
  if a {
    return 1;
  }

  // Because the left operand is `false`, the right operand is not evaluated.
  let b: bool = false && returns_false();
  if b {
    return 2;
  }

  return 0;
}
```

### Common Pitfalls

- **Assuming “truthy” values**: `bool` is a distinct type. Use comparisons to
  produce a `bool` (for example `x != 0`) rather than writing `if x { ... }`.
- **Forgetting short-circuiting**: `&&` and `||` may skip evaluating the right
  operand; do not rely on side effects in the skipped operand.

### Related Documents

- `Types` (the `bool` type)
- `Operators` (`!`, `&&`, `||`)
- ``if` / `else`` (`if` statement semantics)
- ``while` Loop` (`while` statement semantics)

### Relevant Tests

- Boolean control flow:
  - `the runnable fixtures`
  - `the runnable fixtures`
- Short-circuit semantics:
  - `the runnable fixtures`
  - `the runnable fixtures`
- Unary `!`:
  - `the runnable fixtures`

## Duration Literals

The `Duration` and `Instant` types have specialized literal support.

### Syntax

Duration literals are written as a decimal integer or decimal float immediately
followed by a unit suffix:

- Examples:
  - `10ns`
  - `250us`
  - `5ms`
  - `1s`
  - `1.5s`
  - `2min`
  - `1h`

The unit suffix is part of the literal token; the lexer must not split it into
an integer token followed by an identifier.

### Units

The current implementation recognizes the following suffixes:

- `ns` — nanoseconds
- `us` — microseconds
- `ms` — milliseconds
- `s` — seconds
- `min` — minutes
- `h` — hours
- `d` — days

### Semantics

Duration literals evaluate to a `Duration` value represented as an `i64`
nanosecond count.

- For integer forms (e.g. `5ms`), the value is scaled exactly.
- For floating-point forms (e.g. `1.5s`), the value is scaled and then rounded
  toward zero to an integral nanosecond count.

If the scaled value does not fit in `i64`, compilation fails.

Compiler requirements:

- Implement lexing rules that distinguish unit suffixes from identifiers.
- Map duration literals to the `Duration` type with correct unit scaling.
- Ensure constant-evaluation behavior (rounding, overflow) matches the spec.

## Flow Control Overview

Flow control describes how Silk programs sequence work, branch, loop, and exit.
This concept spans several surface constructs and their static rules (typing,
scoping, and diagnostics).

### Core Constructs

- `if` / `else`
- `loop` loops
- `while` loops
- `for` loops
- `match` expressions
- `return`
- `break`
- `continue`
- blocks and statement composition
- expression statements

Each construct has defined syntax, typing, and evaluation semantics which the
compiler must implement.

### Principles

These rules help keep control flow explicit and statically checkable:

- Conditions are boolean: `if` and `while` require a `bool` condition (no
  integer “truthiness”).
- Bodies are blocks: flow constructs use `{ ... }` blocks as their bodies.
- Statements are terminated: most statement forms end with `;` (for example
  `let`, `return`, `break`, `continue`, `panic`, `assert`, and expression
  statements).

### Quick Examples

Branching:

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  } else {
    return 1;
  }
}
```

Looping:

```silk
fn main () -> int {
  let mut i: int = 0;
  while i < 3 {
    i += 1;
  }
  return 0;
}
```

Matching:

```silk
fn main () -> int {
  let x: int? = Some(7);
  let y: int = match x {
    None => 0,
    Some(v) => v,
  };
  return y;
}
```

See the dedicated documents:

- ``if` / `else``
- ``loop` Loop`
- ``while` Loop`
- ``for` Loop`
- ``match` Expression`
- ``return``
- ``break``
- ``continue``
- `Blocks and Statement Composition`
- `Expression Statements`

## `if` / `else`

The `if` / `else` construct provides branching based on a boolean condition.

In Silk, `if` is a **statement** that selects which
block of statements executes. The broader language design also includes
expression-oriented forms; those are documented as planned where relevant.

### Surface Syntax

Minimal form:

```silk
if <condition> {
  ...
}
```

With an `else`:

```silk
if <condition> {
  ...
} else {
  ...
}
```

Notes:

- `<condition>` is an expression; parentheses are optional because the normal
  expression grammar already includes parenthesized expressions.
- Bodies are blocks. `else` may be followed by either:
  - a block (`else { ... }`), or
  - another `if` (`else if ... { ... }`) to form an “else-if” chain.

### Surface Syntax (Expression Form)

Silk also supports `if` / `else` as an **expression** form that yields a value:

```silk
let v: int = if cond { 123 } else { 456 };
```

Notes:

- `if` expressions require an `else` branch so the expression yields a value on
  all paths.
- The `else if ...` chain form is supported in expression position:

  ```silk
  let v: int = if a { 1 } else if b { 2 } else { 3 };
  ```

- Current compiler subset restriction: the `{ ... }` bodies of `if` expressions
  contain a single expression (not a full statement block).

### Semantics

- The condition expression is evaluated exactly once.
- If the condition is `true`, the `if` block executes and the `else` block (if
  present) does not execute.
- If the condition is `false`, the `else` block executes if present; otherwise
  the `if` statement does nothing.

Blocks create scopes:

- Declarations inside the `if` body are not visible outside that body.
- Declarations inside the `else` body are not visible outside that body.

### Type Checking Rules

- The condition must have type `bool`. If it does not, the checker reports a
  type mismatch (`Compiler Diagnostics`, `E2001`).

For `if` expressions:

- The `then` and `else` branches must produce compatible value types.
- The expression’s result type is the shared branch type (or the expected type
  when the expression is type-directed).

### `else if` Chains

The language supports chained conditions (“else-if chains”). The compiler
parses `else if` as sugar for nesting an `if` inside the `else` block:

```silk
fn main () -> int {
  let x: int = 1;

  if x == 0 {
    return 0;
  } else {
    if x == 1 {
      return 1;
    } else {
      return 2;
    }
  }
}
```

The equivalent direct surface form is:

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  } else if x == 1 {
    return 1;
  } else {
    return 2;
  }
}
```

### Examples

#### Minimal `if` / `else`

```silk
fn main () -> int {
  if true {
    return 0;
  } else {
    return 1;
  }
}
```

#### Boolean expressions in conditions

```silk
fn main () -> int {
  let x: int = 1;
  let y: int = 2;

  if x < y && y < 10 {
    return 3;
  } else {
    return 4;
  }
}
```

#### Control flow inside branches

```silk
fn main () -> int {
  let x: int = 1;
  let y: int = 2;

  if x < y {
    while false {
      continue;
    }
    return 3;
  } else {
    return 4;
  }
}
```

## `while` Loop

The `while` loop repeatedly executes a block while a boolean condition holds.

### Surface Syntax

Minimal form:

```silk
while <condition> {
  // body
}
```

`<condition>` is an expression. Parentheses are optional because the condition
is parsed using the normal expression grammar:

```silk
while (x < y && y < 10) {
  ...
}
```

#### Loop Specifications (`#invariant` / `#variant` / `#monovariant`)

The language supports attaching loop specifications immediately before a
`while`. This is part of Formal Silk (see `Formal Silk`).
When Formal Silk syntax is present, the compiler proves these obligations with
Z3 at compile time.

```silk
#invariant <expr>;
#variant <expr>;
#monovariant <expr>;
while <condition> {
  ...
}
```

### Semantics

Evaluation rules:

- The condition is evaluated before each iteration.
- If the condition evaluates to `true`, the body block executes.
- After the body completes normally, control returns to the condition.
- If the condition evaluates to `false`, the loop terminates and execution
  continues after the loop statement.

Control-flow statements inside the body follow their own definitions:

- `break` exits the nearest enclosing loop (``break``).
- `continue` skips to the next iteration (``continue``).
- `return` exits the function (``return``).
- `panic` exits the function via the typed error system (`Typed Errors (`error`, `panic`, and `T | ErrorType...`)`).

Blocks create scopes. A `let` declared inside the body is not visible outside
the loop’s body block.

### Type Checking Rules

The checker enforces:

- The loop condition must have type `bool` (otherwise `E2001`).
- Each `#invariant` expression must have type `bool` (otherwise `E2001`).
- If present, the `#variant` expression must have an integer type (`int` or a
  fixed-width integer; otherwise `E2001`).
- Each `#monovariant` expression must have an integer type (`int` or a
  fixed-width integer; otherwise `E2001`).

`#invariant`, `#variant`, and `#monovariant` expressions are compile-time-only
(erased from runtime code). When Formal Silk verification is enabled by syntax,
they are proved with Z3 during compilation.

### Examples

#### Minimal loop with `break`

```silk
fn main () -> int {
  while true {
    break;
  }
  return 0;
}
```

#### Loop with invariants and a variant

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  while i < limit {
    i = i + 1;
  }

  return 0;
}
```

## `break`

`break` exits the nearest enclosing loop.

### Surface Syntax

```silk
break;
```

Notes:

- `break` is a statement, terminated by a semicolon.
- `break` does not carry a value in the current language design; there is no
  `break <expr>` form.

### Semantics

When executed, `break;`:

- terminates the innermost enclosing loop (`loop`, `while`, or `for`), and
- continues execution at the statement immediately following that loop.

In nested loops, `break` only exits the nearest loop:

```silk
fn main () -> int {
  while true {
    while true {
      break; // exits the inner loop only
    }
    break; // exits the outer loop
  }
  return 0;
}
```

`break` does not exit the current function. Use `return` for that.

### Type Checking Rules

- `break` is only permitted inside a loop body.
- A `break` outside a loop is a type-check error (`Compiler Diagnostics`,
  `E2007`).

### Common Pitfalls

- Forgetting the semicolon (`break` is a statement).
- Expecting `break` to return a value (not supported).
- Using `break` outside a loop (rejected, `E2007`).

## `continue`

`continue` skips the remainder of the current loop iteration and jumps to the
next iteration of the nearest enclosing loop.

### Surface Syntax

```silk
continue;
```

Notes:

- `continue` is a statement, terminated by a semicolon.

### Semantics

When executed inside a loop body, `continue;`:

- stops executing the remainder of the current iteration’s body, and
- transfers control to the loop’s “next iteration” point:
  - for `loop`, this means jumping to the start of the loop body.
  - for `while`, this means re-evaluating the loop condition.
  - for `for`, this means advancing to the next iteration (and for C-style `for`
    loops, executing the loop step before re-checking the loop condition).

Example:

```silk
fn main () -> int {
  let mut i: int = 0;
  while i < 10 {
    i += 1;
    if i == 5 {
      continue; // skips the return below for i == 5
    }
    // More work could happen here.
  }
  return 0;
}
```

In nested loops, `continue` applies to the nearest loop:

```silk
fn main () -> int {
  while true {
    while true {
      continue; // continues the inner loop
    }
  }
  return 0;
}
```

### Type Checking Rules

- `continue` is only permitted inside a loop body.
- A `continue` outside a loop is a type-check error (`Compiler Diagnostics`,
  `E2008`).

### Common Pitfalls

- Forgetting the semicolon (`continue` is a statement).
- Expecting `continue` to exit the loop (it does not; use `break`).
- Using `continue` outside a loop (rejected, `E2008`).

## `return`

The `return` statement exits a function, optionally with a value.

### Surface Syntax

Return a value:

```silk
return <expr>;
```

Return from a `void` function:

```silk
return;
```

### Semantics

When a `return` statement executes:

- the current function terminates immediately, and
- control transfers back to the caller,
- carrying a return value if the function’s result type is non-`void`.

No statements after a `return` in the same control-flow path are executed.

### Type Checking Rules

The checker enforces:

- `return` is only valid inside a function body (otherwise `E2009`).
- In a function with non-`void` result type `R`, `return` must provide an
  expression whose type is `R` (otherwise `E2009`).
- In a `void` function, `return;` is permitted and `return <expr>;` is rejected
  (`E2009`).
- In a function with non-`void` result, falling off the end of the function
  body is a compile-time error (`Compiler Diagnostics`, `E2010`).

### Examples

#### Returning from `main`

```silk
fn main () -> int {
  return 0;
}
```

#### Early return

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  }
  return 1;
}
```

#### `return;` in a `void` function

```silk
struct Counter {
  value: int,
}

impl Counter {
  fn inc (mut self: &Counter) -> void {
    self.value += 1;
    return;
  }
}
```

## `match` Expression

The `match` expression provides structured pattern matching.

Key ideas:

- A `match` selects one of several branches based on a scrutinee expression.
- Patterns and guards are defined as per the language specification in `this specification`.
- `match` is an expression; all arms must be compatible in type.

The compiler must:

- Enforce exhaustiveness rules (where specified).
- Type check each arm and compute a consistent result type.

### Surface Syntax

The full language design includes rich pattern matching, guards, and matching
over many scrutinee types. The current compiler implementation supports only a
narrow, explicitly documented subset so we can validate end-to-end lowering and
code generation.

In the current implementation, `match` is accepted as an *expression* of the
form:

```silk
match <scrutinee> {
  <pattern> => <expr>,
  <pattern> => <expr>,
}
```

Notes:

- Arms are separated by commas; a trailing comma is permitted.
- Arm bodies are expressions (not blocks) in the current implementation.

#### Optional Matching (`T?`)

The currently implemented pattern subset is limited to optionals:

- The scrutinee expression must have optional type `T?` (`Option(T)`), where `T`
  is a payload type supported by the backend.
- Patterns are restricted to:
  - `None`
  - `Some(<name>)`
  - `Some(_)`
- No guards (`if ...`) are implemented yet.
- Matches must be exhaustive for the optional scrutinee: there must be exactly
  one `None` arm and exactly one `Some(...)` arm (order is not significant).

Example:

```silk
fn main () -> int {
  let x: int? = Some(7);
  let y: int = match x {
    None => 5,
    Some(v) => v,
  };
  return y;
}
```

#### Enum Matching (`enum`)

The language design supports matching over user-defined `enum` types
(``enum` Types`).

Defined initial subset:

- The scrutinee expression must have an enum type `E` (including an
  instantiated generic enum in module-set builds).
- Patterns are restricted to enum variants:
  - unit variants: `E::Cancelled` or `Cancelled`
  - tuple variants: `E::Msg(x)` / `Msg(x)` / `E::Pair(a, b)` / `Pair(a, b)` (binders may be identifiers or `_`)
- For instantiated generic enums, the qualifier `E` in patterns may be a type
  alias for the instantiation (for example `type R = Result(int, string);` then
  `R::Ok(v)` / `R::Err(e)`), or patterns may omit the qualifier and use the
  variant name directly.
- No guards (`if ...`) are implemented yet.
- Matches must be exhaustive for the enum scrutinee in the initial subset:
  there must be exactly one arm for each enum variant (order is not
  significant).

#### Type Union Matching (`T1 | T2 | ...`)

The language supports matching over **type unions** (`Type Unions (`T1 | T2 | ...`)`).

Defined initial subset:

- The scrutinee expression must have a union type `T1 | ... | Tn`.
- Patterns are restricted to typed binders:
  - `name: Ti` (binds the payload as `Ti`), or
  - `_: Ti` (matches and ignores the payload),
  where `Ti` is one of the union member types.
- No guards (`if ...`) are implemented yet.
- Matches must be exhaustive: there must be exactly one arm per union member
  type (order is not significant).

### Semantics (Initial Subset)

- The scrutinee expression is evaluated exactly once.
- The selected arm is chosen based on the scrutinee value; non-selected arms
  are not evaluated.
- For `Some(v) => ...`, the binder `v` is in scope only within that arm and has
  type `T` (the inner payload type of the scrutinee `T?`).
- The result type of a `match` expression is the common type of its arms; all
  arms must type-check to the same result type in the current implementation.

### `match` Statement (Typed Errors)

The language design also includes a statement form of `match` used for
*typed errors* (`Typed Errors (`error`, `panic`, and `T | ErrorType...`)`).

Surface form:

```silk
match (expr) {
  pattern => { ... },
  err: SomeError => { std::abort(); }
}
```

Key semantic rule (Terminal Arm Rule):

- If `expr` is an error-producing expression (its signature includes `T | ErrorType...`),
  then any arm that matches an `error` type must end in a terminal statement.


- The compiler currently implements `match` as an expression for:
  - the optional subset (`T?`), and
  - exhaustive `enum` matches (no guards) for the current CFG IR backend subset.
- The statement form required for typed errors is implemented as part of the
  typed errors feature work and is described in `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`.

Note: the compiler also allows the `match` statement form to destructure
recoverable `Result`-style values. This form does not trigger the Terminal Arm
Rule because it is not a `T | ...` typed-error expression.

#### Result Matching (`Ok(...)` / `Err(...)`)

The `match` expression also supports a small subset for
recoverable “success or error” values. In the current implementation this
includes:

- `std::result::Result(T, E)` (an `enum` with `Ok(T)` and `Err(E)` variants), and
- “Result-like” structs of the form `{ value: T?, err: E? }`.

For the struct form, the runtime invariant is: exactly one of `value` and `err`
is `Some(...)`. If this invariant is broken at runtime, execution traps.

Patterns:

- `Ok(name)` / `Ok(_)`
- `Err(name)` / `Err(_)`

Rules ():

- Enum form:
  - The scrutinee expression must have an enum type with variants `Ok` and `Err`.
  - `Ok(...)` / `Err(...)` patterns are shorthand for `R::Ok(...)` / `R::Err(...)` where `R`
    is the scrutinee enum type, and may appear alongside other enum variant patterns.
  - Exhaustiveness follows the enum rules: there must be exactly one arm per enum variant.
- Struct form:
  - The scrutinee expression must have a nominal struct type that contains
    `value: T?` and `err: E?`.
- Matches must be exhaustive:
  - for enum scrutinees, follow the enum rules (one arm per variant),
  - for struct scrutinees, there must be exactly one `Ok(...)` arm and exactly one `Err(...)` arm.
- In `Ok(v) => ...`, the binder `v` has type `T`.
- In `Err(e) => ...`, the binder `e` has type `E`.

Example:

```silk
import std::result;
import std::strings::String;

fn main () -> int {
  let s: String = match String.from_string("hello") {
    Ok(v) => v,
    Err(_) => String.empty(),
  };
  return s.len as int;
}
```

### Relevant Tests

- Optional `match` expressions:
  - `the runnable fixtures`
- Enum `match` expressions:
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
- Union `match` expressions:
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
- Result-like `match` expressions:
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
- Typed error-handling `match` statements:
  - `the runnable fixtures`
  - `the runnable fixtures`

## Structs, Impl Blocks, and Memory Layout

Structs and impl blocks are separated:

- `struct` declarations define pure data layout.
- `impl` blocks attach behavior to types without changing their layout.

### `struct` Declarations

Structs define a composite data type made of named fields:

```silk
struct Packet {
  sequence: u32,
  size: u16,
  flag: u8,
}
```

Key rules:

- Structs contain only data members.
- Memory layout and padding are well-defined so that FFI and ABI rules can rely on them.
- Stack vs heap allocation is specified in `Memory Model (Stack, Heap, and Moves)`.

#### Generic structs

Structs may declare type parameters:

```silk
struct Data(T) {
  value: T,
}
```

Rules:

- A generic `struct Name(T, ...)` introduces a **type constructor** `Name`.
- Outside a generic context, uses of the type must be fully applied (for
  example `Data(u8)`), not bare `Data`.
- A declaration name may not be reused across different generic arities (for
  example `struct Foo { ... }` and `struct Foo(T) { ... }` cannot both exist in
  the same namespace).

#### Field Default Initializers

Struct fields may include an optional default initializer expression:

```silk
struct Point {
  x: int = 0,
  y: int = 0,
}
```

When a struct literal omits a field, the compiler initializes the field from its
default expression.

In Silk, default field expressions use the same
restriction as default function arguments:

- no name references, and
- no `new`.

Example:

```silk
struct Point {
  x: int = 0,
  y: int = 0,
}

fn main () -> int {
  let p = Point{ x: 5 };
  return p.y; // defaults to 0
}
```

#### Single Inheritance (`extends`)

Silk supports **single inheritance** for `struct` declarations via `extends`.

Surface syntax:

```silk
struct Base {
  x: int,
  y: int = 0,
}

struct Derived extends Base {
  z: int,
}
```

Semantics:

- A derived struct inherits all fields of its base struct.
- The derived struct’s field sequence is:
  1) all base fields (in declaration order), then
  2) all derived fields (in declaration order).
- Field access on the derived struct can refer to inherited base fields
  directly (`d.x`, `d.y`).
- Default field initializers are inherited:
  - a `Derived{ ... }` literal may omit inherited fields that have defaults in
    the base struct.

Type checking rules:

- `extends` is permitted only on non-opaque `struct` declarations.
- The base name must resolve to a `struct` type in the compiled module set.
- Cycles in `extends` chains are rejected.
- A derived struct may not declare a field whose name conflicts with an
  inherited field name.

Notes:

- `extends` does not imply implicit subtyping in Silk:
  there is no implicit coercion from `Derived` to `Base` (or `&Derived` to
  `&Base`) yet.

#### Opaque Structs (FFI Handles)

Opaque structs are a special form of `struct` declaration intended for safely
representing foreign pointers/handles from C APIs.

Syntax:

```silk
// Declares an opaque handle type.
struct MyFFIHandle;
```

An opaque struct has **no fields** and **no Silk-defined layout**. It exists
only as a nominal handle type that can be passed around safely.

Rules:

- Opaque structs **cannot be instantiated** (no struct literals).
- Opaque structs **do not support field/member access** (`.` / `?.`).
- Opaque structs **must not be used by value** in type positions (locals,
  parameters, results). Only the reference form `&MyFFIHandle` is allowed.

These rules increase safety at the language boundary:

- **Eliminates type confusion**: distinct handle types such as `&DatabaseHandle`
  and `&FileHandle` are not interchangeable.
- **Prevents invalid operations in Silk**: Silk code cannot read/write fields or
  assume a size/layout for the foreign type.

##### Safety and Undefined Behavior (UB)

Opaque handles do not carry lifetime information. You are responsible for
calling the corresponding destruction/free function provided by the foreign
library.

Using an opaque handle after it has been destroyed is **undefined behavior**.
The compiler does not currently enforce this at compile time.

##### ABI and Lowering ()

In Silk, an `&Opaque` value is lowered as a single pointer
scalar (`u64` on the current `linux/x86_64` target), rather than as a
struct-of-pointers like `&struct` borrows.

#### Memory Layout (Intended Contract)

The long-term Silk design is for `struct` layout to match conventional C layout
rules for the corresponding field types on the target:

- **Sequential layout**: fields appear in memory in the exact order they are
  declared in the `struct` definition.
- **Alignment and padding**: each field is placed at an offset that is a
  multiple of the field type’s required alignment. The compiler inserts padding
  bytes where necessary.
- **Final padding**: the overall struct size is padded to a multiple of the
  struct’s alignment (typically the maximum alignment of its fields), so arrays
  of the struct keep each element correctly aligned.

Example (typical C layout on `linux/x86_64`):

```silk
struct Packet {
  sequence: u32, // 4 bytes
  size: u16,     // 2 bytes
  flag: u8,      // 1 byte
}
```

Conceptually, this layout would be:

- `sequence` at offset `0` (4 bytes)
- `size` at offset `4` (2 bytes)
- `flag` at offset `6` (1 byte)
- 1 byte of tail padding at offset `7` to make the total size a multiple of 4

Total size: 8 bytes (alignment 4).

#### Memory Layout

the compiler does **not** implement packed C-like struct
layout yet. Instead, it uses a *scalar slot* model:

- A `struct` value is lowered into a sequence of scalar “slots” in source order,
  after recursively expanding certain composite field types:
  - `string` contributes two slots: `(u64 ptr, i64 len)`.
  - nested non-opaque structs contribute their slot sequence.
  - optionals contribute `(bool tag, payload slots...)`, where payload slots
    follow the lowering of the underlying non-optional type.
- When a `struct` is stored in memory (stack locals and heap boxes), each slot
  is stored in a separate **8-byte cell**.
  - This means sub-64-bit fields (`bool`, `i8`/`u8`, `i32`/`u32`, `f32`, `char`,
    etc.) are not packed yet.
  - Values are still *typed* as their declared scalar kinds (the checker and IR
    track widths/sign), but the physical in-memory representation is widened to
    one 8-byte slot per scalar.

This design keeps lowering/codegen simple and lets the compiler support nested
aggregates without committing to a final packed layout. The trade-off is that
the in-memory representation is not ABI-compatible with a C struct unless the
struct is restricted to ABI-safe 64-bit slots.

Example (current implementation): the `Packet` above is lowered as 3 scalar
slots and occupies 24 bytes when stored in memory (3 × 8-byte cells), even
though the intended C-like packed layout would be 8 bytes.

#### ABI and Code Generation

The Silk language design includes full support for user-defined structs, nested
aggregates, and FFI-safe ABI mapping. The current compiler/backend
implementation supports only a narrow, explicitly documented subset:

- Only "plain" structs with **0+ fields** are supported by codegen.
  - Empty structs (`struct Empty {}`) are currently represented as a single
    placeholder `u64` slot in the scalar-slot model.
- Fields may be:
  - scalar primitive types (`bool`, fixed-width integers, `int`, `char`,
    `f32`/`f64`, `Instant`, `Duration`),
  - `string` (lowered as `{ ptr: u64, len: i64 }`),
  - nested (non-opaque) structs,
  - and optionals (`T?`) of supported payload types.
- At ABI boundaries (exported functions and `ext` declarations), structs must be
  ABI-safe: after slot-flattening, all slots must be `i64`/`u64`/`f64` (for
  example `string` fields are ABI-safe because they lower to `(u64, i64)`, but
  `bool`, `char`, and `f32` fields are not).
- Such structs are passed and returned by value by lowering them to their
  scalar slots in order and following the System V AMD64 ABI rules for
  those scalar slots:
  - integer-like slots consume general-purpose argument slots (`rdi`, `rsi`,
    `rdx`, `rcx`, `r8`, `r9`, then the stack),
  - `f32`/`f64` slots consume XMM argument slots (`xmm0`..`xmm7`, then the stack),
  - 1–2 slot results use `rax`/`rdx` for integer-like slots and `xmm0`/`xmm1`
    for float slots, with mixed aggregates using both,
  - 3+ slot results return indirectly via a hidden sret pointer passed in `rdi`
    (caller-allocated return buffer), with the callee storing each scalar slot
    sequentially and returning the pointer in `rax`.

Note: at the C ABI surface, exported functions accept ABI-safe structs by
flattening parameters to their scalar slots in order. For 1–2 slot structs this
is ABI-compatible with passing an equivalent by-value C struct parameter, while
for 3+ slot structs downstream C callers should declare separate scalar
parameters for the slots. Struct returns with 3+ slots use sret and are
ABI-compatible with returning an equivalent C struct by value.

This subset is intentionally small so that we can validate the end-to-end type
pipeline (parsing → checking → lowering → IR→ELF codegen) while keeping ABI
behavior consistent with C for the supported cases.

### `impl` Blocks

`impl` blocks attach functions and methods to existing types without affecting
memory layout.

The intent is to provide “high-level” APIs without baking behavior into `struct`
layout. In the initial implementation, `impl` blocks are *syntax and
type-checking structure*; code generation treats methods as ordinary functions
that follow the same calling conventions as other Silk functions.

#### Generic impl blocks

If a type is declared with type parameters (struct or enum), its impl blocks
must also declare those type parameters:

```silk
struct Data(T) { value: T }

// OK:
impl Data(T) {
  fn get(self: &Self) -> T { return self.value; }
}

// Error:
// impl Data { ... }
```

This rule makes monomorphization explicit and ensures method receivers are not
ambiguous when the type is specialized.

#### Syntax

```silk
impl List {
  // Ordinary static method (no receiver).
  fn init (cap: i64) -> List { ... }

  // Heap constructor used by `new List(...)` (special name, receiver + `void`).
  fn constructor (mut self: &Self, cap: i64) -> void { ... }

  // Instance method (receiver as first parameter).
  public fn len (self: &List) -> i64 { ... }

  // Mutating instance method (mutable receiver).
  public fn push (mut self: &List, value: u8) -> void { ... }
}
```

Rules:

- An `impl` block attaches methods to exactly one nominal type name (a `struct`
  or an `enum`).
- Multiple `impl` blocks may exist for the same type name; the compiler merges
  their methods (subject to duplicate-name rules).
- Methods inside an `impl` block are `fn` declarations (with bodies).
- The receiver, when present, is the first parameter and must be a borrowed
  reference to the `impl` type (`self: &Type` or `mut self: &Type`).
- Within an `impl` block, the special type name `Self` may be used anywhere a
  type name is accepted, and is treated as an alias for the `impl` type.
  For example, `self: &Self` is equivalent to `self: &Type`, and `-> Self` is
  equivalent to `-> Type`.
- Static methods omit the receiver parameter.
- Method visibility:
  - Methods are **private by default**: a method declared without an explicit
    visibility modifier is callable only within the **defining `impl { ... }`
    block**.
  - `public fn` marks a method as callable from outside the defining `impl`
    block.
  - `private fn` is permitted to make intent explicit.
  - `export` is reserved for static members (no `self` receiver) and is not
    permitted on instance methods; use `public fn` instead.
  - When an `impl` block declares conformance to an interface (`impl T as I`),
    the interface’s required methods are **public by definition**:
    - the corresponding impl methods may omit `public`, but
    - they may not be explicitly marked `private`.
    See `Interfaces`.
- The method named `constructor` is treated specially:
  - it is only meaningful for `struct` types (it backs `new Type(...)`); enums
    do not support `constructor` methods in Silk,
  - it is `public` by default,
    - when explicitly marked `private`, it is callable only within the defining
      `impl { ... }` block,
  - it may be declared multiple times in a single `impl` block (an overload set),
  - its overload set includes `constructor` declarations across all merged
    `impl` blocks for the type,
  - it is invoked by heap allocation (`new Type(...)`) and by certain
    call-argument coercions (see `Types`),
  - `new Type(args...)` invokes the unique overload whose receiver is
    `mut self: &Type`, whose return type is `void`, and whose non-receiver
    parameter list matches `args...` after applying the normal call-argument
    type-checking rules,
  - if multiple overloads are applicable, the compiler prefers overloads that do
    **not** rely on implicit call-argument coercions (notably the `U -> &T`
    constructor coercion for `&T` parameters); if multiple overloads remain tied,
    the call is rejected as ambiguous.

#### Call syntax

The surface call syntax uses field-access + call:

- Instance method call: `value.method(arg0, arg1, ...)`
- Static method call: `Type.method(arg0, arg1, ...)`

Semantically, method calls behave like ordinary function calls where the
receiver is passed as an explicit first argument.

Static-method receiver sugar ():

- If `value.method(...)` does not resolve to an instance method (a method whose
  first parameter is a receiver `self: &Type` / `mut self: &Type`), the
  compiler may resolve it as a call to a visible static method of the receiver
  type by inserting the receiver as the first argument: `Type.method(value, ...)`.
- This supports fluent chaining for value-consuming helper APIs like
  `std::result::Result.unwrap_or`:

  ```silk
  let r: R = /* ... */;
  let x: int = r.unwrap_or(0); // sugar for `R.unwrap_or(r, 0)`
  ```

Mutability rule ():

- If the method receiver is `self: &Type`, the call site passes a read-only
  borrow of the receiver (for example `value.method(...)`).
- If the method receiver is `mut self: &Type`, the call site must pass a
  mutable borrow of the receiver.
  - When the receiver is a **name binding** that is mutable (`let mut value = ...`)
    or a mutable reference binding (for example a `mut self: &Type` receiver),
    the compiler treats `value.method(...)` as a mutable receiver call (no
    `(mut value)` wrapper required).
  - The explicit `(mut value).method(...)` form is permitted but is no longer
    required for name receivers.

 limitations:

- Mutable receiver calls must use a name receiver; mutable borrows from
  non-name receiver expressions (for example `make().push(1)`) are rejected.
- Non-`mut` receivers may be arbitrary expressions (including calls), so
  chaining like `url.href().as_string()` is permitted.

Compiler requirements:

- Keep data layout and behavior separate in the IR.
- Preserve struct layout exactly for ABI and FFI.
- Enforce rules for opaque structs and UB as described in this document and the ABI spec.

## `enum` Types

An `enum` defines a *tagged union* type: a value that is exactly one of several
named variants, optionally carrying a payload.

Use enums to model:

- finite state machines (connection state, parser state),
- protocol messages and events,
- and any API where “exactly one of these cases” is the core invariant.

If your goal is “a function can fail with one of several error shapes”, prefer
typed errors (`Typed Errors (`error`, `panic`, and `T | ErrorType...`)`) over enums.

### Surface Syntax

Enum declarations introduce a nominal type and its variants:

```silk
enum RecvJob {
  Msg(Job),
  Cancelled,
  Timeout,
}
```

Rules:

- Variant names are identifiers and must be unique within the enum.
- Variant names may not be the reserved optional constructors `Some` / `None`.
- An enum must declare at least one variant.
- A variant is either:
  - a **unit** variant (no payload): `Cancelled`,
  - or a **tuple** variant with one or more payload element types: `Msg(Job)`,
    `Pair(int, int)`.
- A trailing comma after the last variant is permitted.

### Construction

#### Unit variants

Unit variants are constructed as values using `Enum::Variant` (or, in
type-directed contexts, just `Variant`):

```silk
enum E {
  A,
  B,
}

fn main () -> int {
  let x: E = E::A;
  let y: E = A;
  return 0;
}
```

Notes:

- `E::A()` and `A()` are invalid in Silk (unit variants are not callable).

#### Tuple variants

Tuple variants are constructed using `Enum::Variant(<args...>)` where the
argument count and types match the variant’s declared payload element types:

```silk
enum E {
  Data(int),
  Pair(int, int),
  Empty,
}

fn main () -> int {
  let a: E = E::Data(7);
  let b: E = Data(7);
  let b: E = E::Pair(1, 2);
  let c: E = E::Empty;
  return 0;
}
```

Notes:

- `E::Data` by itself is not a value in Silk (tuple variants must
  be constructed with `(...)`).
- If a tuple-variant constructor argument has the wrong type, you get `E2001`.
- If the argument count does not match the variant definition, the compiler
  currently rejects the construct with `E2002`.

#### Generic enums (instantiation via alias)

When an enum is generic, callers typically alias an instantiation and then use
that alias as the qualifier for constructors:

```silk
enum Result(T, E) {
  Ok(T),
  Err(E),
}

type R = Result(int, int);

fn main () -> int {
  let x: R = R::Ok(123);
  return match x {
    R::Ok(v) => v,
    R::Err(_) => 0,
  };
}
```

#### Namespaced enums (packages)

Across packages, enums and variants may be referenced with `::` qualification.
For example, if `util` defines `enum Mode { Inc, Dec }`, an importer can write:

- `util::Mode` as the type name, and
- `util::Mode::Inc` / `util::Mode::Dec` as the constructors and patterns.

See `Packages, Imports, and Exports` for module-set rules and for how
package imports seed qualified type names.

### Matching

Enum values are typically consumed via `match` expressions. The `match`
expression rules are defined in ``match` Expression`; this section
focuses on the enum-specific subset.

#### Patterns

Enum patterns are variant patterns:

- Unit variant: `E::A`
- Tuple variant: `E::Data(x)`, `E::Pair(a, b)`
- Tuple binder omission: `E::Pair(_, b)` (underscore binder ignores that element)

Shorthand:

- When the scrutinee type is the enum `E`, the qualifier may be omitted:
  - Unit variant: `A`
  - Tuple variant: `Data(x)`, `Pair(a, b)`

For instantiated generic enums, the qualifier `E` may be a type alias (for
example `type R = Result(int, string);` then `R::Ok(v)` / `R::Err(e)`).

Binders:

- introduce a name scoped to that arm only, and
- shadow outer bindings of the same name (because they create a new binding in
  the arm’s environment).

#### Exhaustiveness ()

In Silk, enum matches must be exhaustive:

- There must be exactly one arm per enum variant.
- Each variant must appear exactly once.
- Wildcard arms (`_ => ...`) are not supported for enum matches yet.

If a match is not exhaustive, the compiler currently reports `E2002` rather than
a dedicated “missing match arm” diagnostic.

#### Example: unit enum match

```silk
enum E {
  A,
  B,
}

fn main () -> int {
  let v: E = E::A;

  let x: int = match v {
    E::A => 10,
    E::B => 20,
  };

  if x != 10 {
    return 1;
  }
  return 0;
}
```

#### Example: tuple enum match (payload binders)

```silk
enum E {
  Pair(int, int),
  Empty,
}

fn main () -> int {
  let v: E = E::Pair(1, 2);

  let x: int = match v {
    E::Pair(a, _) => a,
    E::Empty => 0,
  };

  if x != 1 {
    return 1;
  }
  return 0;
}
```

#### Example: struct payload enum match

```silk
struct Job {
  id: int,
}

enum RecvJob {
  Msg(Job),
  Cancelled,
}

fn main () -> int {
  let j: Job = Job{ id: 5 };
  let evt: RecvJob = RecvJob::Msg(j);

  let rc: int = match evt {
    RecvJob::Msg(job) => job.id,
    RecvJob::Cancelled => 0,
  };

  if rc != 5 {
    return 1;
  }
  return 0;
}
```

### Representation

Enums are values. In the current IR-backed lowering, an enum value is lowered to
scalar slots as:

1. a `u64` **tag** (variant index in declaration order, starting at `0`), and
2. a **payload region** that includes a distinct slot range for each variant’s
   payload elements, in variant declaration order.

Conceptually:

```text
(u64 tag,
 payload slots for variant 0,
 payload slots for variant 1,
 ...)
```

Only the active variant’s payload region is meaningful for a given value; other
payload regions are unspecified.

This representation is an implementation detail and is expected to evolve (for
example, toward a tag + max-payload “union-style” layout) as the compiler and
ABI mature.

### Common Pitfalls

- **Forgetting parentheses**: `E::Data(7)` is valid, but `E::Data` is not a value
  In Silk (error `E2002`).
- **Calling a unit variant**: `E::A` is a value; `E::A()` is rejected (`E2002`).
- **Wrong binder count**: `E::Pair(a)` does not match `Pair(int, int)` (`E2002`).
- **Non-exhaustive matches**: you must list every variant (error `E2002` in the
  ).
- **Assuming enum equality is defined**: use `match` to inspect the tag/payload;
  the backend does not define `==`/`!=` over enums yet.

### Related Documents

- ``match` Expression` (match expression rules)
- `Structs, Impl Blocks, and Memory Layout` (struct payloads)
- `Types` (nominal types and type annotations)
- `Packages, Imports, and Exports` (namespaces and imports)
- `Typed Errors (`error`, `panic`, and `T | ErrorType...`)` (typed errors, not enums)

### Relevant Tests

- Enum matches (end-to-end):
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
  - `the runnable fixtures`
- Namespaced enum references (module-set build):
  - `the runnable fixtures` (built with `the runnable fixtures`)

## Interfaces

Interfaces allow types to declare that they implement a particular contract.
They are the foundation for standard-library “protocols” such as readers,
writers, iterators, and allocators.

Key components:

- The `interface` declaration.
- The `struct` that implements the interface.
- The `impl ... as ...` declaration that ties them together.
- A `module ... as ...` declaration for module-level conformance.

### Interface declarations

An interface declares a set of required method *signatures*.

Syntax:

```silk
interface Element {
  fn onclick(event: &Event) -> void;
}
```

Rules:

- Interface members are method declarations introduced with `fn`.
- Interface methods have **no body** and end with `;`.
- Parameter types in interface methods should be explicitly annotated (the
  compiler should not rely on type inference for interface contracts).
- Interface methods are part of a **public contract**:
  - interfaces do not have private members, and
  - interface method declarations do not accept visibility modifiers.

### Generic interfaces

Interfaces may declare type parameters:

```silk
interface Channel(T) {
  fn send(value: T) -> bool;
  fn recv() -> T?;
}
```

Rules:

- Generic parameter lists use the same syntax as structs (`(T, ...)`).
- Type parameters may provide default type arguments (`T = Type`). When defaults
  are present, use sites may omit trailing arguments that have defaults.
- The interface name is a **type constructor** and must be applied with the
  correct number of type arguments where a concrete interface type is required
  (for example in `impl ... as ...` declarations).

### `Self` in interface signatures

Within an interface method signature, the special type name `Self` refers to
the concrete implementing type when checking `impl Type as Interface { ... }`
conformance.

### Interface inheritance (`extends`)

Interfaces may use `extends` for **single inheritance**:

```silk
interface BaseLogger {
  fn log(msg: string) -> void;
}

interface FancyLogger extends BaseLogger {
  fn warn(msg: string) -> void;
}
```

Semantics:

- An interface that `extends` another interface inherits all of the base
  interface’s method signatures.
- A conformance declaration (`impl T as I` or `module ... as I`) must satisfy
  the full inherited interface surface.

Rules:

- `extends` is permitted only on `interface` declarations.
- Only single inheritance is permitted (at most one `extends` base).
- Cycles in `extends` chains are rejected.
- A derived interface may not redeclare a method with the same name as an
  inherited base method.

### Implementations (`impl ... as ...`)

An implementation block declares that a concrete type implements an interface
and provides method bodies.

Example:

```silk
interface Element {
  fn onclick(event: &Event) -> void;
}

struct Button {
  handle: i64;
}

impl Button as Element {
  fn constructor(...) -> Button { ... }
  fn onclick(self: &Button, event: &Event) -> void { ... }
}
```

Applied interface types:

```silk
interface Read(T) {
  fn read() -> T;
}

struct ByteSource { /* ... */ }

impl ByteSource as Read(u8) {
  fn read(self: &ByteSource) -> u8 { /* ... */ }
}
```

Compiler requirements:

- Represent interface types and `impl ... as ...` relationships.
- Enforce that all required interface methods are implemented with compatible
  signatures.
- Treat required interface methods as **public by definition**:
  - impl methods that satisfy an interface requirement may omit `public`, but
  - they may not be explicitly marked `private`.

Conformance rules (initial implementation):

- For an `interface I { fn m(p0: T0, ...) -> R; }`, the corresponding impl must
  provide a method `m` whose signature matches after accounting for the
  receiver:
  - the impl method’s first parameter is the receiver `self: &Type` (or
    `mut self: &Type`), and
    - the remaining parameters and result type must match the interface method.
- Exception (static protocol, implemented subset):
  - `std::interfaces::Deserialize(S)` is a static conversion protocol used by
    `as` casts. Its conformance does **not** use a receiver parameter:
    - `impl T as std::interfaces::Deserialize(S)` provides
      `fn deserialize(value: S) -> Self` (no `self` parameter),
    - calls use `T.deserialize(value)`.

Generic interface conformance rule:

- When the `as` clause names an applied generic interface type (for example
  `Read(u8)`), all type arguments must be fully known at the conformance site,
  unless the conformance itself is generic and binds those type parameters (for
  example `impl Data(T) as DataInterface(T)`).

### Module conformance (`module ... as ...`)

A module declaration may declare conformance to an interface:

```silk
interface Logger {
  fn log(msg: string) -> void;
}

module my_app::logger as Logger;

export fn log (msg: string) -> void {
  // ...
}
```

Conformance rules:

- For an `interface I { fn m(p0: T0, ...) -> R; }`, the corresponding module must
  provide a function `m` whose signature matches exactly:
  - there is no receiver parameter for module conformance, and
  - the parameter and result types must match the interface method.
- In Silk, module conformance is checked against the
  module’s **exported** functions (written as `export fn ...`), since those are
  the module members that are visible across module boundaries.

Generic module conformance:

- A module may declare conformance to an applied generic interface type
  (for example `module my_app::bytes as Read(u8);`).
- All interface type arguments must be fully specified (modules do not bind
  their own type parameters).

### Dispatch model (status)

objects / vtables) is part of the language design, but is not implemented yet.

For the initial compiler/backend subset, interface use is limited to:

- declaring interfaces and impl blocks, and
- calling methods directly on concrete types (no interface-typed values at
  runtime).
- special-case compiler hooks for specific interfaces (currently
  `std::interfaces::Drop` for deterministic cleanup; see
  `std::interfaces` and `Memory Model (Stack, Heap, and Moves)`).

## Packages, Imports, and Exports

This document specifies the initial surface syntax for packages, imports, and
exports in Silk. The semantics are intentionally minimal for now and will be
extended as the compiler’s resolver and linker mature.

### Terminology

- **Source file**: a single `.slk` source file.
- **Package**: a named collection of source files that share a namespace (declared via
  `package ...;`).
- **Module declaration**: a `module ...;` header that declares a namespace and a
  **compile-time-only** module value, and may declare interface conformance via `as`.
- **Module set**: the set of source files the compiler is compiling together for a
  given command. Package imports can only resolve to packages that exist in this
  module set.
- **Named import**: `import { A, B as C } from "...";` (introduces unqualified names).
- **Default import**: `import X from "...";` (binds either a default export symbol or
  a namespace, depending on what is imported).
- **Namespace import**: a default import that binds a module or package namespace; you
  access its members as `X::Name`.

### Packages

A Silk program is organized into packages and source files.

Each source file may declare the package it belongs to using a `package`
declaration at the top of the file:

```silk
package my_app::core;
```

Rules:

- Each module MAY declare at most one `package` declaration.
- When present, the `package` declaration MUST appear before all other
  top-level declarations in the module; it is the first declaration in
  the file.
- Package names are sequences of identifiers separated by `::`.
  - As a special case, the keyword `task` is permitted as a `::`-qualified
    segment so `std::task` is a valid package name.
  - `std::strings`
  - `std::task`
  - `my_app::core`
  - `example`
- The standard library lives under the reserved `std::` namespace, for
  example `std::strings`, `std::memory`, etc.

If a source file omits a `package` declaration, it is treated as belonging to an
implementation-defined default package (for example, the “main” package for
an executable). The exact rules for default packages will be specified as
multi-module builds are implemented.

In the current `silk` CLI implementation, when building a package via a package
manifest (`silk.toml`), source files that omit `package` default to the
manifest’s `package.name`. See `Package Manifests (`silk.toml`)`.

### Modules (`module`)

`module` declares a named module namespace and a **compile-time-only** module
value.

Syntax:

```silk
module my_app::core;
module my_app::core as SomeInterface;
```

Rules:

- A source file MAY declare at most one `module` declaration.
- A source file MAY declare at most one of:
  - a `package` declaration, or
  - a `module` declaration.
- When present, the `module` declaration MUST appear before all other top-level
  declarations in the source file; it is the first declaration in the file.
- Module names follow the same `::`-qualified naming rules as packages.
- Modules are **compile-time-only** values: there is no runtime representation
  for a module value.
- If a module declares `as <Interface>`, the compiler MUST validate that the
  module satisfies the interface surface as specified in
  `Interfaces`.

#### Inline modules (`module Name { ... }`)

In addition to the source file header form (`module ...;`), Silk supports
**inline modules** as a nested-namespace mechanism inside a file:

```silk
package my_package;

export module inner_module {
  export fn hello () -> string {
    return "hello world";
  }
}
```

Rules (current compiler subset):

- Inline modules MUST appear at top level (not inside function blocks).
- The inline module name is a single identifier.
- The body is a brace-delimited list of top-level declarations; inline modules
  may be nested.
- `package`, header-form `module ...;`, and `import` declarations are not
  permitted inside an inline module body.
- Declarations inside an inline module are referenced from outside using `::`
  qualification (`inner_module::hello()`).
- Within an inline module body, unqualified name lookup for inline-module
  declarations is not implemented yet in Silk; use
  explicit `::` qualification.
- `export module Name { ... }` exports the namespace:
  - exported declarations inside it become part of the containing package’s
    export surface with their names prefixed by `Name::` (for example
    `inner_module::hello`),
  - nested `export module` declarations extend the prefix (for example
    `outer::inner::name`).

### Source File Header Ordering (Mandatory)

In each source file, top-level declarations must appear in this order:

1. Optional `package` or `module` declaration (`package ...;` or `module ...;`).
2. Zero or more `import` declarations, as a contiguous block.
3. All other top-level declarations.

This ordering is enforced by the parser/resolver and keeps dependency structure
easy to understand and tooling-friendly.

### Imports

Source files may refer to other packages or modules via `import` declarations:

```silk
package my_app::core;

import std::strings;

fn main () -> int {
  return 0;
}
```

Rules:

- `import` declarations MUST appear at top level (not inside functions or
  blocks).
- All `import` declarations in a module, if any, MUST appear after the
  optional `package` declaration (if present) and before any other kind of
  top-level declaration. In other words, imports form a contiguous block at
  the beginning of the module immediately following the optional package.
- An `import` path is a sequence of identifiers separated by `::`, matching
  the package naming rules above (including the `std::task` special case).
  - As with expression/type qualified names, an import path MAY start with `::`
    to explicitly name the global namespace (the unnamed package).
- `import` declarations identify dependencies and bring exported symbols
  from the imported package into scope in the importing module, subject to
  the visibility rules below.
- In the current implementation:
  - importing a package makes its exported `let` bindings with explicit
    type annotations visible as ordinary, unqualified names in the
    importing module (for example, `import util;` followed by `answer`
    refers to `util::answer` when `util` exports `let answer: int = 42;`),
  - imported exported `let` bindings are also reachable via qualified
    names of the form `pkg::name` (for example, `util::answer` after
    `import util;`); both unqualified (`answer`) and qualified
    (`util::answer`) forms are accepted for now, but the qualified form
    reflects the intended package-namespaced style,
  - exported functions (`export fn`) are callable across packages for the
    compiler’s current backend subset:
    - within a package, top-level functions form a shared namespace across
      all modules in that package (so functions in one module may call
      functions defined in another module of the same package),
    - when a module imports a package, that package’s `export fn`
      declarations become callable from the importing module,
    - both unqualified (`foo()`) and qualified (`util::foo()`) call forms
      are accepted initially for imported exports, matching the current
      constant-import behavior, though the qualified form reflects the
      intended package-namespaced style,
    - this callable subset is limited to the compiler’s current
      code generation subset (supported parameters/results, direct calls, and
      structured control flow supported by the IR→ELF backend on
      `linux/x86_64`),
  - struct type names (`struct` declarations) from imported packages are visible in the importing module for the current supported `struct` subset:
    - the qualified form `pkg::Struct` is always accepted when `pkg` is imported,
    - the unqualified form `Struct` is accepted when it is unambiguous across the module’s imports and does not conflict with a locally defined struct name,
    - when multiple imported packages define the same struct name, the unqualified form is rejected as ambiguous and the qualified form must be used,
  - enum type names (`enum` declarations) from imported packages are visible in the importing module for the current supported enum subset:
    - the qualified form `pkg::Enum` is always accepted when `pkg` is imported,
    - the unqualified form `Enum` is accepted when it is unambiguous across the module’s imports and does not conflict with a locally defined type name,
    - enum variants are referenced relative to the enum name (`Enum::Variant` or `pkg::Enum::Variant`),
  - if an imported package does not exist, resolution fails before
    type-checking (see the resolver).
  - a leading `::` on a qualified name forces lookup in the **global namespace**
    (the unnamed package), bypassing any same-named declarations in the current
    package or imported packages. This is intended as an explicit escape hatch
    for shadowing (for example, calling `::malloc(...)` when the current module
    also defines or exports `malloc`). The prefix is valid in both expression
    and type positions, including:
    - values: `::malloc(...)`,
    - types and struct literals: `::Foo` and `::Foo{...}`,
    - enum variant paths/patterns: `::E::Variant`.

#### Qualified Symbol Imports

In addition to importing whole packages, a module may import a single symbol by
fully qualifying it:

```silk
import std::io::println;
import std::url::URL;
import ::malloc;
```

Semantics:

- If the import path matches a package name present in the module set, it is a
  **package import** (`import std::io;`).
- Otherwise, it is treated as a **qualified symbol import**:
  - the compiler finds the longest package-name prefix of the path,
  - the remaining suffix is the symbol name within that package (it may contain
    `::` due to exported inline modules),
  - the symbol is introduced into the importing module under its final path
    segment (for example, `println` for `import std::io::println;`).
- When the import path begins with `::`, the symbol is resolved from the global
  namespace (the unnamed package) and is not subject to package export gating.

`import { Name } from "...";` remains the preferred form when you need to rename
imports (`as`) or import from a file path.

Global namespace (`::name`) rules (current compiler subset):

- The global namespace is the package formed by modules that have **no**
  `package ...;` or header-form `module ...;` declaration (their package name is
  empty).
- `::Name` resolves `Name` from that global namespace, if a matching declaration
  exists in the current module set.
- `::Outer::Inner::Name` resolves `Outer::Inner::Name` from that same global
  namespace (for example, names nested under inline modules in a global module).
- Global names are only accessible via the explicit `::` prefix; there is no
  implicit “prelude import” of global symbols.

Future extensions may introduce aliasing (e.g. `import std::strings as str;`)
and more fine-grained import forms. Such features will be documented here
before they are implemented.

#### Example: a two-module package program

Two modules can share a package name and export symbols for other packages to
use.

```silk
// util.slk
package util;

export let answer: int = 41;

export fn add1 (x: int) -> int {
  return x + 1;
}
```

```silk
// app.slk
package app;

import util;

fn main () -> int {
  // In the current implementation, both unqualified and qualified access are
  // accepted after importing a package. Prefer the qualified form to make the
  // origin explicit.
  if util::add1(util::answer) != 42 {
    return 1;
  }
  return 0;
}
```

#### Package imports resolve against the module set

In the current implementation, a **package import** can only resolve if the
package exists in the current module set.

This matters most when you use package specifiers (`from "ns_pkg"`) or when you
expect a package import to find a package that is not otherwise present.

Tooling note (the `silk` CLI):

- The language semantics are still “imports resolve against the module set”.
  The CLI grows the module set by loading additional source files.
- In addition to auto-loading `std::...` packages from the stdlib root, the CLI
  MAY load non-`std::` packages from a **package search path** when a bare
  package specifier is imported (e.g. `import api from "my_api";`).
- The package search path is configured via `SILK_PACKAGE_PATH` (PATH-like:
  roots separated by `:` on POSIX).
- A package name like `my_api::core` maps to the filesystem candidate
  `<root>/my_api/core/silk.toml`. The first matching manifest in search order is
  used.
- Qualified imports that include extra `::` segments (e.g. `my_api::core::Thing`)
  are treated as qualified symbol imports: the CLI resolves the **longest**
  package prefix that exists (`my_api::core`, then `my_api`) and loads that
  package into the module set.

Example: bringing a package into the module set via a file import, then importing
the package namespace:

```silk
// main.slk
import { answer as ignored } from "./support_pkg_ns_pkg.slk"; // declares `package ns_pkg;`
import pkg from "ns_pkg"; // now resolves because `ns_pkg` exists in the module set

fn main () -> int {
  return pkg::add1(pkg::answer);
}
```

If you omit the file import (or otherwise fail to include a module that declares
`package ns_pkg;`), the package import fails with `E1001` (“unknown imported package”).

From the CLI, the usual fix is to ensure the missing package’s module(s) are
part of the command’s module set (for example by passing their `.slk` files to
`silk check` / `silk build`, or by adding a file import). See
``silk` CLI` and `CLI Usage Examples`.

### Import Specifier Imports (JS-style)

In addition to `import pkg::name;` package imports, Silk supports JS-style
import forms that use a string literal *import specifier* after `from`.

An import specifier string is interpreted in one of three ways:

- **File specifier**: the string begins with `./` or `../`, or is an absolute
  path. These imports resolve to a module by file path.
- **Std-root file specifier**: the string begins with `std/`. These imports
  resolve to a module by file path under the configured stdlib root (see the
  stdlib root selection rules in ``silk` CLI` and
  `C99 ABI and `libsilk.a``).
- **Package specifier**: any other string. These imports resolve to a package
  by name (for example `"ui"` or `"std::strings"`).

Note: in Silk, package specifiers are matched literally
against package names present in the module set. In practice this means the
specifier must be a valid Silk package path (identifiers separated by `::`,
with `task` permitted as a `::` segment).

This mirrors the common JS convention that relative file imports must start
with `./` or `../`. Silk additionally reserves the `std/` prefix for stdlib
source imports resolved via the configured stdlib root.

Example (namespace-style imports):

```silk
import ui from "ui";                 // package namespace
import helpers from "./helpers.slk";  // file module namespace (if no default export)

fn main () -> void {
  let opts: &ui::WindowOptions = new ui::WindowOptions();
  helpers::do_something();
}
```

#### Named imports

Named imports import selected exported names directly into the importing
module:

```silk
import { StringBuilder, write_u8 as writeByte } from "./runtime.slk";
```

Notes:

- There is no combined `import foo, { bar } from "...";` form in the current grammar.
  Use separate `import` declarations.
- For non-`std/` file specifiers, include the `.slk` extension explicitly. (Only
  `std/...` specifiers get `.slk` appended automatically in the current implementation.)

Rules:

- File imports MUST appear in the same import-declaration block as package
  imports: after the optional `package` declaration and before any other
  top-level declaration.
- The `from` keyword is part of the import syntax.
- The `from` specifier may be either:
  - a string literal (`from "./file.slk"`, `from "std/io"`, `from "ns_pkg/sub"`), or
  - a package path (`from std::io;`, `from ns_pkg::sub;`).
- If the specifier is a **file specifier**, it is resolved relative to the
  importing file’s directory. `./` and `../` path segments are permitted.
  (Absolute paths are permitted for tooling, but downstream projects should
  prefer relative imports.)
- If the specifier is a **std-root file specifier** (`"std/<path>"` or
  `"std/<path>.slk"`), it is resolved relative to the configured stdlib root and
  then treated as a file import. If the `.slk` extension is omitted, it is
  appended during std-root resolution.
- If the specifier is a **package specifier**, it is interpreted as a package
  name (using the same `::`-separated syntax as `package` declarations) and is
  resolved via the package graph.
- The imported module MAY declare a `package` or omit it. File specifiers refer
  to the target module *by file path*, not by package name.

Exported names for named imports:

- Named imports can import:
  - exported values: `export fn`, `export let`, and exported `ext` bindings, and
  - type names: `struct`, `enum`, `error`, and `interface` declarations (treated
    as visible across module boundaries in the current implementation),
  - exported type aliases: `export type ...;`, and
  - exported Formal Silk theories: `export theory` declarations (importable so
    they can be applied via `#theory Name(args);`).
- `impl` blocks do not introduce importable names directly, but loading the
  imported module makes its methods available for method-call checking on the
  corresponding types.

Name binding rules:

- Each entry in the `{ ... }` list names one imported symbol.
- `as` can be used to rename an imported symbol (`Name as Alias`).
  - For values (`fn` / `let` / `ext`), this introduces a value alias.
  - For type names (`struct` / `enum` / `error` / `interface`) and exported
    type aliases (`export type`), this introduces a local `type` alias
    (transparent: it does not create a new type identity).
  - For Formal Silk theories (`export theory`), this introduces a theory alias.
- Imported names are introduced into the importing module as unqualified names
  (matching the existing behavior for package imports).
- Importing an unknown name from a file is an error.
- Importing the same value name from multiple file imports without aliasing is
  an error.
- Importing a value name that is already visible in the module (for example
  via same-package scope or a package import) is treated as a no-op in the
  current implementation **unless** it conflicts with a local declaration in
  the importing module.
- Importing a type name that is already visible in the module is treated as a
  no-op in the current implementation.

#### Default imports and namespace imports

A module may declare a single *default export* and importing modules may bind
that default export with a JS-style default import:

```silk
// module.slk
package module;

export default fn () -> int {
  return 1 + 2;
}
```

```silk
// main.slk
import foo from "./module.slk";

fn main () -> int {
  let value = foo();
  if (value != 3) {
    return 1;
  }
  return 0;
}
```

Rules:

- Default exports are module-level and are consumed by default imports
  (`import Name from "<specifier>";`).
- A default export may be declared in either of two ways:
  - a default-exported function declaration:
    - `export default fn ...` (the function name is optional only in this form),
  - or a default-export statement:
    - `export default Name;` (names an in-scope symbol in the current module).
- Default exports may target any top-level symbol kind that can be referenced
  by name:
  - functions (`fn`),
  - top-level bindings (`let` / `const` / `var`),
  - external bindings (`ext`),
  - type aliases (`type`),
  - nominal types (`struct`, `enum`, `error`, `interface`),
  - Formal Silk theories (`theory`).
- Each module MAY declare **at most one** default export.
- A default export is distinct from named exports:
  - `export default fn add () -> int { ... }` declares a default export whose
    internal name is `add` within the module,
  - but it does **not** implicitly create a named export of `add` for other
    modules. To export it as a named export, write `export fn add ...` (or add
    an explicit named export form once one exists in the language).
- The function name after `fn` is optional only for default exports. When the
  name is omitted (`export default fn () -> ...`), the function is anonymous in
  the surface language and can only be referenced by importing it via a default
  file import.
- Default imports have two behaviors depending on whether a default export
  exists:

  - If the imported module declares `export default`, the local name binds to
    that default-exported symbol.
  - If the imported module does **not** declare a default export, the default
    import becomes a **namespace import**: the local name refers to the
    imported module’s namespace and its exported names are accessed via
    `foo::Name`.

  In other words: *if there is no explicit default export, the module’s
  namespace is treated as the default export.*

- When a default import binds a default export, it introduces a single
  unqualified name into the importing module:
  - if the default export is callable (a `fn` or an `ext` function), it binds a
    callable value name (`foo()`),
  - if the default export is a type (`struct`/`enum`/`error`/`interface`/`type`),
    it binds a type name usable in type positions (and as the head of struct
    literals),
  - if the default export is a Formal Silk theory, it binds a theory name that
    may be applied via `#theory foo(args...);`,
  - if the default export is a non-callable value (`let`/`const`/`var` or a
    non-function `ext`), it binds a value name.
  When a default import binds a namespace, it does not introduce any unqualified
  imported names; you must use `foo::Name` to access exported names.
- Using a namespace import name as a callable (e.g. `foo()`) is an error; add an
  explicit `export default` to the imported module or use a named import.

Package namespace imports:

- For a **package specifier** (for example `import ui from "ui";`), the default
  import binds the package’s default export when the package declares one.
  Otherwise, it binds a namespace and exported names are accessed via `ui::Name`.

### Exports

Top-level declarations can be marked as exported using the `export`
modifier:

```silk
package my_app::core;

export fn main () -> int {
  return 0;
}

export let answer: int = 42;
```

Rules:

- `export` is not allowed inside blocks; it applies only to module-level
  declarations. Inside `impl` blocks, `public` controls method visibility and
  `export` is reserved for static members.
- The initial implementation supports `export` on:
  - functions (`export fn ...`),
  - `let` and `const` bindings (`export let ...`, `export const ...`).
  - `ext` declarations (`export ext name = ...;`),
  - Formal Silk theories (`export theory Name(...) { ... }`),
  - `type` aliases (`export type Name = ...;`),
  - `struct` declarations (`export struct Name { ... }`),
  - `enum` declarations (`export enum Name { ... }`),
  - `error` declarations (`export error Name { ... }`),
  - `interface` declarations (`export interface Name { ... }`),
  - static members inside `impl` blocks (`impl T { export fn ... }` with no
    `self` receiver).
- The `export` modifier marks a declaration as part of the package’s
  externally visible surface. The exact visibility rules across packages
  (including how exports appear in the resolver and back-end symbol tables)
  will be specified and implemented alongside the package graph in
  `Compiler Architecture`.

In the current implementation, most type names are treated as visible across
module boundaries once the relevant module(s) are loaded into the module set.
The `export` modifier is still recorded on type declarations so the
package/export model can be tightened later without changing source.

#### Re-export declarations (`export { ... };`)

In addition to `export fn ...` and `export let ...`, Silk supports exporting an
*already in-scope name* via a re-export declaration:

```silk
import { my_function } from "./module.slk";
export { my_function };
```

This is the idiomatic way to build “barrel” modules that forward selected
exports from other modules.

Rules (current compiler subset):

- A re-export declaration must appear at top level and ends with `;`.
- Each entry in the `{ ... }` list names a **local** in-scope symbol.
  - The entry may rename the exported name: `export { localName as ExportedName };`.
- Re-exported names are part of the module/package export surface, so other
  modules may import them via `import { Name } from "./barrel.slk";`.
- In the current implementation, `export { ... }` supports values and exported
  Formal Silk theories (`theory` declarations). It does not export type names.

### Common Pitfalls

- **Forgetting semicolons**: `package` and `import` declarations end with `;` (parse error, `E0001`).
- **Imports not at the top**: imports must come immediately after the optional
  `package` declaration and before any other top-level declaration (`E0001`).
- **Assuming package imports find code automatically**: a package import can only
  resolve if the package exists in the module set (fix by adding the relevant `.slk`
  files to the build, or by file-importing them; missing packages are `E1001`).
- **Calling a namespace import**: if `import foo from "./mod.slk";` binds a namespace
  (because there is no default export), then `foo()` is invalid; use `foo::Name` or
  add `export default` (`E2018`).
- **Name collisions with named imports**: when importing from multiple modules, use
  `as` to rename one binding (`E2004`).

### Relevant Tests

- Package import + unqualified/qualified access:
  - `the runnable fixtures`
  - `the runnable fixtures` (module-set package import; built with `the runnable fixtures`)
- Namespace imports (file and package):
  - `the runnable fixtures`
  - `the runnable fixtures`
- Named imports + aliasing:
  - `the runnable fixtures`
  - `the runnable fixtures`
- Re-exports (`export { ... };`):
  - `the runnable fixtures` (built with `the runnable fixtures` and `the runnable fixtures`)
  - `the runnable fixtures` (built with `the runnable fixtures`)
- Default exports:
  - `the runnable fixtures`
- Importing types and using exported methods:
  - `the runnable fixtures`

## Optional

The `Optional` type provides a safe way to represent values that may or may not
be present, instead of relying on sentinel values such as `null`.

- The nominal type constructor is `Option(T)`.
- The shorthand `T?` is sugar for `Option(T)` and is the recommended form.
- Optional values are constructed using `Some(...)` and `None` (the compiler
  also accepts `none` as an alias of `None`).
- The `null` literal is distinct from `None`, but may coerce to `None` when an
  optional type is expected.
- Use `match`, `?.` (optional chaining), and `??` (coalescing) to consume optionals.

### Declaring Optional Types

You can declare variables or fields as optional using either:

- `T?` (idiomatic suffix form),
- `Option(T)` (nominal form).

The language design treats these as equivalent.


- The type system (`the implementation`) models optional types, and the parser
  now accepts both:
  - the suffix form `T?` in type annotations, and
  - the nominal form `Option(T)` for simple cases (a single type argument),
    which is desugared into the same internal optional representation as
    `T?`.
  - For example, the following is valid today and type-checks successfully
    (note that the current compiler requires `let` initializers; see
    `Compiler Diagnostics`, `E2015`):

    ```silk
    fn main () -> int {
      let a: string? = None;
      let b: Option(string) = None;
      return 0;
    }
    ```

- The current `linux/x86_64` IR→ELF backend subset now supports a first slice
  of optional *values* for a subset of payload types:
  - construct optionals via `None` and `Some(value)`,
  - access fields of optional structs via optional chaining
    (`opt?.field`, producing a `FieldType?` value),
  - use nested optionals (`T??`) for a subset of payloads in the current backend
    (see below),
  - compare supported optionals via `==` / `!=` (tag + payload equality; nested
    optionals compare recursively),
  - unwrap optionals via `??` (coalescing) with short-circuit evaluation of
    the fallback expression,
  - explicitly branch on optionals via the `match` expression (see
    ``match` Expression`),
  - and pass/return such optionals between helpers in the supported IR
    subset.

  Supported optional payloads in this backend subset include:

  - scalars (`bool`, `char`, `f32`, `f64`, `int`, and fixed-width integers),
  - `string` (lowered as `{ ptr: u64, len: i64 }`),
  - enums (tagged unions) in the current enum backend subset (lowered as `(u64 tag, payload_0, payload_1, ...)`),
  - and the supported `struct` subset (0+ fields of supported value types,
    including nested structs and optionals; see `Structs, Impl Blocks, and Memory Layout`).

  In this subset, optionals are represented at IR boundaries as a `Bool` tag
  followed by the payload scalars: `(Bool tag, payload0, payload1, ...)` where
  `tag=0` means `None` and `tag=1` means `Some(...)`. The payload scalar slots
  follow the same lowering rules as the underlying non-optional type (1 scalar
  for scalar payloads, 2 scalars for `string`, N scalars for the current `struct`
  subset, and N scalars for enums (including the enum’s own `u64` tag slot).

  Nested optionals (`T??`) are supported in this backend subset for the same
  payload subset (scalars, `string`, enums, and the supported `struct` subset).

  In this subset, `T??` is represented as an outer optional whose payload is
  the full inner optional representation: for example `int??` lowers as
  `(Bool tag0, Bool tag1, i64 payload)`.

- Not yet implemented:
  - optional chaining beyond the current optional-struct field access subset
    (for example chaining through optional fields, optional method calls, and
    optional indexing),
  - `match` over non-optional scrutinee types (and richer pattern forms beyond
    `None`/`Some(...)`),
  - and richer optional forms beyond the backend.

Note: optional payload equality (`==` / `!=`) is still limited in the current
backend subset; comparisons against `None` are supported broadly, but full
payload equality for all optional payload kinds (notably optional-of-enum) is
still evolving.

For the current C ABI mapping of optionals in exported function signatures
within the supported backend subset, see `C99 ABI and `libsilk.a`` and
`External Declarations (`ext`)`.

### Creating Optional Values

An optional can be:

- `None` — the empty state.
- `Some(value)` — the value‑holding state.

Examples from the spec:

- `let age: u32? = None;`
- `let age: u32? = Some(30);`
- `struct User = { profile: None };`
- `profile: Some({ email: "some@example.com", age: Some(30) })`

The compiler infers the optional’s element type from context when possible.

In the current implementation, equality comparisons provide optional type
context for `None` / `Some(...)` operands, so forms like `opt == None` and
`opt == Some(value)` type-check when `opt` has type `T?`.

### `None`: The Empty State

`None` represents the absence of a value.

Spelling note: `None` may also be written as `none` (alias). The `null` literal
is a distinct literal that can coerce to `None` in optional contexts.

Key points:

- `None` can be assigned to any `T?`; its concrete `T` is inferred.
- In pattern matching and control flow, `None` corresponds to the empty branch.

### `Some(value)`: The Value-Holding State

`Some(value)` wraps a concrete value in an `Option(T)`.

Key points:

- The type of `Some(value)` is `T?` (or `Option(T)`).
- Nested optionals are allowed (e.g. a struct containing fields that are `T?`).

### Optional-Coalescing Operator `??`

The `??` operator unwraps an optional by providing a fallback value if it is `None`.

From the spec:

- It “coalesces” the optional’s value and the default into a single, non‑optional result.
- The expression `opt ?? default_value` has type `T` when `opt` has type `T?`.
- When `opt` has type `T??`, the expression `opt ?? default_value` has type
  `T?` (it unwraps one optional layer).
- It composes naturally with optional chaining.

Example:

- `let email_address: string = user2.profile?.email ?? "no-email-provided@domain.com";`

### Using Optional Values

The spec provides several mechanisms for working with optionals:

- Optional chaining `?.`:
  - `user.profile?.email` yields `string?`.
  - If any link in the chain is `None`, the result is `None`.
- Coalescing `??`:
  - Converts an optional into a non‑optional by supplying a default.
- Explicit checking via `match`:
  - Pattern‑matching on `Some(...)` / `None` to handle both cases explicitly.

### Compiler Requirements

The compiler must:

- Support `T?` and `Option(T)` as equivalent surface forms.
- Ensure that `Some` / `None` usage is type‑correct.
- Track optionality in the type system and enforce checks when unwrapping.
- Implement `?.` and `??` with the short‑circuit semantics described above.
- Support `match` on `Option(T)` and integrate optionals with flow control and error reporting.

## Errors

This document summarizes the Silk error-handling model at a level suitable for compiler implementation. It is based on the language design captured in `this specification` (optionals, verification, `ext`, ABI).

For unrecoverable logic bugs and contract violations, Silk uses **typed
errors** (`error`, `panic`, and `T | ErrorType...`), specified in
`Typed Errors (`error`, `panic`, and `T | ErrorType...`)`.

### Design Goals

- Error signaling is explicit and typed (no hidden global error state).
- Error paths are part of normal control flow, not out-of-band exceptions.
- The verifier can reason about both success and error paths symmetrically.
- The C99 ABI must be able to represent error outcomes in a stable, documented way.

### Recoverable Errors (Recommended Pattern)

Silk distinguishes between:

- **Recoverable errors** (invalid user input, I/O failures, parse failures): model
  these as normal values, typically using `std::result::Result(T, E)` or an
  optional (`T?`).
- **Typed errors** (`T | ErrorType...` + `panic`): reserved for unrecoverable
  contract violations and logic bugs that should not be silently ignored (see
  `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`).

#### Example: Recovering from URL parse errors

`std::url` exposes a recoverable parsing API (`std::url::parse`) that returns a
tagged result (`std::url::URLResult`), so callers can report an error and keep
going without aborting.

A runnable example that wraps `URLResult` into `std::result::Result` and parses
all command-line arguments is in:

- `an example program`

### Error Representation

From the overall language design:

- Silk favors explicit types such as:
  - optionals (`T?` / `Option(T)`) for “may be present / may be absent” values.
  - domain-specific error types (enums or structs) for richer error reporting.
- Functions that can fail should surface that in their type signatures:
  - either by returning a value that encodes both success and error (e.g. an optional or a nominal error-aware type),
  - or by returning an error-only type where success is absence of error.

The naming and shapes of error-carrying types are defined by this language spec and by standard library APIs, but the compiler must:

- treat them as regular, first-class types,
- enforce that callers handle them appropriately (e.g. via pattern matching, explicit checks).

### Interaction with Control Flow

Error-aware types integrate with control flow constructs:

- `if` / `match` can be used to branch on error vs. success cases.
- Pattern matching can destructure enum-based error types, exposing error codes or payloads.
- Optionals (`T?`) can be used where “absence” is a common error shape; they compose with `?.` and `??` to keep code concise while still explicit.

The compiler must:

- ensure that branches that depend on error conditions are type-checked,
- support exhaustiveness checks when matching on error enums/types.

### Verification and Errors

Formal Silk constructs (`#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`) apply equally to:

- success paths (e.g. postconditions describing the returned value),
- error paths (e.g. guarantees about when and how certain errors can occur).

The verifier should be able to:

- treat error-carrying types as ordinary values with invariants,
- prove that certain errors cannot happen given preconditions,
- or, conversely, require explicit handling of error cases when the proof cannot eliminate them.

### ABI and FFI Considerations

On the C99 side:

- Error values exposed through `libsilk.a` should use well-defined C types (e.g. enums or structs) documented in `C99 ABI and `libsilk.a``.
- For external functions declared via `ext`, any error behavior must be captured in the Silk-side function type and corresponding C signature (e.g. error-return codes, nullable pointers, or explicit error structs).

The compiler must:

- preserve error-related information across the FFI boundary,
- avoid implicit, hidden error channels (such as untracked global error codes) in favor of explicit parameters or return values.

### Assertions (`assert`)

`assert` is a debugging/safety construct intended to catch programmer mistakes.
It is **not** part of Silk’s typed error model and is not a replacement for
returning optionals or `Result(...)`.

Syntax (initial):

- `assert <Expr>;`
- `assert (<Expr>, <message>?);`

Rules:

- The condition expression must type-check as `bool`.
- The optional message, when present, must type-check as `string`.

Runtime behavior (current compiler subset):

- By default (release builds), if the condition evaluates to `false`, execution
  traps immediately (a panic-like abort). In the current `linux/x86_64` backend
  this is implemented as an invalid-instruction trap.
- In debug builds (`silk build --debug` / `-g`) on `linux/x86_64`, a failed
  assertion prints a panic header, the optional message (when present), and a
  stack trace to stderr when available (via glibc `backtrace_symbols_fd`)
  before aborting.

Notes:

- Failed assertions are currently isolated by the `silk test` runner (each
  test runs in its own process). Future work may allow reporting failed
  assertions without process isolation (for example by lowering `assert` to a
  typed error in test contexts).
- See also: `Testing`.

## Typed Errors (`error`, `panic`, and `T | ErrorType...`)

Silk’s typed error system exists to eliminate the “trust gap” between a
function’s signature and its real behavior. There are no hidden exceptions and
no implicit panic channel: if a function can terminate due to a logic bug /
contract violation, it must say so in its signature, and the compiler must
enforce it.

This document specifies the surface syntax and checker rules for typed errors.

The compiler supports `error` declarations, `panic` statements, error-aware
return types (`T | ErrorType...`), and the `match` *statement* form for handling
typed errors (including the Terminal Arm Rule), plus the postfix `?`
propagation operator for error-producing calls.

### Overview

- An `error` represents an unrecoverable logic bug or contract violation.
- A function that can `panic` must declare that in its return type using `|`:
  - `fn get_at(xs: &u8[], index: int) -> u8 | OutOfBounds;`
- A typed error is triggered with `panic`, which terminates the current function
  and propagates the error to the caller.
- Typed errors are handled explicitly via `match` (statement form), and any arm
  that handles an error must end in a terminal statement.

This model is intentionally closer to “typed, explicit non-local errors” than
to try/catch exceptions or an implicit panic mechanism.

#### Recoverable errors are values (not typed errors)

Typed errors are intentionally *not* the primary mechanism for routine runtime
failures such as:

- invalid user input,
- parsing failures,
- I/O failures.

Those should typically be modeled as ordinary values using `std::result::Result`
or optionals (`T?`) so callers can handle them and continue normal execution.

See:

- `Errors` (overview),
- `std::result` (recoverable `Result(T, E)`),
- `std::url` and `an example program`
  (recoverable URL parsing example).

### Declaring Error Types (`error`)

Syntax:

```silk
error OutOfBounds {
  index: int,
  len: int
}
```

Rules:

- `error Name { ... }` declares a nominal, struct-like type that represents an
  unrecoverable logic bug / contract violation.
- An `error` declaration has the same field rules as `struct` in the current
  compiler subset (scalar fields; see
  `Structs, Impl Blocks, and Memory Layout`).
- An `error` type may also be used as data (returned, stored, logged) when it is
  *not* part of a `T | ...` error contract.


- The compiler treats `error` as a distinct nominal type category (separate from
  `struct`) but reuses the same field/layout rules in Silk.

### Error-Producing Function Signatures (`T | ErrorType...`)

A function declares that it may `panic` by adding one or more error types after
its success type using `|`.

Examples:

```silk
fn get_at(xs: &u8[], index: int) -> u8 | OutOfBounds { ... }
fn parse() -> Packet? | PacketTooLarge { ... }
fn init() -> void | InitFailure { ... }
```

Note on `|` disambiguation:

- In function declarations, an unparenthesized `|` sequence after `->` is
  always parsed as a typed-error contract.
- To return a **union type** from a function, parenthesize the union:
  - `fn f () -> (A | B);`
  - `fn g () -> (A | B) | SomeError;`

See `Type Unions (`T1 | T2 | ...`)` for union types.

Rules:

- The leftmost type is the single *success* type.
- Each type on the right side of `|` must name a declared `error` type.
- The list of error types in a signature is the complete contract: the
  implementation may not `panic` with any other error type.

Implementation notes:

- The current compiler models typed errors as a distinct “error set” attached to
  the function signature and to expressions that may `panic`.
- The success type is still a normal Silk type (including optionals).

### Triggering a Typed Error (`panic`)

Syntax:

```silk
panic OutOfBounds {
  index: index,
  len: std::length(xs)
};
```

Rules:

- `panic` constructs a value of the named `error` type and immediately
  terminates the current function, propagating the error to the caller.
- A `panic X { ... };` statement is only legal inside a function whose signature
  includes `| X` (directly or indirectly via propagation).

Implementation notes:

- `panic` is a statement (not an expression) in Silk.

### Propagating Typed Errors (`?`)

The postfix `?` operator propagates a typed error from an *error-producing call
expression* to the caller without requiring an explicit `match` at every call
site.

Syntax:

```silk
let value: T = error_call(...)?;
```

Semantics:

- If the call succeeds, `call()?` evaluates to the call’s success value.
- If the call panics with a declared error type, `call()?` immediately returns
  from the current function, propagating the same error to the caller.

Rules:

- `?` is only legal inside a function that declares an error contract
  (`-> SuccessType | ErrorType...`).
- The callee’s error set must be a subset of the enclosing function’s error set.
  Otherwise the call must be handled explicitly with a `match` statement that
  maps the error into the caller’s contract.
- `?` is only meaningful on an error-producing call expression (a call whose
  signature includes `| ErrorType...`). Applying `?` to an infallible call is a
  type-check error.

Implementation notes:

- In the current compiler, `call()?` is lowered as “call + tag dispatch; on
  error return the appropriate error payload; on success yield the value”,
  using the same encoding as the `match` statement lowering.

### Handling Typed Errors (`match` statement + Terminal Arm Rule)

When the scrutinee expression of a `match` statement may `panic` (i.e. its
signature includes `|`), the compiler activates a special rule for error arms.

#### Match statement form

```silk
match (create_packet(user_size)) {
  Some(packet) => {
    io::println("ok");
  },
  None => {
    io::println("no packet");
  },
  err: PacketTooLarge => {
    log::critical("invalid packet size requested", err);
    std::abort();
  }
}
```

#### Terminal Arm Rule

If the scrutinee expression has an error contract (`T | ErrorType...`), then
for any arm that matches an `error` type, the arm’s block must end with a
terminal statement.

Terminal statements are:

- `panic <ErrorType> { ... };` (propagate or map to another error)
- `std::abort();`
- `std::halt();`
- `std::reboot();`

Implementation notes:

- `std::abort()` is lowered as a terminal action:
  - in the native backend subset, this is routed through the platform
    `abort()` so the process terminates with `SIGABRT`,
  - in non-debug builds on `linux/x86_64`, the compiler disables core dumps
    (`prctl(PR_SET_DUMPABLE, 0, 0, 0, 0)`) before calling `abort()` to keep abort fast,
  - on backends/targets where `abort()` is unavailable, it is lowered to the
    backend’s `Trap` primitive.
- `std::halt()` and `std::reboot()` are currently lowered to `Trap` in the
  native backend subset.

This rule is intentionally *context-dependent*: it is triggered by the error
contract of the scrutinee expression, not by the fact that a type is declared
with `error`.

#### Error types as data (no Terminal Arm Rule)

If a function returns an `error` type as a normal value (no `|` in its
signature), the special rule does not apply:

```silk
fn inspect_issues() -> PacketTooLarge;

match (inspect_issues()) {
  err: PacketTooLarge => {
    log::warn("non-critical issue", err);
    // Allowed to complete normally because the scrutinee is not a `T | ...`.
  }
}
```

#### `match` statements over Result-like values (recoverable)

The `match` **statement** form can also be used to destructure common
recoverable result shapes such as `std::result::Result(T, E)`.

When the scrutinee expression is a **call expression** whose result type is
either:

- `std::result::Result(T, E)` (an `enum` with `Ok(T)` and `Err(E)` variants), or
- a “Result-like” struct with fields:
  - `value: T?`
  - `err: E?` where `E` is an `error` type,

then the checker accepts binder patterns of the form:

- `name => { ... }` / `_ => { ... }` for the success payload (binds `name` as `T`),
- `err: E => { ... }` for the error payload (binds `err` as `E`).

The Terminal Arm Rule does **not** apply in this form because the scrutinee is
not a `T | ErrorType...` typed-error expression; the error is a normal returned
value.

Runtime invariant (struct form, current backend): exactly one of `value` and
`err` must be `Some(...)`. If the invariant is broken, execution traps.

Implementation notes:

- The current compiler supports a match subset for optionals as an
  *expression* (`match x { None => expr, Some(v) => expr }`).
- The `match` expression also supports `Ok(...)` / `Err(...)` patterns for
  `Result` values (see ``match` Expression`).
- Typed error handling uses the *statement* form of `match` with block arms.

### Restrictions

#### `pure fn`

`pure fn` must not introduce or handle typed errors:

- `pure fn` may not have a `|` in its return type.
- `pure fn` may not contain `panic` statements.

The checker enforces these rules in Silk (see
`Compiler Diagnostics`).

#### `ext` boundary

Typed errors must not cross the external boundary. External shims must translate
typed errors into:

- explicit error return codes,
- nullable pointers / optionals,
- explicit error structs/enums,
- or a terminal action appropriate for the platform.

`|` (and rejects exported C ABI surfaces with `|`) in the current
implementation.

### Related proposals

- Open/variadic error sets for higher-order adapters (`E...`).
- `return <error>` as shorthand for `panic <error>` (AP131).

## Mutability

Mutability in Silk is “safe by default”: values are immutable unless explicitly marked mutable under clear rules using the `mut` keyword.

- All local bindings are immutable (read‑only) by default.
- `const` bindings are always immutable (there is no `const mut`).
- All function parameters are immutable (read‑only) by default.
- A **value** parameter may be declared `mut` to allow reassignment of the
  parameter binding inside the callee (this does not affect the caller).
- A borrowed reference parameter (`&T`) follows a two‑part `mut` borrow
  contract:
  - the parameter is declared `mut`, and
  - the call site uses `mut <expr>` to explicitly create a mutable borrow.
- A slice parameter (`T[]`) is a non-owning view; when the callee intends to
  mutate through a slice view, it also follows a two-part contract:
  - the parameter is declared `mut`, and
  - the call site uses `mut <expr>` to explicitly pass a mutable slice view.

This two‑part system makes mutation explicit and intentional.

### Local Mutability (`let mut`)

Local bindings introduced with `const` and `let` are immutable by default. To
allow a local binding to be updated, it must be declared with `let mut` (or
`var`, which is an alias for `let mut`):

```silk
fn main () -> int {
  let mut x: int = 0;
  x = 1;
  x += 2;
  return x;
}
```

Key rules:

- Only `let mut` bindings may appear on the left-hand side of an assignment.
- The left-hand side must refer to an existing binding (an lvalue).
- The type checker enforces that the assigned value’s type matches the binding’s type.

### The Principle: Safe by Default

Example from the spec:

```silk
fn read_runner(r: &Runner) {
  // This is OK:
  io::print("Points: {}", r.point);

  // This would be a compile-time error:
  // r.point = 5;
}
```

Key points:

- Borrowed references (`&T`) are read‑only unless explicitly declared `mut`.
- Attempts to mutate through a non‑mutable reference are compile‑time errors.

### Granting Permission to Mutate

To make mutation possible **through a borrowed reference**, `mut` is used both:

- **In the function definition**, to declare that the function intends to mutate:

  ```silk
  fn reset_runner(mut r: &Runner) {
    r.point = 0;
  }
  ```

- **At the call site**, to explicitly pass a mutable argument, acknowledging that the callee is allowed to modify it (syntax defined in the language reference).

The compiler uses this to:

- encode a clear contract that the function may modify its argument,
- ensure callers are consciously opting into mutation.

### Compiler Requirements

The compiler must:

- Enforce immutability by default for parameters and references.
- Require `mut` at both the declaration and call site for mutable borrows.
- Surface clear diagnostics when mutation is attempted without proper `mut` markings.
- Integrate mutability rules with regions, buffers, and concurrency:
  - disallow patterns that would lead to data races,
  - ensure that aliasing and lifetime rules are respected when mutation is allowed.

### Current Implementation Restrictions

the compiler implements:

- Local `let mut` bindings, including assignment and numeric compound assignment.
- `mut` value parameters (`fn inc(mut x: int) { x = x + 1; }`) as a callee-local
  mutable binding (no call-site `mut` marker is required).
- Borrowed reference parameters of the form `&Struct` for the current supported `struct` subset.
- The two-part `mut` borrow contract for mutable reference parameters:
  - parameter declared `mut` (e.g. `fn bump(mut p: &Pair)`), and
  - call site uses `mut <expr>` (e.g. `bump(mut pair)`).
- Field updates through both:
  - local `let mut` struct bindings (`pair.a = 1`, `pair.b += 2`), and
  - `mut` borrowed reference parameters (`p.a = 1`, `p.b += 2`).
- Local borrowed references (`&Struct`) as first-class values:
  - via the borrow operator `&expr` on borrowable lvalues (e.g. `&pair`, `&obj.field`), and
  - via implicit borrow coercions in contexts that expect `&T`
    (for example `let r: &Pair = pair;`).
  These borrows are checked with conservative **lexical lifetime** rules (they
  may not escape the scope of the borrowed stack storage).
- Local bindings of `&Struct` values that originate from heap allocation (`new`)
  or from calls that return `&Struct`:
  - these `&Struct` values are refcounted in Silk,
  - copying a `&Struct` binding (e.g. `let g: &File = f;`) creates an alias to
    the same underlying heap allocation and increments the refcount.

### Borrow Safety Rules ()

Borrowed references (`&T`) in Silk are safe-by-default
and, for now, use conservative **lexical lifetime** checks:

- Borrowed references can be created and stored as local values (see above).
- The callee can mutate a borrowed reference only when:
  - the parameter is declared `mut`, and
  - the caller uses `mut <expr>` at the call site.
- Mutable borrows must be explicit and must originate from a borrowable lvalue:
  - borrowing a local binding requires a writable base (`let mut`) or an
    already-mutable view, and
  - field borrows follow the same rule (the base must be writable).

Slice views (`T[]`) are also call-scoped and safe-by-default:

- A slice value is a non-owning view (pointer + length) and may alias other
  slice views into the same underlying storage.
- Slice range borrows are created via:
  - `&a[start..end]`
  - `&a[..end]`
  - `&a[start..]`
- A mutable slice view is created via `mut &a[...]` and is restricted:
  - the base must be a borrowable lvalue (a name or a field-access chain rooted
    at a name), and
  - the base storage must be writable (`let mut` for fixed arrays / structs, or
    an already-mutable view such as a `mut` borrowed reference parameter), or
    already a mutable slice view.
- A function parameter of slice type may be declared `mut` to allow mutation
  through the slice view, and requires the caller to pass a mutable slice view
  using `mut <expr>`.
- When a slice value is stored in a struct field (`xs: T[]`), the stored view’s
  mutability is tracked:
  - storing `&a[...]` stores a read-only view, and
  - storing `mut &a[...]` stores a mutable view.
  A call-site `mut <expr>` marker does not upgrade a read-only stored view into
  a mutable one; passing a field as `mut` requires that the field already holds
  a mutable view.

#### Aliasing Restrictions (Per Call)

Within a single call expression, the compiler enforces conservative aliasing
rules to avoid creating multiple mutable views of the same storage:

- A given binding may be mutably borrowed at most once in a single call.
- A binding may not be both mutably and immutably borrowed in the same call.
- Multiple immutable borrows of the same binding are permitted.

For slice parameters (`T[]`), these same per-call aliasing restrictions apply.
Additionally, when both borrows are slice range borrows of the same base with
integer-literal bounds, the checker permits multiple mutable borrows in the same
call when it can prove the two ranges are disjoint (including when the slices
are first bound to locals and then passed by name).

When borrowing a range from an existing slice binding (for example `s: T[]`),
the checker interprets `&s[start..end]` as a subrange of the underlying base
(offset by `s`’s known bounds) for the purposes of overlap checks. This
disjointness reasoning is currently limited to integer-literal bounds and to
slice bindings whose own bounds are known.

For `&Struct` reference-typed local bindings and slice-typed (`T[]`) local
bindings, the compiler also tracks obvious aliasing introduced by copying and
ref “shape casts”:

- Copying a `&Struct` binding produces an alias (it refers to the same storage).
- Copying a slice binding (`T[]`) produces an alias (it refers to the same underlying storage).
- Casting `&S` to `&T` via `as` under the shape-cast rules produces an alias
  (it is a retyped view of the same storage).
- The per-call aliasing restrictions apply across aliases: within a single call
  expression, you may not take multiple mutable borrows (or both mutable and
  immutable borrows) of the same underlying reference, even if they are held
  under different local names.

Example (rejected):

```silk
fn swap(mut a: &Pair, mut b: &Pair) {
  // ...
}

fn main () -> int {
  let mut p: Pair = Pair{ a: 1, b: 2 };
  swap(mut p, mut p); // error: two mutable borrows of `p` in one call
  return 0;
}
```

Example (allowed, immutable):

```silk
fn sum2(a: &Pair, b: &Pair) -> int {
  return a.a + a.b + b.a + b.b;
}

fn main () -> int {
  let p: Pair = Pair{ a: 1, b: 2 };
  return sum2(p, p); // OK: multiple immutable borrows
}
```

### ABI Notes (Exported/C Boundaries)

At C ABI boundaries (`export fn`), reference types are supported only for
opaque handle types (`&Opaque` / `mut &Opaque`). Non-opaque `&Struct` borrows
are not ABI-stable; see the ABI and struct layout docs for the current rules.

## Memory Model (Stack, Heap, and Moves)

This document specifies Silk’s intended memory model: how values are allocated,
passed, and how (future) heap-managed values interact with the type system.

minimal heap model for `new` on `linux/x86_64` and a small lexical
move/cleanup model for droppable values:

- `new` is supported for allocating non-opaque `struct` values on the heap and
  producing an `&Struct` reference.
- These heap allocations are managed via reference counting (RC) inserted by the
  compiler during lowering.

Regions and a richer move/borrow model remain design-in-progress. See
`Regions`, `Borrow Checking (Static Alias and Lifetime Safety)`, and `the implementation status`
for current scope.

### Goals

- Make allocation behavior explicit and predictable.
- Prefer stack allocation for most local data.
- Prevent unsafe implicit lifetime extension (for example implicitly “moving”
  stack data into a longer-lived heap allocation).
- Keep borrow safety a compile-time property (no runtime borrow errors in the
  safe subset).

### Stack vs Heap

#### Stack allocation (default)

Rule: values created without `new` are stack values by default.

- Locals hold their data directly (for example an `int` or a small POD `struct`).
- Passing to functions is **by value**. For ownership-tracked values, this is a
  move (the source binding is consumed); for plain scalars it behaves like a
  copy.
- Lifetime is lexical (ends when the scope ends).

This aligns with the compiler, which is value-oriented and does
not implement a general heap allocation model.

#### Heap allocation (`new`) and boxed values

Rule: values created with `new` live on the
heap and are represented as an `&Struct` reference in user code.

- The reference value is passed by value (copying the reference representation).
- The underlying allocation’s lifetime is managed by compiler-inserted reference
  counting (RC) for values originating from `new`.

Important: this is currently an internal Silk-managed heap for Silk code, not an
FFI pointer model. The current implementation does not permit `&Struct` for
non-opaque structs in `ext` signatures; only `&Opaque` handles may cross the
FFI boundary (see `Structs, Impl Blocks, and Memory Layout` and
`External Declarations (`ext`)`).

##### Details

- `new` is supported only in function bodies (top-level `let` initializers
  cannot contain `new` in the current implementation).
- `new` is supported only when the checker can determine a concrete reference
  result type of the form `&Struct`. In the current implementation this happens
  in two ways:
  - from an expected type context `&Struct` (for example `let x: &Packet = new
    Packet{ ... };` or as a call argument where the parameter type is `&Struct`)
  - from the `new` operand itself when it names a struct type (for example
    `let x = new Packet{ ... };` or `let x = new Packet(...);`), which allows
    `let` bindings to infer `&Packet` without an explicit annotation
- Only non-opaque `struct` types are supported for `new`.
- Reference counting is applied only to `&Struct` values that originate from
  `new` (borrowed stack references are not treated as RC-managed values).
- The `silk build` CLI supports `--noheap` to disable heap allocation for the
  :
  - heap-backed `new` (outside a `with` region) is rejected with `E2027`,
  - `async`/`task`/`await`/`yield` and capturing closures are rejected with `E2027`,
  - `ext` bindings to libc heap primitives (`malloc`/`calloc`/`realloc`/`free`/etc) are rejected with `E2027` in non-stdlib modules,
  - `std::runtime::mem::{alloc,realloc,free}` traps when called without an active `with` region (no implicit heap fallback),
  - region-backed `new` inside `with` is still permitted.

##### Region-backed allocation (`with` + `region`)

In Silk, `new` may also allocate from a region when an active
region context is established with `with` (see `Regions`).

- Inside `with <region> { ... }`, `new` allocates from the region’s backing
  bytes instead of calling the heap allocator.
- On last-release, region-backed `new` allocations run `drop` (when defined),
  but do not free their backing storage (region memory is not reclaimed by RC).

##### Reference counting rules

- `new` initializes the allocation’s RC cell to `1`.
- Copying an RC-managed `&Struct` binding (for example `let q: &T = p;`) emits an
  RC retain (increment).
- Assigning to an RC-managed `&Struct` binding (for example `p = q;` where `p` is
  a `var`) releases the previous value; when the RHS is an RC-managed binding, a
  retain is emitted before the release to keep self-assignment safe.
- Exiting a scope emits RC releases (decrement) for RC-managed bindings declared
  in that scope, including on fallthrough, `return`, `break`, and `continue`.
- Passing `new` directly as a call argument to a `&Struct` parameter allocates a
  temporary and releases it after the call completes.
- When an RC release decrements the count to `0`, the allocation is freed.

### Destructors (`Drop`)

In Silk, Silk supports deterministic cleanup for
resource-owning `struct` values via `std::interfaces::Drop`.

A `struct` type is considered “droppable” when it provides a method with this
surface signature (usually via an interface impl):

```silk
import std::interfaces;

impl T as std::interfaces::Drop {
  public fn drop (mut self: &T) -> void { ... }
}
```

Automatic invocation (current compiler):

- **Scope exit:** values are dropped when they go out of scope (including via
  fallthrough, `break`, and `continue`).
- **Return:** on `return`, the compiler drops all in-scope droppable bindings
  except any value moved into the return result (for example `return value;`
  and `return Some(value);` treat `value` as moved in Silk).
- **Overwrite:** assigning to an existing value drops the old value before the
  new value is copied in.
- **Heap last-release:** for `new` allocations managed by compiler-inserted RC,
  `drop` is called before freeing the backing allocation when the refcount
  reaches zero.

Notes and limitations:

- `drop` is resolved statically (no dynamic dispatch).
- Values that require deterministic cleanup should be treated as
  ownership-tracked:
  - consuming a binding moves it and suppresses scope-exit cleanup for that
    binding,
  - using a moved binding is rejected by the checker,
  - explicit ownership transfer may be written as `move <name>` (see
    `Borrow Checking (Static Alias and Lifetime Safety)`).

### No Implicit Heap Promotion

Planned rule: stack values cannot be implicitly promoted to heap-managed
storage. Any promotion must be explicit and must perform a copy.

This avoids accidental lifetime extension and makes performance characteristics
obvious.

The precise syntax for “heap-copy this value” is still under design; any
proposed surface form must be written down in `Formal Grammar Spec` before
it is implemented.

### Closure Captures

Silk supports capturing closures as a subset of function values.

Representation:

- A function-typed value is a small pair: `{ func_ptr, env_ptr }`.
- `func_ptr` is a pointer to the closure code.
- `env_ptr` is either `0` (non-capturing) or a pointer to a heap-allocated
  environment box that stores captured values.

Calling convention:

- When `env_ptr == 0`, an indirect call behaves like a normal function-pointer
  call: `func_ptr(user_args...)`.
- When `env_ptr != 0`, the backend passes `env_ptr` as a hidden first argument
  to the closure function: `func_ptr(env_ptr, user_args...)`.

Environment allocation and lifetime ():

- Captures are by-value copies of **scalar** locals/parameters (`int`, fixed
  width ints, `bool`, `char`, `f32`, `f64`, `Instant`, `Duration`).
- The environment box begins with a `u64` refcount header, followed by the
  captured scalar fields in a stable order.
- Copying a closure value retains the environment (increments refcount) when
  `env_ptr != 0`.
- Dropping a closure value releases the environment (decrements refcount) when
  `env_ptr != 0`; when the refcount reaches zero the environment box is freed.

Limitations:

- Capturing non-scalar values (including `string`, structs, arrays/slices,
  optionals, and `Drop` types) is rejected in Silk.
- Captures are immutable snapshots; the  does not support
  capturing by reference or mutating captured state.

### Relationship to Borrowing and Mutability

- Borrow checking is intended to be a compile-time property in the safe subset:
  invalid borrows should be rejected statically.
- See `Mutability` for the current implemented borrow rules
  (call-scoped aliasing checks for `&T` parameters in Silk).
- See `Borrow Checking (Static Alias and Lifetime Safety)` for the broader planned borrow checker.

## Borrow Checking (Static Alias and Lifetime Safety)

This document specifies Silk’s intended borrow-checking model for references.


- call-scoped alias checks for mutable borrows (including slice range borrows),
- lexical lifetime checks for slice and reference borrows (no escaping borrows
  of stack locals),
- and a small explicit ownership-transfer form (`move`) used by the checker and
  lowering to prevent accidental double-drops in the safe subset.

### Goals

- Prevent use-after-free and data races in safe code.
- Make mutation explicit and intentional.
- Reject invalid borrows at compile time (no runtime borrow errors required for
  safe code).
- Keep diagnostics actionable (highlight the borrow origin, conflicting use,
  and suggest a fix).

### Details

Today, the language subset implemented by the compiler supports only:

- call-scoped borrow alias checks for:
  - borrowed reference parameters (`&T`, `mut p: &T`), and
  - slice parameters (`T[]`, `mut s: T[]`) and slice range borrows
    (`&base[start..end]`, `mut &base[start..end]`).
- first-class borrowed `&Struct` values created from borrowable lvalues:
  - `&expr` (borrow operator) for borrowable lvalues, and
  - implicit borrow coercions in contexts that expect `&T`
    (for example `let r: &Pair = pair;`).

Additionally, the subset implements **lexical lifetime checks** for both slice
borrows and borrowed `&T` values so obvious use-after-scope cases are rejected
(for example returning a slice borrowed from a local fixed array, or returning
`&T` borrowed from a local struct binding).

### Lexical Lifetimes

Slices (`T[]`) are non-owning views. Slice range borrows create slices that
point into existing storage:

- `&base[start..end]` creates a slice view whose lifetime is tied to `base`.
- When borrowing a range from an existing slice binding `s: T[]`, the borrow’s
  underlying origin is `s`’s origin (sub-slicing does not extend lifetime).

Lexical lifetime rules enforced by the compiler:

- A slice value that ultimately borrows from a **local fixed array binding**
  (`T[N]`) may not escape that binding’s lexical scope.
  - Returning such a slice from a function is rejected.
  - Assigning such a slice into outer-scope storage is rejected (including via
    field assignment and via mutable reference parameters).
- Returning a slice is permitted when the returned slice ultimately borrows
  from a **function parameter** (for example returning a sub-slice of a `T[]`
  parameter).

These rules are intentionally conservative and are expected to be generalized
to a richer lifetime model as more borrow forms become first-class.

### Lexical Reference Lifetimes

Borrowed `&T` values that ultimately reference **stack storage** may not escape
that storage’s lexical scope. This includes:

- returning a borrowed `&T` that points to a local struct binding,
- and assigning such a borrowed reference into outer-scope storage.

Returning a reference is permitted when the returned `&T` ultimately refers to
an input reference parameter (that is, storage owned by the caller), and not to
stack locals.

### Ownership Transfer (`move`)

Silk’s safe subset includes a small explicit ownership-transfer form:

- `move <name>`

This expression:

- consumes the binding `<name>` when its type requires ownership tracking
  (for example values that are dropped on scope exit),
- and makes `<name>` unavailable for further use until it is reinitialized
  (for `var`) or permanently (for `let`).

This enables moving values into other values (for example as call arguments or
as the payload of `Some(...)`) without accidentally copying a resource-owning
value and dropping it twice.

In Silk, ownership transfer is intentionally conservative:

- A binding may not be moved while it has any live borrows (reference or slice
  views) in scope, including borrows stored in struct fields.
- A by-value call argument that requires ownership tracking is treated as a
  move, and is rejected when the same binding is also borrowed in that call.

### Planned Expansion

As the language grows, borrow checking is expected to expand to cover:

- borrowed references as first-class values (`&expr` producing `&T` values),
- references and borrows in more positions (locals, fields, returns),
- lifetime/region inference across control flow,
- explicit disambiguation when multiple input references exist (for example a
  label syntax like `as A` to tie a return reference to a specific input),
- restrictions around suspension points in `async`/`await`,
- and well-defined rules for passing references across FFI boundaries.

Any expansion must be specified in `Formal Grammar Spec` and in this
document before implementation lands, and must be reflected in diagnostics
(`Compiler Diagnostics`) and tests.

## Buffers

`Buffer(T)` is an intrinsic type providing low-level access to a contiguous block of memory. It is intentionally unsafe and used as a foundation for higher-level collections and strings.

Key points:

- `Buffer(T)` is a “fat pointer” with:
  - a raw pointer to the start of the memory block,
  - a capacity (number of elements that can be stored).
- `Buffer(T)` does **not** track the number of initialized elements (length).
- The intrinsic API includes operations such as:
  - `std::buffer::alloc`
  - `std::buffer::write`
  - `std::buffer::read`
  - `std::buffer::capacity`
  - `std::buffer::drop`
  - `std::buffer::view`
  - `std::buffer::slice`
- The safety model is layered:
  - Layer 1: unsafe `Buffer(T)` primitive.
  - Layer 2: compile-time safety via the verifier.
  - Layer 3: provable safety via refinement types.

Compiler requirements:

- Treat `Buffer(T)` as an intrinsic type with special semantics.
- Ensure the verifier has enough information to reason about buffer safety.
- Coordinate with the standard library so that safe collections are built on top of `Buffer(T)`.

## Regions

Regions provide a fixed-size, **statically allocated** block of memory that can
be used as an allocation context for `new`.

Regions are represented at runtime as a first-class `Region` handle value. A
`Region` value may be passed to functions, stored in structs, and exported.

### Syntax

#### `Region` handle type

`Region` is a primitive value type representing a region allocation context.

Conceptually, a `Region` value contains:

- a base pointer to the backing bytes,
- a pointer to a mutable cursor cell (shared by copies of the handle), and
- a byte limit used for overflow checking.

Copying a `Region` value copies the handle; copies refer to the same backing
store and cursor.

#### Declaring a region

A region declaration has the surface form:

```silk
const region arena: u8[1024];
```

Rules:

- `const region` is a declaration form (it is not a type).
- A region declaration has no initializer.
- The type annotation specifies the region backing size and must be a fixed
  byte array type: `u8[N]`.
- The declared name is bound as a `Region` value.

#### Using a region: `with`

`with` establishes a region allocation context for the enclosed block.

##### 1) Bind an existing region

`with <region> { ... }` activates a named region binding:

```silk
struct Packet { x: int }

fn main () -> int {
  const region arena: u8[1024];

  with arena {
    let p: &Packet = new Packet{ x: 1 };
    // ...
  }

  return 0;
}
```

The `<region>` name may refer to any `Region`-typed binding, including a region
parameter passed to a function:

```silk
struct Packet { x: int }

fn alloc_in (r: Region) -> int {
  with r {
    let p: &Packet = new Packet{ x: 1 };
    return p.x;
  }
}
```

##### 2) Use an anonymous region with an explicit byte budget

`with <bytes> { ... }` (or `with(<bytes>) { ... }`) creates an anonymous region
backed by `<bytes>` writable bytes and activates it for the block:

```silk
struct Packet { x: int }

fn main () -> int {
  with 1024 {
    let p: &Packet = new Packet{ x: 1 };
    // ...
  }
  return 0;
}
```

Rules ():

- `<bytes>` must be a positive integer literal.

##### 3) Use a slice of an existing region (`from`)

`with <bytes> from <region> { ... }` creates an anonymous region backed by the
first `<bytes>` bytes of `<region>`:

```silk
struct Packet { x: int }

fn main () -> int {
  const region arena: u8[2048];

  with 1024 from arena {
    let p: &Packet = new Packet{ x: 1 };
    // ...
  }

  return 0;
}
```

You may also specify a byte slice of the source region:

```silk
with 1024 from arena[64..] {
  // uses bytes 64..(64 + 1024) of `arena`
}

with 1024 from arena[64..1088] {
  // uses bytes 64..1088 of `arena`
}
```

Rules ():

- `<bytes>` must be a positive integer literal.
- `<region>` must name a `Region` value that has a compile-time-known backing size
  In Silk (for example a `const region` declaration).
- Slice bounds use **byte offsets** (the region backing store is `u8[N]`).
- `<start>` / `<end>` must be non-negative integer literals.
- When an explicit `<end>` is present, it is exclusive (`[start..end]`).
- The `from` slice must contain at least `<bytes>` writable bytes:
  - `with <bytes> from r { ... }` requires `<bytes> <= sizeof(r)`.
  - `with <bytes> from r[start..end] { ... }` requires `<bytes> <= end - start`.
  - `with <bytes> from r[start..] { ... }` requires `<bytes> <= sizeof(r) - start`.

### Semantics

#### Region-backed `new`

Within a `with <region> { ... }` block:

- any `new` allocation performed by the compiler’s `new` lowering uses the
  active region as its backing store,
- allocations are **8-byte aligned** in the current implementation subset,
- if the region does not have enough remaining space, the program traps.

Outside of a `with` block, `new` uses the current heap model described in
`Memory Model (Stack, Heap, and Moves)`.

#### Region-backed raw allocation (`std::runtime::mem::alloc`)

Within the dynamic extent of a `with <region> { ... }` block (including calls
performed while the block is active):

- `std::runtime::mem::alloc(n)` allocates an `n`-byte payload from the active
  region (8-byte aligned) and reserves an additional 8-byte header immediately
  before the returned pointer (used by the runtime to distinguish region-backed
  and heap-backed pointers and to record the allocation size),
- if the region does not have enough remaining space, the program traps.

Implication for `with <bytes>` limits: each `alloc(n)` consumes at least
`n + 8` bytes of region capacity (plus any alignment padding from 8-byte
alignment).

Region-backed raw allocations are bump-allocated. In the current runtime model:

- `std::runtime::mem::free` is a no-op for region-backed pointers,
- `std::runtime::mem::realloc` reallocates by allocating a new region block and
  copying bytes (it never calls libc `realloc` on a region-backed pointer).

#### Nested `with`

Nested `with` blocks use the innermost active region:

```silk
with a {
  with b {
    // `new` uses region `b` here.
  }
}
```

### Reclaiming Region Memory ()

Regions are bump allocators: each allocation advances a cursor within the
backing byte buffer.

Because region-backed `new` allocations are still RC-managed in the current
subset and do not free backing bytes on last-release, reclaiming region memory
requires resetting the region cursor so the backing bytes can be reused.

Current behavior:

- `with <region> { ... }` activates the region but does **not** reset its cursor.
  - allocations across multiple `with <region>` blocks accumulate and can
    eventually overflow and trap.
- `with <bytes> { ... }` creates an anonymous region and resets its cursor to `0`
  on entry so repeated execution of the block starts from an empty region.
- `with <bytes> from <region>[...] { ... }` creates an anonymous region backed by
  a subrange of `<region>` and resets its cursor to the slice start on entry.

Important limitation:

- The compiler does not yet enforce “region allocations must not escape the
  `with` block”. Because anonymous-region cursors are reset on entry, code must
  treat pointers/`&Struct` values allocated inside `with <bytes> { ... }` and
  `with <bytes> from ... { ... }` as block-scoped.

### Exports

Region declarations may be exported and imported like other top-level bindings:

```silk
export const region global_arena: u8[4096];
```

Exporting a region exports a `Region` handle that refers to the same backing
bytes and cursor cell. Importing a region binds a `Region` value that may be
used with `with` like a locally declared region.

## Concurrency

Concurrency in Silk is built around two orthogonal function modifiers:

- `async` — marks a function as pausable/awaitable (concurrency),
- `task` — marks a function as safe to execute on a worker pool (parallelism),

plus structured concurrency blocks (`async { ... }` and `task { ... }`)
intended to provide **structured concurrency**.

- The runtime manages a thread pool to execute tasks.
- The compiler is intended to enforce task-safety rules when values cross task
  boundaries (Send/Sync-like constraints).

### Core Keywords: `async` and `task`

#### `async`

- Marks a function as **awaitable** (pausable).
- Primary domain (design): I/O-bound concurrency on an event loop/executor.

#### `task`

- Marks a function as **task-safe** and eligible to be executed as a parallel
  task on a worker pool.
- Primary domain (design): CPU-bound parallelism and offloading blocking work.
- In the intended design, *calling a `task fn` is non-blocking* and produces a
  task handle.

#### `await`

`await <expr>` is the surface syntax for unwrapping a `Promise(T)` handle.

In Silk:

- `await Promise(T)` unwraps the completed promise and yields `T`.
- `await Promise(Task(T))` yields `Task(T)` (which can then be consumed via `yield` / `yield *`).
- `await Task(T)` is rejected; use `yield` / `yield *` for task values.

##### Task/Promise Handle Ownership ()

In Silk, `Task(T)` and `Promise(T)` are **single-use
handles**:

- A `Promise(T)` handle may be **awaited at most once**. `await` consumes the handle.
- A `Task(T)` handle may be **drained/joined at most once** via `yield *`
  (and `yield` on a temporary task expression drains/joins as well).
- Handles are **non-copyable**: you may not copy a handle into another binding
  or use it as a normal value expression.
- A consumed handle may not be used again (including attempting to `await` it a
  second time, or attempting to `yield *` it a second time).
- Consuming a handle that was created outside the current loop body is rejected
  In Silk (a loop may iterate multiple times).

These rules are enforced at compile time and exist to prevent double-free and
use-after-free bugs in the current runtime lowering, where `await` frees the
underlying handle storage after join/unwrap.

##### Handle Lifetime and Cleanup ()

In Silk, `Task(T)` and `Promise(T)` handles are stored in
heap-allocated handle memory:

- `await` unwraps a promise and then frees the promise handle storage.
- `yield *` drains/joins a task and then frees the task handle storage.
- If a handle is **not consumed** (`await`/`yield *`), the compiler inserts
  automatic cleanup when the handle binding is overwritten or goes out of scope:
  - `Task(T)` cleanup joins the worker thread and then frees the handle storage.
  - `Promise(T)` cleanup frees the handle storage.

Because the current runtime subset uses OS threads (no coroutine transform or
event loop), this automatic cleanup can block the current OS thread when it
joins a task.

#### `yield`

`yield` is the task-side counterpart to `await`.

In the intended model for tasks:

- A `task fn ... -> T` produces a `Task(T)` handle when called.
- Inside the task body, `yield <expr>;` sends a value (convertible to `T`) to
  the task’s receiver and continues execution.
- `return <expr>;` sends the final task value (of type `T`) and terminates the
  task.
- Outside the task, `yield <task_handle>` blocks until the task produces its
  next value and yields it.
- `yield * <task_handle>` drains all remaining task values and then joins the
  worker thread for cleanup, yielding a collected `T[]` in value position.
- `yield * <task_handle>;` as a statement forwards all remaining values from the
  right-hand task to the enclosing task’s receiver and then joins/cleans up the
  drained task.

In Silk:

- `yield` is a blocking OS-thread operation (like the rest of the current
  concurrency runtime).
- `yield` is permitted only inside `task fn` / `async task fn` bodies and inside
  `task { ... }` / `task loop { ... }` blocks.
- The statement forms (`yield <value>;` and `yield * <task_handle>;` forwarding)
  require an enclosing task function (`task fn` / `async task fn`), since they
  send values to the task’s receiver.

##### Collected Array Ownership ()

In Silk, `yield *` and `await *` produce a heap-allocated
collection of values (`T[]`) for convenience. This is a current behavior:

- the compiler inserts deterministic cleanup for these collections when their
  bindings are overwritten or go out of scope,
- the returned `T[]` value must not be copied, and must not escape its defining
  scope until a stable owning collection type is specified.

#### Structured Concurrency Blocks and Loops

`async { ... }`, `task { ... }`, `async loop { ... }`, and `task loop { ... }`
introduce structured regions intended for scheduler-backed concurrency and
ensure all work started in the region completes before exit.

In Silk, these forms parse and type-check, but they do
not yet introduce any runtime scheduling; they currently behave like a normal
lexical block.

### Future Work: Runtime and Safety

The long-term design is to provide:

- a well-defined `Task(T)` handle type,
- scheduler-backed lowering of `task` calls into non-blocking spawns,
- `await` that unwraps promises and propagates errors/contracts,
- `yield` / `yield *` that receive/drain tasks without blocking the OS thread,
- structured blocks (`async { ... }` / `task { ... }`) that provide well-delimited lifetimes,
- static rules for data-race prevention and safe sharing across tasks.

## Formal Silk

Formal Silk is Silk’s compile-time formal verification language. It is written
using syntax that does not exist at runtime and is discharged at compile time
using the Z3 SMT solver.


When Formal Silk syntax is present, compilation generates verification
conditions (VCs), proves them with Z3, and fails the build if any VC cannot be
proven. This behavior applies to:

- the `silk` CLI (`silk check`, `silk test`, `silk build`), and
- the C ABI build entrypoints (`silk_compiler_build`, `silk_compiler_build_to_bytes`).

### Proof requirements are opt-in by syntax

Silk requires proofs only when verification syntax is present in the compiled
module set:

- any use of `#...` directives (`#require`, `#assure`, `#assert`, `#invariant`,
  `#variant`, `#monovariant`, `#const`), and/or
- any use of `where` predicates (for example refinement-type binders).

Note: `where` predicates are not implemented yet. When they land, they will
also be treated as verification syntax.

When verification syntax is present, compilation MUST:

1. generate VCs,
2. prove them using Z3, and
3. fail compilation with clear diagnostics if any VC cannot be proven.

When verification syntax is not present, compilation does not require proofs.

### Z3 linkage and overrides

On `linux/x86_64`, Silk always links the vendored Z3 static library
(`vendor/lib/x64-linux/libz3.a`) and its headers (`vendor/include`).

To override the Z3 library at runtime (for example to test against a different
Z3 build), provide a dynamic library path:

- CLI: pass `--z3-lib <path>`, or
- CLI/ABI: set `SILK_Z3_LIB` in the environment.

When `--z3-lib` is provided, it overrides `SILK_Z3_LIB`.

### Debugging proofs with Z3 (`--debug`)

When a verification condition fails, the compiler reports a normal diagnostic
at the failing annotation site.

When `--debug` is passed to `silk build` or `silk test`, the verifier also emits
additional Z3 debugging output to stderr and writes an SMT-LIB2 reproduction
script under `.silk/z3/` in the current working directory (or `$SILK_WORK_DIR/z3`):

- `.silk/z3/silk_z3_m<module>_<n>.smt2`

You can replay the query with an external Z3 binary:

```sh
z3 -smt2 .silk/z3/silk_z3_m0_0.smt2
```

### Z3 model ()

The current Formal Silk verifier maps Silk constructs directly to Z3:

- `bool` → Z3 Bool.
- `string` → Z3 String (: literals and equality/inequality comparisons).
- integer primitives → fixed-width Z3 bitvectors:
  - `i8`/`u8` → BV8
  - `i16`/`u16` → BV16
  - `i32`/`u32` → BV32
  - `i64`/`u64`/`int` → BV64

  Arithmetic is modular 2^N (wraparound). Ordered comparisons and `>>` use
  signed semantics for signed integers (`i*`/`int`) and unsigned semantics for
  unsigned integers (`u*`).

Supported operators in specification expressions ():

- boolean: `!`, `&&`, `||`, `==`, `!=`
- string: `==`, `!=`
- integer:
  - unary: `-`, `~`
  - arithmetic: `+`, `-`, `*`, `/`, `%`
  - bitwise: `&`, `|`, `^`, `<<`, `>>`
  - comparisons: `<`, `<=`, `>`, `>=`, `==`, `!=`
- size/layout queries: `sizeof`, `alignof`, `offsetof` (type operands and other statically-sized operands in Silk)

Other operators and expression forms are currently rejected in verified code
(see “Implementation Status” below).

### The `ext` boundary

External declarations (`ext`) have no body available to the verifier.

Therefore:

- The verifier cannot generate VCs about the behavior of `ext` bodies.
- In the current verifier subset, calls are supported only to functions that
  have Formal Silk contracts (see “Calls in verified code” below). `ext`
  declarations do not have Formal Silk contracts yet, so verified code cannot
  call `ext` functions.

See `External Declarations (`ext`)` for the external-declaration rules.

The main constructs are:

- `#const` — formal Silk declarations used inside specifications.
- `#require` — precondition.
- `#assure` — postcondition.
- `#assert` — block-local proof obligation.
- `#invariant` — loop or state invariant.
- `#variant` — well-founded termination measure (ranking function).
- `#monovariant` — monotonic measure (non-decreasing or non-increasing).
- `theory` / `#theory` — reusable, parameterized proof obligations.

Key properties:

- These annotations appear before the function or loop they describe.
- They are used by the verifier only and incur no runtime cost.

#### Formal Silk declarations (`#const`)

Formal Silk declarations let you name intermediate values for use in specifications.

Syntax:

```silk
#const name = <Expr>;
```

Rules:

- `#const` is a statement that may appear inside function bodies (inside blocks).
- The binding is **compile-time-only** and is not lowered into runtime code.
- A `#const` binding is visible only inside specification expressions:
  - function specs (`#require`, `#assure`),
  - loop specs (`#invariant`, `#variant`, `#monovariant`).
- Using a `#const` name in a runtime expression (e.g. in `while` conditions or normal
  `let` initializers) is a compile-time error. Use a normal `let` binding for
  runtime values, and (optionally) introduce a `#const` alias for specifications.

Example:

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  while i < limit {
    i = i + 1;
  }
  return 0;
}
```

#### Function annotations (initial syntax)

For functions, the initial surface syntax is:

```silk
#require <Expr>;
#require <Expr2>;
#assure <Expr3>;
#theory TheoryName(args...);
fn name (params) -> ResultType {
  ...
}
```

- One or more `#require`, `#assure`, and contract-theory attachments
  (`#theory Name(args...);`) may appear, in any order, immediately before the
  `fn` declaration (and before any `export` modifier).
- Each annotation is terminated by a semicolon.
- The compiler front-end:
  - lexes these annotations as dedicated tokens,
  - parses the annotation expressions using the normal expression grammar,
  - type-checks each annotation expression as `bool` so obvious mistakes are
    rejected early (specifications are still compile-time-only metadata),
  - attaches them to the corresponding function in the AST as lists of
    preconditions, postconditions, and contract theories.

Loop specifications (`#invariant`, `#variant`, `#monovariant`) follow a similar
pattern for loops.

#### Loop annotations (initial syntax)

For `while` loops, the initial surface syntax is:

```silk
#invariant <Expr>;
#variant <Expr2>;
#monovariant <Expr3>;
while condition {
  ...
}
```

Rules:

- One or more `#invariant` annotations, zero or more `#monovariant` annotations,
  and at most one `#variant` annotation may appear immediately before the
  `while` keyword.
- Each annotation is terminated by a semicolon.
- The compiler front-end:
  - lexes these annotations as directive tokens,
  - parses the annotation expressions using the normal expression grammar,
  - attaches them to the corresponding loop in the AST as invariants,
    monovariants, and a (single) variant expression.

The verifier will interpret:

- `#invariant` expressions (type `bool` in Silk) as properties that must hold:
  - before entering the loop,
  - after each iteration (assuming the body and condition do not diverge),
  - and at `break` exits (so proofs after the loop may rely on the invariant).
- `#variant` expressions as a well-founded measure that must decrease on each
  iteration (and be non-negative at the loop head), used for termination proofs.
- `#monovariant` expressions as measures that must be monotonic on each
  iteration (either non-decreasing or non-increasing, proved consistently across
  all continuation paths).

Compiler requirements:

- Parse and represent these annotations in the AST.
- Integrate with the verifier to check specifications.
- Ensure that, if verification fails, compilation fails with clear diagnostics.

#### Block assertions (`#assert`)

Formal Silk also supports block-local proof obligations:

```silk
#assert <Expr>;
```

Rules:

- `#assert` is a statement that may appear inside function/test bodies (inside
  blocks).
- It is compile-time-only metadata and is not lowered into runtime code.
- The verifier must prove the assertion holds in the current symbolic state at
  the `#assert` site. If it cannot be proven, compilation fails.
- After a `#assert` succeeds, the asserted expression is assumed to hold for
  the remainder of the block (so later proofs may rely on it).

### Theories (`theory` / `#theory`)

A **theory** is a reusable, parameterized block of Formal Silk directives that
can be applied at points inside a function body to assert properties about the
current symbolic state.

#### Syntax

Declaration form (top-level):

```silk
export theory a_custom_theory (x: int, y: int) {
  #const z = x + y;
  #invariant x != 0 && y != 0;
  #invariant z > 1;
}
```

An inline theory declaration may also appear as a statement inside a
function/test block:

```silk
fn main (x: int, y: int) -> int {
  #theory local_sum_nonzero (x: int, y: int) {
    #const z = x + y;
    #assure z != 0;
  }

  #theory local_sum_nonzero(x, y);
  return 0;
}
```

Use form (statement inside a function body, or inside another theory body):

```silk
fn main (x: int, y: int) -> int {
  #theory a_custom_theory(x, y);
  return 0;
}
```

Theories may apply other theories:

```silk
export theory nonzero (x: int) {
  #require x != 0;
}

export theory nonzero_sum (x: int, y: int) {
  #theory nonzero(x);
  #theory nonzero(y);
  #assure (x + y) != 0;
}
```

Notes:

- Top-level theory declarations use the `theory` keyword.
- Inline (block) theory declarations and theory use sites share the `#theory`
  token; the parser disambiguates by the token that follows the
  argument/parameter list:
  - `{ ... }` starts an inline theory declaration,
  - `;` terminates a theory use.
- A top-level theory declaration may be exported (`export theory ...`). Exported
  theories may be imported from other modules and reused.
- Inline theory declarations inside a block are not exportable/importable; they
  exist only in the containing block and may be applied via `#theory Name(...);`
  after they are declared.
- A theory body may contain `#theory Name(args);` statements. These are
  compile-time-only theory applications; they are checked by the verifier in the
  current symbolic state at the point they appear in the theory body.
- Theory recursion is rejected (direct or indirect cycles).
- Theories are not runtime functions. They can only be applied via `#theory` use
  statements; calling a theory with normal call syntax (`Name(...)`) is a
  compile-time error.

#### Prefix `#require` / `#assure` on theories

For ergonomics, a `theory` declaration may be preceded by `#require` and/or
`#assure` directives:

```silk
#require x >= 0;
export theory ensure_nonnegative_x (x: int) {
  #assure x >= 0;
}
```

These prefix directives are treated as if they were written at the beginning of
the theory body.

#### Theories as function contracts

A function may attach one or more theories as part of its Formal Silk contract
surface by placing `#theory Name(args...);` directives in the function-spec
prelude:

```silk
import { bounded_nonneg_add } from "./theories.slk";

#theory bounded_nonneg_add(x, y);
export fn add (x: int, y: int) -> int {
  return x + y;
}
```

Contract-theory attachments:

- are compile-time-only metadata (not runtime statements),
- contribute additional preconditions/postconditions to the function contract:
  - `#require` become additional function preconditions,
  - `#assure` and `#invariant` become additional function postconditions,
- are used by the verifier to enable contracted calls in verified code (see
  “Calls in verified code” above),
- are not permitted before a top-level `theory` declaration (only `#require` /
  `#assure` may prefix a theory declaration).

#### Importing theories

Exported theories may be imported via JS-style named imports and then applied
via `#theory` use statements.

Example:

```silk
// theories.slk
export theory ensure_positive_x (x: int) {
  #assure x > 0;
}
```

```silk
// main.slk
import { ensure_positive_x as pos_x } from "./theories.slk";

fn main () -> int {
  let x: int = 1;
  #theory pos_x(x);
  return 0;
}
```

Rules:

- Only exported theories may be imported.
- A theory use (`#theory Name(args);`) resolves `Name` as either:
  - a local theory declared in the same module, or
  - an imported theory name from `import { ... } from "<specifier>";`.
- Namespace imports (`import ns from "<specifier>";`) do not currently provide
  theory access, because theory use sites do not accept qualified names
  (`ns::TheoryName`) yet.

#### Semantics (initial subset)

When a theory is applied (`#theory Name(args);`):

- its parameters are bound to the provided argument expressions (as
  specification expressions),
- its `#const` formal declarations are evaluated and are visible only within the
  theory during checking,
- each `#require <Expr>;`, `#invariant <Expr>;`, and `#assure <Expr>;`
  directive in the theory body is treated as a compile-time proof obligation
  that must hold in the current symbolic state at the use site,
- each `#variant <Expr>;` directive in the theory body is treated as a
  non-negativity obligation (`Expr >= 0`) at the use site (the theory form does
  not model decrease across iterations).

Theory bodies are verifier-only:

- Theory argument expressions and theory directive expressions are **Formal Silk
  specification expressions** evaluated by the verifier.
- In Silk, specification expressions do not support function
  calls or value construction (for example `foo(x)`, `Type{...}`, arrays, or
  `new`). Such expressions are rejected as unsupported Formal Silk.

The theory form is compile-time-only and has no runtime semantics.

## Generics (Monomorphized)

This document specifies Silk’s parameterized type and declaration syntax.

parameterized declarations are **monomorphized** into concrete, fully specified
types and functions at build time (there are no runtime type parameters).

Note: `Option(T)` is a special-case surface form that is treated as sugar for
`T?` in Silk (see `Optional`). This is still
accepted in Silk even as general-purpose type-parameter generics are
implemented.

### Overview

Silk supports parameterized declarations by allowing a parameter list on
`struct`, `interface`, `enum`, `impl`, and `fn` declarations.

In Silk:

- **Supported**: type parameters (`T`) and const parameters (`N: usize`) on
  `struct`/`interface`/`enum`/`impl`, type application in type positions
  (`Name(args...)`), and generic functions using a compile-time parameter
  section separated by `;` in the signature (`fn id(T; x: T) -> T`) (including
  generic methods in `impl` blocks).

### Declaration syntax

#### Parameter lists

The parameter list uses parentheses:

```silk
struct Vector(T) {
  // ...
}
```

Rules:

- `T` is a type parameter.
- Type parameters may provide a default type argument using `=`:
  - `interface Serialize(S = string) { ... }`
  - defaults must be **trailing** (once a parameter has a default, all
    subsequent parameters must also have defaults).
- Const parameters are written with an explicit type annotation:
  - `N: usize`
  - const parameters are compile-time integer values and may be used in type
    positions such as array lengths (`T[N]`) and type applications.
- The parameter list may be empty (though it is uncommon): `struct Foo() { ... }`.

Supported declaration forms:

- `struct Name(T, ...) { ... }`
- `interface Name(T, ...) { ... }`
- `enum Name(T, ...) { ... }`
- `impl Name(T, ...) { ... }`
- `impl Name(T, ...) as InterfaceName(T, ...) { ... }`

#### Applying parameters in types

Parameterized types are referenced using the same call-like syntax in type
positions:

```silk
Vector(int)
Mutex(Account)
Result(int, string)
```

### Generic enums (tagged unions)

Enums may be parameterized and are monomorphized like generic structs.

Because applied types are not used directly as expression qualifiers in the
current surface syntax, callers typically introduce a local alias for an
instantiation and then use that alias to construct and match variants:

```silk
enum Result(T, E) {
  Ok(T),
  Err(E),
}

type R = Result(int, string);

fn main () -> int {
  let x: R = R::Ok(123);
  return match x {
    R::Ok(v) => v,
    R::Err(_) => 0,
  };
}
```

Default type arguments:

- When a parameterized declaration provides default type arguments, a use site
  may omit **trailing** arguments that have defaults.
- If all parameters have defaults, the type may be referenced as `Name` or
  `Name()` (both are equivalent to applying the defaults).

Type arguments may be:

- types (e.g. `int`, `&Foo`, `Option(string)`).
- integer literals for const parameters (e.g. `Vector(u8, 1024)`).

Const arguments are compile-time integer literals and participate in
monomorphization identity.

### Interfaces and applied interface types

Interfaces may be generic:

```silk
interface Channel(T) {
  fn send(value: T) -> bool;
  fn recv() -> T?;
}
```

An `impl ... as ...` conformance may apply type arguments to the interface:

```silk
struct QueueU8 {
  // ...
}

impl QueueU8 as Channel(u8) {
  // ...
}
```

Rule: when a generic interface is referenced in a concrete `impl X as I(...)`,
all interface type arguments must be fully known at that conformance site. The
only exception is when the conformance itself is generic (type parameters are
in scope), for example:

```silk
struct Data(T) { /* ... */ }
interface DataInterface(T) { /* ... */ }

impl Data(T) as DataInterface(T) {
  // ...
}
```

### Impl blocks for generic structs

If a struct is declared with type parameters, its impl blocks must also declare
those parameters:

```silk
struct Data(T) { /* ... */ }

// OK:
impl Data(T) { /* ... */ }

// Error:
// impl Data { /* ... */ }
```

This rule keeps method receiver typing unambiguous and makes monomorphization
explicit.

### Functions (initial parsed surface form)

Generic functions require a way to declare type/const parameters distinct from
value parameters. The initial parsed surface form is:

```silk
fn get_first(T, N: usize; v: &T[N]) -> T {
  // ...
}
```

Where the `;` separates generic parameters from value parameters inside the
function’s parameter list.

#### Alternate (Go-like) function declaration syntax

Silk also supports a Go-like generic header form:

```silk
fn (T, N: usize) get_first (v: &T[N]) -> T {
  // ...
}
```

This is sugar for the `;` form above; the compiler records the same generic
parameter list (`T, N: usize`) either way.

Rules:

- At most one generic parameter list may be provided:
  - either `fn name(T; ...)`,
  - or `fn (T) name (...)`.

#### Call syntax for generic functions

Calls mirror the signature split:

```silk
let x: int = get_first(int, 4; &xs);
```

Rules:

- the `;` separates compile-time arguments from runtime value arguments,
- compile-time arguments are a comma-separated list of:
  - type arguments (`int`, `&Foo`, `Option(string)`),
  - and integer literals for const arguments,
- runtime arguments are ordinary expressions.
- the compile-time argument list may be empty when defaults supply all generic
  parameters, for example `id_default(; 1)` uses the default type argument for
  `T` in `fn id_default(T = int; x: T) -> T`.

#### Call-site type inference (omitting `;`)

When a call does not include the generic separator (`;`), the compiler may
infer type and const arguments from runtime arguments:

```silk
fn (X, Y) add (x: X, y: Y) -> X {
  return x + y as X;
}

let a = add(1.123, 2); // infers X = f64, Y = int
```

Rules:

- Both **type** parameters (`T`) and **const** parameters (`N: usize`) may be
  inferred.
- Inference is driven by the runtime argument expressions and any types that
  are known at the call site:
  - literals (`123`, `1.0`, `"hi"`, `'a'`, `true`),
  - struct literals (`Point { ... }`),
  - explicit casts (`expr as Type`),
  - and name expressions (`x`) when the binding’s type is known (from an
    annotation like `let x: T = ...` or from a simple initializer like a
    literal/struct literal).
- Const parameters are inferred only from type structure:
  - array lengths (`T[N]`),
  - and const arguments in applied types (`Buffer(T, N)`),
  when the corresponding runtime argument type provides a concrete value.
- When inference cannot determine a type argument, compilation fails with an
  actionable diagnostic. Disambiguate by either:
  - inserting `as` casts on runtime arguments, or
  - using the explicit `;` form (`add(f64, int; 1.123, 2)`).
  When inference cannot determine a const argument, disambiguate by using the
  explicit `;` form (`take_buf(4; buf)`).

### Implementation notes

- Monomorphization produces a concrete instance for each referenced
  instantiation `Name(args...)`.
- Type names share one namespace within a `package`: `struct`, `interface`,
  `enum`, `error`, and `type` declarations may not reuse the same name.
- Name conflicts across generic arities are rejected (for example, `struct Foo`
  and `struct Foo(T)` cannot both exist in the same package namespace).
- Const parameters are currently restricted to integer primitive types; const
  values are usable in type positions (for example `T[N]`) but are not yet
  exposed as runtime values.

## Refinement Types

Refinement types are types annotated with logical predicates that constrain the
set of values they may represent. They are a tool for making illegal states
unrepresentable and for turning certain classes of bugs into compile-time
errors.

current compiler subset. Today, Silk provides verification annotations
(`#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`) and formal Silk declarations (`#const`)
as compile-time-only metadata; see `Formal Silk`.

Note: in Silk, any use of a `where` predicate is verification syntax. When
`where` predicates are implemented, their presence will require proof (VC
generation + Z3 discharge) for the compiled module set, per
`Formal Silk`.

### Overview

A refinement type consists of:

- a **base type** (for example `int`, `string`, `&T`, or a struct), and
- a **predicate** that must hold for all values of the refinement type.

The predicate is written in Silk’s specification expression language (the same
expression grammar used by `#require` / `#assure`).

### Proposed Surface Syntax

One intended surface form is a record-like binder with a `where` clause:

```silk
type NonEmptyString = { s: string where std::length(s) > 0 };
```

Notes:

- `type` aliases are not implemented yet (this is design work).
- The binder name (`s`) is a name for the value being constrained, usable
  inside the predicate.

### Checking Model

The compiler/verifier discharges refinement predicates using:

- constant-folding and local reasoning for literals and simple expressions,
- facts established by control-flow (guards) when the verifier can prove them,
- facts provided by contracts (`#require` / `#assure`) and invariants
  (`#invariant`),
- and, where necessary, explicit evidence via helper constructors or lemmas.

When the compiler cannot prove a predicate, the program should fail to compile
with a diagnostic that:

- points to the predicate that could not be proven, and
- suggests how to provide evidence (guard, constructor, or contract).

### Relationship to `#require` / `#assure`

Refinement types and function contracts are meant to compose:

- A parameter of a refinement type encodes a precondition at the type level.
- A refinement return type encodes a postcondition at the type level.

Example (design-only):

```silk
type NonZeroInt = { n: int where n != 0 };
fn safe_divide(numer: int, denom: NonZeroInt) -> int {
  return numer / denom;
}
```

### Implementation Notes

In the current implementation:

- there is no `type` alias declaration,
- there is no `where` clause in types,
- and there is no verifier that can prove user-defined predicates.

The existing verification directives (`#require`, `#assure`, `#assert`,
`#invariant`, `#variant`, `#monovariant`) are parsed, type-checked as `bool` where appropriate, and preserved
as metadata, but they do not yet affect code generation.

## Dependent Types (Const Parameters and Type-Level Computation)

This document specifies Silk’s intended support for “dependent-type-like”
patterns where types mention compile-time values (most notably integers).


- declaration parameter lists on `struct`, `impl`, and `fn`,
- type application in type positions (for example `VectorN(int, 1024)`),

but the compiler does not yet implement constraint checking, inference, or
monomorphization/code generation for parameterized declarations. In the current
compiler subset, generic parameter lists and applied types are rejected during
type checking (`Compiler Diagnostics`, `E2016`). See
`Generics (Monomorphized)`.

### Const Parameters

Const parameters are compile-time values that appear in parameter lists with a
type annotation:

```silk
struct VectorN(T, N: int) { /* ... */ }
```

Where:

- `T` is a type parameter, and
- `N: int` is a const parameter whose value must be known at compile time.

The initial supported const-argument form in type application is integer
literals (for example `VectorN(int, 1024)`).

### Type-Level Computation

The language intends to allow certain expressions over const parameters in type
positions (design-only):

```silk
fn concat(T, M: int, N: int; a: VectorN(T, M), b: VectorN(T, N)) -> VectorN(T, M + N) {
  // ...
}
```

This requires:

- a notion of const expressions at the type level,
- evaluation rules (and overflow behavior) for those expressions,
- and a compilation strategy (typically monomorphization) that produces concrete
  layouts and code for each instantiated type.

### Function Parameter Lists (CT/RT Split)

Generic functions use a single parameter list split by a top-level `;` inside
the parentheses:

```silk
fn id(T; x: T) -> T { return x; }
fn g(T;) -> T { /* CT-only, rare */ }
fn h(x: int) -> int { return x; } // RT-only
```

This split is parsed and preserved by the front-end, but generic functions are
rejected by the current checker until monomorphization is implemented
(`Compiler Diagnostics`, `E2016`).

### Relationship to Arrays and Collections

Const parameters are intended to power:

- fixed-size arrays (`T[N]`),
- dependent-length collections (for example `VectorN(T, N)`),
- and compile-time-checked indexing/slicing APIs.

These features require additional language and runtime support beyond the
current compiler subset.

## Function Disciplines (`pure`, `task`, `async`)

This document specifies Silk’s intended “function discipline” system: how
functions declare whether they are pure, asynchronous, or safe to run as
parallel tasks.

Const functions (`const fn`) are specified separately in
`Const Functions (`const fn`)`. The `const` modifier is orthogonal to the
discipline system described here (a `const fn` may also be declared `pure`).

`pure fn` parsing and a strict purity checker. Concurrency disciplines (`task` /
`async`) are parsed and `Task(T)` / `Promise(T)` handles plus `yield` (task
values) and `await` (promise values) are implemented in Silk
(`await Task(T)` is rejected), but the compiler does not yet implement an async
event loop, coroutine lowering, or task-safety (`Send`/`Sync`) rules. See
`Concurrency` for the concurrency model and implementation
status.

### Overview

The language design distinguishes:

- `fn` — normal function (may perform effects; blocking).
- `pure fn` — function with no observable side effects (referentially
  transparent).
- `task fn` — function safe to execute on a worker pool as a parallel task.
- `async fn` — function that may suspend at `await` points (returns an
  awaitable).
- `async task fn` — async function executed as a separate task (self-contained
  worker).

### Intended Call Rules (Design)

The checker is expected to enforce:

- `pure` code may call only `pure` code (and cannot perform I/O or mutation
  outside local, non-escaping temporaries).
- `task` code may call `task` and `pure` code, and must satisfy task-safety
  rules for captured/argument data.
- `async` code may `await` other async operations; it may call `pure` code and
  may offload blocking work via explicit adapters (planned intrinsics).

Crossing discipline boundaries is intended to be explicit and diagnostic-driven
(for example suggesting the correct adapter/intrinsic).

### Standard Intrinsics

The standard library is expected to provide typed adapters to cross boundaries
safely (names and exact signatures are design work):

- lifting sync work onto a task pool,
- presenting a task as an async operation,
- running blocking work from async without stalling the event loop,
- structured spawn/join primitives.

These APIs are not yet present in the in-tree `std/` implementation.

### Implementation Notes

Today:

- `pure fn` is parsed and checked ():
  - a `pure fn` may call only `pure` functions; `ext` is treated as impure,
  - the checker also supports purity inference (“auto-pure”) for ordinary `fn`
    declarations and `impl` methods:
    - when an unannotated function/method has an eligible signature and its
      body satisfies the purity rules, it is treated as `pure` for call
      checking, and may be called from `pure` code,
    - functions/methods with `&T` parameters are not eligible for inference
      (explicit `pure fn` remains supported for `&T` parameters in the current
      subset),
  - `pure` cannot be combined with `task` or `async` in Silk,
  - a `pure fn` may not have `mut` parameters,
  - a `pure fn` may not declare mutable locals (`var` or `let mut`) and may not
    perform mutation via assignment,
  - a `pure fn` may not allocate (`new`) in Silk,
  - a `pure fn` may not have a typed-error contract (`-> T | Error...`) and may
    not contain `panic` statements.
- `task fn`, `async fn`, and `async task fn` are parsed and preserved in the AST.
- Calls across disciplines are now reflected in expression types:
  - calling a `task fn` yields `Task(T)`,
  - calling an `async fn` yields `Promise(T)`,
  - calling an `async task fn` yields `Promise(Task(T))`,
  - `yield` sends task values (`yield v;`) and receives task values (`yield t`),
    and `yield * t` drains/collects remaining task values into `T[]`,
  - `await` unwraps `Promise(T)` and yields `T` (`await Task(T)` is rejected),
    and `await * ps` unwraps `Promise(T)[]` into `T[]`.
- `await <expr>` and `async { ... }` / `task { ... }` blocks are enforced as
  **async-only** constructs:
  - `await` is only permitted inside `async` functions (including `async task fn`),
  - `async { ... }` / `task { ... }` blocks are only permitted inside `async` functions.
- `yield <expr>` is enforced as a **task-only** construct:
  - `yield` is permitted only inside `task` functions (`task fn` / `async task fn`)
    and inside `task { ... }` / `task loop { ... }` blocks.
- Lowering/codegen implements `task` execution using OS threads on `linux/x86_64`
  and implements `yield`/`yield *` for task values plus `await` for promises.
  - There is not yet a coroutine transformation or event loop; awaiting a
    `Promise(T)` currently does not “park” the OS thread (it is still a
    synchronous unwrap in Silk).
  - `async { ... }` / `task { ... }` blocks are still lexical blocks in the
     (they do not yet introduce scheduler behavior).
- Function types are parsed in type positions (notably for `ext`).
- Function expressions are implemented as first-class function values:
  - `fn (x: int) -> x + 1` (expression body),
  - `fn (x: int) -> int { return x + 1; }` (block body).
  - Function expressions may not declare `&T` parameters.
  - Non-capturing function expressions are inferred as `pure` and are callable
    from `pure` code.
  - Capturing closures are supported as a subset:
    - a function expression may reference immutable locals/parameters from an
      enclosing scope,
    - captures are by-value copies into a heap environment (scalar-only in the
      ),
    - capturing closures are not `pure` and are rejected in `pure` code.
  - Function values (both non-capturing and capturing) are supported end-to-end:
    they may be passed, returned, stored, and called indirectly.

## Const Functions (`const fn`)

### Summary

Silk supports compile-time evaluation of certain expressions to produce
compile-time constants. `const fn` (and `const pure fn`) declarations opt a
function into this compile-time evaluation system so that it can be called from
compile-time contexts (for example, a `const` binding initializer).

### Syntax

`const` is a function modifier:

```silk
const fn add (a: int, b: int) -> int {
  return a + b;
}

const pure fn add2 (a: int, b: int) -> int {
  return a + b;
}
```

Notes:

- `const pure fn` is simply a `const fn` that also opts into the `pure` rules
  (see `Function Disciplines (`pure`, `task`, `async`)`).
- `const fn` is a **compile-time-only** function:
  - it may be called only from compile-time contexts (for example `const`
    initializers and Formal Silk specifications),
  - it is not emitted as a runtime/linkable symbol in executable, object, or
    library outputs.

### Compile-Time Values ()

In this document, a “compile-time value” is a value that the compiler can
produce and manipulate during compile-time evaluation.

 (initial implementation target):

- scalar primitives:
  - `bool`
  - fixed-width integers (`i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`)
  - `int`
  - `f32`, `f64`
  - `char`
  - `Instant`, `Duration`

Planned (not yet supported for `const fn` in Silk):

- `string` values (string literals are supported directly in `const` bindings),
- aggregate values (struct/enum/optional/slice/array) as return values,
- function values as compile-time values (for higher-order const evaluation).

### Rules ()

The  defines a deliberately small “const-eval VM” surface. A
`const fn` must fit within this surface.

#### Signature rules

In Silk, a `const fn`:

- must not be `task` or `async`,
- must not declare a typed-error contract (`-> T | ErrorType...`),
- must have a non-`void` return type that is a compile-time value type,
- must have parameters whose types are compile-time value types.

#### Body rules

In Silk, a `const fn`:

- must not allocate (`new`) and must not use regions/`with`,
- must not contain `panic` statements,
- must not declare `const` local bindings,
- may call only other `const fn` declarations,
- is restricted to a small expression subset over scalar values:
  - literals and local names (parameters and `let` bindings; no global `const` reads in Silk),
  - `as` casts between supported scalar types,
  - unary operators: `-`, `~`, `!`,
  - binary operators:
    - arithmetic: `+`, `-`, `*` (division/modulo are not part of the const-eval subset),
    - bitwise: `&`, `|`, `^`, `<<`, `>>`,
    - comparisons: `==`, `!=`, `<`, `<=`, `>`, `>=`,
  - `if` expressions (`if cond { a } else { b }`).
  - assignments to local names: `=`, `+=`, `-=`, `*=`, plus `++`/`--`.

Control flow is limited to:

- `if` / `else` statements,
- `while` loops with boolean conditions,
- `break` / `continue`,
- `return` statements.

### Calling Const Functions

The initial intended compile-time use site is `const` bindings:

```silk
const fn add (a: int, b: int) -> int {
  return a + b;
}

const answer: int = add(20, 22);

fn main () -> int {
  return answer;
}
```

Const functions may also be imported/exported across modules/packages like
runtime declarations, but they are still compile-time-only: importing a `const
fn` does not make it callable from runtime code.

### “No Static Storage” Rule

Const functions do not create new static storage. In particular:

- compile-time execution may compute scalar values and fold them into constants,
- compile-time execution must not allocate heap memory,
- compile-time execution must not synthesize new global read-only data (for
  example, it cannot build a new string at compile time in Silk).

String literals are still backed by read-only static storage, but they are
introduced by the literal syntax itself (see `String Literals`), not by the
`const fn` evaluator.

### Evaluation Limits

Compile-time evaluation must terminate. The current implementation enforces an
instruction budget and a call-depth budget when executing `const fn` bodies at
compile time; evaluation that exceeds these budgets is rejected as not
compile-time evaluable.

## Varargs (Variable Arguments)

Silk supports declaring functions that accept a variable number of trailing
arguments (“varargs”). This is used heavily by `std::io::print` /
`std::io::println` for formatted output.

### Syntax

Varargs are declared by prefixing the final parameter with `...`:

```silk
fn log (fmt: string, ...args: std::fmt::Arg) -> void {
  std::io::println(fmt, args);
}
```

Rules:

- A function may declare **at most one** varargs parameter.
- The varargs parameter must be **the final** parameter in the list.
- The varargs parameter must have an explicit **type annotation**.
- Varargs parameters are **not** permitted to be `mut` in Silk.
- Varargs parameters may not have a default expression (`= ...`) in the current
  subset.

### Call Semantics

At call sites:

- All non-varargs parameters are matched positionally as usual.
- Any additional arguments are collected into the varargs parameter.

Example:

```silk
std::io::println("hello {s} answer={d}", "world", 42);
```

Here `"world"` and `42` become varargs elements.

#### Forwarding

Because Silk does not yet have a general “spread” operator for calls, the
current implementation supports forwarding a varargs pack when you pass a
varargs binding as the final argument.

```silk
fn log (fmt: string, ...args: std::fmt::Arg) -> void {
  // `args` is forwarded as-is to `println`.
  std::io::println(fmt, args);
}
```

This is primarily intended for building wrappers that preserve the caller’s
argument list without repacking.

### Representation

In Silk, a varargs parameter is lowered as a
fixed-size **pack value** with:

- `len: int` — the number of provided varargs arguments.
- `a0 .. a(N-1)` — storage for up to `N` arguments (implementation-defined,
  currently `N = 128`).

The pack is passed by value using the same “flattened scalar slot” ABI as other
POD structs.

Notes:

- Accessing `aK` where `K >= len` is a logic error (the value is unspecified).
- Calls supplying more than `N` varargs arguments are rejected.

### FFI (C Variadics)

This document is about Silk varargs. C variadic functions declared via `ext`
(`printf`-style `...`) are a separate concern and are **not** implemented yet
In Silk.

## Language Spec Conventions

This document defines conventions used across `this specification`. It exists to
keep the language specification consistent and easy to navigate for both:

- first-time readers learning Silk, and
- returning readers looking up precise rules.

See also: `Silk Language Guide (Index)` for recommended reading paths.

### Document Structure (Recommended)

Concept documents should be structured so readers can answer, quickly:

- “What is this feature for?”
- “What syntax does the compiler accept?”
- “What are the rules and edge cases?”
- “What works in the current compiler today?”

Recommended sections:

1. **One-paragraph summary**
2. **Implementation status** (if the concept is partially implemented)
3. **Surface syntax**
4. **Semantics** (evaluation order, scoping, control-flow behavior)
5. **Type checking rules** (static requirements and diagnostics)
6. **Examples**
   - minimal examples (smallest correct usage)
   - realistic examples (how the feature is used in real code)
7. **Common pitfalls**
8. **Related documents**
9. **Relevant tests** (links to `the runnable fixtures` and `the runnable fixtures`)

Not every concept needs every section, but the goal is that a reader should
never have to infer critical rules from examples.

### “Implementation status” Format

When a feature is not fully implemented end-to-end, the concept doc should
include an explicit “Implementation status” section near the top.

Use concrete statements, not vague language. Prefer describing support in
these layers:

- Parser: which surface forms are accepted.
- Checker: which typing/validation rules are enforced.
- Lowering/backends: which forms code-generate end-to-end on supported targets.
- C ABI / FFI: whether the feature is permitted at exported boundaries.

When something is rejected in Silk, include the diagnostic code
from `Compiler Diagnostics` when one exists.

### Examples

Examples in language docs should follow these rules:

- Use 2-space indentation and spaces only.
- Prefer complete, runnable snippets when possible:

  ```silk
  fn main () -> int {
    return 0;
  }
  ```

- When an example requires multiple files, label them with comments, e.g.:

  ```silk
  // app/main.slk
  package app;
  ```

- When an example is intentionally invalid (to show a rule), label it and
  mention the expected diagnostic.

### Terminology

These terms are used consistently across the spec:

- **Expression**: a construct that produces a value and has a type.
- **Statement**: a construct evaluated for its effects and sequencing.
- **Block**: `{ stmt* }`, a scope boundary and the unit of structured control
  flow. (Whether blocks are also expressions depends on the concept; docs must
  be explicit.)
- **Current compiler subset**: the set of features that parse, type-check, and
  code-generate end-to-end in the current implementation.

### Cross-References

When describing a rule, link to the most relevant concept doc rather than
restating it everywhere. Common cross-links include:

- `Formal Grammar Spec` for the exact accepted syntax,
- `Types` for type-system rules and special cases,
- `Mutability` for `mut` and borrowing rules,
- `Compiler Diagnostics` for error codes,
- `the implementation status` for a high-level implementation snapshot.

## Operators

This document summarizes the operator set and precedence for Silk.

### Operator Set

The language includes the following operators and delimiters:

- Assignment and compound assignment: `=`, `+=`, `-=`, `*=`, `/=`.
- Increment/decrement: `++`, `--` (prefix and postfix).
- Arithmetic: `+`, `-`, `*`, `/`, `%`.
  - In the current implementation:
    - integer operands support `+`, `-`, `*`, `/`, and `%`,
    - floating-point operands (`f32`/`f64`) support `+`, `-`, `*`, and `/`
      (no `%`).
    - unary `-x` is supported for both integer and floating-point operands.
    - time types support a small arithmetic subset:
      - `Duration + Duration`, `Duration - Duration`, and unary `-Duration`,
      - `Instant + Duration`, `Duration + Instant`, `Instant - Duration`,
      - and `Instant - Instant` (producing a `Duration`).
- Bitwise: `&`, `|`, `^`, `~`, `<<`, `>>`.
  - In the current implementation, bitwise operators are defined for
    integer operands (`int` and the fixed-width integer types):
    - `&`, `|`, `^` perform bitwise AND/OR/XOR on two integer values of the
      same type and produce a result of that same type.
    - `~x` performs bitwise NOT on an integer value and produces a result of
      that same type.
    - `<<`, `>>` shift the left-hand integer operand by an integer shift
      amount of the same type; `>>` uses an arithmetic right shift for
      signed integers (`i*`/`int`) and a logical right shift for unsigned
      integers (`u*`).
- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`.
  - In the current implementation, comparisons are defined for both integer
    operands and floating-point operands of the same type.
  - In Silk, `==` and `!=` are also defined for `bool`
    operands.
  - In Silk, comparisons are also defined for `Duration`
    and `Instant` when both operands have the same time type.
  - In Silk, `==` and `!=` are also defined for `string`
    operands, comparing the underlying UTF-8 byte sequences for equality
    (length check + bytewise compare).
  - In Silk, ordered comparisons over `string`
    (`<`, `<=`, `>`, `>=`) are defined as bytewise lexicographic ordering over
    the underlying UTF-8 byte sequences (unsigned byte comparison, with
    shorter-prefix ordering when one string is a prefix of the other).
  - In Silk, `==` and `!=` are also defined for supported
    optional values (`T?`, `string?`, optionals of the supported `struct`
    subset, and nested optionals `T??`):
    - `None == None` is true,
    - `Some(x) == Some(y)` compares the payload values for equality (recursively
      for nested optionals),
    - and `!=` is the logical negation of `==`.
    - In the current implementation, `None` and `Some(...)` can appear in
      equality expressions when the other operand has an optional type (for
      example `opt == None` and `opt == Some(x)`), using that other operand’s
      type to infer the optional payload type.
  - In Silk, `==` and `!=` are also defined for the
    supported `struct` subset (see `Structs, Impl Blocks, and Memory Layout`),
    performing slot-wise equality over the lowered scalar slots (including
    embedded strings, nested structs, and optionals); float slots use IEEE-754
    equality semantics. Ordered struct comparisons are not implemented.
  - Float comparisons follow IEEE-754 semantics: `NaN` compares unequal to
    everything (including itself), and ordered comparisons (`<`, `<=`, `>`,
    `>=`) are false when either operand is `NaN`.
- Logical: `!`, `&&`, `||`.
  - In the current implementation:
    - `!` is supported for `bool` operands.
- Member and scope: `.`, `::`, `?.`.
- In the current implementation:
  - `.` and `::` are supported,
  - and `?.` is supported for optional field access on the supported `struct`
    subset (`opt?.field` yields `FieldType?`; see `Optional`).
- Casts: `as` and `as raw` (postfix).
  - Syntax:
    - numeric/shape cast: `<expr> as <Type>`,
    - raw bit-cast: `<expr> as raw <Type>`.
  - `as` is an explicit, potentially lossy conversion operator intended for
    primitive numeric conversions (see “Casts (`as`)” below).
  - `as raw` is an explicit bit reinterpretation operator intended for
    generic storage/marshalling of scalar values (see “Raw casts (`as raw`)”
    below).
- Typed error propagation: `?` (postfix).
  - Syntax: `<call_expr>?`.
  - This propagates typed errors from an error-producing call to the enclosing
    function; see `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`.
- Ranges: `...`, `..=`, `..`.
- Other punctuation: `?`, `??`, `->`, `=>`, `,`, `;`, `(`, `)`, `{`, `}`, `[`, `]`, `_`, `:`.
  - In the current implementation, `??` is supported for optionals in the
    current backend subset (including scalar, `string`, and the current
    `struct` subset, plus nested optionals in the supported payload subset;
    see `Optional`). The `?` token is used both in type
    annotations (`T?`) and as the postfix typed error propagation operator for
    error-producing calls (`call()?`; see `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`).

The lexer and parser must recognize these tokens exactly as specified, and precedence/associativity must match the formal grammar.

### Assignment

Assignment updates an existing binding (an lvalue). Assignment is “statement-like”:
it is parsed as an expression but has type `void` and is intended to appear as an
expression statement.

#### `=`

`x = expr` evaluates `expr` and stores the resulting value into `x`.

Rules:

- The left-hand side must be an assignable lvalue. In the current implementation, it may be:
  - an identifier that refers to a local `let mut` binding, or
  - a struct field lvalue `name.field` where `name` is either:
    - a local `let mut` binding of a supported POD `struct`, or
    - a `mut` borrowed reference parameter (`mut name: &Struct`).
- Identifier lvalues must refer to `let mut` local bindings.
- The type of `expr` must match the binding’s type.
- The assignment expression has type `void`.

#### Compound assignment (`+=`, `-=`, `*=`, `/=`)

Compound assignments are shorthand for “read-modify-write”:

- `x += y` is equivalent to `x = x + y` (and similarly for `-=`/`*=`/`/=`),
  with `y` evaluated exactly once.

Rules:

- The left-hand side must be an assignable lvalue (as described above for `=`).
- In the current implementation, compound assignments are supported only for numeric
  scalar types (integers and `f32`/`f64`), including numeric struct fields.
- The compound assignment expression has type `void`.

### Increment and Decrement (`++` / `--`)

`++x`, `x++`, `--x`, and `x--` increment or decrement an existing binding by
`1`.

In Silk, increment/decrement expressions are “statement-like”: they have type
`void` and are intended to appear only as expression statements.

Rules:

- The operand must be an assignable lvalue (the same lvalue rules as `=`).
- The operand type must be an integer scalar type (`int`, `i8`, `u8`, `i16`,
  `u16`, `i32`, `u32`, `i64`, `u64`, `size`, `usize`). (`isize` is accepted as
  an alias for `size`.)
- Prefix and postfix forms are equivalent in Silk (both update the binding and
  produce `void`).
- Conceptual desugaring:
  - `x++` and `++x` are equivalent to `x += 1;`
  - `x--` and `--x` are equivalent to `x -= 1;`

### `sizeof`

`sizeof <operand>` produces the size of a type or value in bytes.

Result type:

- `sizeof` always returns `usize`.

Evaluation mode:

- When the operand is a **type name** (a primitive type, `struct`/`enum` name,
  type alias, or qualified type name), `sizeof` is a compile-time constant.
- When the operand is a **compile-time constant value** (literals and other
  const-evaluable expressions), `sizeof` is a compile-time constant.
- When the operand is a **runtime value**, `sizeof` is evaluated at runtime.

`Sized` integration:

- Planned: for runtime values, if the operand type provides an instance method
  matching `std::interfaces::Sized` (`fn size(self: &Self) -> usize`),
  `sizeof value` will lower to a call of that method.
- For type operands, if the operand type provides a static, pure method
  `pure fn size() -> usize`, the compiler may fold `sizeof Type` to that value
  when the method body is const-evaluable; otherwise it falls back to the
  compiler’s built-in size model.

Built-in size model (current backend subset):

- Sizes reflect the current scalar-slot lowering model (`Structs, Impl Blocks, and Memory Layout`):
  each lowered scalar occupies one 8-byte slot.
- A `string` value occupies two slots (`(u64 ptr, i64 len)`), so `sizeof string`
  is `16` in Silk.
- A `T[]` slice value occupies two slots (`(u64 ptr, i64 len)`), so `sizeof T[]`
  is `16` in Silk.
- A `T[N]` fixed array occupies `N * sizeof(T)` bytes in Silk,
  using the element’s scalar-slot size.

Parsing note:

- Because `Name[expr]` is also indexing syntax, fixed array **type** operands
  should be parenthesized: `sizeof (u8[4])`. Without parentheses, `sizeof u8[4]`
  is parsed as an index expression.
- Because `as` binds at postfix precedence, `sizeof x as T` parses as
  `sizeof (x as T)`. To cast the result of `sizeof`, write `(sizeof x) as T`.

### `alignof`

`alignof <operand>` produces the alignment of a type or value in bytes.

Result type:

- `alignof` always returns `usize`.

Evaluation mode:

- When the operand is a **type name** (a primitive type, `struct`/`enum` name,
  type alias, or qualified type name), `alignof` is a compile-time constant.
- When the operand is a **compile-time constant value** (literals and other
  const-evaluable expressions), `alignof` is a compile-time constant.
- When the operand is a **runtime value**, `alignof` is evaluated at runtime.

Built-in alignment model (current backend subset):

- Alignments reflect the current scalar-slot lowering model
  (`Structs, Impl Blocks, and Memory Layout`): values are stored as 8-byte slots.
- All non-`void` types currently have alignment `8`.
- `alignof void` is `1`.

Parsing notes:

- As with `sizeof`, fixed array **type** operands should be parenthesized:
  `alignof (u8[4])`. Without parentheses, `alignof u8[4]` is parsed as an index
  expression.
- Because `as` binds at postfix precedence, `alignof x as T` parses as
  `alignof (x as T)`. To cast the result of `alignof`, write `(alignof x) as T`.

### `offsetof`

`offsetof(Type, field_path)` produces the byte offset of a struct-like field
within `Type` in the current memory layout model.

Result type:

- `offsetof` always returns `usize`.

Evaluation mode:

- `offsetof` is always a compile-time constant.

Operands:

- `Type` must name a `struct` or `error` type (including nested structs).
- `field_path` is one or more field identifiers separated by `.` (for example
  `b` or `inner.header.len`).

Built-in offset model (current backend subset):

- Offsets reflect the current scalar-slot lowering model
  (`Structs, Impl Blocks, and Memory Layout`): each lowered slot is stored in an
  8-byte cell, and composite fields (nested structs, optionals, strings, etc.)
  are expanded into their slot sequences in source order.
- `offsetof(Type, field)` returns the offset of the **first slot** of that
  field’s lowered representation, in bytes.
- When `field_path` traverses an optional `T?` field, it refers to the payload
  layout (the path implicitly skips the tag slot).

### `typename`

`typename <expr>` and `typename(<expr>)` produce a `string` naming the static
type of `<expr>`.

Result type:

- `typename` always returns `string`.

Evaluation mode:

- `typename` is always a compile-time constant string.

Operand notes ():

- When the operand is a bare name that does **not** resolve to an in-scope
  runtime binding (for example `int`, `User`, or `std::wasm::Module`), the
  compiler interprets it as a type name and returns that type’s name.
- Formatting uses the compiler’s normal type formatting (for example `T[]`,
  `&T`, and `fn (...) -> ...`).
- For monomorphized generic instantiations, the string is the human-readable
  display name (not an internal `__silk_mono__...` symbol).

### `is`

`<expr> is <Type>` checks whether the **static type** of `<expr>` conforms to
`<Type>`.

Result type:

- `is` always returns `bool`.

Evaluation mode:

- `is` is always a compile-time constant boolean.

Rules ():

- The right-hand side must be a type (primitive, nominal `struct`/`enum`/`error`,
  `interface`, a function type, or a type alias for one of those).
- If `<Type>` is a nominal `struct` type, `expr is Type` is true when the
  expression’s static type is exactly `Type` **or** a `struct` that `extends`
  `Type`.
- If `<Type>` is an `interface`, `expr is Interface` is true when the expression’s
  static type declares conformance (`impl T as Interface`) or when the operand is
  a module declared `module Name as Interface`.
- For primitive types, enum/error types, reference types (`&T`), slice/array types
  (`T[]`, `T[N]`), optionals (`T?`), and function types, `is` currently checks
  **exact type equality** (after resolving type aliases).

Notes:

- `is` does not perform runtime tagging or value inspection. For runtime
  discrimination of union/optional values, use `match` and the relevant pattern
  forms.

Examples:

```silk
type Adder = fn (x: int, y: int) -> int;
fn my_adder (x: int, y: int) -> int { return x + y; }
if my_adder is Adder { /* ... */ }

struct User { id: u64 = 0 }
struct Beep extends User { boop: string = "" }
let beep = Beep{ boop: "boop" };
if beep is User { /* ... */ }

let n = 123;
if n is int { /* ... */ }

interface Logger { fn log (value: string) -> void; }
module my_logger as Logger {
  export log (value: string) { /* ... */ }
}
if my_logger is Logger { /* ... */ }
```

### Wrapping and Overflow

The spec notes “Arithmetic Wraps” for certain operators. The checker and code generator must:

- Implement deterministic wrapping behavior for integer arithmetic where required.
- Clearly separate wrapping operations from checked or saturating variants (if exposed in the standard library).

### Casts (`as`)

`as` is a postfix operator that performs an explicit conversion to a target
type.

#### Precedence

`as` binds at postfix precedence (like calls, field access, and `?`). For example:

- `a + b as int` parses as `a + (b as int)`.
- To cast the result of `new`, use parentheses so the cast applies to the heap
  reference: `(new Type{ ... }) as &Other`. Without parentheses,
  `new Type{ ... } as &Other` parses as `new (Type{ ... } as &Other)`.

#### Supported conversions ()

In Silk, `as` is supported for primitive scalar
conversions:

- Integer → Integer (including `Instant`, `Duration`, and `char`):
  - The conversion is deterministic and may be lossy. It is performed by
    canonicalizing the underlying bits to the destination integer type
    (width truncation + sign/zero extension as appropriate). This matches the
    behavior of `ir.CastInt` in the current IR.
- Float → Float:
  - `f32` ↔ `f64` using standard IEEE-754 conversion and rounding.
- Integer → Float:
  - Converts the integer value to the destination float type (IEEE-754),
    with rounding when the integer cannot be represented exactly.
- Float → Integer:
  - Converts by truncating toward zero.
  - If the source value is `NaN`, the result is `0`.
  - If the source value is outside the destination integer’s representable
    range, the result saturates to the nearest bound (min/max for signed,
    `0`/max for unsigned).

- Struct → Struct (safe “shape cast”):
  - A cast from `S` to `T` is permitted when both `S` and `T` name **non-opaque**
    struct types and their fields match **positionally**:
    - same field count, and
    - for each index `i`, the field type of `S` at `i` is exactly the same type
      as the field type of `T` at `i` (field names may differ).
  - This is intended for “newtype-like” wrappers and schema evolution where two
    structs have the same shape but different field names.
  - Semantics: the cast produces a **value copy** of the underlying struct
    slots, retyped as `T`. The operation does not reorder fields.
- `&Struct` → `&Struct` (safe “shape cast” for references):
  - A cast from `&S` to `&T` is permitted when `S` and `T` are compatible under
    the same Struct → Struct “shape cast” rules above.
  - Semantics: the cast produces a **retyped view** of the same referenced
    storage. It does **not** allocate and does **not** copy the underlying
    struct slots.
  - For refcounted heap references created by `new`, the cast is still a view
    only: it must **not** change which `drop` implementation runs when the
    refcount reaches zero. The allocation’s concrete type (tracked through the
    value, not the view type) determines Drop behavior at the last release.
  - This means the two references alias: reading fields through the cast view
    observes updates made through the original reference (and vice versa).
  - Because the two references alias, the compiler’s per-call mutable-borrow
    restrictions treat aliases as the same storage: a single call expression
    may not take multiple mutable borrows (or both mutable and immutable
    borrows) of the same underlying reference, even if the aliases are held
    under different local names. See `Mutability`.
  - This cast is intentionally conservative: it is permitted only when the
    compiler can prove the two referenced struct layouts are identical at the
    type level (same field types in the same order). It does **not** permit
    arbitrary “reinterpret pointer” casts.

- `u64` ↔ `T[]` / `T[N]` (unsafe pointer/slice view cast):
  - Silk’s  represents raw addresses as `u64`. For low-level
    byte-copy routines and runtime interop, `as` supports explicit conversions
    between raw addresses and array/slice views:
    - `ptr as T[]` constructs a `T[]` slice view where the pointer component is
      `ptr` and the length component is a dedicated **unknown-length** sentinel
      (in the current implementation, `i64.min`). The compiler does not validate
      the pointer value.
      - Indexing and assignment through an unknown-length slice are permitted
        but **unchecked**: the runtime performs no `index < len` bounds check.
      - Operations that require a known length (iteration, slicing, etc.) trap
        unless an explicit length is provided.
    - `ptr as T[](len)` constructs a `T[]` slice view where the pointer
      component is `ptr` and the length component is `len` (element count).
    - `slice as u64` extracts the pointer component of a `T[]` slice.
    - `arr as u64` extracts the address of element `0` of a fixed array `T[N]`
      (for `N == 0`, the result is `0`).
  - These casts remain **unsafe**:
    - the compiler does not validate pointer provenance (whether the address is
      valid for the claimed element type).
  - In Silk, indexed accesses through
    arrays/slices trap when:
    - the pointer is `0`,
    - the pointer is not 8-byte aligned,
    - the explicit length is negative (when provided),
    - the index is out of bounds (`index < len`) when the slice/array has a
      known (non-unknown) length.

- `Serialize(T)`-backed casts (explicit conversion via `serialize()`):
  - When the operand type provides a unique instance method named `serialize`
    matching the `std::interfaces::Serialize(T)` surface (`fn serialize(self: &Type) -> T`),
    `expr as T` is permitted and lowers to a call of that method.
  - The conversion is explicit (it does not introduce implicit coercions).
  - The `serialize` method must be infallible (no typed errors).
  - Purity rules apply: inside `pure fn`, the `serialize` method must be `pure`.
  - Limitation: the compiler must be able to resolve the
    receiver’s nominal type at the cast site so it can lower the implicit
    `serialize()` call. This includes name expressions, field accesses, calls,
    and array/slice indexing (`arr[i] as T`) in the current implementation.
- `Deserialize(S)`-backed casts (explicit conversion via `deserialize(...)`):
  - When the target type provides a unique **static** method named `deserialize`
    matching the `std::interfaces::Deserialize(S)` surface (`fn deserialize(value: S) -> Self`),
    `expr as Self` is permitted and lowers to `Self.deserialize(expr)`.
  - This rule is checked before struct shape casts: when both a `deserialize`
    conversion and a shape cast could apply, the `deserialize` conversion is
    used.
  - The conversion is explicit (it does not introduce implicit coercions).
  - The `deserialize` method must be infallible (no typed errors).
  - Purity rules apply: inside `pure fn`, the `deserialize` method must be `pure`.

Examples:

```silk
struct Data {
  value: string,
}

struct User {
  name: string,
}

fn main () -> int {
  let data = Data{ value: "hello" };
  let user = data as User;
  assert data.value == user.name;
  return 0;
}
```

```silk
struct A {
  value: string,
}

struct B {
  value: string,
}

fn set_value (mut b: &B, value: string) -> void {
  b.value = value;
}

fn main () -> int {
  let a: &A = new A{ value: "hello" };
  var b = a as &B;
  set_value(mut b, "world");
  assert a.value == "world";
  assert b.value == "world";
  return 0;
}
```

Notes:

- `as` does not participate in the implicit call-argument coercion mechanism
  described in `Types` (that mechanism is opt-in per
  destination struct and is used primarily for stdlib ergonomics).

### Raw casts (`as raw`)

`as raw` is a postfix operator that reinterprets the **raw bits** of a scalar
value as another scalar type. It is intended for use in generic collections
and low-level marshalling where numeric conversion would be incorrect (notably
when storing `f32`/`f64` values in integer-backed storage).

Syntax:

- `<expr> as raw <Type>`

Rules ():

- Both the operand and the target type must be scalar numeric types supported
  by the current backend (`i8`/`u8`/`i16`/`u16`/`i32`/`u32`/`i64`/`u64`/`int`,
  `f32`/`f64`, plus int-like primitives lowered to those scalars such as
  `Duration`/`Instant` and `char`).
- `as raw` is not permitted for `string`, `void`, `&T`, optionals, arrays,
  maps, function types, or structs/enums.
- Semantics:
  - The operand’s current canonical scalar bits are reinterpreted as the target
    type’s canonical scalar bits (bit-level truncation/masking for narrower
    target widths such as `u8`/`u16`/`u32` and `f32`).
  - No numeric conversion is performed. For example, `1.0 as u64` yields
    `1`, while `1.0 as raw u64` yields the IEEE-754 bit pattern.

Examples:

```silk
let bits: u64 = (1.0 as f32) as raw u64;
let f: f32 = bits as raw f32;
```

## `Duration` & `Instant`

`Duration` and `Instant` are time-related types with special literal and operator support.

Key ideas:

- `Duration` represents a signed time span.
- `Instant` represents a signed point-in-time on a monotonic timeline (an opaque
  epoch chosen by the runtime).
- Duration literals represent time spans with unit suffixes and are converted into
  integral ticks.
- Operators cover arithmetic, comparisons, and construction from scalars.

### Representation

In Silk:

- `Duration` is represented as a signed 64-bit integer count of **nanoseconds**.
- `Instant` is represented as a signed 64-bit integer count of **nanoseconds**
  since a monotonic, runtime-defined origin.

These are distinct Silk types in the type system, but share the same underlying
scalar representation (`i64`) at the IR and native ABI layers.

### Operators

The current implementation supports the following operator subset:

- `Duration + Duration -> Duration`
- `Duration - Duration -> Duration`
- `-Duration -> Duration`

- `Instant + Duration -> Instant`
- `Duration + Instant -> Instant`
- `Instant - Duration -> Instant`
- `Instant - Instant -> Duration`

- Comparisons (`==`, `!=`, `<`, `<=`, `>`, `>=`) are supported for:
  - `Duration` vs `Duration`
  - `Instant` vs `Instant`

Other arithmetic (`*`, `/`, `%`) and bitwise operators are not defined for time
types in the current implementation.

### Overflow

Arithmetic uses the same deterministic wrapping behavior as the underlying
`i64` operations in the current back-end subset (two’s complement wraparound).

### Future Work

At maturity, this document will be expanded to fully specify:

- duration/instant division semantics and rounding rules,
- checked/saturating variants exposed by the standard library,
- the precise relationship between `Instant` and the platform clock APIs,
- and FFI-safe conversions and APIs in `std::temporal`.

Compiler requirements:

- Implement type-checking and lowering for the operator subset above.
- Implement duration literal parsing as specified in `Duration Literals`.
- Integrate with `std::temporal` in the standard library.

## External Declarations (`ext`)

Silk’s external declaration feature lets Silk code call foreign functions and
access foreign variables.

- The core construct is the `ext` definition, which declares:
  - external C functions and their Silk function types, or
  - external C variables and their Silk types.
- The compiler and runtime perform marshalling between Silk’s internal representations and the C ABI, following a documented mapping.

### Declaring an External Binding

Example:

```silk
ext foo = fn (string) -> void;
ext bar = u32;
```

Here:

- `foo` is a C function named `foo` with the given Silk function type.
- `bar` is a C variable of type `u32`.

### Binding a Different External Symbol Name

Sometimes you want the Silk binding name to differ from the linked external
symbol name (for example, when writing wrapper modules that want to expose
stable public API names without colliding with imported libc names).

Syntax:

```silk
// The binding name is `c_malloc`, but the linked symbol is `malloc`.
ext c_malloc "malloc" = fn (i64) -> u64;
ext c_free "free" = fn (u64) -> void;
```

Rules:

- The identifier after `ext` is the **Silk binding name** (used for imports and
  calls from Silk code).
- The optional string literal is the **external symbol name** used for linking
  (native) or as the import name (wasm).
- If the string literal is omitted, the external symbol name is the same as the
  binding name.

### Avoiding Shadowing (Global `::...`)

If an `ext` binding is declared in the global namespace (a module with no
`package ...;` or header-form `module ...;` declaration) and a local declaration
shadows it (for example, a wrapper function named `malloc`), use the global-name
prefix to force lookup of the global binding:

```silk
return ::malloc(bytes);
```

The global-name prefix is not limited to `ext`: it also applies to type names
and enum variant paths in expression and type positions (for example, `::Foo`,
`::Foo{...}`, or `::E::Variant`), always forcing resolution in the global
(unnamed) package.

### Verification and `ext` (Silk rule)

External declarations have no body available to the verifier.

Therefore:

- It is a compile-time error to attempt to verify an `ext` declaration.
- It is a compile-time error for verified code (code whose compilation requires
  proofs) to call an `ext` function or read an `ext` variable.

This intentionally limits verification across the `ext` boundary.

### Opaque Struct Handles

Opaque structs are intended for representing foreign pointers/handles safely.
They strengthen type safety at the language boundary by preventing accidental
mixups between different handle types and by disallowing invalid operations in
Silk.

Declare an opaque handle type with a fieldless `struct` declaration:

```silk
// runtime.slk
struct StringBuilder;

ext sb_new = fn () -> &StringBuilder;
ext sb_append = fn (&StringBuilder, string) -> void;
ext sb_destroy = fn (&StringBuilder) -> void;
```

Use the handle by importing the type name and the `ext` functions:

```silk
import { StringBuilder, sb_new, sb_append, sb_destroy } from "./runtime.slk";

fn main () -> int {
  let sb: &StringBuilder = sb_new();
  sb_append(sb, "hello");
  sb_destroy(sb);

  // Using `sb` after destroy is UNDEFINED BEHAVIOR (dangling foreign pointer).
  return 0;
}
```

Rules:

- The handle type must be used behind `&` (`&StringBuilder`), not by value.
- Opaque structs cannot be instantiated and do not support member access.

Safety:

- You are responsible for managing the lifetime of foreign handles. Most C APIs
  provide explicit create/destroy functions; always call the destruction
  function when you are done.
- Using a handle after destruction is undefined behavior; the compiler does not
  currently enforce this at compile time.

Notes on executable `ext` calls (current linux/x86_64 implementation):

- When an executable uses `ext` calls or `ext` variable reads, the compiler
  emits a **dynamically-linked** ELF64 executable (PIE-style `ET_DYN` with
  `PT_INTERP`, `.dynamic`, `.rela.dyn`, and a `.got`).
- External symbols are resolved by the platform dynamic loader. Dependencies
  can be declared via the CLI (`silk build --needed <soname> ...`) or via the
  C99 embedding API (`silk_compiler_add_needed_library`), and runtime search
  paths can be declared via `--runpath` / `silk_compiler_add_runpath`.

### ABI Contract (Overview)

The language defines two closely related views of the ABI:

- A “fat pointer” internal representation for `string` and `regexp`:
  - conceptually: `struct string { ptr: ptr, len: i64 }` where `ptr` is a UTF‑8 pointer.
  - conceptually: `struct regexp { ptr: ptr, len: i64 }` where `ptr` is an engine-owned bytecode pointer.
- A C ABI contract (e.g. via `silk.h`) using an explicit struct:

  ```c
  typedef struct {
      char   *ptr;
      int64_t len;
  } SilkString;
  ```

- A mapping to an LLVM type used internally by the compiler:

  ```llvm
  %silk.string = type { i8*, i64 }
  ```

When calling conventional C APIs, the compiler may pass a `const char *` derived from this structure, with the guarantee that the underlying data is null‑terminated. This distinction is important:

- Internal/runtime ABI: operates on `{ ptr, len }` structs (`SilkString`).
- Compatibility calls to typical C libraries: may expose `const char *` for parameters declared as `string` in Silk `ext` declarations, with the compiler extracting the `ptr`.

Our embedding ABI for `libsilk.a` will treat `SilkString` as the canonical C representation; details are further specified in `C99 ABI and `libsilk.a``.

### Primitive Type Mapping

The spec includes a table mapping Silk primitive types to C types, for example:

- `i8`, `u8` → `int8_t`, `uint8_t`
- `i16`, `u16` → `int16_t`, `uint16_t`
- `i32`, `u32` → `int32_t`, `uint32_t`
- `i64`, `u64` → `int64_t`, `uint64_t`
- `int` → `int64_t` (current `linux/x86_64` baseline; do not assume C `int`)
- `f32` → `float`
- `f64` → `double`
- `bool` → `bool` (or `_Bool`)
- `char` → `uint32_t` (UTF‑32)
- `string` → `SilkString` (`{ char *ptr; int64_t len; }`)
- `regexp` → `SilkString` (`{ char *ptr; int64_t len; }`, opaque bytecode view)
- `void` → `void`

Notes:

- For FFI with APIs that use a C `int` (for example many POSIX syscalls),
  prefer `i32`/`u32` in your `ext` declarations rather than `int`.

These mappings must be reflected exactly in the C99 ABI.

### Strings and Passing Convention

For strings, the spec makes the following points:

- Silk’s `string` is represented internally as a `{ ptr, len }` pair.
- For `ext` calls to typical C APIs:
  - the compiler can extract `ptr` and pass it as a `const char *`,
  - the data is guaranteed to be null‑terminated so standard C string functions are safe.

For regex bytecode values (`regexp`):

- Silk’s `regexp` is represented internally as a `{ ptr, len }` pair with the
  same slot layout as `string`, but the bytes are *not text* and are not
  required to be null‑terminated.
- At ABI boundaries, `regexp` uses the same C shape as `SilkString`, but C code
  must treat it as an opaque `(ptr, len)` byte span (not a C string).

For the embedding ABI (`libsilk.a`):

- We treat `SilkString` (`{ char *ptr; int64_t len; }`) as the primary C representation of Silk `string` values.
- Functions exported by `libsilk.a` will use `SilkString` in their signatures wherever strings cross the boundary.

This layered design allows:

- idiomatic FFI to existing C libraries using `const char *`,
- a precise, length‑carrying ABI (`SilkString`) for embedding the compiler/runtime.

### Safety & Ownership

The external interface rules must ensure:

- No C code can violate Silk’s invariants about ownership and lifetimes.
- Any shared data representation (strings, structs, arrays, closures) is documented and stable.

### Typed Errors and the `ext` boundary

Typed errors (`error`, `panic`, and `T | ErrorType...`) must not cross the `ext`
boundary.

Rules:

- `ext` function types must not use `|` in their return types.
- Silk-to-C ABI surfaces must not expose `|` in exported function signatures.
  Shims should convert typed errors into explicit error codes, optionals, or
  domain-specific error types, or terminate in a platform-appropriate way.


- The current compiler rejects `ext` declarations that include `|`, and rejects
  exporting error-producing functions to C ABI outputs.

The spec also includes a “Structs, Arrays, and Closures (Complex Types)” subsection for FFI. As the implementation proceeds, this document must be extended to:

- describe how user‑defined structs map to C structs (respecting the layout rules in `Structs, Impl Blocks, and Memory Layout`),
- define how arrays and slices are represented across the boundary,
- document any stable closure representation, if exposed in the C ABI.

### Structs (Initial ABI Subset)

The full language design includes rich user-defined structs and nested
aggregates. The current compiler implementation supports only a small subset of
structs in code generation:

- structs with 0+ fields of supported value types (scalar primitives, `string`,
  nested structs, and supported optionals) in function bodies and internal helper calls,
- on `linux/x86_64`, passing and returning these structs by value at ABI boundaries
  using a scalar-slot lowering model:
  - a struct value lowers to N scalar “eightbyte” slots in field order, and
    each slot is classified as INTEGER (integer-like scalars such as `int`,
    fixed-width integers, `bool`, `char`, `Instant`, `Duration`) or SSE (`f32`/`f64`),
  - exported function *parameters* accept these slots as separate parameters;
    for 1–2 slot structs this is ABI-compatible with a by-value C struct
    parameter for the 8-byte-field subset, while for packed structs with
    smaller fields ABI compatibility with an equivalent C struct layout is not
    yet implemented/validated; for 3+ slot structs downstream C callers should
    declare separate parameters for the slots,
  - exported function *returns* support 1+ slot structs; 1–2 slot results
    return in `rax`/`rdx` and/or `xmm0`/`xmm1` accordingly, while 3+ slot
    results return indirectly via a hidden sret pointer.

This subset is intended as a stepping stone toward fully general struct layout
and SysV ABI classification (including packed layout for smaller fields such
as `f32` and small integers, nested structs, and larger aggregates returned via
hidden sret pointers).

### Optionals (Initial ABI Subset)

The full language design includes rich optional patterns (`?.`, `match`, nested
optionals, etc.). The current compiler implementation supports only a limited
optional subset in code generation:

- optionals whose payload type is a supported scalar, `string`, or a supported
  ABI-safe `struct` (i.e. after slot-flattening, all scalar slots are `i64`/`u64`/`f64`),
- construction via `None` and `Some(value)`,
- unwrapping via `??` with short-circuit fallback evaluation,
- and nested optionals (`T??`) for the same supported payload subset, including
  unwrapping `T??` to `T?` via `??`.

At ABI boundaries in the current `linux/x86_64` subset, optionals are lowered
as a `Bool` tag followed by the payload scalar slots in order:

- `(tag, payload)` for scalar payload optionals,
- `(tag, ptr, len)` for `string?`,
- `(tag, slot0, slot1, ...)` for `struct?` where the payload lowers to N scalar slots.

For nested optionals (`T??`) in this subset, the payload slots are the full
inner optional representation (for example `int??` lowers as
`(tag0, tag1, i64 payload)`).

For exported functions, these slots consume the normal scalar argument and
result locations (registers then stack), and 3+ scalar results return via a
hidden sret pointer.

Compiler requirements:

- Implement `ext` declarations as specified.
- Map Silk types to C types per the ABI document.
- Enforce the documented passing conventions and ownership rules for external-call strings and other bridged types.
- Keep this document and `C99 ABI and `libsilk.a`` in sync with the actual codegen strategy.

## Blocks and Statement Composition

Blocks group statements, establish lexical scopes, and provide the “body” form
for structured control-flow constructs like `if`, `while`, and the `match`
statement used for typed errors.

### Surface Syntax

A block is a sequence of zero or more statements delimited by braces:

```silk
{
  stmt0;
  stmt1;
  ...
}
```

The empty block `{}` is permitted.

### Statements

the compiler supports these statement forms (see
`Formal Grammar Spec` for exact syntax):

- Local bindings:
  - `const` (compile-time constant binding; initializer must be const-evaluable),
  - `let` and `let mut` (and `var` as an alias for `let mut`).
- Specification-only declarations: `#const` (Formal Silk; not usable in runtime expressions).
- Structured blocks: `async { ... }` / `task { ... }` (see `Concurrency`).
- Expression statements: limited to calls, assignments, and increment/decrement
  In Silk (`Expression Statements`).
- Flow control:
  - `if` / `else` statements,
  - `while` loops,
  - `break`, `continue`,
  - `return`,
  - `assert`,
  - `panic` (typed errors),
  - `match` statement (typed errors; see `Typed Errors (`error`, `panic`, and `T | ErrorType...`)`).

### Semantics

#### Sequencing

Statements in a block execute in source order. If a statement transfers control
out of the current block (`return`, `panic`, `break`/`continue` inside loops),
the remainder of the block is not executed on that path.

#### Scope

A block introduces a lexical scope:

- Names declared by `const`/`let`/`var` are visible only after their
  declaration within the same block, and within any nested blocks.
- Inner blocks may shadow outer bindings by reusing a name (this is a normal
  lexical-shadowing rule; the checker should reject only when a specific
  feature imposes stricter rules).
- The special name `_` is a discard binding:
  - `let _ = expr;` and `let _: T = expr;` evaluate the initializer but do not
    introduce a binding into scope.
  - `_` may be used repeatedly in the same scope without conflicts.
  - Any produced runtime value is cleaned up at end-of-statement (not at scope
    exit).

Destructuring `let` bindings bind multiple locals from a
single struct value:

- Positional (field order):

  ```silk
  struct User { id: u64, name: string }
  let (id, name) = User{ id: 123, name: "alice" };
  ```

- Named (by field name, order-independent), with aliasing:

  ```silk
  struct Record { id: u64, data: string }
  let { data, id } = Record{ id: 123, data: "a record" };
  let { data as d, id as i } = Record{ id: 456, data: "other record" };
  ```

Array destructuring binds multiple locals from a single array/slice value:

```silk
struct Record { id: u64, data: string }

let records: Record[] = [{ id: 123, data: "a" }, { id: 456, data: "b" }];
let [a, b] = records;
```

Rules ():

- Only flat patterns are supported (no nested destructuring).
- The initializer is required.
- The initializer must have a non-opaque `struct` value type.
- The pattern must account for every field exactly once:
  - positional patterns must have exactly one binder per declared field (in
    field order),
  - named patterns must list each field exactly once (in any order),
  - use `_` to discard a field (`let (_, name) = ...;` or `let { data as _ } = ...;`).

For array/slice destructuring:

- The initializer must have an array type (`T[N]`) or slice type (`T[]`).
- Each binder is positional (index order).
- The pattern binds exactly the number of listed binders:
  - fixed arrays require an exact arity match (`[a, b]` requires `T[2]`),
  - slices trap at runtime if too short (as if indexing each element).

`const` bindings are compile-time constants:

- their initializer expression must be compile-time evaluable (otherwise the
  compiler reports an error),
- the binding is immutable (there is no `const mut`),
- a `const` binding is a normal runtime value (unlike `#const`), but its value
  is computed by the compiler at compile time and does not incur runtime
  computation cost in Silk.

In Silk, compile-time evaluation for runtime `const`
bindings is restricted to:

- scalar primitive types (`bool`, integer/float scalars, `char`, `Instant`, `Duration`), and
- pure scalar expressions composed of:
  - literals,
  - other `const` bindings,
  - calls to `const fn` functions where all arguments are themselves compile-time evaluable, and
  - `as` casts between supported scalar types, and
  - a small operator subset (notably `+`, `-`, `*`, bitwise ops, shifts; `/` and `%` are currently rejected for `const`).

- `string` bindings whose initializer is either:
  - a string literal (`"..."` or `` `...` ``), or
  - another `const` string binding.

Formal Silk declarations (`#const`) are compile-time-only names intended for specifications
(`#require`, `#assure`, `#assert`, `#invariant`, `#variant`, `#monovariant`). They must not be referenced
in runtime expressions (see `Formal Silk` and
`Compiler Diagnostics`, `E2014`).

#### Blocks as Expressions

The broader language design includes expression-oriented flow constructs (for
example `match` expressions today and `if` expressions).

In Silk:

- a block is not an expression and does not produce a value; it is purely a
  statement list used as the body of constructs.

The `if` expression form is a special-case expression-oriented construct; it
does not make `{ ... }` a general expression form.

If/when general block expressions are introduced, the spec will define:

- which contexts accept them (and how ambiguity with `{ ... }` struct literals
  is resolved), and
- how their result values are computed.

### Examples

#### Nested scope

```silk
fn main () -> int {
  let x: int = 1;
  {
    let y: int = 2;
    if x < y {
      return 0;
    }
  }
  return 1;
}
```

#### Formal Silk declarations for loop specifications

```silk
fn main () -> int {
  let limit: int = 3;
  #const original_limit = limit;

  let mut i: int = 0;
  #invariant i >= 0;
  #invariant i <= original_limit;
  #variant original_limit - i;
  while i < limit {
    i = i + 1;
  }

  return 0;
}
```

## Build Metadata (`BUILD_KIND`, `BUILD_MODE`, `BUILD_VERSION`)

Silk exposes a small set of compiler-provided **build metadata** values to both
runtime code and Formal Silk (compile-time verification) so programs can adapt
to build configuration and so theories can express “this code is only valid in
test builds”, “this feature requires a minimum version”, and similar policies.

### Built-In Constants

The compiler provides the following built-in constants in every module:

- `BUILD_KIND: string`
- `BUILD_MODE: string`
- `BUILD_VERSION: string`
- `BUILD_VERSION_MAJOR: u64`
- `BUILD_VERSION_MINOR: u64`
- `BUILD_VERSION_PATCH: u64`

These behave like normal `const` string values:

- They do not require an import.
- They may be used anywhere a `string` expression is allowed.
- They are compile-time constants (their values are fixed at compile time and
  are embedded into the output artifact).

#### `BUILD_KIND`

The output kind currently being built:

- `"executable"`
- `"object"`
- `"static"`
- `"shared"`

#### `BUILD_MODE`

The build mode currently being built:

- `"debug"`
- `"release"`
- `"test"`

Notes:

- `"test"` is the mode used by `silk test`.
- Debug stack traces and debug assertion behavior are controlled separately by
  `std::runtime::build::is_debug()` (see `std::runtime`).

#### `BUILD_VERSION`

The semantic version of the current package when building from a manifest.

- When building from a package manifest (`silk.toml`), `BUILD_VERSION` is the
  manifest `version`.
- When not building from a manifest, `BUILD_VERSION` is `"0.0.0"`.

#### `BUILD_VERSION_MAJOR` / `BUILD_VERSION_MINOR` / `BUILD_VERSION_PATCH`

The SemVer **core triplet** (`major.minor.patch`) of `BUILD_VERSION` exposed as
`u64` values for convenient comparisons (especially in Formal Silk).

Rules:

- These parse the `major.minor.patch` prefix of `BUILD_VERSION`.
- Any trailing `-prerelease` or `+build` suffix is ignored.
- On parse failure, all three values default to `0`.

### Relationship to `std::runtime::build`

The standard library provides `std::runtime::build` functions that return the
same metadata:

- `std::runtime::build::kind() -> string`
- `std::runtime::build::mode() -> string`
- `std::runtime::build::version() -> string`

Use `std::runtime::build` when you prefer explicit namespacing or when writing
code intended to run under alternate stdlib roots.

### Examples

#### Build-mode gated behavior

```silk
fn main () -> int {
  if BUILD_MODE == "test" {
    // Test-only behavior.
    return 0;
  }
  return 0;
}
```

#### Version-gated behavior

For semver parsing and comparison, use `std::semver` at runtime or reuse the
formal theories provided by `std::formal` (see `Formal Silk`).

## Testing

This document specifies the initial **language-level testing** surface for
Silk.

The goal is a Zig-like authoring experience (tests live next to the code they
exercise) with a simple CLI runner that emits modern TAP output for downstream
consumption.

### `test` declarations

A `test` declaration is a top-level block of statements that the compiler can
compile and execute under `silk test`.

Syntax:

```silk
test "name" {
  // statements...
}
```

The string name is optional:

```silk
test {
  // statements...
}
```

Rules:

- `test` declarations MAY appear:
  - at top level (like `fn` and `let`), and
  - nested inside another `test` block (scoped subtests).
- A `test` block introduces its own scope (like a function body).
- Nested `test` blocks are executed inline, in source order, as part of the
  enclosing test’s execution. They may be used for hierarchical grouping and
  shared setup.
- `test` blocks may use `let`, `var`, control flow, and call functions/methods
  using the same expression subset as normal code.
- `return;` is allowed inside a `test` block (equivalent to ending the test
  early). `return <expr>;` is not allowed.

Doc comments:

- Doc comments (`/** ... */` and `/// ...`) attach to a `test` declaration the
  same way they attach to other top-level declarations.

### Running tests (`silk test`)

The `silk test` command:

- loads a module set (like `silk check` / `silk build`),
- discovers all `test` declarations in the module set, and
- executes them, emitting TAP output.

#### TAP output

The initial runner uses TAP version 13 formatting:

- `TAP version 13`
- `1..N`
- `ok <n> - <name>`
- `not ok <n> - <name>`

#### Assertions inside tests

In `silk test` builds, failed assertions do not abort the process. Instead:

- A failed `assert` records a test failure and execution continues.
- If the assertion has no explicit message, the compiler uses the assertion
  condition text as the message (e.g. `assert value != 123;` uses `value != 123`).
- The test executable exits non-zero if any failures were recorded so TAP output
  reflects failures.

The current runner still isolates top-level tests in separate processes, but a
single test case may now accumulate multiple failures.

### `std::test` (standard test helpers)

The standard library provides `std::test` helpers for test-only assertions that
record failures without aborting:

- `expect(ok: bool, message: string? = None);`
- `expect_equal(expected: X, actual: Y) -> bool;`
- `expect_error(err: E?) -> bool;`

See `std::test` for the detailed API.

Note: `std::test` helpers carry a Formal Silk contract requiring
`BUILD_MODE == "test"` via `std::formal.requires_test_mode()` so downstream
verification can model them as test-only APIs.

## Arenas

Arenas are not part of the language surface. Use **regions** instead.

See `Regions`.

## Silkdoc (Documentation Comments)

This document specifies **Silkdoc**, Silk’s documentation-comment format.
Silkdoc comments are intended for tools (documentation generators, editors,
and the language server). They **do not** affect program semantics.

The goal is a familiar JSdoc feel with Silk/TypeScript-style type annotations.

### Comment Forms

Two doc-comment forms are recognized:

- **Block doc comments**: `/** ... */`
- **Line doc comments**: one or more consecutive lines starting with `///`

In both forms, doc comments attach to the *next* declaration when they appear
immediately before it with only whitespace/comments between them.

Initial implementation scope:

- Doc comments attach to **top-level declarations** (`package`, `module`,
  `import`, `fn`, `theory`, `let`, `struct`, `ext`, `interface`, `impl`).
- Doc comments also attach to:
  - methods inside `impl Type { ... }` blocks, and
  - method signatures inside `interface Name { ... }` blocks.
- For function declarations, doc comments attach even when one or more formal
  verification annotations (`#require` / `#assure`) appear between the doc
  comment and the `fn` keyword.
- Doc comments inside function bodies are treated as ordinary comments (not
  attached to anything).
- Attaching doc comments to struct fields, parameters, and locals is future
  work.

### Content Model

A doc comment contains:

- free-form text (Markdown-friendly) describing the declaration, and
- optional **tags** starting with `@`.

The free-form text is everything before the first tag line.

Any non-tag lines that appear after the first tag line are ignored unless they
are part of a multi-line tag body (for example `@example` or `@remarks`).

#### Leading `*` convention

For block doc comments, the conventional leading `*` is ignored:

```silk
/**
 * Hello
 * world
 */
```

Tools strip the leading `*` (and one following space when present) before
parsing.

### Tags

Tags begin at the start of the logical line after stripping comment prefixes.

#### `@param`

Declare a parameter description.

Syntax:

```text
@param <name>: <Type> <description...>
@param <name> <description...>
```

The `<Type>` uses Silk type syntax as defined in `Types`.

Example:

```silk
/**
 * Appends one byte to the vector, growing as needed.
 *
 * @param self: &std::vector::Vector(u8) The receiver.
 * @param value: u8 The byte to append.
 */
```

#### `@returns`

Describe the return value.

Syntax:

```text
@returns <Type> <description...>
@returns <description...>
```

#### `@throws`

Describe an error/exception-like condition.

Syntax:

```text
@throws <Type> <description...>
@throws <description...>
```

Note: the language does not yet have a stable error type; `@throws` is
documentation-only until `Result(T, E)` and error conventions are fully
implemented.

#### `@external`

Indicate that a declaration is an **external FFI binding** (its implementation
is provided outside Silk).

This tag is typically used to document `ext` function declarations.

Syntax:

```text
@external
```

#### `@example`

Provide an example snippet. The tag may optionally declare a language for
Markdown fenced code blocks.

Syntax:

```text
@example
<one or more lines of example text>

@example silk
<one or more lines of code>
```

The example body continues until the next tag line or the end of the doc
comment.

#### Other tags

The initial toolchain may also recognize:

- `@since <text...>`
- `@deprecated <text...>`
- `@remarks <text...>` (may span multiple lines like `@example`)
- `@see <text...>` (repeatable)

Additional tags must be documented here before they are relied on by tooling.

#### Formal Silkdoc tags

Silkdoc can document Formal Silk constructs without affecting verification.
These tags are documentation-only (they do not prove anything and do not
introduce Formal Silk obligations).

##### `@requires`

Document one precondition for a declaration (typically mirroring `#require` on a
function or a theory).

Syntax:

```text
@requires <Expr...>
```

This tag is repeatable.

##### `@assures`

Document one postcondition for a declaration (typically mirroring `#assure` on
a function or a theory).

Syntax:

```text
@assures <Expr...>
```

This tag is repeatable.

##### `@asserts`

Document one internal proof obligation (typically mirroring a `#assert` inside a
function or theory body).

Syntax:

```text
@asserts <Expr...>
```

This tag is repeatable.

##### `@theory`

Document one theory attachment or use (typically mirroring `#theory Name(args...);`).

Syntax:

```text
@theory <Name(args...)...>
```

This tag is repeatable.

#### Manpage-oriented tags

The toolchain uses a small set of optional doc tags to generate `man(7)` pages
from source comments (`silk doc --man` and `silk man`).

These tags are documentation-only and do not affect program semantics.

##### `@misc`

Declare a conceptual documentation block intended for man section 7.

Syntax:

```text
@misc <label> <summary...>
@misc <label>
```

Notes:

- The `<label>` is an opaque identifier used by tooling for discovery (for
  example `silk man <label>`). It should be stable and globally unique within a
  package (recommendation: use a `pkg::topic` label).
- The optional `<summary...>` provides a one-line description for the manpage
  `NAME` section. When omitted, tools may derive a summary from the first line
  of the free-form description text.

##### `@cli`

Declare that a doc comment describes a command-line interface, intended for man
section 1.

Syntax:

```text
@cli <name>
@cli
```

When `<name>` is omitted, tools derive the command name from context (for
example the module name or executable name provided by the build system).

##### `@synopsis`

Provide one or more synopsis lines for a CLI manpage.

Syntax:

```text
@synopsis
<one or more lines of synopsis text>
```

The synopsis body continues until the next tag line or the end of the doc
comment.

##### `@option`

Declare a command-line option for a CLI manpage. This tag is repeatable.

Syntax:

```text
@option <prototype...>
@option `<prototype...>` <description...>
```

Examples:

```text
@option `-h, --help` Show help and exit.
@option `--out <path>` Write output to <path>.
```

##### `@command`

Declare a subcommand for a CLI manpage. This tag is repeatable.

Syntax:

```text
@command <name> <description...>
```

### Markdown Rendering

The documentation generator renders doc comments to Markdown using:

- the free-form text as the leading description (paragraphs preserved),
- `@param` entries as a “Parameters” list,
- `@returns` as a “Returns” section,
- `@throws` as a “Throws” section,
- `@requires`, `@assures`, `@asserts`, and `@theory` as dedicated sections (one
  bullet per tag instance),
- `@example` blocks as fenced code blocks.

The generator must keep formatting stable (deterministic output) so that
documentation diffs are meaningful.

## Expression Statements

Expression statements allow expressions to be used for their side effects.

### Syntax

An expression statement is an expression followed by a semicolon:

```
expr;
```

### Semantics

- The expression is evaluated exactly once.
- The result value (if any) is discarded.

### Current implementation restrictions

For the compiler, an expression statement is only valid when
the expression is either:

- a call expression (a function call), or
- an assignment / compound assignment expression.
- an increment/decrement expression (`++x`, `x++`, `--x`, `x--`).

All other expression statements are rejected.

This restriction will be relaxed as more of the expression language is lowered
and code-generated.

Examples (accepted in Silk):

```silk
fn main () -> int {
  std::io::println("hello");

  let mut x: int = 0;
  x = 1;
  x += 2;
  x++;

  return 0;
}
```

Examples (rejected in Silk):

```silk
fn main () -> int {
  1 + 2; // rejected: non-call/non-assignment expression statement (E2002)
  return 0;
}
```

### Guidance

If you computed a value and you want to keep it, bind it:

```silk
fn main () -> int {
  let x: int = 1 + 2;
  return x;
}
```

If you want a value for control flow, prefer an expression form that produces a
value (for example `match` expressions; see ``match` Expression`).

### Compiler requirements

The compiler must:

- Distinguish between expressions that can appear as statements and those that cannot (if the spec imposes restrictions).
- Preserve evaluation order consistent with the language’s semantics.

## `for` Loop

The `for` loop iterates over a range or iterable and executes a block once per
element.

`start..=end`), array/slice iteration (`for x in xs { ... }` for `T[N]` and
`T[]`), iterator iteration (`for x in it { ... }` when `it.next() -> T?`), and
C-style `for (init; condition; step) { ... }` loops.

### Goals

- Provide a readable, structured loop construct for iteration.
- Avoid “off-by-one” patterns by making range boundaries explicit.
- Integrate with `break` / `continue`.
- Integrate with future iteration protocols (interfaces/generics) without
  introducing hidden allocation.

### Surface Syntax ()

Supported surface forms:

```silk
for <pattern> in <iterable> {
  ...
}
```

```silk
for (<init>; <condition>; <step>) {
  ...
}
```

Notes:

- `<pattern>` is intended to be a pattern binder. In early implementations it
  is restricted to a single identifier (and `_`). It will be expanded alongside
  pattern matching.
- `<iterable>` is an expression.
- `<init>` is a local binding (`let` / `var` / `const`) with an initializer.
- `<condition>` is a boolean expression.
- `<step>` is a statement-like expression (the same restricted subset as
  expression statements; see `Expression Statements`).

### Semantics

General rules:

- The iterable expression is evaluated once to produce an iteration source.
- The loop body executes once per produced element.
- `break` exits the loop; `continue` advances to the next element.

#### Range iteration

When the iterable is a range expression (for example `start..end` or
`start..=end`), the loop iterates over integer values.

Design intent:

- `start..end` iterates `start, start+1, ..., end-1` (end-exclusive).
- `start..=end` iterates `start, start+1, ..., end` (end-inclusive).

Notes: 

- The range bounds are evaluated once, left-to-right (`start` then `end`).
- If the start bound is greater than or equal to the end bound (`start >= end`)
  for an end-exclusive range, the loop executes zero times.
- If the start bound is greater than the end bound (`start > end`) for an
  end-inclusive range, the loop executes zero times.
- `continue` advances to the next element (it performs the increment step, then
  re-checks the range condition).
- The loop binder is in scope only inside the loop body block.
- The binder is immutable in Silk (it behaves like a `let`
  binding that is updated by the loop machinery; user code cannot assign to it).

Type checking:

- Both range bounds must have integer type (`int`, `i8`/`u8`, `i16`/`u16`,
  `i32`/`u32`, `i64`/`u64`).
- The two bound types must match, except that an integer literal bound may be
  coerced to the other bound’s integer type (for example `for i in 0..n_u32`).
- The loop binder (when not `_`) has the bound’s integer type.

Example:

```silk
fn main () -> int {
  let mut sum: int = 0;

  for i in 0..3 {
    // i takes values 0, 1, 2
    sum += i;
  }

  // 0 + 1 + 2 = 3
  return sum;
}
```

#### Array and slice iteration

In Silk, `for` also supports iterating over builtin
array and slice types:

- fixed arrays `T[N]`,
- slices `T[]`.

Semantics:

- The iterable expression is evaluated once.
- The loop executes in increasing index order, starting at index `0`.
- The loop binder (when not `_`) is bound to the element value (a copy) for the
  current iteration.
- The binder is in scope only inside the loop body block.
- `break` exits the loop; `continue` advances to the next element.

Limitations:

- Element types are limited to the currently-supported array/slice element
  subset (types that lower to a fixed scalar slot sequence in the current
  back-end, such as primitive scalars, `string`, and supported non-opaque
  structs).
- Iteration is by value; to mutate an element, use indexing (`xs[i] = ...`).

Example:

```silk
fn main () -> int {
  let xs: int[3] = [1, 2, 3];
  let mut sum: int = 0;
  for x in xs {
    sum += x;
  }
  return sum;
}
```

#### Iterator protocol

In addition to builtin arrays and slices, `for` supports iterating over a
stateful iterator value.

An expression `it` is treated as an iterator when it has a `next() -> T?`
instance method (typically by implementing `std::interfaces::Iterator(T)`).

Semantics:

- The iterable expression is evaluated once to produce the iterator value.
- The loop repeatedly calls `(mut it).next()`.
  - When the result is `None`, the loop exits.
  - When the result is `Some(value)`, the binder (when not `_`) is bound to
    `value` (a copy) for that iteration and the body executes.
- `continue` advances by calling `next()` again; `break` exits the loop.

### C-style `for` loops

Silk also supports the traditional “C-style” `for` loop:

```silk
fn main () -> int {
  let len: int = 10;
  let mut sum: int = 0;

  for (let i = 0; i < len; ++i) {
    sum += i;
  }

  return sum;
}
```

Semantics:

- `<init>` executes exactly once before the first condition check.
- `<condition>` is checked before each iteration; if it is `false`, the loop
  exits.
- The loop body executes once per iteration when `<condition>` is `true`.
- After the body executes normally, `<step>` executes, then the loop re-checks
  `<condition>`.
- `continue;` skips the remainder of the loop body and jumps to `<step>` (then
  re-checks `<condition>`).
- `break;` exits the loop immediately without executing `<step>` for that
  iteration.
- The init binding’s name is in scope within the entire loop (condition, step,
  and body) but is not visible after the loop.

Init binding mutability:

- For ergonomics, `for (let i = 0; ...; ++i)` is accepted and the init binding
  is treated as mutable (equivalent to `var`) within the loop.
  - `const` init bindings remain immutable.

### Guidance

In Silk, `for` supports integer ranges and builtin
array/slice iteration. To write other loops today, use `while`:

```silk
fn main () -> int {
  let mut i: int = 0;
  while i < 3 {
    std::io::println("i = {}", i);
    i += 1;
  }
  return 0;
}
```

### Compiler Requirements

- Recognize `for` loop syntax.
- Resolve iteration targets (ranges, collections) according to the language’s
  iteration model.
- Lower `for` into explicit control flow, with correct semantics for `break`
  and `continue`.

Compiler requirements:

- Recognize `for` loop syntax.
- Resolve iteration targets (ranges, collections) according to the language’s iteration model.

## `loop` Loop

The `loop` statement executes a block repeatedly until it is terminated by a
`break` or `return`.

`task loop { ... }`.

### Surface Syntax

```silk
loop {
  // ...
}
```

```silk
async loop {
  // ...
}
```

```silk
task loop {
  // ...
}
```

Notes:

- `async loop` and `task loop` are still loop statements: they do not end with
  `;`.
- In Silk, `async loop` / `task loop` follow the same
  async-context restriction as `async { ... }` / `task { ... }`:
  they are only allowed inside functions declared with `async`
  (`Compiler Diagnostics`, `E2031`).

### Semantics

- The body block executes repeatedly.
- `break;` exits the nearest enclosing loop and continues execution at the
  statement immediately following the loop (``break``).
- `continue;` skips the remainder of the current iteration’s body and begins the
  next iteration (``continue``).
- `return;` exits the current function (``return``).

### Type Checking Rules

- The loop body is checked in a loop context so `break` / `continue` are valid.
- `break;` outside a loop is rejected (`Compiler Diagnostics`, `E2007`).
- `continue;` outside a loop is rejected (`Compiler Diagnostics`, `E2008`).

## Type Unions (`T1 | T2 | ...`)

Silk supports **type unions** in type annotations. A union type represents a
value that is exactly one of several **member types**.

This feature exists to model small, explicit “one-of-these-types” outcomes
without requiring a dedicated nominal `enum` declaration for every case.


See also:

- `Typed Errors (`error`, `panic`, and `T | ErrorType...`)` (unparenthesized `|` in function *signatures*
  is reserved for typed-error contracts),
- ``enum` Types` (general tagged unions with named variants),
- ``match` Expression` (`match` over union values).

### Surface Syntax

Union types use `|` between member types:

```silk
let x: Foo | Bar;
struct S { v: u8 | bool }
type U = Foo | Bar | Baz;
```

#### Return types (important disambiguation)

In **function declarations**, unparenthesized `|` after `->` is reserved for
typed errors (`SuccessType | ErrorType...`). To write a union as a function’s
return type, the union must be parenthesized:

```silk
fn f () -> (Foo | Bar);
fn g () -> (Foo | Bar) | SomeTypedError;
```

This disambiguation is required so the parser and checker can treat typed-error
contracts as authoritative.

### Rules

The initial implementation intentionally supports only unions whose member
types have a safe, well-defined representation in the current compiler/backend
subset.

A union type `T1 | T2 | ... | Tn` is permitted when all member types are in the
supported union-member set:

- **Primitive scalar** types in `{ bool, char, i8, u8, i16, u16, i32, u32, i64,
  u64, int, usize, size, Instant, Duration }` (`isize` is accepted as an alias
  for `size`), and/or
- **Nominal POD structs** (including `error` types) that lower to a scalar-slot
  representation in Silk (no opaque structs; no enums).

Unions may freely **mix** primitive and nominal members in this subset.

For primitive members, the current native backend requires that **each member
type be distinguishable at injection sites**. In practice, that means a union
may not contain two primitive types that lower to the same backend scalar
representation (for example `int | i64`, `usize | u64`, `char | u32`,
`Duration | i64`). This restriction is specific to the backend
and may be relaxed once union injection uses full type identity rather than a
backend-scalar heuristic.

Notes:

- Nested unions are flattened: `(A | B) | C` is the same union as `A | B | C`.
- Duplicate member types are rejected.

### Semantics

A value of a union type is a **tagged** value:

- It stores a runtime tag identifying which member type is active.
- It stores the payload value in a uniform representation compatible with all
  members in Silk.

#### Representation

In the current native backend subset, unions are lowered as:

- `(u64 tag, u64 payload_0, ..., u64 payload_(N-1))`

where `N` is the maximum scalar-slot count across the union’s member types
(primitive members contribute `1`).

Member payload values are stored/loaded via raw-bit casts (`cast_raw`) to and
from the `u64` payload slots. Unused payload slots are **zero-filled** on
injection and on widening coercions.

#### Union-to-union coercions (supersets)

When a context expects a union type `U_sup`, a value of a union type `U_sub`
may be used if `U_sub`’s member set is a subset of `U_sup`’s member set. The
compiler remaps the runtime tag to the destination union’s tag numbering when
needed so pattern matches on the destination union remain correct.

If `U_sup`’s payload is larger than `U_sub`’s payload (because `U_sup` contains a
member with a larger scalar-slot representation), the payload is widened by
copying existing payload slots and zero-filling the newly-added slots.

#### Construction (injection)

When a context expects a union type, a value whose type is one of the union’s
member types may be used directly and is injected into the union.

Examples:

```silk
struct A { x: int }
struct B { x: int }
type U = A | B;

fn main () -> int {
  let a: A = A{ x: 1 };
  let u: U = a; // inject `A` into `U`
  return 0;
}
```

### Matching (`match`)

Union values are consumed via `match` expressions using **typed binder**
patterns:

```silk
type U = A | B;

let out: int = match u {
  a: A => a.x,
  b: B => b.x,
};
```

Rules ():

- The scrutinee must have a union type.
- Patterns are restricted to `name: Type` (or `_: Type`) where `Type` is one of
  the union member types.
- Matches must be exhaustive: exactly one arm per member type (order does not
  matter).

## `using` (Aliases and Method Reuse)

`using` introduces a local alias to an existing symbol, and (in `interface` /
`impl` bodies) can import method signatures/implementations under a new name.

This feature is intended to make large module trees ergonomic (short local
names) and to enable explicit, audited method reuse across types.

### Syntax

At any supported scope, `using` has two surface forms:

```silk
using Alias = QualifiedName;
using QualifiedName;
using QualifiedName as Alias;
```

Where `QualifiedName` uses the normal `::`-separated name syntax (including the
global-prefix form `::name`).

### Module / Package Scope

At module scope, `using` introduces a local alias for an in-scope symbol:

- types (`struct` / `enum` / `error` / `interface` / `type` aliases),
- functions (`fn` and `ext` function bindings),
- Formal Silk theories (`theory`).

The alias is transparent: using `Alias` is equivalent to using the target
symbol directly.

Name conflicts are errors, except when the alias already refers to the same
symbol as the target (a redundant alias). In that case the `using` declaration
is accepted as a no-op.

### `interface` Scope

Inside an `interface { ... }` body, `using` may import method **signatures**
from another interface:

```silk
interface Read {
  fn read() -> u8;
}

interface ReadAndPeek {
  using Read::read;
  fn peek() -> u8;
}
```

- `using Other::name;` is equivalent to copying the corresponding `fn name(...);`
  signature from `Other`.
- `using Other::name as alias;` imports it under the new name `alias`.
- Name conflicts (including conflicts with inherited `extends` members) are
  errors.

Note: interface method signatures omit the receiver parameter. The receiver is
introduced only in `impl` method declarations (see `Interfaces`).

### `impl` Scope

Inside an `impl Type { ... }` body, `using` may import a method implementation
from another impl:

```silk
impl Foo {
  fn id(self: &Foo) -> int { return 1; }
}

impl Bar {
  using Foo::id;
}
```

This makes the imported method available as if it were declared in the target
impl, including as a candidate for interface conformance checking.

#### Visibility

Imported methods inherit the source method’s visibility:

- importing a `public fn` method produces a `public` method in the target impl,
- importing a private method produces a private method in the target impl.

Since `using` does not accept visibility modifiers in Silk, this
inheritance rule is the only way to control whether an imported method is
callable outside the target `impl { ... }` block.

#### `Self` and Layout Compatibility

When the imported method’s signature depends on `Self` (for example
`self: &Self`, parameters of type `Self`, or returning `Self`), importing it
across distinct struct types requires that the underlying layouts are
compatible.

In Silk, a pair of non-opaque, non-`error` structs are
considered compatible when they have the same number of fields and the same
field types in the same order (field names do not matter).

If the source and target struct layouts are not compatible, the `using`
declaration is rejected.

###  Limitations

- `using` does not accept `public` / `private` modifiers yet (imported methods
  inherit the source method’s visibility).
- Imported methods whose `Self`-dependent parameters require a mutable borrow
  (`mut` `&Self`) are rejected in Silk.
- Constructor reuse (`constructor`) via `using` is not supported yet.

## Compiler Diagnostics

This document specifies the *human-readable* diagnostic format emitted by the Silk toolchain, including:

- the `silk` CLI (`silk check`, `silk build`),
- the embedding ABI (`libsilk.a` via `silk_compiler_last_error` / `silk_error_format`),
- and tooling that reuses the front-end (for example `silk-lsp`).

The goal is to provide diagnostics that are:

- precise (file + line + column + source span),
- stable (consistent wording and stable error codes for known error kinds),
- consumable by humans (caret snippets, notes/help where appropriate),
- easy to test (deterministic formatting; the canonical text contains no ANSI escapes).

### Terminology

- **Source span**: a byte range in the UTF‑8 source buffer (`offset`, `length`).
  - Displayed **line** and **column** numbers are **1-based**.
  - Columns are measured in **UTF‑8 bytes** (matching the lexer’s current `Token.column` behavior).
- **Primary label**: the main span where the error is reported (single span in the initial implementation).
- **Note / Help**: supplemental lines that explain context or suggest a fix.

### Text Format (CLI and ABI)

The standard human-readable diagnostic format is:

```
error[E<code>]: <message>
 --> <path>:<line>:<column>
  |
<line> | <source line text>
  | <caret underline>
  = note: <note text>        (optional, repeatable)
  = help: <help text>        (optional, repeatable)
```

Rules:

- The `error[...]` line always appears for known error kinds; `<code>` is stable for that error kind.
- For diagnostics with no usable location, the `--> ...` and snippet block may be omitted.
- The snippet block uses the 1-based line number and includes the full line text as it appears in the source.
- The caret underline is placed under the primary span:
  - for a zero-length span, print a single `^`,
  - otherwise print `^` repeated for the span length, clipped to the line end if needed.
- The canonical text format contains no ANSI color escapes.

### Manifest and Config Errors

The CLI uses the same caret diagnostic format for errors in tooling/config inputs,
including the package manifest `silk.toml` and build-script-generated manifests.
These diagnostics may not yet have stable error codes.

Example (missing `=` in `silk.toml`):

```
error: invalid TOML in package manifest
 --> silk.toml:2:6
  |
2 | name "app"
  |      ^ expected `=`
```

### ANSI Color (CLI)

The `silk` CLI may decorate the canonical diagnostic format with ANSI SGR escape codes
when writing to a terminal. The visible text (after stripping ANSI escapes) must still
match the canonical format.

Color is enabled only when:

- stderr is a TTY that supports ANSI escapes,
- `NO_COLOR` is not set,
- `TERM` is not `dumb`.

Color is never used for the embedding ABI (`silk_error_format` / `silk_compiler_last_error`),
and is not used when stderr is not a TTY (for example when piping diagnostics to a file).

### Suggestions and Help Text

Diagnostics may include one or more `= help:` lines that suggest concrete fixes.
These are heuristic and may be omitted when the compiler cannot compute a safe
suggestion.

Examples of help/suggestion content the compiler may emit:

- for unknown imports, a `"did you mean ...?"` suggestion based on nearby names,
- for file imports, a note about the *resolved* import path,
- reminders about enabling or configuring the standard library (`--nostd`,
  `--std-root`, `SILK_STD_ROOT`) when importing `std::...`,
- guidance to include additional modules in the build/module set when an import
  refers to a package or file that is not present.

### Error Codes (Initial Set)

The compiler assigns a stable code to each currently supported error kind.

#### Parsing

- `E0001` — unexpected token / invalid top-level ordering.

#### Import and Package Resolution

- `E1001` — unknown imported package.
- `E1002` — cyclic package imports.
- `E1003` — unknown imported file.
- `E1004` — cyclic file imports.
- `E1005` — duplicate exported symbol within a package.
- `E1006` — file imports require a module file path.

#### Type Checking

- `E2001` — type mismatch.
- `E2002` — unsupported construct in Silk (the diagnostic detail may identify the rejected statement/expression form).
- `E2003` — unknown imported name.
- `E2004` — duplicate imported name.
- `E2005` — invalid assignment.
- `E2006` — invalid borrow.
- `E2007` — invalid `break`.
- `E2008` — invalid `continue`.
- `E2009` — invalid `return`.
- `E2010` — missing `return`.
- `E2011` — opaque struct used by value.
- `E2012` — cannot instantiate opaque struct.
- `E2013` — cannot access fields on opaque struct.
- `E2014` — formal Silk declaration used in runtime expression.
- `E2015` — `let` requires an initializer.
- `E2016` — unsupported generic form in Silk (for example const parameters / const type arguments).
- `E2017` — builtin `map(K, V)` type form was removed (use `std::map::{HashMap, TreeMap}` instead).
- `E2018` — namespace import is not callable.
- `E2019` — duplicate default export in a module.
- `E2020` — invalid `panic` statement.
- `E2021` — unknown error type.
- `E2022` — error not declared in function signature.
- `E2023` — error-producing call must be handled with `match`.
- `E2024` — match scrutinee is not an error-producing call.
- `E2025` — match is missing an arm.
- `E2026` — typed error-handling match arm must end with a terminal statement.
- `E2027` — heap allocation is disabled (`--noheap`) and heap-backed allocation is rejected (`new` outside `with`, libc allocator `ext`, concurrency keywords, capturing closures).
- `E2028` — unknown name.
- `E2029` — ambiguous implicit coercion.
- `E2030` — `await` requires an `async` function.
- `E2031` — `async { ... }` / `task { ... }` requires an `async` function.
- `E2032` — ambiguous constructor call.
- `E2033` — `await` requires a Promise operand.
- `E2034` — cannot copy a Task/Promise handle.
- `E2035` — Task/Promise handle used after `await`/`yield *`.
- `E2036` — cannot consume an outer Task/Promise handle inside a loop.
- `E2037` — `task fn` uses a non-task-safe type at a task boundary.
- `E2038` — `?` requires an error contract (`-> T | ErrorType...`).
- `E2039` — `?` requires a fallible call operand.
- `E2040` — propagated error is not declared in the function signature.
- `E2041` — `const` initializer is not compile-time evaluable.
- `E2042` — `pure fn` may not have a typed-error contract (`|` in return type).
- `E2043` — `pure fn` may not contain `panic` statements.
- `E2044` — `pure fn` may not have `mut` parameters.
- `E2045` — `pure fn` may not declare mutable locals (`var` or `let mut`).
- `E2046` — `pure fn` may not perform mutation via assignment.
- `E2047` — `pure fn` may not allocate (`new`).
- `E2048` — `pure fn` may not call impure functions.
- `E2049` — `pure fn` may not be combined with `task` or `async`.
- `E2050` — theories are not callable as runtime functions (use `#theory Name(...);`).
- `E2051` — module does not satisfy the declared interface (missing exported function).
- `E2052` — module does not satisfy the declared interface (signature mismatch).
- `E2053` — unknown re-export name.
- `E2054` — duplicate exported name.
- `E2056` — function expression may not have `&T` parameters.
- `E2057` — duplicate type alias name.
- `E2058` — type alias cycle.
- `E2059` — type alias kind mismatch.
- `E2060` — unknown `extends` base.
- `E2061` — invalid `extends` base.
- `E2062` — cyclic `extends` chain.
- `E2063` — derived struct redeclares an inherited field name.
- `E2064` — derived interface redeclares an inherited method name.
- `E2065` — opaque structs may not use `extends`.
- `E2067` — capturing closure is not allowed in `pure` code.
- `E2068` — capturing closure capture type is not supported in Silk.
- `E2069` — capturing closure may not capture a mutable binding in Silk.
- `E2070` — `yield` requires a `task` context.
- `E2071` — `yield` in value position requires a Task operand.
- `E2072` — `yield *` requires a Task operand.
- `E2073` — `yield` as a statement requires an enclosing task function.
- `E2074` — `await *` requires a Promise-array operand.
- `E2075` — duplicate type name.
- `E2076` — generic type arguments must be fully specified at the use site (missing a required, non-default type argument).
- `E2077` — invalid `region` declaration.
- `E2078` — `with` requires a region binding.
- `E2079` — invalid `with ... from` region slice.
- `E2080` — reserved (previously: indexing a slice cast from `u64` required an explicit length).
- `E2081` — slice-length cast suffix requires a `u64` pointer operand.
- `E2082` — `const fn` may not be `task` or `async`.
- `E2083` — `const fn` may not have a typed-error contract (`|` in return type).
- `E2084` — `const fn` parameter types must be compile-time value types.
- `E2085` — `const fn` result type must be a compile-time value type.
- `E2086` — `const fn` may not allocate (`new`).
- `E2087` — `const fn` may not call a non-`const fn`.
- `E2088` — `const fn` may not contain `panic` statements.
- `E2089` — unsupported construct in a `const fn` body (outside the current const-eval subset).
- `E2090` — `const fn` may be called only from compile-time contexts.
- `E2091` — generic function call type arguments could not be inferred at the call site.
- `E2092` — use of moved value.
- `E2093` — `move` requires a local binding name.
- `E2094` — slice borrow escapes its lexical scope.
- `E2095` — reference borrow escapes its lexical scope.
- `E2096` — unknown `using` target.
- `E2097` — `using` alias conflicts with an existing name.
- `E2098` — `using` target is ambiguous.
- `E2099` — `using` cannot import `constructor` in Silk.
- `E2100` — `using` may not import methods that require mutable `Self` borrows in Silk.
- `E2101` — `using` method reuse requires compatible struct layouts.
- `E2102` — cannot move value while it is borrowed.
- `E2103` — invalid regexp flags (unknown or duplicate).
- `E2104` — invalid regexp literal (pattern compile failed).
- `E2105` — method is private to its `impl` block (not visible from the call site).
- `E2106` — interface-required methods may not be declared `private`.
- `E2107` — destructuring requires a non-opaque struct value.
- `E2108` — cannot destructure opaque struct.
- `E2109` — destructuring pattern does not match the struct type (wrong arity, unknown field, or duplicate binder/field).
- `E2110` — array destructuring requires an array/slice value.
- `E2111` — array destructuring pattern does not match the array type (wrong arity for fixed arrays, or duplicate binder).

#### Formal Silk Verification

- `E3001` — loop invariant may not hold.
- `E3002` — loop variant may be negative.
- `E3003` — loop variant may not decrease.
- `E3004` — postcondition may not hold.
- `E3005` — Formal Silk verification failed to initialize or encountered an unsupported construct.
- `E3006` — assertion may not hold (`#assert` and theory assertions).
- `E3007` — call precondition may not hold.
- `E3008` — loop monovariant may not be monotonic.

Notes:

- When `silk build --debug` or `silk test --debug` is used, failed Formal Silk
  checks emit additional Z3 debug output and write an SMT-LIB2 reproduction
  script under `.silk/z3/` in the current working directory (or `$SILK_WORK_DIR/z3`).

#### Code Generation / Backend Lowering

- `E4001` — unsupported construct in Silk.
- `E4002` — code generation failed in the backend (unexpected backend error).

Notes:

- This error is reported when a program successfully parses and type-checks, but
  IR lowering or native code generation cannot yet handle a construct.
- The diagnostic detail names the rejected construct kind (statement /
  expression / function) and its surface form tag when available.

### Tooling Integration Notes

- `silk-lsp` should map the compiler’s primary source span to the LSP diagnostic range directly.
- When the compiler grows multi-span diagnostics (labels and secondary spans), the LSP implementation must be updated to surface them.

## C99 ABI and `libsilk.a`

This document defines the C99 ABI and the interface of the `libsilk.a` static library.

### Goals

- Provide a stable C ABI for embedders.
- Mirror the external-declaration semantics described in `External Declarations (`ext`)`.
- Keep the ABI small, explicit, and well-documented.

### Library & Headers

- Static library: `libsilk.a`.
- Primary header: `include/silk.h`.

#### Linking on `linux/x86_64` (vendored Z3)

On `linux/x86_64`, `libsilk.a` vendors Z3 (via `vendor/lib/x64-linux/libz3.a`) to
support Formal Silk verification. The vendored Z3 static library is built as
**C++**, so downstream embedders linking against `libsilk.a` MUST also link the
system C++ runtime and any required system libraries:

```sh
cc -std=c99 -Wall -Wextra \
   -I/path/to/include your_app.c \
   -L/path/to/lib -lsilk \
   -lstdc++ -lpthread -lm
```

The `silk cc` wrapper adds these flags automatically when linking on
`linux/x86_64`.

The header must define:

- Core bridged types (e.g. `SilkString`, and any other structs or enums used by the ABI).
- Opaque handle types (`SilkCompiler`, `SilkModule`, `SilkError`) and their lifetime rules.
- Entry points for:
  - initializing and shutting down compiler/runtime state,
  - configuring compilation (target triple, stdlib name, optimization level),
  - adding source buffers,
  - compiling Silk source to executables, libraries, or object files,
  - interacting with diagnostics and error reporting.

#### Initial C Header Shape (`include/silk.h`)

The initial C header provided in this repository defines:

- `SilkString` mirroring the internal Silk `string` layout:
  - Note: `SilkString` is also the C ABI shape for Silk `regexp` values
    (bytecode-backed `{ ptr, len }`), but the bytes are opaque and not required
    to be null-terminated.

  ```c
  typedef struct SilkString {
      char   *ptr;
      int64_t len;
  } SilkString;
  ```

- `SilkBytes` for owned binary buffers returned by in-memory build APIs:

  ```c
  typedef struct SilkBytes {
      uint8_t *ptr;
      int64_t  len;
  } SilkBytes;
  ```

- Opaque handles:

  ```c
  typedef struct SilkCompiler SilkCompiler;
  typedef struct SilkModule   SilkModule;
  typedef struct SilkError    SilkError;
  ```

- An output-kind enum:

  ```c
  typedef enum SilkOutputKind {
      SILK_OUTPUT_EXECUTABLE = 0,
      SILK_OUTPUT_STATIC_LIBRARY = 1,
      SILK_OUTPUT_SHARED_LIBRARY = 2,
      SILK_OUTPUT_OBJECT = 3,
  } SilkOutputKind;
  ```

- ABI version query:

  ```c
  void silk_abi_get_version(int *out_major,
                            int *out_minor,
                            int *out_patch);
  ```

- Compiler lifecycle:

  ```c
  SilkCompiler *silk_compiler_create(void);
  void          silk_compiler_destroy(SilkCompiler *compiler);
  ```

- Configuration:

  ```c
  bool silk_compiler_set_stdlib(SilkCompiler *compiler, SilkString stdlib_name);
  bool silk_compiler_set_std_root(SilkCompiler *compiler, SilkString std_root);
  bool silk_compiler_set_nostd(SilkCompiler *compiler, bool nostd);
  bool silk_compiler_set_debug(SilkCompiler *compiler, bool debug);
  bool silk_compiler_set_noheap(SilkCompiler *compiler, bool noheap);
  bool silk_compiler_set_target(SilkCompiler *compiler, SilkString target_triple);
  bool silk_compiler_set_z3_lib(SilkCompiler *compiler, SilkString path);
  bool silk_compiler_set_std_archive(SilkCompiler *compiler, SilkString path);
  bool silk_compiler_add_needed_library(SilkCompiler *compiler, SilkString soname);
  bool silk_compiler_add_runpath(SilkCompiler *compiler, SilkString path);
  bool silk_compiler_set_soname(SilkCompiler *compiler, SilkString soname);
  bool silk_compiler_set_optimization_level(SilkCompiler *compiler, int level);
  bool silk_compiler_set_c_header(SilkCompiler *compiler, SilkString path);
  ```

  `silk_compiler_set_std_root` configures the filesystem stdlib root directory used
  to auto-load `std::...` packages when modules contain `import std::...;`. The
  `std_root` string is copied. When set, it overrides `SILK_STD_ROOT` and the
  working-directory/default search behavior described below.

  `silk_compiler_set_nostd` disables this stdlib auto-loading behavior when set
  to `true`. When `nostd` is enabled, `import std::...;` declarations must be
  satisfied by explicitly adding the corresponding std sources as modules (for
  example via `silk_compiler_add_source_buffer`); the compiler will not consult
  `SILK_STD_ROOT` or the filesystem std root search paths.

  `silk_compiler_set_debug` enables the same debug build mode as the CLI
  (`silk --debug`): debug-mode lowering for supported native outputs, and
  additional Z3 debug output plus `.smt2` reproduction scripts on failing Formal
  Silk obligations (written under `.silk/z3/` or `$SILK_WORK_DIR/z3`).

  `silk_compiler_set_noheap` enables the same no-heap mode as the CLI
  (`silk --noheap`): heap-backed allocation is disabled for the supported
  subset. `--noheap` is currently incompatible with `--debug`; the ABI rejects
  configurations that enable both.

  `silk_compiler_set_target` selects the code generation target. The
  `target_triple` string is copied. The initial implementation recognizes:

  - `linux-x86_64` (default), and common `x86_64-*-linux-*` triples such as
    `x86_64-linux-gnu` and `x86_64-unknown-linux-gnu`,
  - `wasm32-unknown-unknown`,
  - `wasm32-wasi` (and other `wasm32` triples containing `wasi`).

  For `wasm32` targets, only `SILK_OUTPUT_EXECUTABLE` is supported. The output
  bytes are a final WebAssembly module (`.wasm`) produced by the IR-backed wasm
  backend (`the implementation`), with a smaller constant-only fallback for
  programs that fit the constant subset.

  The wasm backend is still early-stage, but it is no longer limited
  to single-module constant programs:

  - Multi-module builds (packages + file imports) are supported.
  - `ext foo = fn (...) -> ...;` declarations become imported functions under
    `env.foo` for `wasm32-unknown-unknown`, analogous to `extern` symbols in C.
  - String and other constant data are emitted into wasm data segments.

  Entrypoint conventions:

  - `wasm32-unknown-unknown`:
    - when a valid executable `main` exists, it is exported as `main` for
      embedder use,
    - when no `main` exists, an export-only module is emitted that exports each
      supported `export fn` from the root package.
  - `wasm32-wasi`:
    - requires `fn main () -> int` (the `main(argc, argv)` form is not supported
      yet for WASI),
    - emits an exported `_start () -> void` wrapper that calls `main` and then
      imports/calls WASI `proc_exit`,
    - export-only modules are supported for embedding (export-only modules do
      not include `_start`).

  `silk_compiler_add_needed_library` records a dynamic loader dependency for
  executable and shared library outputs (emitted as `DT_NEEDED`). The `soname`
  string is copied; the function may be called multiple times (duplicates are
  ignored). For static library and object outputs, the value is ignored.
  `DT_NEEDED` entries starting with `libsilk_rt` are rejected: bundled runtime
  helpers are linked statically from `libsilk_rt.a` / `libsilk_rt_noheap.a` and
  must not become runtime loader dependencies.
  On `linux/x86_64` with the glibc dynamic loader (`ld-linux`), when an
  executable or shared library imports any external symbols, the compiler
  automatically adds `libc.so.6` as a `DT_NEEDED` dependency (so embedders do
  not need to manually add libc when using hosted `std::` modules like
  `std::io` and `std::fs`). Additional non-libc dependencies must still be
  declared via `silk_compiler_add_needed_library`.

  `silk_compiler_add_runpath` records a dynamic loader search path element for
  executable and shared library outputs (emitted as `DT_RUNPATH`). The `path`
  string is copied; the function may be called multiple times (duplicates are
  ignored) and the final `DT_RUNPATH` string is formed by joining all entries
  with ':'.

  `silk_compiler_set_soname` configures the shared library soname recorded as
  `DT_SONAME` for shared library outputs. The `soname` string is copied; passing
  an empty string clears the configured soname (no `DT_SONAME` entry). For
  executable, static library, and object outputs, the value is ignored.

  `silk_compiler_set_z3_lib` configures a Z3 dynamic library override for Formal
  Silk verification (equivalent to the CLI `--z3-lib <path>`). Passing an empty
  string clears the override and returns to the normal Z3 selection rules
  (including honoring `SILK_Z3_LIB`).

  `silk_compiler_set_std_archive` configures a stdlib archive override
  (equivalent to the CLI `--std-lib <path>`). Passing an empty string clears
  the override and returns to the normal stdlib archive selection rules
  (including honoring `SILK_STD_LIB`).

  `silk_compiler_set_c_header` configures C header generation for non-executable
  outputs (equivalent to the CLI `--c-header <path>`). The header is written
  when `silk_compiler_build` succeeds for `SILK_OUTPUT_OBJECT`,
  `SILK_OUTPUT_STATIC_LIBRARY`, or `SILK_OUTPUT_SHARED_LIBRARY`. C header
  generation is not supported for `silk_compiler_build_to_bytes`.

- Source management:

  ```c
  SilkModule *silk_compiler_add_source_buffer(SilkCompiler *compiler,
                                              SilkString    name,
                                              SilkString    contents);
  ```

- Building artifacts:

  ```c
  bool silk_compiler_build(SilkCompiler   *compiler,
                           SilkOutputKind  kind,
                           SilkString      output_path);
  ```

  For embedders that need filesystem-free compilation (for example sandboxed
  hosts or WASM-like environments), the ABI also provides an in-memory build
  API that returns an owned byte buffer:

  ```c
  bool silk_compiler_build_to_bytes(SilkCompiler   *compiler,
                                    SilkOutputKind  kind,
                                    SilkBytes      *out_bytes);

  void silk_bytes_free(SilkBytes *bytes);
  ```

  The returned bytes are target-specific: for example an ELF64 binary on
  `linux-x86_64`, or a `.wasm` module on `wasm32` targets.

  Ownership rules:

  - On success, `silk_compiler_build_to_bytes` fills `*out_bytes` with a pointer
    and length describing the produced artifact, and returns `true`.
  - The returned `out_bytes->ptr` is owned by `libsilk.a` and must be freed
    by calling `silk_bytes_free(&bytes)`. Callers must not free the pointer with
    `free()` (or any other allocator).
  - `silk_bytes_free` is a no-op when passed `NULL` or when `bytes->ptr` is
    `NULL`; it always clears the struct to `{ NULL, 0 }`.

  Note: the compiler may still consult the filesystem to auto-load `std::...`
  modules unless `silk_compiler_set_nostd(compiler, true)` has been set.

  At the current stage of implementation:

  - `silk_compiler_build` always performs full front‑end validation for all modules
    added via `silk_compiler_add_source_buffer`:
    - it lexes and parses each module into an internal representation,
    - it then type‑checks the *set* of modules as a unit, taking into account
      package/import relationships and exported constants, according to the
      language grammar and semantics documented under `this specification`,
    - if Formal Silk syntax is present (for example `#require`, `#assure`,
      `#assert`, `#invariant`, `#variant`, `#monovariant`, `#const`), it also runs the Z3-backed verifier
      and fails the build if verification fails (`E3001`..`E3008`),
    - the verifier is currently skipped for stdlib modules (`std::...`),
    - on `linux/x86_64`, Z3 is linked from the vendored static archive
      `vendor/lib/x64-linux/libz3.a`,
    - the verifier honors `SILK_Z3_LIB` (environment variable) to override
      the Z3 dynamic library at runtime,
    - it fails fast on the first front‑end error.
    - when packages/imports are present:
      - `import` declarations must refer to packages that exist in the current
        module set (otherwise a resolver error is reported, such as
        `"unknown imported package"`),
      - exported `let` bindings with explicit type annotations in an imported
        package are treated as ordinary, unqualified names in the importing
        modules for type‑checking purposes (for example, `import util;` and
        `export let answer: int = 42;` in `util` allows `let x: int = answer;`
        in `app`),
      - imported exported functions (`export fn`) are callable across packages
        for the current scalar subset (both unqualified `foo()` and qualified
        `pkg::foo()` call forms are accepted initially), and functions in the
        same package share a call namespace across modules in the same module
        set,
      - duplicate exported names within a single package are reported as a
        resolver error (`"duplicate exported symbol"`).
    - standard library import resolution (first slice):
      - when a module contains `import std::...;`, the compiler will attempt to
        auto-load the referenced `std::...` package modules from a configured
        stdlib root so embedders do **not** need to provide std sources
        explicitly in the common case,
      - the stdlib root is selected via:
        - `silk_compiler_set_std_root` when set, otherwise
        - `SILK_STD_ROOT` (environment variable) when set, otherwise
        - a `std/` directory in the current working directory (development default), otherwise
        - `../share/silk/std` relative to the current executable (installed default).
      - package-to-path mapping is deterministic:
        - `std::foo::bar` resolves to the file `<std_root>/foo/bar.slk`,
      - if the embedder explicitly provides a `std::...` module via
        `silk_compiler_add_source_buffer`, that module is treated as authoritative
        for its package (auto-loading does not replace already-provided packages).
    - standard library archive linking (`linux/x86_64`, current archive layout):
      - the toolchain can build a target-specific stdlib static archive
        (`libsilk_std.a`) containing one ELF object per std module (for example
        via `make stdlib`),
      - for supported executable builds, the compiler treats *auto-loaded*
        `std::...` modules as external during code generation and resolves their
        exported functions from the archive when available (while still
        type-checking the std sources as part of the module set),
      - archive discovery (in order):
        - `SILK_STD_LIB` when set, otherwise
        - `zig-out/lib/libsilk_std.a` when using the in-repo `std/` root, otherwise
        - `../lib/libsilk_std.a` relative to the current executable, otherwise
        - common installed-layout heuristics derived from the selected stdlib root,
        - walk up from the current working directory to find `libsilk_std.a` or `lib/libsilk_std.a`,
      - when no suitable archive is found (or on unsupported targets), the
        compiler falls back to compiling the reachable std sources into the
        build as part of module-set code generation.
  - When a front‑end error occurs (e.g. parse error, type mismatch, invalid
    control‑flow such as `break`/`continue`/`return` in the wrong context, or
    other semantic violations), the call returns `false` and
    `silk_compiler_last_error`/`silk_error_format` provide a human‑readable
    description (such as `"unexpected token while parsing module"`,
    `"type mismatch"`, `"invalid break statement"`, `"invalid return statement"`,
    `"missing return statement"`,
    etc.).
  - For executable outputs (`kind == SILK_OUTPUT_EXECUTABLE`), the compiler also
    enforces an entrypoint precondition on the front‑end:
    - there MUST be exactly one top‑level function

      ```silk
      fn main() -> int { ... }
      ```

      with no parameters and a declared result type of `int`,
    - otherwise `silk_compiler_build` fails with an error message such as
      `"no valid main function for executable output"` or
      `"multiple main functions for executable output"`.
  - When all modules pass front‑end validation (including the executable
    entrypoint requirement, where applicable), code generation behavior depends
    on `kind`:
    - for non-executable outputs (`SILK_OUTPUT_OBJECT`, `SILK_OUTPUT_STATIC_LIBRARY`, `SILK_OUTPUT_SHARED_LIBRARY`):
      - `main` is optional, but when more than one valid executable `main` exists in the module set,
        `silk_compiler_build` fails with `"multiple main functions for non-executable output"`,
      - when multiple packages are present in the module set, only exports from the *root package*
        (the package of the first module added to the compiler via `silk_compiler_add_source_buffer`)
        are emitted as globally-visible symbols for that output; other packages are compiled as
        dependencies and their `export` declarations are treated as internal for that output.
      - within the current `linux/x86_64` IR subset, `string` and `regexp` values are supported at ABI boundaries in a C-friendly `SilkString { ptr, len }` layout:
        - `string`/`regexp` parameters lower to two integer-like scalars in order (`u64` pointer, then `i64` byte length) and consume the normal integer argument locations (registers then stack),
        - `string`/`regexp` results return as two integer-like scalars in `rax`/`rdx`,
        - within function bodies, the compiler supports a small `string`/`regexp` expression subset:
          - `string`: string literals, `let` bindings of `string`, `return` of a `string` value, direct calls to `string`-returning helpers, and `==`/`!=`/`<`/`<=`/`>`/`>=` comparisons over `string` values (producing `bool`),
          - `regexp`: regex literals (`/pattern/flags`), `let` bindings of `regexp`, `return` of a `regexp` value, and direct calls between helpers that accept/return `regexp`,
          - other string operations (concatenation, indexing, etc.) are not implemented yet; higher-level regex matching lives in `std::regex` and is routed through `ext` calls.
      - within the current `linux/x86_64` IR subset, a limited `struct` subset is supported at ABI boundaries:
        - within function bodies and internal helper calls, `struct` declarations with 0+ fields of supported value types are supported (scalar primitives, `string`, nested structs, and supported optionals),
        - at ABI boundaries for exported/FFI functions, only ABI-safe structs are currently supported: after slot-flattening, all scalar slots must be `i64`/`u64`/`f64` (until packed ABI mapping for smaller fields is implemented),
        - at the C ABI surface, exported function *parameters* support 1+ slot ABI-safe structs by lowering the struct to its scalar slots in order; downstream C callers should declare separate parameters for 3+ slot structs (by-value C struct parameters are ABI-compatible only for the 1–2 slot cases), while exported function *returns* support 1+ slot ABI-safe structs (3+ slot returns use the native backend’s sret return path and are ABI-compatible with returning an equivalent C struct by value),
        - in all cases, the compiler lowers a struct value into N scalar slots in field order and assigns argument/result locations according to System V AMD64 integer/SSE classification for those slots.
      - within the current `linux/x86_64` IR subset, optionals (`T?`) are supported at ABI boundaries for the supported payload subset (scalar payloads, `string?`, and optionals of ABI-safe structs):
        - an optional lowers to a `Bool` tag followed by the payload scalar slots: `(tag, payload0, payload1, ...)` with `tag=0` for `None` and `tag=1` for `Some(...)`,
        - nested optionals (`T??`) lower by treating the payload slots as the full inner optional representation (for example `int??` lowers as `(tag0, tag1, i64 payload)`),
        - optional parameters are passed as these scalar slots in order (so downstream C callers should declare separate parameters, treating `tag` as an integer-like 0/1 value),
        - optional results return as the same scalar slots (1–2 slots in registers; 3+ slots via a hidden sret pointer as described above).
    - for object outputs (`SILK_OUTPUT_OBJECT`):
      - on `linux/x86_64`, the compiler can emit an ELF64 relocatable object
        (`ET_REL`) for the supported IR subset, emitting supported functions
        (scalar-returning, `void`-returning, and a limited `string` subset) and supported exported constants
        (`export let`/`export const`; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit `: string` when the initializer is a string literal), and marking `export fn`
        declarations, supported exported constants, and a valid executable `main`
        (when present) as global symbols,
      - when the module set contains no supported globally-visible symbols (no
        supported `export fn`, no supported `export let` constants, and no valid
        executable `main`), `silk_compiler_build` still succeeds and writes a
        valid relocatable object with no globally-visible symbols,
      - for programs outside that subset (or on unsupported targets),
        `silk_compiler_build` returns `false` with an `E4001` / `E4002` formatted diagnostic (via `silk_compiler_last_error` / `silk_error_format`)
        and does not write an output file.
    - for static library outputs (`SILK_OUTPUT_STATIC_LIBRARY`):
      - on `linux/x86_64`, the compiler can emit a static library archive
        (`.a`) containing an object file for the supported IR subset, emitting
        supported functions (scalar-returning, `void`-returning, and a limited `string` subset) and supported
        exported constants (`export let`/`export const`; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit `: string` when the initializer is a string literal), and
        marking `export fn` declarations, supported exported constants, and a
        valid executable `main` (when present) as global symbols,
      - when the module set contains no supported globally-visible symbols (no
        supported `export fn`, no supported `export let` constants, and no valid
        executable `main`), `silk_compiler_build` still succeeds and writes a
        valid archive containing an object file with no globally-visible symbols,
      - for programs outside that subset (or on unsupported targets),
        `silk_compiler_build` returns `false` with an `E4001` / `E4002` formatted diagnostic (via `silk_compiler_last_error` / `silk_error_format`)
        and does not write an output file.
    - for shared library outputs (`SILK_OUTPUT_SHARED_LIBRARY`):
      - on `linux/x86_64`, the compiler can emit an ELF64 shared library
        (`ET_DYN`, typically with a `.so` filename) for the supported IR subset,
        emitting supported functions (scalar-returning, `void`-returning, and a limited `string` subset) and
        supported exported constants (`export let`/`export const`; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit `: string` when the initializer is a string literal), and
        marking `export fn` declarations, supported exported constants, and a
        valid executable `main` (when present) as dynamic global symbols,
      - when the module set contains no supported globally-visible symbols (no
        supported `export fn`, no supported `export let` constants, and no valid
        executable `main`), `silk_compiler_build` still succeeds and writes a
        valid shared library with an empty export set,
      - for programs outside that subset (or on unsupported targets),
        `silk_compiler_build` returns `false` with an `E4001` / `E4002` formatted diagnostic (via `silk_compiler_last_error` / `silk_error_format`)
        and does not write an output file.
    - for executable outputs (`SILK_OUTPUT_EXECUTABLE`):
      - the implementation supports a **minimal constant‑expression backend**:
        - the program must satisfy the entrypoint rule above,
        - the body of `main` must be one of the following shapes:
          - zero or more `let` statements whose initializers are constant
            integer expressions, followed by exactly one `return` statement
            that returns a *constant integer expression* built only from:
            - integer literals,
            - the arithmetic operators `+`, `-`, `*`, `/`, and `%`,
            - and references to immutable `let` bindings (top‑level or local
              to `main`, or imported exported scalar constants from imported
              packages) whose initializers are themselves constant integer
              expressions in this same sense (no side‑effecting operations);
              imported exported constants must be declared as `export let` or
              `export const` with the shape `export <binding> name: <scalar> =
              <literal>;` (explicit scalar type and literal initializer),
            - on `linux/x86_64`, direct calls to simple helper functions of
              the form

              ```silk
              fn helper (x, y) -> int {
                [let ...;]
                return <expr>;
              }
              ```

              where:
              - parameters may be annotated as scalar types (defaulting to
                `int` when unannotated),
              - arguments at each call site are drawn from the same
                scalar expression subset as `<expr>` (including `bool`,
                `char`, `Instant`, `Duration`, fixed-width integers, and
                `f32`/`f64` on `linux/x86_64`), with optionals (`T?`)
                supported for scalar
                payloads, `string?`, and optionals of the POD `struct`
                subset via `None` / `Some(...)` and `??`
                coalescing, and
              - in module-set builds, helper calls may target:
                - functions defined in the same package (across multiple
                  modules), and
                - imported exported functions (`export fn`) from any
                  packages imported by the module that contains `main`
                  (both `foo()` and `pkg::foo()` call forms are accepted
                  initially for imported exports),
              - the helper body either:
                - consists only of scalar `let` bindings and a final
                  `return`, or
                - ends in a simple `if` / `else` of the form:

                  ```silk
                  if <cond> {
                    [let ...;]
                    return <expr>;
                  } else {
                    [let ...;]
                    return <expr>;
                  }
                  ```

                  where `<cond>` is a boolean expression built from comparisons
                  over scalar expressions and boolean literals, and both
                  branches end in `return`;
              such calls are lowered to IR `Call` instructions and compiled
              to native code together with `main`, using the System V AMD64
              scalar calling convention on `linux/x86_64` (integer-like
              scalars in `rdi`..`r9`, `f32`/`f64` in `xmm0`..`xmm7`, with
              additional arguments spilled to the stack); helpers may have
              more than six integer parameters, and this path is exercised
              in both Zig tests and C tests (see `the C ABI test harness`), or
          - a final `if` statement whose condition is a boolean expression:
            - for the purely constant subset, the condition is a
              **compile‑time boolean literal** (`true` or `false`) and each
              branch body itself satisfies the same “constant lets +
              `return` constant integer expression” rule, and
            - on `linux/x86_64`, a slightly richer branching `main` shape is
              also supported in which the body is exactly:

              ```silk
              fn main () -> int {
                if <cond> {
                  [let ...;]
                  return <expr>;
                } else {
                  [let ...;]
                  return <expr>;
                }
              }
              ```

              where `<cond>` is built from integer comparisons (`==`, `!=`,
              `<`, `<=`, `>`, `>=`) over integer expressions from the same
              constant subset; this shape is lowered to IR using `BrCond` and
              compiled to native code by the IR→ELF backend so that the
              condition is evaluated at runtime, or
          - one or more **trivial constant `while` loops** that appear before
            the final `return`, each of which has:
            - a condition that is a compile‑time boolean literal (`true` or
              `false`),
            - for `while false { ... }`, a body that is ignored by the
              constant backend, and
            - for `while true { ... }`, a body consisting of zero or more
              constant `let` statements followed by a `break;`, with no other
              control‑flow; loop invariants (`#invariant`) and variants
              (`#variant`) may be present but are treated as metadata and do
              not affect constant evaluation,
        - examples of supported forms include:

          ```silk
          fn main() -> int { return 0; }
          fn main() -> int { return 1; }
          fn main() -> int { return 1 + 2 * 3; }

          let answer: int = 21 * 2;

          fn main() -> int {
            return answer;
          }

          // Two-module imported constant example (module-set builds only):
          //
          // util.slk
          package util;
          export let answer: int = 42;
          //
          // app.slk
          package app;
          import util;
          fn main () -> int { return answer; }

          // Two-module imported function example (module-set builds only):
          //
          // util.slk
          package util;
          export fn add (x: int, y: int) -> int { return x + y; }
          //
          // app.slk
          package app;
          import util;
          fn main () -> int { return add(40, 2); }

          fn main () -> int {
            let a: int = 21;
            let b: int = a * 2;
            return b;
          }

          fn main () -> int {
            if true {
              return 0;
            } else {
              return 1;
            }
          }

          fn main () -> int {
            while true {
              break;
            }
            return 0;
          }
          ```

      - when these conditions hold and `output_path` names a valid path,
        `silk_compiler_build`:
        - evaluates the constant integer expression in the body of `main`,
        - emits a tiny native executable image directly using a Silk‑owned
          backend (no C stub, no external C compiler),
          - currently this backend writes a minimal ELF64 executable for
            `linux/x86_64` whose entrypoint immediately performs a
            `sys_exit(value)` system call,
        - returns `true` on success with no last error recorded.
      - when the program is front‑end valid but outside this subset
        (e.g. `main` contains non‑constant expressions, references to
        non‑constant values, or calls that fall outside the simple
        helper‑call subset described above),
        or when the backend cannot produce an executable for the current
        platform or output path, the call returns `false` and records either
        an `E4001` / `E4002` diagnostic (for unsupported constructs or backend failures) or
        a descriptive string for I/O/argument errors as the last error.

- Error reporting:

  ```c
  SilkError *silk_compiler_last_error(SilkCompiler *compiler);

  size_t silk_error_format(const SilkError *error,
                           char            *buffer,
                           size_t           buffer_len);
  ```

  - `silk_error_format` returns a human-readable diagnostic message. When the compiler can associate the error with a source span, the formatted message includes the module name/path plus line/column and a caret snippet.
  - The text format and initial stable error code set are specified in `Compiler Diagnostics`. Embedders should treat the formatted message as user-facing text (not a stable machine-readable protocol).

Ownership, lifetime, and thread-safety guarantees for these APIs must be clearly documented and kept in sync with the implementation.

ABI rules:

- All exposed functions must be C99-compatible.
- Data layouts must be stable and match the Silk side.
- Ownership and lifetime of any pointers passed across the boundary must be explicitly documented.

In addition, the embedding ABI must clearly distinguish:

- functions that consume Silk‑owned values (e.g. `SilkString` whose storage is owned by the runtime) versus
- functions that take ownership of data supplied by the embedder (and are responsible for freeing it via documented APIs).

Any deviation from the mappings documented in `External Declarations (`ext`)` must be justified here and reflected in tests.

### See Also

- `libsilk` (7) — C99 ABI manpage for embedders.
- `silk.h` — public C header shipped with the library.

==============================================================================
WIKI: Silk Wiki (start)
URL: /silk/wiki/?p=start
==============================================================================

# Silk Wiki

The Silk Wiki is a learning-first, example-driven reference.

Use it when you want:

- a practical explanation of a concept
- examples that show how a feature feels in real code
- a gentler progression than the full reference material


## Start here

- Language: [Overview](?p=language/cheat-sheet)
- Standard library: [Overview](?p=std/overview)

==============================================================================
WIKI: `break` (language/flow-break)
URL: /silk/wiki/?p=language/flow-break
==============================================================================

# `break`

`break;` exits the nearest enclosing loop.


## Syntax

```silk
break;
```

## Example 

```silk
fn main () -> int {
  let mut i: int = 0;
  while true {
    i += 1;
    if i == 3 {
      break;
    }
  }
  return i;
}
```

## See also

==============================================================================
WIKI: `continue` (language/flow-continue)
URL: /silk/wiki/?p=language/flow-continue
==============================================================================

# `continue`

`continue;` skips the remainder of the current loop body and advances to the
next iteration.


## Syntax

```silk
continue;
```

## Example 

```silk
fn main () -> int {
  let mut sum: int = 0;
  for i in 0..5 {
    if i == 3 {
      continue;
    }
    sum += i;
  }
  return sum; // 0 + 1 + 2 + 4 = 7
}
```

## See also

==============================================================================
WIKI: `Duration` and `Instant` (language/duration-instant)
URL: /silk/wiki/?p=language/duration-instant
==============================================================================

# `Duration` and `Instant`

`Duration` represents a signed time span and `Instant` represents a signed
point-in-time on a monotonic timeline. the backend treats both
as distinct Silk types that lower to `i64` nanoseconds.


## Example: `Duration` arithmetic

```silk
fn main () -> int {
  let a: Duration = 10ms;
  let b: Duration = 2s;
  let c: Duration = a + b;
  if c > a {
    return 0;
  }
  return 1;
}
```

## See also

==============================================================================
WIKI: `for` loops (language/flow-for)
URL: /silk/wiki/?p=language/flow-for
==============================================================================

# `for` loops

`for` loops iterate over:

- integer ranges (`start..end` / `start..=end`),
- builtin arrays and slices (`for x in xs { ... }`),
- iterator values (`for x in it { ... }` when `it.next() -> T?`),
- and C-style headers (`for (init; cond; step) { ... }`).


## Syntax

```silk
for x in xs {
  // ...
}

for (let i = 0; i < 10; ++i) {
  // ...
}
```

## Examples

### Example: range iteration

```silk
fn main () -> int {
  let mut sum: int = 0;
  for i in 0..3 {
    sum += i; // 0, 1, 2
  }
  return sum;
}
```

### Example: array iteration

```silk
fn main () -> int {
  let xs: int[3] = [1, 2, 3];
  let mut sum: int = 0;
  for x in xs {
    sum += x;
  }
  return sum;
}
```

## See also

==============================================================================
WIKI: `if` / `else` (language/flow-if-else)
URL: /silk/wiki/?p=language/flow-if-else
==============================================================================

# `if` / `else`

Use `if` / `else` for boolean branching.

In Silk, `if` is a statement that chooses which block
executes. The broader language design includes expression-oriented forms; see
the canonical spec for details.


## Syntax

```silk
if condition {
  // ...
} else {
  // ...
}
```

## Examples

### Example: minimal `if` / `else`

```silk
fn main () -> int {
  if true {
    return 0;
  } else {
    return 1;
  }
}
```

### Example: `else if` chains

In the current implementation, `else if` parses as sugar for a nested `if` in
the `else` branch.

```silk
fn main () -> int {
  let x: int = 1;
  if x == 0 {
    return 0;
  } else if x == 1 {
    return 1;
  } else {
    return 2;
  }
}
```

## See also

==============================================================================
WIKI: `loop` (language/flow-loop)
URL: /silk/wiki/?p=language/flow-loop
==============================================================================

# `loop`

`loop { ... }` is an infinite loop that exits via `break` or `return`.


## Syntax

```silk
loop {
  // ...
}
```

## Example 

```silk
fn main () -> int {
  let mut i: int = 0;
  loop {
    if i == 3 {
      break;
    }
    i += 1;
  }
  return i;
}
```

## See also

==============================================================================
WIKI: `match` (language/flow-match)
URL: /silk/wiki/?p=language/flow-match
==============================================================================

# `match`

`match` provides structured pattern matching.

In the current implementation:

- `match <optional> { None => expr, Some(x) => expr }` is supported (expression form),
- `match <enum> { E::V => expr, ... }` is supported in a restricted exhaustive subset,
- typed-error handling uses a separate `match (expr) { ... }` statement form (see typed errors).


## Syntax (Current match-expression subset)

```silk
match value {
  Pattern => expr,
  Pattern => expr,
}
```

## Examples

### Example: matching an optional

```silk
fn main () -> int {
  let x: int? = Some(7);
  let y: int = match x {
    None => 5,
    Some(v) => v,
  };
  return y;
}
```

### Example: matching an enum

```silk
enum Msg {
  Quit,
  Add(int),
}

fn main () -> int {
  let m: Msg = Msg::Add(5);
  return match m {
    Msg::Quit => 0,
    Msg::Add(n) => n,
  };
}
```

## See also

==============================================================================
WIKI: `return` (language/flow-return)
URL: /silk/wiki/?p=language/flow-return
==============================================================================

# `return`

Use `return` to exit the current function.


## Syntax

```silk
return;
return expr;
```

## Example 

```silk
fn add1 (x: int) -> int {
  return x + 1;
}

fn main () -> int {
  return add1(41);
}
```

## See also

==============================================================================
WIKI: `while` (language/flow-while)
URL: /silk/wiki/?p=language/flow-while
==============================================================================

# `while`

Use `while` for condition-controlled looping.


## Syntax

```silk
while condition {
  // ...
}
```

## Example 

```silk
fn main () -> int {
  let mut i: int = 0;
  let mut sum: int = 0;

  while i < 3 {
    sum += i;
    i += 1;
  }

  return sum; // 0 + 1 + 2 = 3
}
```

## See also

==============================================================================
WIKI: Aggregate literals (arrays and structs) (language/literals-aggregate)
URL: /silk/wiki/?p=language/literals-aggregate
==============================================================================

# Aggregate literals (arrays and structs)

Aggregate literals build compound values directly in source code:

- array literals: `[a, b, c]`
- struct literals: `Type{ field: value, ... }`


## Example 

```silk
struct Pair {
  a: int,
  b: int,
}

fn main () -> int {
  let xs: int[3] = [1, 2, 3];
  let p: Pair = Pair{ a: xs[0], b: xs[2] };
  return p.a + p.b;
}
```

## See also

==============================================================================
WIKI: Arenas (language/arenas)
URL: /silk/wiki/?p=language/arenas
==============================================================================

# Arenas

This page has been removed. Use **regions** instead:

==============================================================================
WIKI: Blocks and statements (language/flow-blocks-statements)
URL: /silk/wiki/?p=language/flow-blocks-statements
==============================================================================

# Blocks and statements

Blocks (`{ ... }`) group statements and introduce a new scope.


## Example: scope boundaries

```silk
fn main () -> int {
  let x: int = 1;
  {
    let y: int = 2;
    if x + y != 3 {
      return 1;
    }
  }
  // `y` is not in scope here.
  return 0;
}
```

## See also

==============================================================================
WIKI: Boolean literals (language/literals-boolean)
URL: /silk/wiki/?p=language/literals-boolean
==============================================================================

# Boolean literals

Silk has the boolean type `bool` with literals `true` and `false`.


## Example 

```silk
fn main () -> int {
  let ok: bool = true;
  if ok && !false {
    return 0;
  }
  return 1;
}
```

==============================================================================
WIKI: Borrow checker (design) (language/borrow-checker)
URL: /silk/wiki/?p=language/borrow-checker
==============================================================================

# Borrow checker (design)

Silk’s long-term design includes a borrow-checker-style static safety layer
over references and mutation. the compiler enforces a simpler,
explicit `mut` borrow contract (see mutability).


## Example: explicit mutable borrow

```silk
struct Counter {
  value: int,
}

fn inc (mut c: &Counter) -> void {
  c.value += 1;
}

fn main () -> int {
  let mut c: Counter = Counter{ value: 0 };
  inc(mut c);
  return c.value;
}
```

## See also

==============================================================================
WIKI: Buffers (`Buffer(T)`) (design) (language/buffers)
URL: /silk/wiki/?p=language/buffers
==============================================================================

# Buffers (`Buffer(T)`) (design)

The long-term design includes an intrinsic `Buffer(T)` type for low-level,
unsafe contiguous memory access, intended to sit underneath safe collections.


In the current toolchain, buffer-like functionality is provided via `std::`:

- `std::vector::Vector(T)` for owning growable storage
- `std::buffer::BufferU8` as an owning packed byte buffer, plus width-oriented
  scalar buffer aliases (`BufferI32`, etc.)

## Example: buffer aliases

```silk
import std::buffer;

fn main () -> int {
  let b_r = BufferU8.init(4);
  if b_r.is_err() { return 1; }
  let mut b: BufferU8 = match (b_r) {
    Ok(v) => v,
    Err(_) => BufferU8.empty(),
  };
  (mut b).push(1 as u8);
  (mut b).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: Character literals (language/literals-character)
URL: /silk/wiki/?p=language/literals-character
==============================================================================

# Character literals

`char` represents a Unicode scalar value. Character literals write a `char`
value directly in source code.


## Example 

```silk
fn main () -> int {
  let a: char = 'A';
  let nl: char = '\\n';
  if a != 'A' { return 1; }
  if nl != '\\n' { return 2; }
  return 0;
}
```

## See also

==============================================================================
WIKI: Cheat sheet (language/cheat-sheet)
URL: /silk/wiki/?p=language/cheat-sheet
==============================================================================

# Cheat sheet

If you want a fast, high-signal overview of Silk surface syntax, start with the
canonical cheat sheet:


This wiki page exists to keep wiki navigation self-contained; the cheat sheet
itself is already concise and example-heavy.

## Example 

```silk
fn main () -> int {
  return 0;
}
```

==============================================================================
WIKI: Concurrency (`async`, `task`, `await`, `yield`) (language/concurrency)
URL: /silk/wiki/?p=language/concurrency
==============================================================================

# Concurrency (`async`, `task`, `await`, `yield`)

Silk concurrency is built around:

- `async fn` (pausable/awaitable concurrency),
- `task fn` (parallelizable work),
- `await` for promises, and
- `yield`/`yield *` for task values.


## Examples 

### `task` inside `async fn` + `yield *`

```silk
task fn worker (x: int) -> int {
  return x + 1;
}

async fn main () -> int {
  task {
    let a = worker(10);
    let values: int[] = yield * a;
    return values[0];
  }
}
```

### `Task(Promise(T))` composition: `await * yield *`

```silk
async fn add1 (x: int) -> int {
  return x + 1;
}

task fn produce_promises (n: int) -> Promise(int) {
  var i: int = 0;
  while i < n {
    yield add1(i);
    i = i + 1;
  }
  return add1(n);
}

async fn main () -> int {
  task {
    let t = produce_promises(3);
    let values: int[] = await * yield * t;
    return values[0];
  }
}
```

## See also

==============================================================================
WIKI: Const Functions (`const fn`) (language/const-functions)
URL: /silk/wiki/?p=language/const-functions
==============================================================================

# Const Functions (`const fn`)

`const fn` marks a function as eligible for **compile-time evaluation**.

This wiki page is an overview. The canonical specification is

## Example

```silk
const fn add (a: int, b: int) -> int {
  return a + b;
}

const answer: int = add(20, 22);

fn main () -> int {
  return answer;
}
```

## Notes ()

- Const functions are intended for `const` initializer evaluation.
- Const functions are compile-time-only: they are not callable from runtime
  code and are not emitted as runtime/linkable symbols.
- The  targets scalar-only const evaluation; `string`/aggregate
  return values and higher-order const evaluation are planned.
- In Silk, `const fn` bodies must not allocate (`new`) or use
  regions/`with`, must not contain `panic`, and may only call other `const fn`
  declarations.

## See also

==============================================================================
WIKI: Conventions (language/conventions)
URL: /silk/wiki/?p=language/conventions
==============================================================================

# Conventions

This page summarizes the conventions used throughout the Silk language docs:
notation, naming, and the “implementation status” pattern.


## Example: typical formatting in Silk docs

```silk
fn main () -> int {
  let x: int = 1;
  if x == 1 {
    return 0;
  }
  return 1;
}
```

## See also

==============================================================================
WIKI: Dependent types (const parameters) (design) (language/dependent-types)
URL: /silk/wiki/?p=language/dependent-types
==============================================================================

# Dependent types (const parameters) (design)

This page covers Silk’s intended support for types that mention compile-time
values (especially integers), such as dependent-length collections.


## Example (Design)

```silk
// Design-only sketch: a vector type with a compile-time length `N`.
struct VectorN(T, N: int) { /* ... */ }
```

## See also

==============================================================================
WIKI: Doc comments (language/doc-comments)
URL: /silk/wiki/?p=language/doc-comments
==============================================================================

# Doc comments

Silk supports both line and block doc comments. They attach to the following
declaration (like many C/Rust-style doc systems).


## Syntax

```silk
/// Line doc comment
fn main () -> int { return 0; }

/**
 * Block doc comment
 *
 * @example silk
 * fn main () -> int { return 0; }
 */
fn other () -> int { return 0; }
```

## See also

==============================================================================
WIKI: Duration literals (language/literals-duration)
URL: /silk/wiki/?p=language/literals-duration
==============================================================================

# Duration literals

Duration literals represent time spans with unit suffixes (`ms`, `s`, `min`,
etc) and produce a `Duration` value.


## Example 

```silk
fn main () -> int {
  let a: Duration = 10ms;
  let b: Duration = 2s;
  let c: Duration = a + b;
  if c > a { return 0; }
  return 1;
}
```

## See also

==============================================================================
WIKI: Enums (language/enums)
URL: /silk/wiki/?p=language/enums
==============================================================================

# Enums

`enum` defines a nominal sum type with a fixed set of variants.

In the current implementation, enums support:

- unit variants (`E::A`),
- tuple variants (`E::B(x)`),
- exhaustive `match` expressions over enum values (restricted subset; no guards).


## Syntax

```silk
enum Msg {
  Quit,
  Add(int),
}
```

## Examples

### Example: construct + match

```silk
enum Msg {
  Quit,
  Add(int),
}

fn main () -> int {
  let m: Msg = Msg::Add(5);
  return match m {
    Msg::Quit => 0,
    Msg::Add(n) => n,
  };
}
```

## See also

==============================================================================
WIKI: Errors and assertions (language/errors)
URL: /silk/wiki/?p=language/errors
==============================================================================

# Errors and assertions

Silk favors explicit, typed error modeling (optionals and `Result`-style return
shapes) and uses typed errors (`error`, `panic`, `T | ErrorType...`) for
unrecoverable logic bugs and contract violations.

This page focuses on assertions and the high-level model; see typed errors for
the full rules.


## Example: `assert`

```silk
fn main () -> int {
  assert (1 + 2) == 3;
  return 0;
}
```

## See also

==============================================================================
WIKI: Expression statements (language/flow-expression-statements)
URL: /silk/wiki/?p=language/flow-expression-statements
==============================================================================

# Expression statements

Many expressions can appear as standalone statements when followed by `;`
(assignment, calls, `++`/`--`, and other “statement-like” expressions).


## Example: assignment + increment

```silk
fn main () -> int {
  let mut x: int = 0;
  x += 1;
  ++x;
  return x;
}
```

## See also

==============================================================================
WIKI: External declarations (`ext`) (language/ext)
URL: /silk/wiki/?p=language/ext
==============================================================================

# External declarations (`ext`)

`ext` declares foreign symbols so Silk code can call C (or wasm imports) and
access foreign variables.


## Syntax

```silk
// C function named `puts`.
ext puts = fn (string) -> i32;

// Bind a different symbol name.
ext c_malloc "malloc" = fn (i64) -> u64;
ext c_free "free" = fn (u64) -> void;

// External variable.
ext errno = i32;
```

## Examples

### Example: call a C symbol

```silk
import std::io;

ext puts = fn (string) -> i32;

fn main () -> int {
  puts("hello from ext");
  std::io::println("ok");
  return 0;
}
```

### Example: opaque handle pattern (FFI-safe pointers)

```silk
struct Thing;

ext thing_new = fn () -> &Thing;
ext thing_free = fn (&Thing) -> void;

fn main () -> int {
  let t: &Thing = thing_new();
  thing_free(t);
  return 0;
}
```

## See also

==============================================================================
WIKI: Flow control overview (language/flow-overview)
URL: /silk/wiki/?p=language/flow-overview
==============================================================================

# Flow control overview

Silk has familiar structured control flow:

- branching: `if` / `else`
- loops: `while`, `for`, `loop`
- structured matching: `match`
- early exit: `break`, `continue`, `return`


## Example 

```silk
fn main () -> int {
  let mut sum: int = 0;

  for i in 0..5 {
    if i == 3 {
      continue;
    }
    sum += i;
  }

  if sum > 0 {
    return sum;
  }
  return 0;
}
```

## See also

==============================================================================
WIKI: Formal verification (Formal Silk) (language/formal-verification)
URL: /silk/wiki/?p=language/formal-verification
==============================================================================

# Formal verification (Formal Silk)

Silk includes syntax for writing contracts and verification metadata:

- `#require` / `#assure` for pre/postconditions
- `#assert` for local assertions
- `#invariant` / `#variant` / `#monovariant` for loops


## Example (Design / verifier-oriented)

```silk
#require x >= 0;
#assure result == x + 1;
fn inc (x: int) -> int {
  return x + 1;
}
```

## See also

==============================================================================
WIKI: Function disciplines (`pure`, `async`, `task`) (language/function-disciplines)
URL: /silk/wiki/?p=language/function-disciplines
==============================================================================

# Function disciplines (`pure`, `async`, `task`)

Function modifiers declare constraints and concurrency behavior:

- `pure fn` for side-effect-free functions (checker-enforced subset)
- `async fn` for promise-producing functions
- `task fn` for task-producing functions


## Examples 

```silk
pure fn add (x: int, y: int) -> int {
  return x + y;
}

task fn worker (x: int) -> int {
  return x + 1;
}
```

## See also

==============================================================================
WIKI: Generics (monomorphized) (language/generics)
URL: /silk/wiki/?p=language/generics
==============================================================================

# Generics (monomorphized)

Silk generics are compile-time and monomorphized: each applied type like
`Vector(int)` produces a concrete instantiation at build time (no runtime type
parameters).


## Syntax

```silk
struct Pair(T) {
  a: T,
  b: T,
}

impl Pair(T) {
  public fn first (self: &Pair(T)) -> T { return self.a; }
}
```

## Examples

### Example: generic struct + applied type

```silk
struct Pair(T) {
  a: T,
  b: T,
}

impl Pair(T) {
  public fn first (self: &Pair(T)) -> T { return self.a; }
}

fn main () -> int {
  let p: Pair(int) = { a: 1, b: 2 };
  return p.first();
}
```

## See also

==============================================================================
WIKI: Grammar (language/grammar)
URL: /silk/wiki/?p=language/grammar
==============================================================================

# Grammar

for Silk surface syntax.

This wiki page is a reading guide, not a replacement for the grammar itself.

## How to use the grammar

- Use the grammar when you need the exact token-level surface form.

## Example 

```silk
import std::io;

fn main () -> int {
  std::io::println("hello {s}", "world");
  return 0;
}
```

## See also

==============================================================================
WIKI: Interfaces (language/interfaces)
URL: /silk/wiki/?p=language/interfaces
==============================================================================

# Interfaces

Interfaces declare method signatures that types (or modules) can conform to via
`impl ... as ...` (or `module ... as ...`). This is the basis for protocol-like
surfaces such as iterators and Drop.


## Syntax

```silk
interface Len {
  fn len() -> i64;
}

struct Counter {
  n: i64,
}

impl Counter as Len {
  fn len (self: &Counter) -> i64 { return self.n; }
}
```

## Examples

### Example: conformance + direct method call

```silk
interface Len {
  fn len() -> i64;
}

struct Counter {
  n: i64,
}

impl Counter as Len {
  fn len (self: &Counter) -> i64 { return self.n; }
}

fn main () -> int {
  let c: Counter = Counter{ n: 3 };
  return c.len() as int;
}
```

## See also

==============================================================================
WIKI: Literals (language/literals-overview)
URL: /silk/wiki/?p=language/literals-overview
==============================================================================

# Literals

Literals are the simplest way to write values directly in source code:
numbers, booleans, chars, strings, durations, and aggregates like arrays and
struct literals.

This wiki page is a learning-oriented companion to the canonical spec:

## Syntax

```silk
let n: int = 42;
let pi: f64 = 3.14159;
let ok: bool = true;
let c: char = '\\n';
let s: string = "hello";

// Duration literals
let d: Duration = 10ms;

// Aggregates
let xs: int[3] = [1, 2, 3];
// let p: Point = Point{ x: 1, y: 2 };
```

## Examples

### Example: array literal + indexing

```silk
fn main () -> int {
  let xs: int[3] = [10, 20, 30];
  return xs[1];
}
```

### Example: strings and escapes

```silk
import std::io;

fn main () -> int {
  std::io::println("line1\\nline2");
  return 0;
}
```

## See also

==============================================================================
WIKI: Memory model (language/memory-model)
URL: /silk/wiki/?p=language/memory-model
==============================================================================

# Memory model

This page is a learning-oriented companion to the canonical memory model:

At a high level:

- Most values are plain, copyable scalars (or structs that lower to a fixed set
  of scalar slots in Silk).
- Heap allocation is introduced via `new`, producing `&Struct` references.
- `with` regions can redirect `new` allocations away from the heap (see regions).

## Example: `new` + reference field access

```silk
struct Point {
  x: int,
  y: int,
}

fn main () -> int {
  let p: &Point = new Point{ x: 1, y: 2 };
  return p.x + p.y;
}
```

## See also

==============================================================================
WIKI: Mutability (`mut`) (language/mutability)
URL: /silk/wiki/?p=language/mutability
==============================================================================

# Mutability (`mut`)

Silk is safe-by-default: bindings and borrows are immutable unless you opt in
to mutation.


## Syntax

```silk
let mut x: int = 0;
x += 1;

// Two-part mut borrow contract:
// - parameter declared `mut`, and
// - call site uses `mut <expr>`.
// fn bump(mut p: &Pair) -> void { ... }
// bump(mut pair);
```

## Example: mutable local + mutable borrow

```silk
struct Pair {
  a: int,
  b: int,
}

fn bump_a (mut p: &Pair) -> void {
  p.a += 1;
}

fn main () -> int {
  let mut p: Pair = Pair{ a: 1, b: 2 };
  bump_a(mut p);
  return p.a;
}
```

## See also

==============================================================================
WIKI: Numeric literals (language/literals-numeric)
URL: /silk/wiki/?p=language/literals-numeric
==============================================================================

# Numeric literals

Silk supports integer and floating-point literals, including base prefixes and
suffixes as defined in the canonical spec.


## Example 

```silk
fn main () -> int {
  let a: int = 42;
  let b: u64 = 0xff as u64;
  let c: f64 = 1.5;
  if a + (b as int) > 0 && c > 0.0 {
    return 0;
  }
  return 1;
}
```

## See also

==============================================================================
WIKI: Operators (language/operators)
URL: /silk/wiki/?p=language/operators
==============================================================================

# Operators

Silk’s operators cover arithmetic, comparisons, logical operators, assignment,
casts, ranges, optionals (`?.`, `??`), and typed-error propagation (`?`).

This wiki page is a learning-oriented companion to the canonical reference:

## Syntax

```silk
let a: int = 10;
let b: int = 3;

let sum: int = a + b;
let cmp: bool = a >= b;

// Optional chaining and coalescing
// let email: string = user.profile?.email ?? "no-email";

// Casts
let x: u64 = 123 as u64;

// Typed-error propagation
// let value: T = may_panic()?;
```

## Examples

### Example: arithmetic + comparisons

```silk
fn main () -> int {
  let a: int = 10;
  let b: int = 3;
  if a % b == 1 {
    return a + b; // 13
  }
  return 0;
}
```

### Example: `??` coalescing

```silk
fn main () -> int {
  let x: int? = None;
  return x ?? 42;
}
```

## See also

==============================================================================
WIKI: Optionals (`T?`) (language/optional)
URL: /silk/wiki/?p=language/optional
==============================================================================

# Optionals (`T?`)

Optionals represent “maybe a value” without sentinel `null`s.

- The nominal form is `Option(T)`.
- The idiomatic form is suffix `T?`.
- Values are `None` (empty) or `Some(value)` (present).
- Use `??` (coalescing), `?.` (optional field access), and `match` to consume
  optionals.


## Syntax

```silk
let a: int? = None;
let b: int? = Some(123);

let x: int = b ?? 0;
let y: int = match b {
  None => 0,
  Some(v) => v,
};
```

## Examples

### Example: `??` and `match`

```silk
fn main () -> int {
  let x: int? = Some(7);
  let y: int = x ?? 0;
  let z: int = match x {
    None => 1,
    Some(v) => v,
  };
  return y + z;
}
```

### Example: optional struct field access with `?.`

```silk
struct Profile {
  email: string,
}

struct User {
  profile: Profile?,
}

fn main () -> int {
  let u: User = User{ profile: Some(Profile{ email: "a@b" }) };
  let email: string = u.profile?.email ?? "no-email";
  if email == "a@b" {
    return 0;
  }
  return 1;
}
```

## See also

==============================================================================
WIKI: Packages, imports, and exports (language/packages-imports-exports)
URL: /silk/wiki/?p=language/packages-imports-exports
==============================================================================

# Packages, imports, and exports

Silk has explicit module/package structure:

- a source file may declare `package ...;` or header-form `module ...;` (mutually exclusive),
- imports come next as a contiguous block,
- then declarations (`fn`, `let`, `struct`, `enum`, `impl`, ...).

Silk supports both:

- package imports (`import std::io;`, `import ui;`), and
- file imports (`import { Name } from "./module.slk";`).


## Syntax

```silk
package my_app;

import std::io;
import { add } from "./math.slk";
import helpers from "./helpers.slk"; // default import / namespace import

export fn main () -> int { return 0; }
```

## Examples

### Example: named file import

```silk
// math.slk
package app;

export fn add (x: int, y: int) -> int {
  return x + y;
}
```

```silk
// main.slk
package app;

import { add } from "./math.slk";

fn main () -> int {
  return add(40, 2);
}
```

### Example: default export and default import

```silk
// module.slk
package module;

export default fn () -> int {
  return 1 + 2;
}
```

```silk
// main.slk
import foo from "./module.slk";

fn main () -> int {
  return foo();
}
```

## See also

==============================================================================
WIKI: Refinement types (design) (language/refinement-types)
URL: /silk/wiki/?p=language/refinement-types
==============================================================================

# Refinement types (design)

Refinement types are types annotated with logical predicates (`where`) that
constrain the set of values they may represent.


## Example (Design)

```silk
// Design-only sketch: a string that is proven non-empty.
type NonEmptyString = { s: string where std::length(s) > 0 };
```

## See also

==============================================================================
WIKI: Regions (`with`) (language/regions)
URL: /silk/wiki/?p=language/regions
==============================================================================

# Regions (`with`)

Regions provide a fixed-size, statically allocated backing store that can be
used as an allocation context for `new`.


## Syntax

```silk
const region arena: u8[1024];

with arena {
  // `new` allocations use `arena` as backing storage.
}
```

## Example 

```silk
struct Point {
  x: int,
  y: int,
}

fn main () -> int {
  const region arena: u8[1024];
  with arena {
    let p: &Point = new Point{ x: 1, y: 2 };
    return p.x + p.y;
  }
}
```

## See also

==============================================================================
WIKI: String literals (language/literals-string)
URL: /silk/wiki/?p=language/literals-string
==============================================================================

# String literals

`string` is Silk’s built-in UTF‑8 byte sequence type. String literals write a
`string` value directly in source code.


## Example: escapes

```silk
import std::io;

fn main () -> int {
  std::io::println("line1\\nline2");
  std::io::println("quote=\\\" backslash=\\\\");
  return 0;
}
```

## See also

==============================================================================
WIKI: Structs and `impl` (language/structs-impls-layout)
URL: /silk/wiki/?p=language/structs-impls-layout
==============================================================================

# Structs and `impl`

`struct` is Silk’s primary record type: named fields stored together as one
value. `impl` blocks attach methods (and special methods like `constructor`
and `drop`) to a type.


## Syntax

```silk
struct Point {
  x: int,
  y: int,
}

impl Point {
  public fn sum (self: &Point) -> int {
    return self.x + self.y;
  }
}
```

## Examples

### Example: struct literal + method call

```silk
struct Point {
  x: int,
  y: int,
}

impl Point {
  public fn add (self: &Point, other: Point) -> Point {
    return Point{
      x: self.x + other.x,
      y: self.y + other.y,
    };
  }
}

fn main () -> int {
  let p: Point = Point{ x: 1, y: 2 };
  let q: Point = Point{ x: 3, y: 4 };
  let r: Point = p.add(q);
  return r.x + r.y; // 10
}
```

## See also

==============================================================================
WIKI: Syntax tour (language/syntax-tour)
URL: /silk/wiki/?p=language/syntax-tour
==============================================================================

# Syntax tour

The canonical syntax tour is a soup-to-nuts walkthrough of Silk surface syntax,
with many examples and cross-links:


This wiki page keeps navigation self-contained and highlights where to look
next when you want precise rules.

## Example: minimal executable

```silk
fn main () -> int {
  return 0;
}
```

## See also

==============================================================================
WIKI: Testing (`test`) (language/testing)
URL: /silk/wiki/?p=language/testing
==============================================================================

# Testing (`test`)

Silk supports top-level `test` declarations that are discovered and executed by
`silk test`.


## Syntax

```silk
test "addition works" {
  if (1 + 2) != 3 {
    std::abort();
  }
}
```

## See also

==============================================================================
WIKI: Typed errors (`error`, `panic`, and `T | ErrorType...`) (language/typed-errors)
URL: /silk/wiki/?p=language/typed-errors
==============================================================================

# Typed errors (`error`, `panic`, and `T | ErrorType...`)

Typed errors make “this function can fail” explicit in the type system:

- define `error` types,
- declare error contracts in function return types (`T | MyError`),
- trigger errors with `panic MyError { ... };`,
- handle them with `match (expr) { ... }` (statement form + Terminal Arm Rule),
- and propagate them with the postfix `?` operator (`call()?`).


## Syntax

```silk
error OutOfBounds { index: int, len: int }

fn get_at (xs: &u8[], index: int) -> u8 | OutOfBounds {
  if index < 0 { panic OutOfBounds{ index: index, len: 0 }; }
  return 0;
}

fn caller (xs: &u8[]) -> u8 | OutOfBounds {
  let x: u8 = get_at(xs, 0)?;
  return x;
}
```

## Examples

### Example: `?` propagation

```silk
error Boom { code: int }

fn may_boom () -> int | Boom {
  panic Boom{ code: 7 };
}

fn main () -> int | Boom {
  let x: int = may_boom()?;
  return x;
}
```

### Example: handling with `match` statement

```silk
error Boom { code: int }

fn may_boom (x: int) -> int | Boom {
  if x == 0 {
    panic Boom{ code: 123 };
  }
  return 7;
}

fn main () -> int {
  match (may_boom(0)) {
    value => {
      return value;
    },
    err: Boom => {
      std::abort();
    },
  }
}
```

## See also

==============================================================================
WIKI: Types (language/types)
URL: /silk/wiki/?p=language/types
==============================================================================

# Types

Silk is a statically typed language with a small set of built-in primitive
types and first-class user-defined types (`struct`, `enum`, `interface`).

This wiki page is a learning-oriented companion to the canonical spec:

## Common Type Forms

```silk
// Primitives
let ok: bool = true;
let n: int = 42;
let x: f64 = 3.14;
let c: char = 'A';
let s: string = "hello";

// Optionals
let maybe: int? = None;

// References (borrows)
// (Receiver/borrow rules are in `docs/language/mutability.md`.)
// let r: &MyStruct = ...;

// Arrays and slices
let xs: int[3] = [1, 2, 3];
// let ys: int[] = ...;

// Function types + function values
type IntAdder = fn (int, int) -> int;
```

## Examples

### Example: function values with an explicit function type

```silk
type IntAdder = fn (int, int) -> int;

fn main () -> int {
  let add: IntAdder = fn (x: int, y: int) -> x + y;
  return add(40, 2);
}
```

### Example: arrays + `for` iteration

```silk
fn main () -> int {
  let xs: int[3] = [1, 2, 3];
  let mut sum: int = 0;
  for x in xs {
    sum += x;
  }
  return sum;
}
```

## See also

==============================================================================
WIKI: Varargs (`...args`) (language/varargs)
URL: /silk/wiki/?p=language/varargs
==============================================================================

# Varargs (`...args`)

Silk supports “varargs” parameters to accept a variable number of trailing
arguments, used by `std::io::print` / `std::io::println`.


## Syntax

```silk
fn log (fmt: string, ...args: std::fmt::Arg) -> void {
  std::io::println(fmt, args);
}
```

## Example 

```silk
import std::io;

fn main () -> int {
  std::io::println("hello {s} answer={d}", "world", 42);
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::` conventions (std/conventions)
URL: /silk/wiki/?p=std/conventions
==============================================================================

# `std::` conventions

`std::` modules follow shared conventions for naming, ownership/allocation, and
error reporting.


## Key conventions

- **Naming**: packages are `std::area`; types are `PascalCase`; functions/methods are `snake_case`.
- **Ownership**: allocating APIs return owned containers (for example `std::strings::String`) and callers drop them.
- **Errors**:
  - use `T?` for “absence” (`None`) without extra error information,
  - use typed errors (`T | SomeError`) for recoverable runtime errors with meaning,
  - use `std::result::Result(T, E)` when callers need to distinguish multiple error causes and propagate them cleanly.

## Examples

### Example: optionals + typed errors + dropping owned values

```silk
import std::process;
import std::strings;

fn main () -> int {
  // Optional: `T?` indicates a value may be absent.
  let missing: int? = None;
  let v: int = missing ?? 123;
  if v != 123 { return 1; }

  // Typed errors: handle `T | E` with `match`.
  let mut cwd: std::strings::String = std::strings::String.empty();
  match (std::process::getcwd()) {
    s => { cwd = s; },
    _: std::process::GetCwdFailed => { return 2; },
  }

  // Owned std values are explicitly dropped in the .
  (mut cwd).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::` package structure (std/package-structure)
URL: /silk/wiki/?p=std/package-structure
==============================================================================

# `std::` package structure

This page describes how `std::` modules are organized and how the compiler
finds and links them (including std-root selection and archive wiring).


## How `std::` resolves

- `std::foo::bar` resolves to `<std_root>/foo/bar.slk`.
- The std root can be overridden per build (CLI flags) or via environment variables.
- On supported hosted targets, a prebuilt std archive (`libsilk_std.a`) can be used to link std modules without recompiling them.

## Examples

### Example: import a std module

```silk
import std::io;
import std::strings;

fn main () -> int {
  if std::strings::eq("a", "a") {
    std::io::println("ok");
    return 0;
  }
  return 1;
}
```

### Build with a custom std root (CLI)

```bash
silk build main.slk
silk build --std-root ./my-stdlib main.slk
silk build --std-root ./my-stdlib --std-lib ./my-stdlib/libsilk_std.a main.slk
```

## See also

==============================================================================
WIKI: `std::algorithms` (std/algorithms)
URL: /silk/wiki/?p=std/algorithms
==============================================================================

# `std::algorithms`

`std::algorithms` provides common algorithms over collections. Today, a small
 exists for scalar types.


## Importing

```silk
import std::algorithms;
```

## Example: `clamp_int`

```silk
import std::algorithms;

fn main () -> int {
  if std::algorithms::clamp_int(10, 0, 5) != 5 { return 1; }
  if std::algorithms::clamp_int(-1, 0, 5) != 0 { return 2; }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::args` (std/args)
URL: /silk/wiki/?p=std/args
==============================================================================

# `std::args`

`std::args` provides helpers for working with the hosted
`main(argc, argv)` entrypoint shape.


## Example 

```silk
import args from "std/args";
import { println } from "std/io";

fn main (argc: int, argv: u64) -> int {
  let a = args::Args.init(argc, argv);
  if (a.count() != argc) {
    return 1;
  }
  if argc > 0 {
    println("argv[0]={}", a.get(0));
  }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::arrays` (std/arrays)
URL: /silk/wiki/?p=std/arrays
==============================================================================

# `std::arrays`

`std::arrays` defines borrowed views like `Slice(T)` and helpers for working
with fixed arrays and slices.


## Importing

```silk
import std::arrays;
```

## Examples

### Example: `Slice(T)` + `SliceIter(T)`

```silk
import std::arrays;
import std::buffer;

fn main () -> int {
  let mut buf: BufferU64 = BufferU64.init(4);
  (mut buf).push(10);
  (mut buf).push(11);
  (mut buf).push(12);

  let s: std::arrays::Slice(u64) = { ptr: buf.ptr, len: buf.len() };
  let mut it = s.iter();
  let mut sum: u64 = 0;
  while true {
    let v: u64? = (mut it).next();
    if v == None {
      break;
    }
    sum += (v ?? 0 as u64);
  }

  (mut buf).drop();
  if sum != 33 {
    return 1;
  }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::bits` (std/bits)
URL: /silk/wiki/?p=std/bits
==============================================================================

# `std::bits`

`std::bits` is the standard bit-manipulation and byte-order helper module.


## Supported behavior ()

Defined in `std/bits.slk`:

- Byte swaps:
  - `std::bits::bswap_u16`
  - `std::bits::bswap_u32`
  - `std::bits::bswap_u64`
- Rotations:
  - `std::bits::rotl_u32`, `std::bits::rotr_u32`
  - `std::bits::rotl_u64`, `std::bits::rotr_u64`
- Bit counts:
  - `std::bits::popcount_u32`, `std::bits::clz_u32`, `std::bits::ctz_u32`
  - `std::bits::popcount_u64`, `std::bits::clz_u64`, `std::bits::ctz_u64`

## Example

```silk
import std::bits;

fn main () -> int {
  let v: u32 = 1;
  let r: u32 = std::bits::rotl_u32(v, 5);
  if r != ((1 as u32) << 5) {
    return 1;
  }

  if std::bits::popcount_u32(r) != 1 {
    return 2;
  }

  return 0;
}
```

==============================================================================
WIKI: `std::buffer` (std/buffer)
URL: /silk/wiki/?p=std/buffer
==============================================================================

# `std::buffer`

In the in-tree stdlib, `std::buffer` provides a packed byte buffer
(`BufferU8`) plus width-oriented scalar buffer aliases built on
`std::vector::Vector(T)` (for example `BufferI32`).


## Importing

```silk
import std::buffer;
```

## Example: `BufferU8`

```silk
import std::buffer;

fn main () -> int {
  let b_r = BufferU8.init(4);
  if b_r.is_err() { return 1; }
  let mut b: BufferU8 = match (b_r) {
    Ok(v) => v,
    Err(_) => BufferU8.empty(),
  };
  (mut b).push(1 as u8);
  (mut b).push(2 as u8);
  if (mut b).pop() != Some(2 as u8) {
    (mut b).drop();
    return 1;
  }
  (mut b).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::crypto` (std/crypto)
URL: /silk/wiki/?p=std/crypto
==============================================================================

# `std::crypto`

`std::crypto` provides cryptography primitives (hosted baseline via libsodium
in the current design).


## Importing

```silk
import std::arrays;
import std::crypto;
import std::crypto::hash;
import std::buffer;
import std::runtime::mem;
```

## Examples

### Example: init + memzero + blake2b

```silk
import std::crypto;
import std::crypto::hash;
import std::buffer;
import std::runtime::mem;

fn main () -> int {
  if std::crypto::init() != None {
    return 1;
  }

  // memzero: wipe a buffer in place.
  let wipe_r = std::buffer::BufferU8.init(16);
  if wipe_r.is_err() { return 2; }
  let mut wipe: std::buffer::BufferU8 = match (wipe_r) {
    Ok(v) => v,
    Err(_) => std::buffer::BufferU8.empty(),
  };

  var i: i64 = 0;
  while i < 16 {
    (mut wipe).push(std::runtime::mem::trunc_u8(100 + (i as int)));
    i = i + 1;
  }

  let wipe_err: std::crypto::CryptoFailed? = std::crypto::memzero(wipe.as_bytes());
  if wipe_err != None {
    (mut wipe).drop();
    return 3;
  }

  var j: i64 = 0;
  while j < 16 {
    if wipe.get(j) != 0 {
      (mut wipe).drop();
      return 4;
    }
    j = j + 1;
  }
  (mut wipe).drop();

  // blake2b("abc") with digest_size=32.
  let msg: string = "abc";
  let msg_ptr: u64 = std::runtime::mem::string_ptr(msg);
  let msg_len: i64 = std::runtime::mem::string_len(msg);

  let out_r = std::buffer::BufferU8.init(32);
  let expected_r = std::buffer::BufferU8.init(32);
  if out_r.is_err() || expected_r.is_err() { return 2; }
  let mut out: std::buffer::BufferU8 = match (out_r) {
    Ok(v) => v,
    Err(_) => std::buffer::BufferU8.empty(),
  };
  let mut expected: std::buffer::BufferU8 = match (expected_r) {
    Ok(v) => v,
    Err(_) => std::buffer::BufferU8.empty(),
  };

  // Expected digest: bddd813c634239723171ef3fee98579b94964e3bb1cb3e427262c8c068d52319
  (mut expected).push(189);
  (mut expected).push(221);
  (mut expected).push(129);
  (mut expected).push(60);
  (mut expected).push(99);
  (mut expected).push(66);
  (mut expected).push(57);
  (mut expected).push(114);
  (mut expected).push(49);
  (mut expected).push(113);
  (mut expected).push(239);
  (mut expected).push(63);
  (mut expected).push(238);
  (mut expected).push(152);
  (mut expected).push(87);
  (mut expected).push(155);
  (mut expected).push(148);
  (mut expected).push(150);
  (mut expected).push(78);
  (mut expected).push(59);
  (mut expected).push(177);
  (mut expected).push(203);
  (mut expected).push(62);
  (mut expected).push(66);
  (mut expected).push(114);
  (mut expected).push(98);
  (mut expected).push(200);
  (mut expected).push(192);
  (mut expected).push(104);
  (mut expected).push(213);
  (mut expected).push(35);
  (mut expected).push(25);

  let hash_err: std::crypto::CryptoError? = std::crypto::hash::blake2b(
    mut out,
    32,
    std::arrays::ByteSlice{ ptr: msg_ptr, len: msg_len }
  );
  if hash_err != None {
    (mut out).drop();
    (mut expected).drop();
    return 6;
  }
  let eq_r: std::crypto::CryptoBoolResult = std::crypto::equal(out.as_bytes(), expected.as_bytes());
  let eq_opt: bool? = std::crypto::CryptoBoolResult.ok_value(eq_r);
  if eq_opt == None {
    (mut out).drop();
    (mut expected).drop();
    return 7;
  }
  if !(eq_opt ?? false) {
    (mut out).drop();
    (mut expected).drop();
    return 7;
  }

  (mut out).drop();
  (mut expected).drop();
  return 0;
}
```

## See also

- End-to-end fixtures:

==============================================================================
WIKI: `std::env` (std/env)
URL: /silk/wiki/?p=std/env
==============================================================================

# `std::env`

`std::env` provides access to process environment variables and common
directory helpers.


## Example: `get`

```silk
import std::env;
import { println } from "std/io";

fn main () -> int {
  let v_opt = std::env::get("HOME");
  match (v_opt) {
    Some(v) => println("HOME = {}", v),
    None => println("HOME is not set"),
  };
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::fmt` (std/fmt)
URL: /silk/wiki/?p=std/fmt
==============================================================================

# `std::fmt`

`std::fmt` defines the formatting model used by `std::io::print`/`println` and
by string-building helpers. It follows a Zig-`std.fmt`-style format-string
syntax.


## Examples

### Example: `println` formatting

```silk
import std::io;

fn main () -> int {
  std::io::println("name={s} ok={}", "silk", true);
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::formal` (std/formal)
URL: /silk/wiki/?p=std/formal
==============================================================================

# `std::formal`

`std::formal` provides reusable Formal Silk theories (“standard lemmas”) used
by stdlib code and downstream verified code.


## Importing

Theories are imported via file imports and applied with `#theory`:

```silk
import { nonnegative_i64, bounds_i64 } from "std/formal";
```

## Examples

### Example: applying standard theories

```silk
import { nonnegative_i64, bounds_i64 } from "std/formal";

#theory nonnegative_i64(len);
#theory bounds_i64(index, len);
fn get_at (index: i64, len: i64) -> i64 {
  return index;
}
```

## See also

==============================================================================
WIKI: `std::fs` (std/filesystem)
URL: /silk/wiki/?p=std/filesystem
==============================================================================

# `std::fs`

`std::fs` provides a small hosted POSIX-oriented filesystem API (
subset).


## Example: existence checks

```silk
import std::fs;

fn main () -> int {
  if !std::fs::exists("docs") { return 1; }
  if !std::fs::can_read("docs") { return 2; }
  if std::fs::exists("this_file_should_not_exist___silk_std_fs") { return 3; }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::interfaces` (std/interfaces)
URL: /silk/wiki/?p=std/interfaces
==============================================================================

# `std::interfaces`

`std::interfaces` defines shared std protocol interfaces such as `Drop`,
`Len`, and `Iterator(T)`.


## Example: `Iterator(T)` and `next() -> T?`

```silk
import std::interfaces;

struct CounterIter {
  cur: int,
  end: int,
}

impl CounterIter {
  public fn init (end: int) -> CounterIter {
    return { cur: 0, end: end };
  }
}

impl CounterIter as std::interfaces::Iterator(int) {
  public fn next (mut self: &CounterIter) -> int? {
    if self.cur >= self.end {
      return None;
    }
    let v: int = self.cur;
    self.cur = self.cur + 1;
    return Some(v);
  }
}
```

## See also

==============================================================================
WIKI: `std::io` (std/io)
URL: /silk/wiki/?p=std/io
==============================================================================

# `std::io`

`std::io` provides basic stdin/stdout/stderr I/O and a small formatting surface
(`print`/`println`).


## Importing

```silk
import std::io;
```

## Examples

### Example: formatted printing

```silk
import std::io;

fn main () -> int {
  std::io::println("hello {s} answer={d}", "world", 42);
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::json` (std/json)
URL: /silk/wiki/?p=std/json
==============================================================================

# `std::json`

`std::json` provides JSON parsing and stringifying (initial implementation + expanded
subset).


## Importing

```silk
import std::json;
import std::strings;
```

## API

- `Document.parse(input: string) -> std::json::ParseResult` (borrowed views into `input`)
- `Document.parse_owned(input: string) -> std::json::ParseResult` (owned copies)
- `Document.object_get(obj: i64, key: string) -> i64?`
- `Document.as_string(id: i64) -> string?`
- `Document.as_number_lexeme(id: i64) -> string?`
- `std::json::number_as_i64(doc: &Document, id: i64) -> i64?`
- `std::json::stringify(doc: &Document, id: i64) -> std::result::Result(std::strings::String, std::memory::OutOfMemory)`
- `std::json::stringify_pretty(doc: &Document, id: i64, indent: int) -> std::result::Result(std::strings::String, std::memory::OutOfMemory)`

## Examples

### Example: parse + query + stringify

```silk
import std::json;
import std::strings;
import std::result;
import std::memory;

type StringAllocResult = std::result::Result(std::strings::String, std::memory::OutOfMemory);

fn main () -> int {
  let mut doc: Document = Document{};
  let input: string = `{"a":1,"b":true,"c":null,"d":["x","y"],"u":"\u0041"}`;

  let root_r: std::json::ParseResult = (mut doc).parse(input);
  if root_r.is_err() {
    (mut doc).drop();
    return 1;
  }
  if !doc.is_ok() {
    (mut doc).drop();
    return 2;
  }

  let root: i64 = match (root_r) {
    Ok(v) => v,
    Err(_) => 0 as i64,
  };

  let u_id_opt = doc.object_get(root, "u");
  if u_id_opt == None {
    (mut doc).drop();
    return 3;
  }
  let u_id: i64 = u_id_opt ?? 0 as i64;
  let u_opt = doc.as_string(u_id);
  if u_opt == None {
    (mut doc).drop();
    return 4;
  }
  if (u_opt ?? "") != "A" {
    (mut doc).drop();
    return 5;
  }

  let a_id_opt = doc.object_get(root, "a");
  if a_id_opt == None {
    (mut doc).drop();
    return 6;
  }
  let a_id: i64 = a_id_opt ?? 0 as i64;
  let a_num_opt = std::json::number_as_i64(doc, a_id);
  if a_num_opt == None {
    (mut doc).drop();
    return 7;
  }
  if (a_num_opt ?? 0 as i64) != 1 {
    (mut doc).drop();
    return 8;
  }

  let compact_r: StringAllocResult = std::json::stringify(doc, root);
  if compact_r.is_err() {
    (mut doc).drop();
    return 9;
  }
  let mut compact: std::strings::String = match (compact_r) {
    StringAllocResult::Ok(v) => v,
    StringAllocResult::Err(_) => std::strings::String.empty(),
  };
  let expected: string = `{"a":1,"b":true,"c":null,"d":["x","y"],"u":"A"}`;
  if compact.as_string() != expected {
    (mut compact).drop();
    (mut doc).drop();
    return 10;
  }

  (mut compact).drop();
  (mut doc).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::map` (std/map)
URL: /silk/wiki/?p=std/map
==============================================================================

# `std::map`

`std::map` provides associative containers:

- `HashMap(K, V)` (unordered, hash table),
- `TreeMap(K, V)` (ordered, red-black tree).


## Importing

```silk
import std::map;
```

## Examples

### Example: `HashMap(u64, int)` basic usage

```silk
import std::map;
import std::result;
import std::memory;

type Map = std::map::HashMap(u64, int);
type InitResult = std::result::Result(Map, std::memory::AllocFailed);

fn hash_u64 (k: u64) -> u64 { return k; }
fn eq_u64 (a: u64, b: u64) -> bool { return a == b; }

fn main () -> int {
  let init_r: InitResult = Map.init(16, hash_u64, eq_u64);
  if init_r.is_err() { return 2; }
  let mut m: Map = match (init_r) {
    InitResult::Ok(v) => v,
    InitResult::Err(_) => Map.empty(hash_u64, eq_u64),
  };
  (mut m).put(1, 10);
  let v: int = m.get(1) ?? 0;
  (mut m).drop();
  return v;
}
```

## See also

==============================================================================
WIKI: `std::memory` (std/memory)
URL: /silk/wiki/?p=std/memory
==============================================================================

# `std::memory`

`std::memory` provides low-level helpers and the long-term allocator design.


## Importing

```silk
import std::memory;
```

## Example: alignment helpers

```silk
import std::memory;

fn main () -> int {
  if !std::memory::is_power_of_two_u64(8) { return 1; }
  if std::memory::align_up_u64(9, 8) != 16 { return 2; }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::net` (std/networking)
URL: /silk/wiki/?p=std/networking
==============================================================================

# `std::net`

`std::net` provides networking primitives (hosted POSIX baseline).


## Example: IPv4 helpers

```silk
import std::net;

fn main () -> int {
  let a = ipv4(127, 0, 0, 1);
  if !ipv4_is_loopback(a) { return 1; }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::path` (std/path)
URL: /silk/wiki/?p=std/path
==============================================================================

# `std::path`

`std::path` provides path manipulation helpers.


## Importing

```silk
import std::path;
import std::strings;
```

## Examples

### Example: normalize + `PathBuf`

```silk
import std::path;
import std::strings;

fn main () -> int {
  let mut n: std::strings::String = std::path::normalize("/a//b/");
  if n.as_string() != "/a/b" {
    (mut n).drop();
    return 1;
  }
  (mut n).drop();

  let mut pb: std::path::PathBuf = std::path::PathBuf.empty();
  (mut pb).push("a");
  (mut pb).push("b");
  if pb.as_string() != "a/b" {
    (mut pb).drop();
    return 2;
  }
  if !(mut pb).pop() {
    (mut pb).drop();
    return 3;
  }
  if pb.as_string() != "a" {
    (mut pb).drop();
    return 4;
  }

  (mut pb).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::process` (std/process)
URL: /silk/wiki/?p=std/process
==============================================================================

# `std::process`

`std::process` provides process-oriented primitives (hosted baseline).


## Importing

```silk
import std::process;
import std::strings;
```

## Examples

### Example: `getcwd` + `chdir` with recoverable errors

```silk
import std::process;
import std::strings;

fn main () -> int {
  let cwd_r: std::process::GetCwdResult = std::process::getcwd();
  if cwd_r.is_err() {
    return 1;
  }
  let mut cwd: std::strings::String = match (cwd_r) {
    std::process::GetCwdResult::Ok(v) => v,
    std::process::GetCwdResult::Err(_) => std::strings::String.empty(),
  };

  let err1: std::process::ChdirFailed? = std::process::chdir("/");
  if err1 != None {
    (mut cwd).drop();
    return 2;
  }

  let err2: std::process::ChdirFailed? = std::process::chdir(cwd.as_string());
  if err2 != None {
    (mut cwd).drop();
    return 3;
  }

  (mut cwd).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::result` (std/result)
URL: /silk/wiki/?p=std/result
==============================================================================

# `std::result`

`std::result` standardizes the common “success or error” return shape as
`Result(T, E)` so APIs across `std::` compose cleanly.


## Importing

```silk
import std::result;
```

## Examples

### Example: create and inspect a `Result`

```silk
import std::result;

type R = std::result::Result(int, string);

fn main () -> int {
  let x: R = R.ok(123);
  if x.is_err() { return 1; }
  if R.unwrap_or(x, 0) != 123 { return 2; }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::runtime` (std/runtime)
URL: /silk/wiki/?p=std/runtime
==============================================================================

# `std::runtime`

`std::runtime` is the interface layer that isolates OS/environment-specific
primitives (I/O, filesystem, time, threads, allocation) from higher-level
`std::...` modules.


## Importing

```silk
import std::runtime::build;
import std::runtime::mem;
```

## Examples

### Example: build metadata + raw memory

```silk
import std::runtime::build;
import std::runtime::mem;

fn main () -> int {
  // This reports whether the current artifact was built with `--debug` / `-g`.
  if std::runtime::build::is_debug() {
    return 1;
  }

  // `std::runtime::mem` provides low-level allocation and raw load/store.
  let ptr: u64 = std::runtime::mem::alloc(4);
  if ptr == 0 { return 2; }

  std::runtime::mem::store_u8(ptr, 0, std::runtime::mem::trunc_u8(65));
  std::runtime::mem::store_u8(ptr, 1, std::runtime::mem::trunc_u8(66));

  if std::runtime::mem::load_u8(ptr, 0) != 65 {
    std::runtime::mem::free(ptr);
    return 3;
  }

  std::runtime::mem::free(ptr);
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::semver` (std/semver)
URL: /silk/wiki/?p=std/semver
==============================================================================

# `std::semver`

`std::semver` implements Semantic Versioning (SemVer 2.0.0):

- strict parsing of `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`
- SemVer precedence comparison (build metadata is ignored)


## Quick example

```silk
import std::semver;

fn main () -> int {
  let r = std::semver::parse("1.2.3-alpha.1+build.5");
  if r.is_err() { return 1; }
  let v: std::semver::Version = match (r) {
    Ok(v) => v,
    Err(_) => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None },
  };

  // Precedence comparison ignores build metadata.
  let ar = std::semver::parse("1.0.0-alpha");
  let br = std::semver::parse("1.0.0");
  if ar.is_err() { return 2; }
  if br.is_err() { return 3; }
  let a: std::semver::Version = match (ar) { Ok(v) => v, Err(_) => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None } };
  let b: std::semver::Version = match (br) { Ok(v) => v, Err(_) => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None } };
  if a.cmp(b) >= 0 { return 4; }

  return 0;
}
```

==============================================================================
WIKI: `std::set` (std/set)
URL: /silk/wiki/?p=std/set
==============================================================================

# `std::set`

`std::set` provides set containers:

- `SetMap(T)` (unordered set, open addressing),
- `TreeSet(T)` (ordered set, red-black tree).


## Importing

```silk
import std::set;
```

## Examples

### Example: `SetMap(u64)` basic usage

```silk
import std::set;
import std::result;
import std::memory;

type Set = std::set::SetMap(u64);
type InitResult = std::result::Result(Set, std::memory::AllocFailed);
type InsertResult = std::result::Result(bool, std::memory::OutOfMemory);

fn hash_u64 (k: u64) -> u64 { return k; }
fn eq_u64 (a: u64, b: u64) -> bool { return a == b; }

fn main () -> int {
  let init_r: InitResult = Set.init(4, hash_u64, eq_u64);
  if init_r.is_err() { return 1; }
  let mut s: Set = match (init_r) {
    InitResult::Ok(v) => v,
    InitResult::Err(_) => Set.empty(hash_u64, eq_u64),
  };

  let insert_r: InsertResult = (mut s).insert(1);
  if insert_r.is_err() { (mut s).drop(); return 2; }
  let ok: bool = s.contains(1);
  (mut s).drop();
  if ok { return 0; }
  return 1;
}
```

## See also

==============================================================================
WIKI: `std::strings` (std/strings)
URL: /silk/wiki/?p=std/strings
==============================================================================

# `std::strings`

`std::strings` provides utilities and types built on top of the core `string`
type (UTF‑8 bytes), including simple comparisons and owned
string construction.


## Importing

```silk
import std::strings;
```

## API

```silk
module std::strings;

export fn eq (a: string, b: string) -> bool;
export fn is_empty (s: string) -> bool;
export fn or_empty (s: string?) -> string;
```

## Examples

### Example: equality + optionals

```silk
import std::strings;

fn main () -> int {
  let a: string = "hi";
  let b: string? = None;

  if std::strings::eq(a, "hi") && std::strings::is_empty(std::strings::or_empty(b)) {
    return 0;
  }
  return 1;
}
```

## See also

==============================================================================
WIKI: `std::sync` (std/sync)
URL: /silk/wiki/?p=std/sync
==============================================================================

# `std::sync`

`std::sync` provides synchronization primitives (hosted baseline).


## Importing

```silk
import std::sync;
```

## Examples

### Example: `Channel(u64)` across `task`s

```silk
import sync from "std/sync";

type ChanU64 = sync::Channel(u64);

task fn producer (c: sync::ChannelBorrow(u64)) -> int {
  let err: sync::SyncFailed? = c.send(42);
  if err != None { return 10; }
  return 0;
}

async fn main () -> int {
  task {
    let c_r = ChanU64.init(1);
    if c_r.is_err() {
      return 100;
    }
    let mut c: ChanU64 = match (c_r) {
      Ok(v) => v,
      Err(_) => ChanU64.invalid(),
    };

    let h = producer(c.borrow());

    let v1: u64 = (c.recv() ?? 0);
    c.close();
    let v2: u64 = (c.recv() ?? 99);

    let rc_values: int[] = yield * h;
    let rc: int = rc_values[0];
    (mut c).destroy();

    if rc != 0 { return 11; }
    if v1 != 42 { return 1; }
    if v2 != 99 { return 2; }
    return 0;
  }
}
```

## See also

- End-to-end fixtures:

==============================================================================
WIKI: `std::task` (std/task)
URL: /silk/wiki/?p=std/task
==============================================================================

# `std::task`

`std::task` provides hosted task/runtime helpers, including sleep/yield
operations.


## Example 

```silk
import std::task;

fn main () -> int {
  let n: int = available_parallelism();
  yield_now();
  sleep_ms(0);
  if n < 1 { return 1; }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::temporal` (std/temporal)
URL: /silk/wiki/?p=std/temporal
==============================================================================

# `std::temporal`

`std::temporal` provides `Instant`/`Duration` helpers and time-related
utilities.


## Example 

```silk
import std::temporal;

fn main () -> int {
  let z: Duration = std::temporal::duration_zero();
  if !std::temporal::is_zero(z) { return 1; }
  if std::temporal::is_negative(1s) { return 2; }
  if !std::temporal::is_negative(-1s) { return 3; }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::tls` (std/tls)
URL: /silk/wiki/?p=std/tls
==============================================================================

# `std::tls`

`std::tls` provides TLS client/server primitives (hosted baseline via mbedTLS).


## Importing

```silk
import std::tls;
```

## Examples

### Example: in-memory client/server handshake (MemPipe)

This example uses `MemPipe` so it does not require sockets. It is kept runnable

```silk
import mem from "std/runtime/mem.slk";
import std::arrays;
import std::tls;

fn test_cert () -> string {
  return `-----BEGIN CERTIFICATE-----
MIIDCTCCAfGgAwIBAgIUZGlB8Eq9CXntm2xyJOT1X1eNCjMwDQYJKoZIhvcNAQEL
BQAwFDESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTI2MDEwMzAyMDUyM1oXDTM2MDEw
MTAyMDUyM1owFDESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEF
AAOCAQ8AMIIBCgKCAQEA0RvQxOWGAe2a4qh9/lUFpIeEOdQFKrGf569AwPwAbcLo
/Ah9/wBSXzXL/jCy8ofemWS7HmP94Ikm11zJxjOeufXCbGS+X+M2OrhRYJDx5CCv
FwjZsSpNjTkW/weDr9ysVgTdsuOEVnnHnTVXiO2urKSVwPgkDS9xJjorx8tsBQLk
R/w2GgmNQ+7tp7BD8HmXFSKw+ysCyK4p3s4+UZj8y2ieoEB/wJtEGKh6boYNR4o3
c2tb/pSV0ADB1BijLgiIa/UTejC3vyYNzi9j0vt4lntjsLcBWASdGT++0EX1IBR9
KQtoTvRrdp7Yima383+0Wp7WYa3XLMcpZuZPmD5OyQIDAQABo1MwUTAdBgNVHQ4E
FgQUNBuK6PDKUMNJUvuJzAdki6AztyIwHwYDVR0jBBgwFoAUNBuK6PDKUMNJUvuJ
zAdki6AztyIwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAqcHO
Cfik6/WU/VysILwfO+27xAryD/xcTTT5WWIAKAH7d7Hmg9OyyLe7AZ0hog2rhLzW
+LYzQK8glzKoblXe+h8Mukel84DMzCJHdJAfdNKftf1gg+pxUP7Bg6MyJqBXo6gd
UN2jRsbYhxNPlIECJk/vYuDgi9i+k43+At/CHClZjx9dOmx4Nv8kK9r6aOlI6Vms
y4hZQtsSHGmUJs8T57aW3TKW0mFs/jUAISkeLBoBO84tu7Gzu+QeFGYAgHWR8wp2
4H5eSv3/R0eBaHUM9riHaS6wF+9cF+vZFzRgWHaCHpVghIpQhpQTD+RdO8mdVmi5
4qqkcIeXp+6Zggtv9w==
-----END CERTIFICATE-----
`;
}

fn test_key () -> string {
  return `-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDRG9DE5YYB7Zri
qH3+VQWkh4Q51AUqsZ/nr0DA/ABtwuj8CH3/AFJfNcv+MLLyh96ZZLseY/3giSbX
XMnGM5659cJsZL5f4zY6uFFgkPHkIK8XCNmxKk2NORb/B4Ov3KxWBN2y44RWeced
NVeI7a6spJXA+CQNL3EmOivHy2wFAuRH/DYaCY1D7u2nsEPweZcVIrD7KwLIrine
zj5RmPzLaJ6gQH/Am0QYqHpuhg1Hijdza1v+lJXQAMHUGKMuCIhr9RN6MLe/Jg3O
L2PS+3iWe2OwtwFYBJ0ZP77QRfUgFH0pC2hO9Gt2ntiKZrfzf7RantZhrdcsxylm
5k+YPk7JAgMBAAECggEABBHaBNMAwi3ZK1sjJJ2MABFBIgz90sBlP9GZ3YeqDHjU
Jv+VUC6167N01mwlN3Isg2jB+Yvxp3qT3nIoXSqpBq6BS7HEQMJ/zjHDJ7F6e7ml
Hrol3nxXyQ1Y5LrFNdmCIyRyGiaybypsl6MvonMZyLNlVL2fmgAX4CoWqwtK/Wfx
dwssGbrlr3QvGM6aTBEDDY/xCwSvkZ5l0ImGq1Fuk61rkwnFysRNlzuOwcbAjDoM
Qd+fjRKWfCltnHJdc1BxnyTTuzuc9rR7ZCEaoe4xgG9A1YIrXdA89CPHP3hC9nmr
uTxjJ/fT5xir0p4FBjeImDiyhfMFrARTGexVLx8MpwKBgQDVDXotnEkYPFFyMvWD
nxtT+9pesJpnqF0LGFm1Un9Fgjg7so41P5nJVsO/vSKXDAOG1UT5wAmDVtGSmAre
Zaopy/OWm5QsFUzTet5sALF0j8whIiy2epVGd1Om4ndmWUOrKapq5ZwfR5UW4tei
6xI57YdA9v/N+6Im7DwVAQ4IRwKBgQD7Qs9GoROQ9S0tYh/JHWx8/MiNGycEb4CA
B7dt1QhGkVff+fhfEX6l5uTU6xbtjmX6ZJJHNcjgv6Y/ngC+UvohSrdaIq6R0k03
ZJPzf9WFDdvc8n2sT52MJSMb/lz4zU/TuOiwROuKhJ/M1g3MoY3uFOx7smxHzeV2
b/DBX6WIbwKBgGk4mcHS8OquR48+CbEysD1/Ii8ny2osZZ9oLE3363F5yan6Gm/D
9IDSgCS/FUlCHq/FvqYWKNyb0S80NhH2Zd70ol4cgkZvUp0TjqwKf5nQtwEaLrkE
u5qsrjy6ljuPFHOBRXA77CoqoUBHUjZdIIhJfkYgdt/VShUtENNSzQpbAoGAJY9+
Ntu7dg8AuukRQVpRrnmHbXiio4oblogQxq1y+EGf9k6C74tI+HoEuUOPgOGpov3H
1DdZGSftLVNsXwc+dx2ZPTM0D351ppM1ftAcVjCVLnldihW4wouGrRegRF1E0qyw
tDEJWQKsdM2G8JEyC2Y7V957S1yfMc5YGkA3GacCgYEAuTfYz3IY6lIWGd0eDijU
ElDm/6m2Eb8JcH9F+fayYJ5ebQQgsrvNQXpFI4y0Z01X/l/OtYYgUeO1vDKWVzOp
6Jq1125v1+I7+Fce5KVj56oWiirFHqGXqGJK104sGOSTCjXy7pyZGoVCpplqWabN
GSDCV/JoUBg4iPwQ0rK0Tlo=
-----END PRIVATE KEY-----
`;
}

fn drive_handshake (mut client: &Session, mut server: &Session) -> bool {
  var client_done: bool = false;
  var server_done: bool = false;

  var steps: int = 0;
  while steps < 100000 {
    steps += 1;

    if !client_done {
      let rc = client.handshake_step();
      if rc == 0 {
        client_done = true;
      } else {
        if rc != ERR_WANT_READ && rc != ERR_WANT_WRITE {
          return false;
        }
      }
    }

    if !server_done {
      let rc = server.handshake_step();
      if rc == 0 {
        server_done = true;
      } else {
        if rc != ERR_WANT_READ && rc != ERR_WANT_WRITE {
          return false;
        }
      }
    }

    if client_done && server_done {
      return true;
    }
  }

  return false;
}

fn read_some (mut sess: &Session, ptr: u64, cap: u64) -> i32 {
  var tries: int = 0;
  while tries < 100000 {
    tries += 1;
    let rc = sess.read(std::arrays::ByteSlice{ ptr: ptr, len: cap as i64 });
    if rc > 0 {
      return rc;
    }
    if rc == ERR_WANT_READ || rc == ERR_WANT_WRITE {
      continue;
    }
    return rc;
  }
  return -1 as i32;
}

fn main () -> int {
  var pipe = MemPipe.init(65536);
  if !pipe.is_valid() {
    return 1;
  }

  var client: Session = Session.client() ?? Session.invalid();
  if !client.is_valid() {
    (mut pipe).drop();
    return 2;
  }

  var server: Session = Session.server(test_cert(), test_key()) ?? Session.invalid();
  if !server.is_valid() {
    (mut client).drop();
    (mut pipe).drop();
    return 3;
  }

  client.set_bio_mempipe(pipe.client_ctx());
  server.set_bio_mempipe(pipe.server_ctx());

  if !drive_handshake(mut client, mut server) {
    (mut server).drop();
    (mut client).drop();
    (mut pipe).drop();
    return 4;
  }

  if !client.write_string("ping") {
    (mut server).drop();
    (mut client).drop();
    (mut pipe).drop();
    return 5;
  }

  let buf_ptr = mem::alloc(64);
  if buf_ptr == 0 {
    (mut server).drop();
    (mut client).drop();
    (mut pipe).drop();
    return 6;
  }

  let n = read_some(mut server, buf_ptr, 64);
  if n <= 0 {
    mem::free(buf_ptr);
    (mut server).drop();
    (mut client).drop();
    (mut pipe).drop();
    return 7;
  }

  let got = mem::string_from_ptr_len(buf_ptr, n as int);
  if got != "ping" {
    mem::free(buf_ptr);
    (mut server).drop();
    (mut client).drop();
    (mut pipe).drop();
    return 8;
  }

  if !server.write_string("pong") {
    mem::free(buf_ptr);
    (mut server).drop();
    (mut client).drop();
    (mut pipe).drop();
    return 9;
  }

  let n2 = read_some(mut client, buf_ptr, 64);
  if n2 <= 0 {
    mem::free(buf_ptr);
    (mut server).drop();
    (mut client).drop();
    (mut pipe).drop();
    return 10;
  }

  let got2 = mem::string_from_ptr_len(buf_ptr, n2 as int);
  if got2 != "pong" {
    mem::free(buf_ptr);
    (mut server).drop();
    (mut client).drop();
    (mut pipe).drop();
    return 11;
  }

  mem::free(buf_ptr);
  (mut server).drop();
  (mut client).drop();
  (mut pipe).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::toml` (std/toml)
URL: /silk/wiki/?p=std/toml
==============================================================================

# `std::toml`

`std::toml` provides TOML parsing (initial implementation + expanded subset).


## Importing

```silk
import std::toml;
```

## API

- `Document.parse(input: string) -> std::toml::ParseResult` (borrowed views into `input`)
- `Document.parse_owned(input: string) -> std::toml::ParseResult` (owned copies)
- `Document.table_get(table: i64, key: string) -> i64?`
- `Document.as_string(id: i64) -> string?`
- `std::toml::int_as_i64(doc: &Document, id: i64) -> i64?`

## Examples

### Example: parse + query

```silk
import std::toml;

fn main () -> int {
  let mut doc: Document = Document{};
  let input: string = `title = "TOML Example"
answer = 42
`;

  let root_r: std::toml::ParseResult = (mut doc).parse(input);
  if root_r.is_err() {
    (mut doc).drop();
    return 1;
  }
  if !doc.is_ok() {
    (mut doc).drop();
    return 2;
  }
  let root: i64 = match (root_r) {
    Ok(v) => v,
    Err(_) => 0 as i64,
  };

  let title_id_opt = doc.table_get(root, "title");
  if title_id_opt == None {
    (mut doc).drop();
    return 3;
  }
  let title_id: i64 = title_id_opt ?? 0 as i64;
  let title_opt = doc.as_string(title_id);
  if title_opt == None {
    (mut doc).drop();
    return 4;
  }
  if (title_opt ?? "") != "TOML Example" {
    (mut doc).drop();
    return 5;
  }

  let answer_id_opt = doc.table_get(root, "answer");
  if answer_id_opt == None {
    (mut doc).drop();
    return 6;
  }
  let answer_id: i64 = answer_id_opt ?? 0 as i64;
  let answer_opt = std::toml::int_as_i64(doc, answer_id);
  if answer_opt == None {
    (mut doc).drop();
    return 7;
  }
  if (answer_opt ?? 0 as i64) != 42 {
    (mut doc).drop();
    return 8;
  }

  (mut doc).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::url` (std/url)
URL: /silk/wiki/?p=std/url
==============================================================================

# `std::url`

`std::url` provides a WHATWG URL parser/serializer and `URLSearchParams`-style
behavior.


## Importing

```silk
import std::url;
import std::strings;
```

## API

- `std::url::parse(input: string) -> URLResult`
- `std::url::parse_with_base(input: string, base: &URL) -> URLResult`
- `URL.href() -> std::result::Result(std::strings::String, std::memory::OutOfMemory)`
- `URL.origin() -> std::result::Result(std::strings::String, std::memory::OutOfMemory)`
- `URLSearchParams.from_string(s: string) -> std::result::Result(URLSearchParams, std::memory::OutOfMemory)`
- `URLSearchParams.to_string() -> std::result::Result(std::strings::String, std::memory::OutOfMemory)`
- `URLSearchParams.has(name: string) -> std::result::Result(bool, std::memory::OutOfMemory)`
- `URLSearchParams.get(name: string) -> std::result::Result(std::strings::String?, std::memory::OutOfMemory)`
- `URLSearchParams.append/delete/set/sort -> std::memory::OutOfMemory?`

## Examples

### Example: parse + resolve + query params

```silk
import std::url;
import std::strings;

fn dummy_url () -> URL {
  return URL{
    scheme: std::strings::String.empty(),
    username: std::strings::String.empty(),
    password: std::strings::String.empty(),
    host_kind: 0,
    host_str: std::strings::String.empty(),
    ipv4: 0,
    ipv6_s0: 0,
    ipv6_s1: 0,
    ipv6_s2: 0,
    ipv6_s3: 0,
    ipv6_s4: 0,
    ipv6_s5: 0,
    ipv6_s6: 0,
    ipv6_s7: 0,
    port: None,
    path: std::strings::String.empty(),
    query: std::strings::String.empty(),
    has_query: false,
    fragment: std::strings::String.empty(),
    has_fragment: false,
    cannot_be_a_base: false,
  };
}

fn main () -> int {
  let abs: URLResult = std::url::parse("https://example.com:443/a/./b/../c?x=1#frag");
  if abs.value == None { return 1; }

  let mut url: URL = abs.value ?? dummy_url();
  let mut href_r = url.href();
  if href_r.err != None {
    (mut url).drop();
    return 2;
  }
  href_r.err = None;
  let mut href: std::strings::String = href_r.value ?? std::strings::String.empty();
  href_r.value = None;
  if href.as_string() != "https://example.com/a/c?x=1#frag" {
    (mut href).drop();
    (mut url).drop();
    return 2;
  }
  (mut href).drop();

  let base_res: URLResult = std::url::parse("https://example.com/dir/file");
  if base_res.value == None {
    (mut url).drop();
    return 3;
  }
  let mut base: URL = base_res.value ?? dummy_url();
  let rel_res: URLResult = std::url::parse_with_base("../x?y=z", base);
  (mut base).drop();
  if rel_res.value == None {
    (mut url).drop();
    return 4;
  }

  let mut rel: URL = rel_res.value ?? dummy_url();
  let mut href2_r = rel.href();
  if href2_r.err != None {
    (mut rel).drop();
    (mut url).drop();
    return 5;
  }
  href2_r.err = None;
  let mut href2: std::strings::String = href2_r.value ?? std::strings::String.empty();
  href2_r.value = None;
  if href2.as_string() != "https://example.com/x?y=z" {
    (mut href2).drop();
    (mut rel).drop();
    (mut url).drop();
    return 5;
  }
  (mut href2).drop();
  (mut rel).drop();

  let mut params_r = URLSearchParams.from_string("?a=b%20c&d=e");
  if params_r.err != None {
    (mut url).drop();
    return 6;
  }
  params_r.err = None;
  let mut params: URLSearchParams = params_r.value ?? URLSearchParams.empty();
  params_r.value = None;

  let mut qs_r = params.to_string();
  if qs_r.err != None {
    (mut params).drop();
    (mut url).drop();
    return 6;
  }
  qs_r.err = None;
  let mut qs: std::strings::String = qs_r.value ?? std::strings::String.empty();
  qs_r.value = None;
  if qs.as_string() != "a=b+c&d=e" {
    (mut qs).drop();
    (mut params).drop();
    (mut url).drop();
    return 6;
  }
  (mut qs).drop();

  let mut v_r = params.get("a");
  if v_r.err != None {
    (mut params).drop();
    (mut url).drop();
    return 7;
  }
  v_r.err = None;
  let mut v_opt: std::strings::String? = v_r.value ?? None;
  v_r.value = None;
  if v_opt == None {
    (mut params).drop();
    (mut url).drop();
    return 7;
  }

  let mut v: std::strings::String = v_opt ?? std::strings::String.empty();
  v_opt = None;
  if v.as_string() != "b c" {
    (mut v).drop();
    (mut params).drop();
    (mut url).drop();
    return 8;
  }
  (mut v).drop();

  if (mut params).delete("d") != None {
    (mut params).drop();
    (mut url).drop();
    return 9;
  }

  let mut qs2_r = params.to_string();
  if qs2_r.err != None {
    (mut params).drop();
    (mut url).drop();
    return 9;
  }
  qs2_r.err = None;
  let mut qs2: std::strings::String = qs2_r.value ?? std::strings::String.empty();
  qs2_r.value = None;
  if qs2.as_string() != "a=b+c" {
    (mut qs2).drop();
    (mut params).drop();
    (mut url).drop();
    return 9;
  }
  (mut qs2).drop();

  (mut params).drop();
  (mut url).drop();
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::uuid` (std/uuid)
URL: /silk/wiki/?p=std/uuid
==============================================================================

# `std::uuid`

`std::uuid` provides UUID primitives (parsing, formatting, and variants).


## Importing

```silk
import std::uuid;
import std::strings;
```

## Examples

### Example: parse + name-based UUID (v5)

```silk
import std::uuid;
import std::strings;
import std::result;
import std::memory;

type StringAllocResult = std::result::Result(std::strings::String, std::memory::OutOfMemory);

fn uuid_string_eq (u: UUID, expected: string) -> bool {
  let r: StringAllocResult = u.to_string_lower();
  if r.is_err() {
    return false;
  }
  let mut s: std::strings::String = match (r) {
    Ok(v) => v,
    Err(_) => std::strings::String.empty(),
  };
  let ok: bool = s.as_string() == expected;
  (mut s).drop();
  return ok;
}

fn main () -> int {
  let s0: string = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  let u0_r: std::uuid::ParseResult = std::uuid::parse(s0);
  if u0_r.is_err() { return 1; }
  let u0: UUID = match (u0_r) {
    Ok(v) => v,
    Err(_) => { hi: 0, lo: 0 },
  };
  if !uuid_string_eq(u0, s0) { return 2; }

  let dns: UUID = std::uuid::namespace_dns();
  let v5_dns_r: std::uuid::UUIDResult = std::uuid::v5(dns, "www.widgets.com");
  if v5_dns_r.is_err() { return 3; }
  let v5_dns: UUID = match (v5_dns_r) {
    Ok(v) => v,
    Err(_) => { hi: 0, lo: 0 },
  };
  if !uuid_string_eq(v5_dns, "21f7f8de-8051-5b89-8680-0195ef798b6a") { return 4; }

  if v5_dns.version() != 5 { return 5; }
  if !v5_dns.is_rfc4122() { return 6; }
  return 0;
}
```

## See also

==============================================================================
WIKI: `std::vector` (std/vector)
URL: /silk/wiki/?p=std/vector
==============================================================================

# `std::vector`

`std::vector` provides a generic, growable owning container `Vector(T)` used
widely throughout `std::`.


## Importing

```silk
import std::vector;
```

## Examples

### Example: push/pop

```silk
import std::vector;

type Vec = std::vector::Vector(int);

fn main () -> int {
  let v_r = Vec.init(4);
  if v_r.is_err() { return 0; }
  let mut v: Vec = match (v_r) {
    Ok(v) => v,
    Err(_) => Vec.empty(),
  };
  (mut v).push(1);
  (mut v).push(2);
  let x: int = (mut v).pop() ?? 0;
  (mut v).drop();
  return x;
}
```

## See also

==============================================================================
WIKI: Standard library overview (`std::`) (std/overview)
URL: /silk/wiki/?p=std/overview
==============================================================================

# Standard library overview (`std::`)

the intended API and structure; an in-tree stdlib implementation exists
under `std/` for the compiler.


## Importing

`std::` is available to import by default in normal `silk build` workflows.

```silk
import std::io;
import std::vector;
```

## Examples

### Example: a tiny “hello std” program

```silk
import std::io;
import std::vector;

type VecInt = std::vector::Vector(int);

fn main () -> int {
  let mut v: VecInt = VecInt.init(4);
  (mut v).push(10);
  (mut v).push(32);

  std::io::println("len={d} first_pop={d}", v.len() as int, (mut v).pop() ?? 0);
  (mut v).drop();
  return 0;
}
```

## See also

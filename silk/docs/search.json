{
  "generatedAt": "2026-02-06T22:39:16+00:00",
  "kind": "docs",
  "count": 159,
  "items": [
    {
      "id": "start",
      "title": "Silk Documentation",
      "section": "overview",
      "summary": "Silk is a spec-first programming language and compiler toolchain. The goal is a language you can *read* as well as you can compile: predictable semantics, explicit module boundaries, and a standard library designed for systems work.",
      "text": "Silk Documentation Silk is a spec-first programming language and compiler toolchain. The goal is a language you can read as well as you can compile: predictable semantics, explicit module boundaries, and a standard library designed for systems work. This documentation site is written for downstream users. It is organized into: Guides \u2014 purpose, mental model, hello worlds, and practical workflows. Reference \u2014 the detailed language, standard library, CLI, and ABI surfaces. A minimal \u201chello world\u201d Silk programs are ordinary .slk files. A small program can look like this: import std::io::println; fn main () -> int { println(\"hello from silk\"); return 0; } From here, you can: explore the guided path in Guides jump straight to a topic in Reference (language, std::, tooling) use search to find concepts by name Recommended reading path If you\u2019re new to Silk, this is a good order: 1. What Silk is for: design goals, spec-first workflow, and the mental model. 2. Hello world: the smallest working program and the check \u2192 test \u2192 build loop. 3. Language tour: the shape of real programs (types, functions, control flow, errors). 4. Modules & packages: how code is organized and how imports/exports create clean dependency boundaries. 5. Standard library: what lives in std:: and the common patterns it uses. 7. Testing: language-level tests and TAP output for CI and tooling. 8. Formal Silk: opt-in proofs with Z3; how to write verified code with zero runtime cost. Start here: Guides: What Silk is for Guides: Hello world \u00b7 Language tour \u00b7 Modules & packages Guides: Standard library \u00b7 CLI and toolchain Guides: Testing \u00b7 Formal Silk Spec: Silk Spec (2026)"
    },
    {
      "id": "guides/purpose",
      "title": "What Silk is for",
      "section": "guides",
      "summary": "Silk is a **spec-first** programming language and toolchain: the design is written down as a readable, linkable reference, and the compiler is built to match that contract.",
      "text": "What Silk is for Silk is a spec-first programming language and toolchain: the design is written down as a readable, linkable reference, and the compiler is built to match that contract. This matters because it changes how the language evolves: The \u201cmeaning\u201d of a construct lives in the docs, not in folklore. Tooling can rely on stable concepts (packages, imports, diagnostics, CLI shapes). The implementation can grow incrementally while staying predictable to users. If you\u2019re new to Silk, this page gives you the mental model: what you write, what you get, and why the design looks the way it does. Design goals (practical) Silk is designed around a handful of constraints that show up everywhere: Explicit structure Real systems code is easier to maintain when it is obvious where names come from and how code is organized. Names are qualified with ::. Files declare a package or module header at the top. Imports are explicit and live in a contiguous import block. That gives you codebases where \u201cwhat depends on what\u201d is visible without special tooling. A language you can reason about Silk pushes toward predictable semantics: Types matter most at boundaries (public APIs, FFI, storage formats). Silk keeps those boundaries explicit. Error handling is explicit and typed, so you can see what can fail and what must be handled. Verification is opt-in by syntax (Formal Silk): ordinary code stays ordinary. A toolchain you can embed Silk is not only \u201ca compiler binary\u201d. It is also designed to be integrated as a library: a C99 embedding ABI (libsilk) for host applications and build systems a Zig embedding wrapper for Zig-native integrations This is useful when you want compilation as a component inside another program (editors, language servers, build orchestrators, analysis tools). The basic programming model Files form a module set When you run the compiler, you compile a module set: a set of .slk files that are type-checked together. You can provide that set explicitly (a list of files), or you can ask silk to load it from a package manifest (silk.toml). Either way, the idea is the same: \u201cthese files form a unit.\u201d Packages and imports keep boundaries obvious A simple file often begins like this: package app; import std::io::println; That header tells you the namespace (app) and the dependencies (here: std::io::println) before you read the rest of the file. Programs are ordinary code Executables use a conventional entry point: fn main () -> int (exit code). import std::io::println; fn main () -> int { println(\"hello from silk\"); return 0; } Silk is designed so that \u201cthe smallest program\u201d uses the same constructs you use at scale: packages, imports, types, functions, and explicit boundaries. Where Silk fits well Silk is aimed at code where clarity and correctness matter: tools and developer infrastructure network services and protocol code parsers, encoders, and data plumbing libraries that need a stable ABI boundary systems components that benefit from local verification (Formal Silk) If you want a language that is both low-level enough to express systems concerns and structured enough to keep large projects readable, Silk is built for that space. How to use this documentation This site is organized into two layers: Guides: reading order, \u201chow to think\u201d, and realistic examples. Reference: precise language rules, standard library modules, and CLI/ABI details. The recommended flow: 1. Hello world 2. Language tour 3. Modules & packages 4. Standard library 5. CLI and toolchain 6. Testing 7. Formal Silk If you already know what you\u2019re looking for, use search and the sidebar reference sections."
    },
    {
      "id": "guides/hello-world",
      "title": "Hello world",
      "section": "guides",
      "summary": "This page teaches the Silk \u201cshape of a program\u201d: explicit imports, a normal `main`, and a workflow that makes it cheap to iterate.",
      "text": "Hello world This page teaches the Silk \u201cshape of a program\u201d: explicit imports, a normal main, and a workflow that makes it cheap to iterate. Assumption: you have a silk binary available on your PATH. The smallest program Create a file named hello.slk: import std::io::println; fn main () -> int { println(\"hello from silk\"); return 0; } Why this looks the way it does Imports are explicit. If you want println, you import it. This keeps dependencies obvious and makes refactors safer. main is a normal function. Executables use a conventional entrypoint. There isn\u2019t a special \u201cprogram block\u201d that behaves differently from the rest of the language. The return type is explicit. -> int is the process exit code on hosted platforms. A successful run returns 0. Iteration loop: check \u2192 test \u2192 build Most Silk workflows are intentionally simple: silk check hello.slk silk test hello.slk silk build hello.slk -o build/hello silk check answers: \u201cdoes this module set parse and type-check?\u201d silk test discovers and runs test \"name\" { ... } blocks and emits TAP output. silk build compiles and produces an artifact. When you omit --kind, you\u2019re building an executable. The important term is module set: each command operates on a set of .slk files compiled together. Even in small programs, thinking in module sets scales well to larger codebases. Next: CLI and toolchain A slightly richer example This adds a helper function and shows how \u201creal\u201d Silk code stays ordinary: import std::io::println; fn greet (name: string) -> void { println(\"hello {s}\", name); } fn main () -> int { greet(\"silk\"); return 0; } A practical hello: reading arguments On hosted targets, Silk can also accept a conventional (argc, argv) entrypoint shape. The standard library includes a small std::args helper so you can treat raw argv pointers as string views. import std::args; import std::io::println; fn main (argc: int, argv: u64) -> int { let a = std::args::Args.init(argc, argv); if a.count() < 2 { println(\"usage: hello <name>\"); return 2; } println(\"hello {s}\", a.get(1)); return 0; } This example is intentionally small, but it demonstrates the \u201csystems\u201d posture of Silk: when a boundary is low-level (process arguments are ultimately raw pointers), the language and stdlib make that boundary explicit rather than hiding it behind magic. Where to go next Language tour Modules & packages Reference: packages/imports/exports (Packages, imports, exports in the sidebar under \u201cLanguage\u201d)"
    },
    {
      "id": "guides/language-tour",
      "title": "Language tour",
      "section": "guides",
      "summary": "This is a guided walkthrough of the core ideas you\u2019ll use in real Silk programs: explicit structure, readable types, predictable control flow, and clear boundaries.",
      "text": "Language tour This is a guided walkthrough of the core ideas you\u2019ll use in real Silk programs: explicit structure, readable types, predictable control flow, and clear boundaries. Silk is designed for explicit structure: Programs are organized into packages and modules with clear boundaries. Types are spelled out when they matter (especially at public boundaries). The standard library is under std:: and is designed to be usable for systems programming. This guide is intentionally example-heavy. For the precise rules, use the reference pages in the sidebar. Program structure: packages and imports At the top of a file you declare your package and then import dependencies: package myapp::core; import std::io::println; This header ordering is intentional: it keeps dependency structure tooling-friendly and prevents \u201cimports halfway down the file\u201d patterns. If you omit a package declaration, the file belongs to a default package for that build. In real projects, declaring the package explicitly keeps codebases easier to navigate. Values: let, mut, and explicit types Silk uses let bindings for local values. fn main () -> int { let port: int = 8080; let enabled: bool = true; let name: string = \"silk\"; return 0; } Use mut when a binding needs to change: fn main () -> int { let mut sum: int = 0; sum = sum + 1; return sum; } The \u201cwhy\u201d is simple: mutability is a property you can see at the binding site. Functions: ordinary code, explicit boundaries Functions are declared with fn, and you write return types explicitly at boundaries: fn add (a: int, b: int) -> int { return a + b; } Executables use fn main () -> int by convention. Exports: a deliberate public surface Bindings are explicit and can be exported as part of a package\u2019s public surface: export let buildname: string = \"myapp\"; export fn add (a: int, b: int) -> int { return a + b; } Exports matter because they define what other packages can depend on. A large part of Silk\u2019s \u201creadability\u201d comes from being able to see a package\u2019s public surface without reading every file. Structs and methods Silk uses struct for concrete data with well-defined layout. Methods live in impl blocks: struct Packet { seq: u32; size: u16; } impl Packet { fn bytes (self: &Packet) -> u32 { return self.size as u32; } } The important idea is not the syntax \u2014 it\u2019s that data and behavior stay grouped without turning \u201ctypes\u201d into magical objects. Enums and match Enums model \u201cone of several shapes\u201d and are commonly used with match. enum Mode { Debug, Release, } fn codefor (m: Mode) -> int { return match (m) { Mode::Debug => 1, Mode::Release => 2, }; } match is also the natural way to handle results and typed errors (next sections). Interfaces (practical contracts) Interfaces describe required method signatures for a contract. In user code, these are often used to define \u201cprotocols\u201d such as readers, writers, serializers, or log sinks. import std::io; interface LogSink { fn write(line: string) -> void; } struct StdoutSink {} impl StdoutSink as LogSink { fn write (self: &StdoutSink, line: string) -> void { std::io::println(\"{s}\", line); } } The key idea: interfaces are about meaningful program structure, not about web-specific types. Control flow Silk uses familiar control flow constructs: fn clamp (x: int, lo: int, hi: int) -> int { if x < lo { return lo; } if x > hi { return hi; } return x; } Optionals: T? and \u201cabsence\u201d Optionals (T?) represent an optional value (Some(...) or None). fn parseflag (s: string) -> bool? { if s == \"on\" { return Some(true); } if s == \"off\" { return Some(false); } return None; } Use optionals when \u201cmissing\u201d is a normal outcome and you don\u2019t need structured error details. Results: std::result::Result(T, E) When you want a standard \u201csuccess or error\u201d return shape, use Result(T, E): import std::result; type IntOrMessage = std::result::Result(int, string); fn div (a: int, b: int) -> IntOrMessage { if b == 0 { return Err(\"division by zero\"); } return Ok(a / b); } Callers typically handle results with match: fn main () -> int { match (div(10, 2)) { Ok(v) => { return v; }, Err() => { return 1; }, } } Typed errors: structured failures Silk also supports typed errors directly. You define an error type and return T ErrorType: error ParseFailed { message: string } fn parseport (s: string) -> int ParseFailed { if s == \"\" { return ParseFailed{ message: \"empty\" }; } return 8080; } Then handle it explicitly with match: fn main () -> int { match (parseport(\"8080\")) { port => { return port; }, : ParseFailed => { return 2; }, } } The value-add is clarity: you can see what can fail and how to handle it without conventions or exceptions. Testing (language-level) Silk provides language-level tests (test \"name\" { ... }). Tests live next to the code they exercise and are run with silk test. import std::test::expectequal; fn add (a: int, b: int) -> int { return a + b; } test \"add returns the sum\" { expectequal(3, add(1, 2)); } Next Next: Modules & packages \u00b7 Standard library \u00b7 Testing"
    },
    {
      "id": "guides/modules-and-packages",
      "title": "Modules & packages",
      "section": "guides",
      "summary": "Silk uses `::`-qualified names to organize code. The goal is not novelty \u2014 it\u2019s **clarity**:",
      "text": "Modules & packages Silk uses ::-qualified names to organize code. The goal is not novelty \u2014 it\u2019s clarity: you can see where names come from, you can see what depends on what, and builds stay deterministic because the compiler always knows what the module set is. This page focuses on the practical model you\u2019ll use in real code. Packages A package is a named collection of source files that share a namespace. A file can declare its package at the top: package myapp::core; Package names are ::-qualified paths. The standard library lives under std::... (for example std::io, std::fs, std::strings). Importing packages When you import a package, you are declaring a dependency on that package\u2019s public surface: import std::strings; Exports are explicit (export fn, export let, and named re-exports). This keeps public API surfaces intentional. A tiny multi-file example util.slk: package app::util; export fn add (a: int, b: int) -> int { return a + b; } main.slk: package app; import app::util; import std::io::println; fn main () -> int { println(\"sum={d}\", app::util::add(20, 22)); return 0; } The important thing is how obvious this is: main depends on app::util and std::io::println, and nothing else is implicitly pulled in. Modules A module declaration is a compile-time-only namespace value. It lets you write code that is \u201cabout\u201d a module, including module-level conformance checks. module myapp::logger; Modules are useful when you want a named namespace in a single file without necessarily treating it as \u201ca package you import from other files\u201d. In addition to header-form modules, you can define inline modules for nested namespaces: package myapp; export module math { export fn add (a: int, b: int) -> int { return a + b; } } Imports: whole packages vs individual symbols Silk supports a small set of import forms that cover most real programs: package imports for cohesive namespaces symbol imports when you want a single dependency in scope module-specifier imports (for relative files, std/ file paths, or package specifiers) import std::io::println; import std::strings; Use package imports when you want a cohesive namespace; use symbol imports when you want explicit local dependencies. Exports: keeping APIs deliberate Exports define what other packages can depend on. Common forms: export let version: string = \"0.1.0\"; export fn parse (s: string) -> int? { return None; } export { parse as parseport }; This \u201cexplicit exports\u201d rule is a major readability win in larger codebases: public surfaces stay curated. The CLI view: module sets and package manifests The compiler always operates on a module set: the set of .slk files compiled together for that command. You can define the module set explicitly (a list of files), or you can load it from a package manifest (silk.toml) using package. Why this matters for packages/modules: Package imports only resolve to packages that exist in the module set. Tooling can answer questions like \u201cwhat packages exist?\u201d without executing code. Builds become reproducible because \u201cwhat was compiled\u201d is not a hidden global. If you want the user-facing toolchain model, read: CLI and toolchain. Why this structure matters The language design is intentionally strict about where these declarations live (package/module headers first, then a contiguous import block). The payoff is large in practice: tools can parse dependency structure without executing code refactors are safer because imports and exports are explicit builds can be reproducible because module sets are well-defined Next Standard library Testing"
    },
    {
      "id": "guides/standard-library",
      "title": "Standard library",
      "section": "guides",
      "summary": "Silk\u2019s standard library lives under the reserved `std::` namespace. This is where \u201cpractical systems programming\u201d shows up: I/O, filesystem, networking, parsing, collections, time, and the shared conventions that make those modules compose.",
      "text": "Standard library Silk\u2019s standard library lives under the reserved std:: namespace. This is where \u201cpractical systems programming\u201d shows up: I/O, filesystem, networking, parsing, collections, time, and the shared conventions that make those modules compose. This page is not a full reference (the sidebar is). It\u2019s a guide to the shape of std::, how to use it, and what patterns to expect. Importing std:: modules You can import an entire package, or import a single symbol: import std::io; // package import (use as std::io::println, ...) import std::io::println; // symbol import (use as println(...)) import std::fs; // filesystem import std::result::Result; // common return shape Use symbol imports when you want the dependency to be explicit at the call site (especially in small programs). Use package imports when you want a cohesive namespace (common for larger modules). The three common \u201creturn shapes\u201d std:: APIs intentionally reuse a small set of patterns so code stays readable. 1) Optionals: T? T? means \u201ca T or no value\u201d (Some(...) / None). Use this when \u201cabsence\u201d is expected and you don\u2019t need rich error information. fn parseport (s: string) -> int? { // Example sketch: a real parser would validate digits. if s == \"\" { return None; } return Some(8080); } 2) Results: std::result::Result(T, E) Result(T, E) is the standard \u201csuccess or error\u201d type used across std::. import std::result; type IntOrMessage = std::result::Result(int, string); fn div (a: int, b: int) -> IntOrMessage { if b == 0 { return Err(\"division by zero\"); } return Ok(a / b); } In real code you typically match on a result so success and failure paths stay explicit. 3) Typed errors: T E Silk supports typed errors directly in the language: a value is either a success type T or an error type E. This is a good fit when: the error has structure (fields), and callers are expected to handle distinct failure reasons. You\u2019ll see both T E and Result(T, E) in the ecosystem; std:: uses Result heavily because it composes cleanly and is easy to pattern-match. A quick tour of key modules std::io \u2014 printing and stream I/O std::io covers console I/O and basic stream patterns. import std::io::println; fn main () -> int { println(\"hello {s} answer={d}\", \"world\", 42); return 0; } When you need lower-level I/O, std::io also exposes byte-oriented read/write primitives and stable error kinds. Reference: std::io (see the sidebar under \u201cStandard library\u201d). std::fs \u2014 filesystem operations std::fs provides file and directory helpers and a low-level File handle. Whole-file helpers are intentionally common: import std::fs; import std::io::println; fn main () -> int { match (std::fs::readfilestring(\"message.txt\")) { Ok(s) => { println(\"{s}\", s.asstring()); return 0; }, Err(e) => { // A real program would format/inspect e.kind and report it. println(\"read failed\"); return 1; }, } } Reference: std::fs, std::path. std::strings \u2014 owned strings and utilities Silk has a built-in string type (an immutable view over UTF\u20118 bytes). The standard library adds an owning String for when you need to build or retain dynamic strings. Reference: std::strings, std::unicode. std::json and std::toml \u2014 configuration and structured data Silk includes parsers for data formats used in real programs: std::toml for configuration (including silk.toml manifests) std::json for interoperability and structured data exchange Reference: std::toml, std::json. std::task, std::sync, std::temporal For concurrent and time-aware programs, std:: provides: std::task (tasks, scheduling primitives) std::sync (mutexes/locks and synchronization) std::temporal (time types like Duration/Instant) Reference: std::task, std::sync, std::temporal. How to keep std:: code readable Two patterns pay off quickly: 1. Use small local aliases for verbose types. For example, alias a Result instantiation to a short name. 2. Prefer match at boundaries. Convert errors into your own types at module boundaries, so the rest of your program doesn\u2019t become a chain of \u201cplumbing\u201d. Next CLI and toolchain Testing"
    },
    {
      "id": "guides/cli",
      "title": "CLI and toolchain",
      "section": "guides",
      "summary": "Silk\u2019s CLI is designed to make the \u201cnormal loop\u201d cheap:",
      "text": "CLI and toolchain Silk\u2019s CLI is designed to make the \u201cnormal loop\u201d cheap: 1. check \u2014 parse + type-check 2. test \u2014 run language-level tests 3. build \u2014 produce artifacts (executables and libraries) binary. This guide focuses on the user-facing model: what the commands mean and how they fit together. The key idea: a module set Every invocation operates on a module set: the set of .slk files compiled together. You can define that set in two ways: Explicit files: silk check a.slk b.slk A package manifest: silk check --package . (loads silk.toml) The module set determines: what packages exist how import resolves what gets type-checked together This is why the CLI feels deterministic: you always know what the compiler is looking at. silk check: fast feedback Use silk check when you want a quick, cheap answer: silk check src/main.slk Common patterns: Check a whole package: silk check --package . Check with a custom stdlib root: silk check --std-root ./path/to/std src/main.slk Why it\u2019s valuable: it makes \u201cdoes this program make sense?\u201d a first-class operation editors and CI can run it constantly without building outputs silk build: artifacts and build targets silk build compiles and produces an output artifact. The output kind is explicit: Executable (default kind is executable) silk build src/main.slk -o build/app Object file (useful for embedding into other build systems) silk build src/lib.slk --kind object -o build/lib.o Static / shared libraries silk build src/lib.slk --kind static -o build/libfoo.a silk build src/lib.slk --kind shared -o build/libfoo.so Build targets matter because they change how you structure code: executables center around main libraries emphasize exported functions and stable boundaries (often with a C header via --c-header) Target selection When you need to select a target explicitly: silk build src/main.slk --target x8664-linux-gnu -o build/app silk build src/main.slk --arch wasm32 --kind executable -o build/app.wasm The CLI also exposes knobs for linking metadata (--needed, --runpath, --soname) when producing executables or shared libraries. silk test: language-level tests (TAP) Silk tests are authored in the language and live next to the code they exercise: import std::test::expectequal; fn add (a: int, b: int) -> int { return a + b; } test \"add returns the sum\" { expectequal(3, add(1, 2)); } Run them with: silk test src/main.slk silk test --package . # run package tests silk test --filter add # run only matching tests The runner emits TAP v13 output so it drops into existing tooling without special adapters. silk doc and silk man: documentation as part of the toolchain Silk treats documentation as something the compiler can extract and render: silk doc generates Markdown from doc comments silk man renders a manpage view for a symbol/module/concept This is a practical way to keep \u201cwhat this code means\u201d close to the codebase without inventing a separate doc pipeline. silk cc and embedding (C99 ABI) Silk includes a stable embedding interface (libsilk) for host applications. If you\u2019re integrating Silk into an existing C build: use silk build --kind object static shared for artifacts emit headers with --c-header link against libsilk when embedding the compiler itself For deep embedding details, see: C ABI: libsilk (sidebar \u2192 compiler/ABI) Zig embedding: Zig Embedding API (sidebar \u2192 compiler) Diagnostics When a command fails, the compiler prints a diagnostic with a stable error code. These codes are designed to be: human readable (good in terminals) machine consumable (good in CI and tooling) Reference: Diagnostics (sidebar \u2192 compiler). Next Testing Formal Silk"
    },
    {
      "id": "guides/testing",
      "title": "Testing",
      "section": "guides",
      "summary": "Silk testing is **language-level**: tests live next to the code they exercise. The compiler discovers them, runs them with `silk test`, and emits TAP output (TAP v13) so results are easy to consume in CI and existing tooling.",
      "text": "Testing Silk testing is language-level: tests live next to the code they exercise. The compiler discovers them, runs them with silk test, and emits TAP output (TAP v13) so results are easy to consume in CI and existing tooling. The goal is a workflow where \u201cwrite code + write tests\u201d is the default, not a separate phase. A basic test import std::test::expectequal; test \"addition\" { expectequal(3, 1 + 2); } Run it: silk test hello.slk Nested tests Tests can be nested to share setup and group behavior: import std::test::expectequal; fn add (a: int, b: int) -> int { return a + b; } test \"math\" { test \"addition\" { expectequal(4, add(2, 2)); } test \"associativity (small sample)\" { expectequal(add(add(1, 2), 3), add(1, add(2, 3))); } } Nested tests execute inline (in source order) as part of the enclosing test, which makes them a natural fit for hierarchical grouping and shared setup. Assertions and failures Inside silk test builds, failed assertions record failures instead of aborting the entire run. That means one test run can report multiple failures, which is valuable when you\u2019re iterating. You have two complementary tools: assert <cond>; \u2014 built-in assertion syntax std::test helpers \u2014 ergonomic test-only helpers (expect, expectequal, expecterror) Example: import std::test; test \"example\" { test::expect(1 + 1 == 2, Some(\"basic arithmetic\")); } TAP output (tooling-friendly) The runner emits TAP v13: TAP version 13 1..N ok <n> - <name> not ok <n> - <name> This makes Silk tests easy to integrate with existing CI systems and TAP consumers. Filtering tests When you have a larger suite, you can run a subset: silk test src/main.slk --filter addition The filter matches test names (substring match), which keeps it practical for \u201crun the one I\u2019m working on\u201d loops. What makes Silk testing valuable Silk\u2019s testing model has a few strong properties: Co-location: tests live with the code they validate. Good failure reporting: failures are recorded and execution continues, so you see more than the first failure. Tooling-friendly output: TAP output integrates with existing test tooling. Language integration: the compiler understands tests as part of the language, not as an external framework. Next Formal Silk"
    },
    {
      "id": "guides/formal-silk",
      "title": "Formal Silk",
      "section": "guides",
      "summary": "Formal Silk is Silk\u2019s compile-time formal verification language. It lets you write *machine-checked* specifications next to ordinary code, and have the compiler prove those specifications using the Z3 SMT solver.",
      "text": "Formal Silk Formal Silk is Silk\u2019s compile-time formal verification language. It lets you write machine-checked specifications next to ordinary code, and have the compiler prove those specifications using the Z3 SMT solver. Two properties make this practical: Zero runtime cost. Verification directives do not exist at runtime; they don\u2019t slow down your program. Opt-in by syntax. Normal code stays normal. Proofs are required only where you write verification syntax. The key design choice is opt-in by syntax: normal code stays normal, and proofs are required only when verification syntax is present. Formal Silk is meant to be used the way you actually write systems code: small, local assertions around the parts that are easy to get subtly wrong (boundary checks, invariants, protocol rules, and \u201cthis must never happen\u201d assumptions). The basic pieces Formal Silk uses a small vocabulary of directives: #require \u2014 preconditions (what must be true before a function runs) #assure \u2014 postconditions (what must be true when a function returns) #assert \u2014 a proof obligation at a specific point in a block #invariant \u2014 a property that must hold before/after loop iterations #variant \u2014 a measure used for termination reasoning (it must decrease) #const \u2014 a compile-time-only binding used inside specifications theory / #theory \u2014 reusable proof obligations You\u2019ll see these used in three places: function boundaries, inside blocks, and around loops. Function contracts: #require and #assure You can attach preconditions and postconditions to a function: require x >= 0; assure result > x; fn inc (x: int) -> int { return x + 1; } This gives you a mechanically checked contract with zero runtime cost. A more realistic example: clamp clamp is simple, but it\u2019s exactly the kind of function where off-by-one and boundary mistakes show up: require lo <= hi; assure result >= lo; assure result <= hi; fn clamp (x: int, lo: int, hi: int) -> int { if x < lo { return lo; } if x > hi { return hi; } return x; } The postconditions say what callers actually care about: the result is within range. Loop invariants and termination Formal Silk can express loop invariants (#invariant) and termination measures (#variant) to prove properties that span iterations. Invariants are \u201calways true\u201d properties around the loop. Variants are how you justify termination: the variant must move in the right direction each iteration (usually decreasing toward a bound). Example: counting up to a limit while remembering what the original limit was: fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; while i < limit { i = i + 1; } return 0; } This is a small example, but it illustrates a common pattern: use #const to name the \u201cbefore\u201d value you want to talk about in specifications. Block-local proof obligations Use #assert to create a proof obligation at a specific point in a block: fn demo (x: int) -> int { #assert x == x; return x; } In practice, #assert is most useful for: documenting an assumption you want the compiler to enforce (not just a comment) breaking a large proof into smaller checkpoints expressing a local fact that helps downstream invariants Reusable proofs: theories When you have a property that should hold in many places, you can write it as a theory and attach it where needed. The idea is to keep verification modular: small reusable statements instead of one giant proof block. Why it\u2019s valuable Formal verification is most useful where bugs are expensive: memory safety boundaries cryptographic and security-sensitive logic protocol parsers and encoders concurrency invariants Silk\u2019s approach keeps verification lightweight and local: you opt in where it buys you confidence. Debugging failed proofs When a proof fails, the compiler reports a normal diagnostic at the annotation site. For deeper debugging, run with --debug so the verifier can emit additional information and (when available) write an SMT\u2011LIB reproduction script you can replay with an external Z3 binary. The workflow is intentionally pragmatic: when a proof fails, you should be able to iterate the same way you iterate on type errors \u2014 with good diagnostics and small edits."
    },
    {
      "id": "language/flow-break",
      "title": "`break`",
      "section": "language",
      "summary": "`break` exits the nearest enclosing loop.",
      "text": "break break exits the nearest enclosing loop. Surface Syntax break; Notes: break is a statement, terminated by a semicolon. break does not carry a value in the current language design; there is no break <expr> form. Semantics When executed, break;: terminates the innermost enclosing loop (loop, while, or for), and continues execution at the statement immediately following that loop. In nested loops, break only exits the nearest loop: fn main () -> int { while true { while true { break; // exits the inner loop only } break; // exits the outer loop } return 0; } break does not exit the current function. Use return for that. Type Checking Rules break is only permitted inside a loop body. E2007). Common Pitfalls Forgetting the semicolon (break is a statement). Expecting break to return a value (not supported). Using break outside a loop (rejected, E2007)."
    },
    {
      "id": "language/flow-continue",
      "title": "`continue`",
      "section": "language",
      "summary": "`continue` skips the remainder of the current loop iteration and jumps to the next iteration of the nearest enclosing loop.",
      "text": "continue continue skips the remainder of the current loop iteration and jumps to the next iteration of the nearest enclosing loop. Surface Syntax continue; Notes: continue is a statement, terminated by a semicolon. Semantics When executed inside a loop body, continue;: stops executing the remainder of the current iteration\u2019s body, and transfers control to the loop\u2019s \u201cnext iteration\u201d point: for loop, this means jumping to the start of the loop body. for while, this means re-evaluating the loop condition. for for, this means advancing to the next iteration (and for C-style for loops, executing the loop step before re-checking the loop condition). Example: fn main () -> int { let mut i: int = 0; while i < 10 { i += 1; if i == 5 { continue; // skips the return below for i == 5 } // More work could happen here. } return 0; } In nested loops, continue applies to the nearest loop: fn main () -> int { while true { while true { continue; // continues the inner loop } } return 0; } Type Checking Rules continue is only permitted inside a loop body. E2008). Common Pitfalls Forgetting the semicolon (continue is a statement). Expecting continue to exit the loop (it does not; use break). Using continue outside a loop (rejected, E2008)."
    },
    {
      "id": "language/duration-instant",
      "title": "`Duration` & `Instant`",
      "section": "language",
      "summary": "`Duration` and `Instant` are time-related types with special literal and operator support.",
      "text": "Duration & Instant Duration and Instant are time-related types with special literal and operator support. Key ideas: Duration represents a signed time span. Instant represents a signed point-in-time on a monotonic timeline (an opaque epoch chosen by the runtime). Duration literals represent time spans with unit suffixes and are converted into integral ticks. Operators cover arithmetic, comparisons, and construction from scalars. Representation In Silk: Duration is represented as a signed 64-bit integer count of nanoseconds. Instant is represented as a signed 64-bit integer count of nanoseconds since a monotonic, runtime-defined origin. These are distinct Silk types in the type system, but share the same underlying scalar representation (i64) at the IR and native ABI layers. Operators The current implementation supports the following operator subset: Duration + Duration -> Duration Duration - Duration -> Duration Duration -> Duration Instant + Duration -> Instant Duration + Instant -> Instant Instant - Duration -> Instant Instant - Instant -> Duration Comparisons (==, !=, <, <=, >, >=) are supported for: Duration vs Duration Instant vs Instant Other arithmetic (, /, %) and bitwise operators are not defined for time types in the current implementation. Overflow Arithmetic uses the same deterministic wrapping behavior as the underlying i64 operations in the current back-end subset (two\u2019s complement wraparound). Future Work At maturity, this document will be expanded to fully specify: duration/instant division semantics and rounding rules, checked/saturating variants exposed by the standard library, the precise relationship between Instant and the platform clock APIs, and FFI-safe conversions and APIs in std::temporal. Compiler requirements: Implement type-checking and lowering for the operator subset above. Integrate with std::temporal in the standard library."
    },
    {
      "id": "language/enums",
      "title": "`enum` Types",
      "section": "language",
      "summary": "An `enum` defines a *tagged union* type: a value that is exactly one of several named variants, optionally carrying a payload.",
      "text": "enum Types An enum defines a tagged union type: a value that is exactly one of several named variants, optionally carrying a payload. Use enums to model: finite state machines (connection state, parser state), protocol messages and events, and any API where \u201cexactly one of these cases\u201d is the core invariant. If your goal is \u201ca function can fail with one of several error shapes\u201d, prefer Surface Syntax Enum declarations introduce a nominal type and its variants: enum RecvJob { Msg(Job), Cancelled, Timeout, } Rules: Variant names are identifiers and must be unique within the enum. Variant names may not be the reserved optional constructors Some / None. An enum must declare at least one variant. A variant is either: a unit variant (no payload): Cancelled, or a tuple variant with one or more payload element types: Msg(Job), Pair(int, int). A trailing comma after the last variant is permitted. Construction Unit variants Unit variants are constructed as values using Enum::Variant (or, in type-directed contexts, just Variant): enum E { A, B, } fn main () -> int { let x: E = E::A; let y: E = A; return 0; } Notes: E::A() and A() are invalid in Silk (unit variants are not callable). Tuple variants Tuple variants are constructed using Enum::Variant(<args...>) where the argument count and types match the variant\u2019s declared payload element types: enum E { Data(int), Pair(int, int), Empty, } fn main () -> int { let a: E = E::Data(7); let b: E = Data(7); let b: E = E::Pair(1, 2); let c: E = E::Empty; return 0; } Notes: E::Data by itself is not a value in Silk (tuple variants must be constructed with (...)). If a tuple-variant constructor argument has the wrong type, you get E2001. If the argument count does not match the variant definition, the compiler currently rejects the construct with E2002. Generic enums (instantiation via alias) When an enum is generic, callers typically alias an instantiation and then use that alias as the qualifier for constructors: enum Result(T, E) { Ok(T), Err(E), } type R = Result(int, int); fn main () -> int { let x: R = R::Ok(123); return match x { R::Ok(v) => v, R::Err() => 0, }; } Namespaced enums (packages) Across packages, enums and variants may be referenced with :: qualification. For example, if util defines enum Mode { Inc, Dec }, an importer can write: util::Mode as the type name, and util::Mode::Inc / util::Mode::Dec as the constructors and patterns. package imports seed qualified type names. Matching Enum values are typically consumed via match expressions. The match focuses on the enum-specific subset. Patterns Enum patterns are variant patterns: Unit variant: E::A Tuple variant: E::Data(x), E::Pair(a, b) Tuple binder omission: E::Pair(, b) (underscore binder ignores that element) Shorthand: When the scrutinee type is the enum E, the qualifier may be omitted: Unit variant: A Tuple variant: Data(x), Pair(a, b) For instantiated generic enums, the qualifier E may be a type alias (for example type R = Result(int, string); then R::Ok(v) / R::Err(e)). Binders: introduce a name scoped to that arm only, and shadow outer bindings of the same name (because they create a new binding in the arm\u2019s environment). Exhaustiveness In Silk, enum matches must be exhaustive: There must be exactly one arm per enum variant. Each variant must appear exactly once. Wildcard arms ( => ...) are not supported for enum matches yet. If a match is not exhaustive, the compiler currently reports E2002 rather than a dedicated \u201cmissing match arm\u201d diagnostic. Example: unit enum match enum E { A, B, } fn main () -> int { let v: E = E::A; let x: int = match v { E::A => 10, E::B => 20, }; if x != 10 { return 1; } return 0; } Example: tuple enum match (payload binders) enum E { Pair(int, int), Empty, } fn main () -> int { let v: E = E::Pair(1, 2); let x: int = match v { E::Pair(a, ) => a, E::Empty => 0, }; if x != 1 { return 1; } return 0; } Example: struct payload enum match struct Job { id: int, } enum RecvJob { Msg(Job), Cancelled, } fn main () -> int { let j: Job = Job{ id: 5 }; let evt: RecvJob = RecvJob::Msg(j); let rc: int = match evt { RecvJob::Msg(job) => job.id, RecvJob::Cancelled => 0, }; if rc != 5 { return 1; } return 0; } Representation Enums are values. In the current IR-backed lowering, an enum value is lowered to scalar slots as: 1. a u64 tag (variant index in declaration order, starting at 0), and 2. a payload region that includes a distinct slot range for each variant\u2019s payload elements, in variant declaration order. Conceptually: (u64 tag, payload slots for variant 0, payload slots for variant 1, ...) Only the active variant\u2019s payload region is meaningful for a given value; other payload regions are unspecified. This representation is an implementation detail and is expected to evolve (for example, toward a tag + max-payload \u201cunion-style\u201d layout) as the compiler and ABI mature. Common Pitfalls Forgetting parentheses: E::Data(7) is valid, but E::Data is not a value In Silk (error E2002). Calling a unit variant: E::A is a value; E::A() is rejected (E2002). Wrong binder count: E::Pair(a) does not match Pair(int, int) (E2002). Non-exhaustive matches: you must list every variant (error E2002 in the ). Assuming enum equality is defined: use match to inspect the tag/payload; the backend does not define ==/!= over enums yet. Related Documents Relevant Tests Enum matches (end-to-end): Namespaced enum references (module-set build):"
    },
    {
      "id": "language/flow-for",
      "title": "`for` Loop",
      "section": "language",
      "summary": "The `for` loop iterates over a range or iterable and executes a block once per element.",
      "text": "for Loop The for loop iterates over a range or iterable and executes a block once per element. start..=end), array/slice iteration (for x in xs { ... } for T[N] and T[]), iterator iteration (for x in it { ... } when it.next() -> T?), and C-style for (init; condition; step) { ... } loops. Goals Provide a readable, structured loop construct for iteration. Avoid \u201coff-by-one\u201d patterns by making range boundaries explicit. Integrate with break / continue. Integrate with future iteration protocols (interfaces/generics) without introducing hidden allocation. Surface Syntax Supported surface forms: for <pattern> in <iterable> { ... } for (<init>; <condition>; <step>) { ... } Notes: <pattern> is intended to be a pattern binder. In early implementations it is restricted to a single identifier (and ). It will be expanded alongside pattern matching. <iterable> is an expression. <init> is a local binding (let / var / const) with an initializer. <condition> is a boolean expression. <step> is a statement-like expression (the same restricted subset as Semantics General rules: The iterable expression is evaluated once to produce an iteration source. The loop body executes once per produced element. break exits the loop; continue advances to the next element. Range iteration When the iterable is a range expression (for example start..end or start..=end), the loop iterates over integer values. Design intent: start..end iterates start, start+1, ..., end-1 (end-exclusive). start..=end iterates start, start+1, ..., end (end-inclusive). Notes: The range bounds are evaluated once, left-to-right (start then end). If the start bound is greater than or equal to the end bound (start >= end) for an end-exclusive range, the loop executes zero times. If the start bound is greater than the end bound (start > end) for an end-inclusive range, the loop executes zero times. continue advances to the next element (it performs the increment step, then re-checks the range condition). The loop binder is in scope only inside the loop body block. The binder is immutable in Silk (it behaves like a let binding that is updated by the loop machinery; user code cannot assign to it). Type checking: Both range bounds must have integer type (int, i8/u8, i16/u16, i32/u32, i64/u64). The two bound types must match, except that an integer literal bound may be coerced to the other bound\u2019s integer type (for example for i in 0..nu32). The loop binder (when not ) has the bound\u2019s integer type. Example: fn main () -> int { let mut sum: int = 0; for i in 0..3 { // i takes values 0, 1, 2 sum += i; } // 0 + 1 + 2 = 3 return sum; } Array and slice iteration In Silk, for also supports iterating over builtin array and slice types: fixed arrays T[N], slices T[]. Semantics: The iterable expression is evaluated once. The loop executes in increasing index order, starting at index 0. The loop binder (when not ) is bound to the element value (a copy) for the current iteration. The binder is in scope only inside the loop body block. break exits the loop; continue advances to the next element. Limitations: Element types are limited to the currently-supported array/slice element subset (types that lower to a fixed scalar slot sequence in the current back-end, such as primitive scalars, string, and supported non-opaque structs). Iteration is by value; to mutate an element, use indexing (xs[i] = ...). Example: fn main () -> int { let xs: int[3] = [1, 2, 3]; let mut sum: int = 0; for x in xs { sum += x; } return sum; } Iterator protocol In addition to builtin arrays and slices, for supports iterating over a stateful iterator value. An expression it is treated as an iterator when it has a next() -> T? instance method (typically by implementing std::interfaces::Iterator(T)). Semantics: The iterable expression is evaluated once to produce the iterator value. The loop repeatedly calls (mut it).next(). When the result is None, the loop exits. When the result is Some(value), the binder (when not ) is bound to value (a copy) for that iteration and the body executes. continue advances by calling next() again; break exits the loop. C-style for loops Silk also supports the traditional \u201cC-style\u201d for loop: fn main () -> int { let len: int = 10; let mut sum: int = 0; for (let i = 0; i < len; ++i) { sum += i; } return sum; } Semantics: <init> executes exactly once before the first condition check. <condition> is checked before each iteration; if it is false, the loop exits. The loop body executes once per iteration when <condition> is true. After the body executes normally, <step> executes, then the loop re-checks <condition>. continue; skips the remainder of the loop body and jumps to <step> (then re-checks <condition>). break; exits the loop immediately without executing <step> for that iteration. The init binding\u2019s name is in scope within the entire loop (condition, step, and body) but is not visible after the loop. Init binding mutability: For ergonomics, for (let i = 0; ...; ++i) is accepted and the init binding is treated as mutable (equivalent to var) within the loop. const init bindings remain immutable. Guidance In Silk, for supports integer ranges and builtin array/slice iteration. To write other loops today, use while: fn main () -> int { let mut i: int = 0; while i < 3 { std::io::println(\"i = {}\", i); i += 1; } return 0; } Compiler Requirements Recognize for loop syntax. Resolve iteration targets (ranges, collections) according to the language\u2019s iteration model. Lower for into explicit control flow, with correct semantics for break and continue. Compiler requirements: Recognize for loop syntax. Resolve iteration targets (ranges, collections) according to the language\u2019s iteration model."
    },
    {
      "id": "language/flow-if-else",
      "title": "`if` / `else`",
      "section": "language",
      "summary": "The `if` / `else` construct provides branching based on a boolean condition.",
      "text": "if / else The if / else construct provides branching based on a boolean condition. In Silk, if is a statement that selects which block of statements executes. The broader language design also includes expression-oriented forms; those are documented as planned where relevant. Surface Syntax Minimal form: if <condition> { ... } With an else: if <condition> { ... } else { ... } Notes: <condition> is an expression; parentheses are optional because the normal expression grammar already includes parenthesized expressions. Bodies are blocks. else may be followed by either: a block (else { ... }), or another if (else if ... { ... }) to form an \u201celse-if\u201d chain. Surface Syntax (Expression Form) Silk also supports if / else as an expression form that yields a value: let v: int = if cond { 123 } else { 456 }; Notes: if expressions require an else branch so the expression yields a value on all paths. The else if ... chain form is supported in expression position: let v: int = if a { 1 } else if b { 2 } else { 3 }; Current compiler subset restriction: the { ... } bodies of if expressions contain a single expression (not a full statement block). Semantics The condition expression is evaluated exactly once. If the condition is true, the if block executes and the else block (if present) does not execute. If the condition is false, the else block executes if present; otherwise the if statement does nothing. Blocks create scopes: Declarations inside the if body are not visible outside that body. Declarations inside the else body are not visible outside that body. Type Checking Rules The condition must have type bool. If it does not, the checker reports a For if expressions: The then and else branches must produce compatible value types. The expression\u2019s result type is the shared branch type (or the expected type when the expression is type-directed). else if Chains The language supports chained conditions (\u201celse-if chains\u201d). The compiler parses else if as sugar for nesting an if inside the else block: fn main () -> int { let x: int = 1; if x == 0 { return 0; } else { if x == 1 { return 1; } else { return 2; } } } The equivalent direct surface form is: fn main () -> int { let x: int = 1; if x == 0 { return 0; } else if x == 1 { return 1; } else { return 2; } } Examples Minimal if / else fn main () -> int { if true { return 0; } else { return 1; } } Boolean expressions in conditions fn main () -> int { let x: int = 1; let y: int = 2; if x < y && y < 10 { return 3; } else { return 4; } } Control flow inside branches fn main () -> int { let x: int = 1; let y: int = 2; if x < y { while false { continue; } return 3; } else { return 4; } }"
    },
    {
      "id": "language/flow-loop",
      "title": "`loop` Loop",
      "section": "language",
      "summary": "The `loop` statement executes a block repeatedly until it is terminated by a `break` or `return`.",
      "text": "loop Loop The loop statement executes a block repeatedly until it is terminated by a break or return. task loop { ... }. Surface Syntax loop { // ... } async loop { // ... } task loop { // ... } Notes: async loop and task loop are still loop statements: they do not end with ;. In Silk, async loop / task loop follow the same async-context restriction as async { ... } / task { ... }: they are only allowed inside functions declared with async Semantics The body block executes repeatedly. break; exits the nearest enclosing loop and continues execution at the continue; skips the remainder of the current iteration\u2019s body and begins the Type Checking Rules The loop body is checked in a loop context so break / continue are valid."
    },
    {
      "id": "language/flow-match",
      "title": "`match` Expression",
      "section": "language",
      "summary": "The `match` expression provides structured pattern matching.",
      "text": "match Expression The match expression provides structured pattern matching. Key ideas: A match selects one of several branches based on a scrutinee expression. match is an expression; all arms must be compatible in type. The compiler must: Enforce exhaustiveness rules (where specified). Type check each arm and compute a consistent result type. Surface Syntax The full language design includes rich pattern matching, guards, and matching over many scrutinee types. The current compiler implementation supports only a narrow, explicitly documented subset so we can validate end-to-end lowering and code generation. In the current implementation, match is accepted as an expression of the form: match <scrutinee> { <pattern> => <expr>, <pattern> => <expr>, } Notes: Arms are separated by commas; a trailing comma is permitted. Arm bodies are expressions (not blocks) in the current implementation. Optional Matching (T?) The currently implemented pattern subset is limited to optionals: The scrutinee expression must have optional type T? (Option(T)), where T is a payload type supported by the backend. Patterns are restricted to: None Some(<name>) Some() No guards (if ...) are implemented yet. Matches must be exhaustive for the optional scrutinee: there must be exactly one None arm and exactly one Some(...) arm (order is not significant). Example: fn main () -> int { let x: int? = Some(7); let y: int = match x { None => 5, Some(v) => v, }; return y; } Enum Matching (enum) The language design supports matching over user-defined enum types Defined initial subset: The scrutinee expression must have an enum type E (including an instantiated generic enum in module-set builds). Patterns are restricted to enum variants: unit variants: E::Cancelled or Cancelled tuple variants: E::Msg(x) / Msg(x) / E::Pair(a, b) / Pair(a, b) (binders may be identifiers or ) For instantiated generic enums, the qualifier E in patterns may be a type alias for the instantiation (for example type R = Result(int, string); then R::Ok(v) / R::Err(e)), or patterns may omit the qualifier and use the variant name directly. No guards (if ...) are implemented yet. Matches must be exhaustive for the enum scrutinee in the initial subset: there must be exactly one arm for each enum variant (order is not significant). Type Union Matching (T1 T2 ...) Defined initial subset: The scrutinee expression must have a union type T1 ... Tn. Patterns are restricted to typed binders: name: Ti (binds the payload as Ti), or : Ti (matches and ignores the payload), where Ti is one of the union member types. No guards (if ...) are implemented yet. Matches must be exhaustive: there must be exactly one arm per union member type (order is not significant). Semantics (Initial Subset) The scrutinee expression is evaluated exactly once. The selected arm is chosen based on the scrutinee value; non-selected arms are not evaluated. For Some(v) => ..., the binder v is in scope only within that arm and has type T (the inner payload type of the scrutinee T?). The result type of a match expression is the common type of its arms; all arms must type-check to the same result type in the current implementation. match Statement (Typed Errors) The language design also includes a statement form of match used for Surface form: match (expr) { pattern => { ... }, err: SomeError => { std::abort(); } } Key semantic rule (Terminal Arm Rule): If expr is an error-producing expression (its signature includes T ErrorType...), then any arm that matches an error type must end in a terminal statement. The compiler currently implements match as an expression for: the optional subset (T?), and exhaustive enum matches (no guards) for the current CFG IR backend subset. The statement form required for typed errors is implemented as part of the Note: the compiler also allows the match statement form to destructure recoverable Result-style values. This form does not trigger the Terminal Arm Rule because it is not a T ... typed-error expression. Result Matching (Ok(...) / Err(...)) The match expression also supports a small subset for recoverable \u201csuccess or error\u201d values. In the current implementation this includes: std::result::Result(T, E) (an enum with Ok(T) and Err(E) variants), and \u201cResult-like\u201d structs of the form { value: T?, err: E? }. For the struct form, the runtime invariant is: exactly one of value and err is Some(...). If this invariant is broken at runtime, execution traps. Patterns: Ok(name) / Ok() Err(name) / Err() Rules: Enum form: The scrutinee expression must have an enum type with variants Ok and Err. Ok(...) / Err(...) patterns are shorthand for R::Ok(...) / R::Err(...) where R is the scrutinee enum type, and may appear alongside other enum variant patterns. Exhaustiveness follows the enum rules: there must be exactly one arm per enum variant. Struct form: The scrutinee expression must have a nominal struct type that contains value: T? and err: E?. Matches must be exhaustive: for enum scrutinees, follow the enum rules (one arm per variant), for struct scrutinees, there must be exactly one Ok(...) arm and exactly one Err(...) arm. In Ok(v) => ..., the binder v has type T. In Err(e) => ..., the binder e has type E. Example: import std::result; import std::strings::String; fn main () -> int { let s: String = match String.fromstring(\"hello\") { Ok(v) => v, Err() => String.empty(), }; return s.len as int; } Relevant Tests Optional match expressions: Enum match expressions: Union match expressions: Result-like match expressions: Typed error-handling match statements:"
    },
    {
      "id": "language/flow-return",
      "title": "`return`",
      "section": "language",
      "summary": "The `return` statement exits a function, optionally with a value.",
      "text": "return The return statement exits a function, optionally with a value. Surface Syntax Return a value: return <expr>; Return from a void function: return; Semantics When a return statement executes: the current function terminates immediately, and control transfers back to the caller, carrying a return value if the function\u2019s result type is non-void. No statements after a return in the same control-flow path are executed. Type Checking Rules The checker enforces: return is only valid inside a function body (otherwise E2009). In a function with non-void result type R, return must provide an expression whose type is R (otherwise E2009). In a void function, return; is permitted and return <expr>; is rejected (E2009). In a function with non-void result, falling off the end of the function Examples Returning from main fn main () -> int { return 0; } Early return fn main () -> int { let x: int = 1; if x == 0 { return 0; } return 1; } return; in a void function struct Counter { value: int, } impl Counter { fn inc (mut self: &Counter) -> void { self.value += 1; return; } }"
    },
    {
      "id": "language/using",
      "title": "`using` (Aliases and Method Reuse)",
      "section": "language",
      "summary": "`using` introduces a local alias to an existing symbol, and (in `interface` / `impl` bodies) can import method signatures/implementations under a new name.",
      "text": "using (Aliases and Method Reuse) using introduces a local alias to an existing symbol, and (in interface / impl bodies) can import method signatures/implementations under a new name. This feature is intended to make large module trees ergonomic (short local names) and to enable explicit, audited method reuse across types. Syntax At any supported scope, using has two surface forms: using Alias = QualifiedName; using QualifiedName; using QualifiedName as Alias; Where QualifiedName uses the normal ::-separated name syntax (including the global-prefix form ::name). Module / Package Scope At module scope, using introduces a local alias for an in-scope symbol: types (struct / enum / error / interface / type aliases), functions (fn and ext function bindings), Formal Silk theories (theory). The alias is transparent: using Alias is equivalent to using the target symbol directly. Name conflicts are errors, except when the alias already refers to the same symbol as the target (a redundant alias). In that case the using declaration is accepted as a no-op. interface Scope Inside an interface { ... } body, using may import method signatures from another interface: interface Read { fn read() -> u8; } interface ReadAndPeek { using Read::read; fn peek() -> u8; } using Other::name; is equivalent to copying the corresponding fn name(...); signature from Other. using Other::name as alias; imports it under the new name alias. Name conflicts (including conflicts with inherited extends members) are errors. Note: interface method signatures omit the receiver parameter. The receiver is impl Scope Inside an impl Type { ... } body, using may import a method implementation from another impl: impl Foo { fn id(self: &Foo) -> int { return 1; } } impl Bar { using Foo::id; } This makes the imported method available as if it were declared in the target impl, including as a candidate for interface conformance checking. Visibility Imported methods inherit the source method\u2019s visibility: importing a public fn method produces a public method in the target impl, importing a private method produces a private method in the target impl. Since using does not accept visibility modifiers in Silk, this inheritance rule is the only way to control whether an imported method is callable outside the target impl { ... } block. Self and Layout Compatibility When the imported method\u2019s signature depends on Self (for example self: &Self, parameters of type Self, or returning Self), importing it across distinct struct types requires that the underlying layouts are compatible. In Silk, a pair of non-opaque, non-error structs are considered compatible when they have the same number of fields and the same field types in the same order (field names do not matter). If the source and target struct layouts are not compatible, the using declaration is rejected. Limitations using does not accept public / private modifiers yet (imported methods inherit the source method\u2019s visibility). Imported methods whose Self-dependent parameters require a mutable borrow (mut &Self) are rejected in Silk. Constructor reuse (constructor) via using is not supported yet."
    },
    {
      "id": "language/flow-while",
      "title": "`while` Loop",
      "section": "language",
      "summary": "The `while` loop repeatedly executes a block while a boolean condition holds.",
      "text": "while Loop The while loop repeatedly executes a block while a boolean condition holds. Surface Syntax Minimal form: while <condition> { // body } <condition> is an expression. Parentheses are optional because the condition is parsed using the normal expression grammar: while (x < y && y < 10) { ... } Loop Specifications (#invariant / #variant / #monovariant) The language supports attaching loop specifications immediately before a When Formal Silk syntax is present, the compiler proves these obligations with Z3 at compile time. invariant <expr>; variant <expr>; monovariant <expr>; while <condition> { ... } Semantics Evaluation rules: The condition is evaluated before each iteration. If the condition evaluates to true, the body block executes. After the body completes normally, control returns to the condition. If the condition evaluates to false, the loop terminates and execution continues after the loop statement. Control-flow statements inside the body follow their own definitions: Blocks create scopes. A let declared inside the body is not visible outside the loop\u2019s body block. Type Checking Rules The checker enforces: The loop condition must have type bool (otherwise E2001). Each #invariant expression must have type bool (otherwise E2001). If present, the #variant expression must have an integer type (int or a fixed-width integer; otherwise E2001). Each #monovariant expression must have an integer type (int or a fixed-width integer; otherwise E2001). invariant, #variant, and #monovariant expressions are compile-time-only (erased from runtime code). When Formal Silk verification is enabled by syntax, they are proved with Z3 during compilation. Examples Minimal loop with break fn main () -> int { while true { break; } return 0; } Loop with invariants and a variant fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; while i < limit { i = i + 1; } return 0; }"
    },
    {
      "id": "language/literals-aggregate",
      "title": "Aggregate Literals",
      "section": "language",
      "summary": "Aggregate literals cover arrays and structs.",
      "text": "Aggregate Literals Aggregate literals cover arrays and structs. Array Literals Array literals construct fixed-size array values from a list of elements. Surface Syntax An array literal is written using square brackets: let xs = [1, 2, 3]; let ys = [1, 2, 3,]; // trailing comma allowed Empty array literals are permitted only when an expected array type is available from context (so the compiler knows the element type and, for fixed-size arrays, the required length): let empty: i32[0] = []; let emptyslice: i32[] = []; Typing A non-empty array literal has type T[N] where N is the number of elements and T is inferred from the elements (or from an expected type when present). When an expected type is present and it is T[N], the literal must contain exactly N elements. When an expected type is present and it is T[], the literal\u2019s elements are type-checked against T and the resulting value has type T[]. In Silk, this slice form is lowered as a non-owning view over a compiler-generated backing array. The current implementation does not yet enforce lifetime rules for such slices; do not allow a slice derived from a stack-backed array literal to outlive the scope where it was created. Compiler requirements: Infer element type when possible, or require explicit annotation where ambiguity exists. Validate that all elements are convertible to the target element type. Enforce current-subset restrictions on which element types are supported for Struct Literals Struct literals construct values of struct types by specifying field names and values. Surface Syntax A struct literal may be written in two forms: An explicit struct literal begins with a struct type name followed by a brace-enclosed field initializer list. A contextual (inferred) struct literal omits the type name and consists only of the brace-enclosed field initializer list. This form is only valid when an expected struct type is available from context (for example a function argument position or an explicit type annotation). An explicit struct literal looks like: struct Pair { a: int, b: int, } fn make () -> Pair { return Pair { a: 1, b: 2 }; } An inferred struct literal looks like: struct User { name: string, } fn printuser (user: User) -> void { std::println(\"user.name = {}\", user.name); } fn main () -> int { // Equivalent to: printuser(User{ name: \"user name\" }); printuser({ name: \"user name\" }); return 0; } Initializers are written as either: fieldname: <expr> (explicit initializer), or fieldname (shorthand initializer, equivalent to fieldname: fieldname). Initializers are separated by commas and an optional trailing comma is permitted. Example (shorthand): struct User { name: string, } fn main () -> int { let name: string = \"alice\"; let user = User{ name }; // equivalent to User{ name: name } if (user.name != \"alice\") { return 1; } return 0; } Field defaults (struct declarations) A struct field declaration may include a default value expression: struct Beep { value: string = \"boop\", } When a struct literal omits a field, the compiler uses the field default expression when present; otherwise it falls back to zero-initialization in the current backend subset. This means the empty literal form is useful when all fields have defaults: let b = Beep {}; Important notes: Inferred struct literals are a value construction mechanism. They do not imply heap allocation. The compiler will not infer &T from { ... }; use new for heap allocation explicitly. The parser only treats { ... } as an inferred struct literal when it contains a struct-style initializer list (or is {}); blocks ({ Stmt }) remain statement syntax (there is no general \u201cblock expression\u201d in the current subset). Compiler requirements: Enforce that field names are valid and that each field is initialized at most once. Define the behavior for omitted fields (in Silk, omitted fields are default-initialized). Respect struct lowering/layout rules from structs-impls-layout.md. Details The current compiler implementation supports struct literals only for the limited struct subset described in structs-impls-layout.md: structs with 0+ fields of supported value types (scalar primitives, string, nested structs, and supported optionals), literals may omit fields: omitted fields that have a field default (field: T = <expr>) use that default expression, otherwise, omitted fields are zero-initialized in the current backend subset, no duplicate field initializers are permitted, field order is not semantically significant."
    },
    {
      "id": "language/arenas",
      "title": "Arenas",
      "section": "language",
      "summary": "Arenas are not part of the language surface. Use **regions** instead.",
      "text": "Arenas Arenas are not part of the language surface. Use regions instead."
    },
    {
      "id": "language/flow-blocks-statements",
      "title": "Blocks and Statement Composition",
      "section": "language",
      "summary": "Blocks group statements, establish lexical scopes, and provide the \u201cbody\u201d form for structured control-flow constructs like `if`, `while`, and the `match` statement used for typed errors.",
      "text": "Blocks and Statement Composition Blocks group statements, establish lexical scopes, and provide the \u201cbody\u201d form for structured control-flow constructs like if, while, and the match statement used for typed errors. Surface Syntax A block is a sequence of zero or more statements delimited by braces: { stmt0; stmt1; ... } The empty block {} is permitted. Statements the compiler supports these statement forms (see Local bindings: const (compile-time constant binding; initializer must be const-evaluable), let and let mut (and var as an alias for let mut). Specification-only declarations: #const (Formal Silk; not usable in runtime expressions). Expression statements: limited to calls, assignments, and increment/decrement Flow control: if / else statements, while loops, break, continue, return, assert, panic (typed errors), Semantics Sequencing Statements in a block execute in source order. If a statement transfers control out of the current block (return, panic, break/continue inside loops), the remainder of the block is not executed on that path. Scope A block introduces a lexical scope: Names declared by const/let/var are visible only after their declaration within the same block, and within any nested blocks. Inner blocks may shadow outer bindings by reusing a name (this is a normal lexical-shadowing rule; the checker should reject only when a specific feature imposes stricter rules). The special name is a discard binding: let = expr; and let : T = expr; evaluate the initializer but do not introduce a binding into scope. may be used repeatedly in the same scope without conflicts. Any produced runtime value is cleaned up at end-of-statement (not at scope exit). Destructuring let bindings bind multiple locals from a single struct value: Positional (field order): struct User { id: u64, name: string } let (id, name) = User{ id: 123, name: \"alice\" }; Named (by field name, order-independent), with aliasing: struct Record { id: u64, data: string } let { data, id } = Record{ id: 123, data: \"a record\" }; let { data as d, id as i } = Record{ id: 456, data: \"other record\" }; Array destructuring binds multiple locals from a single array/slice value: struct Record { id: u64, data: string } let records: Record[] = [{ id: 123, data: \"a\" }, { id: 456, data: \"b\" }]; let [a, b] = records; Rules: Only flat patterns are supported (no nested destructuring). The initializer is required. The initializer must have a non-opaque struct value type. The pattern must account for every field exactly once: positional patterns must have exactly one binder per declared field (in field order), named patterns must list each field exactly once (in any order), use to discard a field (let (, name) = ...; or let { data as } = ...;). For array/slice destructuring: The initializer must have an array type (T[N]) or slice type (T[]). Each binder is positional (index order). The pattern binds exactly the number of listed binders: fixed arrays require an exact arity match ([a, b] requires T[2]), slices trap at runtime if too short (as if indexing each element). Enum destructuring binds payload elements from a single enum variant: import std::result; error Oops { code: int } fn foo (oops: bool) -> std::result::Result(int, Oops) { if (oops) { return Err(Oops{ code: 123 }); } return Ok(7); } fn main () -> int { // Destructure Ok(...) and bind its payload. // If the value is Err(...), the program traps. let Ok(value) = foo(false); return value; } Rules: The initializer is required. The initializer must have an enum type E (including a monomorphized generic enum). The initializer value is consumed (moved); the original binding may not be used after destructuring. The pattern must be an enum variant pattern: Variant(...) (shorthand), or E::Variant(...) / pkg::E::Variant(...) / ::pkg::E::Variant(...). Binder arity must match the variant payload arity (use to discard payload elements). If the runtime value is not the matched variant, execution traps. const bindings are compile-time constants: their initializer expression must be compile-time evaluable (otherwise the compiler reports an error), the binding is immutable (there is no const mut), a const binding is a normal runtime value (unlike #const), but its value is computed by the compiler at compile time and does not incur runtime computation cost in Silk. In Silk, compile-time evaluation for runtime const bindings is restricted to: scalar primitive types (bool, integer/float scalars, char, Instant, Duration), and pure scalar expressions composed of: literals, other const bindings, calls to const fn functions where all arguments are themselves compile-time evaluable, and as casts between supported scalar types, and a small operator subset (notably +, -, , bitwise ops, shifts; / and % are currently rejected for const). string bindings whose initializer is either: a string literal (\"...\" or ` ... ), or another const string binding. Formal Silk declarations (#const) are compile-time-only names intended for specifications (#require, #assure, #assert, #invariant, #variant, #monovariant). They must not be referenced Blocks as Expressions The broader language design includes expression-oriented flow constructs (for example match expressions today and if expressions). In Silk: a block is not an expression and does not produce a value; it is purely a statement list used as the body of constructs. The if expression form is a special-case expression-oriented construct; it does not make { ... } a general expression form. If/when general block expressions are introduced, the spec will define: which contexts accept them (and how ambiguity with { ... }` struct literals is resolved), and how their result values are computed. Examples Nested scope fn main () -> int { let x: int = 1; { let y: int = 2; if x < y { return 0; } } return 1; } Formal Silk declarations for loop specifications fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; while i < limit { i = i + 1; } return 0; }"
    },
    {
      "id": "language/literals-boolean",
      "title": "Boolean Literals",
      "section": "language",
      "summary": "Boolean literals are the two built-in logical values:",
      "text": "Boolean Literals Boolean literals are the two built-in logical values: true false Examples Basic control flow fn main () -> int { let ready: bool = true; if ready { return 0; } else { return 1; } } Short-circuit evaluation fn returnsfalse () -> bool { return false; } fn main () -> int { // Because the left operand is true, the right operand is evaluated. let a: bool = true && returnsfalse(); if a { return 1; } // Because the left operand is false, the right operand is not evaluated. let b: bool = false && returnsfalse(); if b { return 2; } return 0; } Common Pitfalls Assuming \u201ctruthy\u201d values: bool is a distinct type. Use comparisons to produce a bool (for example x != 0) rather than writing if x { ... }. Forgetting short-circuiting: && and may skip evaluating the right operand; do not rely on side effects in the skipped operand. Related Documents Relevant Tests Boolean control flow: Short-circuit semantics: Unary !:"
    },
    {
      "id": "language/borrow-checker",
      "title": "Borrow Checking (Static Alias and Lifetime Safety)",
      "section": "language",
      "summary": "This document specifies Silk\u2019s intended borrow-checking model for references.",
      "text": "Borrow Checking (Static Alias and Lifetime Safety) This document specifies Silk\u2019s intended borrow-checking model for references. call-scoped alias checks for mutable borrows (including slice range borrows), lexical lifetime checks for slice and reference borrows (no escaping borrows of stack locals), and a small explicit ownership-transfer form (move) used by the checker and lowering to prevent accidental double-drops in the safe subset. Goals Prevent use-after-free and data races in safe code. Make mutation explicit and intentional. Reject invalid borrows at compile time (no runtime borrow errors required for safe code). Keep diagnostics actionable (highlight the borrow origin, conflicting use, and suggest a fix). Details Today, the language subset implemented by the compiler supports only: call-scoped borrow alias checks for: borrowed reference parameters (&T, mut p: &T), and slice parameters (T[], mut s: T[]) and slice range borrows (&base[start..end], mut &base[start..end]). first-class borrowed &Struct values created from borrowable lvalues: &expr (borrow operator) for borrowable lvalues, and implicit borrow coercions in contexts that expect &T (for example let r: &Pair = pair;). Additionally, the subset implements lexical lifetime checks for both slice borrows and borrowed &T values so obvious use-after-scope cases are rejected (for example returning a slice borrowed from a local fixed array, or returning &T borrowed from a local struct binding). Lexical Lifetimes Slices (T[]) are non-owning views. Slice range borrows create slices that point into existing storage: &base[start..end] creates a slice view whose lifetime is tied to base. When borrowing a range from an existing slice binding s: T[], the borrow\u2019s underlying origin is s\u2019s origin (sub-slicing does not extend lifetime). Lexical lifetime rules enforced by the compiler: A slice value that ultimately borrows from a local fixed array binding (T[N]) may not escape that binding\u2019s lexical scope. Returning such a slice from a function is rejected. Assigning such a slice into outer-scope storage is rejected (including via field assignment and via mutable reference parameters). Returning a slice is permitted when the returned slice ultimately borrows from a function parameter (for example returning a sub-slice of a T[] parameter). These rules are intentionally conservative and are expected to be generalized to a richer lifetime model as more borrow forms become first-class. Lexical Reference Lifetimes Borrowed &T values that ultimately reference stack storage may not escape that storage\u2019s lexical scope. This includes: returning a borrowed &T that points to a local struct binding, and assigning such a borrowed reference into outer-scope storage. Returning a reference is permitted when the returned &T ultimately refers to an input reference parameter (that is, storage owned by the caller), and not to stack locals. Ownership Transfer (move) Silk\u2019s safe subset includes a small explicit ownership-transfer form: move <name> This expression: consumes the binding <name> when its type requires ownership tracking (for example values that are dropped on scope exit), and makes <name> unavailable for further use until it is reinitialized (for var) or permanently (for let). This enables moving values into other values (for example as call arguments or as the payload of Some(...)) without accidentally copying a resource-owning value and dropping it twice. In Silk, ownership transfer is intentionally conservative: A binding may not be moved while it has any live borrows (reference or slice views) in scope, including borrows stored in struct fields. A by-value call argument that requires ownership tracking is treated as a move, and is rejected when the same binding is also borrowed in that call. Planned Expansion As the language grows, borrow checking is expected to expand to cover: borrowed references as first-class values (&expr producing &T values), references and borrows in more positions (locals, fields, returns), lifetime/region inference across control flow, explicit disambiguation when multiple input references exist (for example a label syntax like as A to tie a return reference to a specific input), restrictions around suspension points in async/await, and well-defined rules for passing references across FFI boundaries. document before implementation lands, and must be reflected in diagnostics"
    },
    {
      "id": "language/buffers",
      "title": "Buffers",
      "section": "language",
      "summary": "`Buffer(T)` is an intrinsic type providing low-level access to a contiguous block of memory. It is intentionally unsafe and used as a foundation for higher-level collections and strings.",
      "text": "Buffers Buffer(T) is an intrinsic type providing low-level access to a contiguous block of memory. It is intentionally unsafe and used as a foundation for higher-level collections and strings. Key points: Buffer(T) is a \u201cfat pointer\u201d with: a raw pointer to the start of the memory block, a capacity (number of elements that can be stored). Buffer(T) does not track the number of initialized elements (length). The intrinsic API includes operations such as: std::buffer::alloc std::buffer::write std::buffer::read std::buffer::capacity std::buffer::drop std::buffer::view std::buffer::slice The safety model is layered: Layer 1: unsafe Buffer(T) primitive. Layer 2: compile-time safety via the verifier. Layer 3: provable safety via refinement types. Compiler requirements: Treat Buffer(T) as an intrinsic type with special semantics. Ensure the verifier has enough information to reason about buffer safety. Coordinate with the standard library so that safe collections are built on top of Buffer(T)."
    },
    {
      "id": "language/build-metadata",
      "title": "Build Metadata (`BUILD_KIND`, `BUILD_MODE`, `BUILD_VERSION`)",
      "section": "language",
      "summary": "Silk exposes a small set of compiler-provided **build metadata** values to both runtime code and Formal Silk (compile-time verification) so programs can adapt to build configuration and so theories can express \u201cthis code is only valid in",
      "text": "Build Metadata (BUILDKIND, BUILDMODE, BUILDVERSION) Silk exposes a small set of compiler-provided build metadata values to both runtime code and Formal Silk (compile-time verification) so programs can adapt to build configuration and so theories can express \u201cthis code is only valid in test builds\u201d, \u201cthis feature requires a minimum version\u201d, and similar policies. Built-In Constants The compiler provides the following built-in constants in every module: BUILDKIND: string BUILDMODE: string BUILDVERSION: string BUILDVERSIONMAJOR: u64 BUILDVERSIONMINOR: u64 BUILDVERSIONPATCH: u64 These behave like normal const string values: They do not require an import. They may be used anywhere a string expression is allowed. They are compile-time constants (their values are fixed at compile time and are embedded into the output artifact). BUILDKIND The output kind currently being built: \"executable\" \"object\" \"static\" \"shared\" BUILDMODE The build mode currently being built: \"debug\" \"release\" \"test\" Notes: \"test\" is the mode used by silk test. Debug stack traces and debug assertion behavior are controlled separately by BUILDVERSION The semantic version of the current package when building from a manifest. When building from a package manifest (silk.toml), BUILDVERSION is the manifest version. When not building from a manifest, BUILDVERSION is \"0.0.0\". BUILDVERSIONMAJOR / BUILDVERSIONMINOR / BUILDVERSIONPATCH The SemVer core triplet (major.minor.patch) of BUILDVERSION exposed as u64 values for convenient comparisons (especially in Formal Silk). Rules: These parse the major.minor.patch prefix of BUILDVERSION. Any trailing -prerelease or +build suffix is ignored. On parse failure, all three values default to 0. Relationship to std::runtime::build The standard library provides std::runtime::build functions that return the same metadata: std::runtime::build::kind() -> string std::runtime::build::mode() -> string std::runtime::build::version() -> string Use std::runtime::build when you prefer explicit namespacing or when writing code intended to run under alternate stdlib roots. Examples Build-mode gated behavior fn main () -> int { if BUILDMODE == \"test\" { // Test-only behavior. return 0; } return 0; } Version-gated behavior For semver parsing and comparison, use std::semver at runtime or reuse the"
    },
    {
      "id": "language/literals-character",
      "title": "Character Literals",
      "section": "language",
      "summary": "Character literals represent Unicode scalar values (code points) and have type",
      "text": "Character Literals Character literals represent Unicode scalar values (code points) and have type Use char for: single-character markers and delimiters (e.g. ',', ':'), working with code points when interfacing with parsing/lexing logic, representing control characters ('\\n', '\\t', '\\0'). Surface Syntax Character literals are delimited by single quotes: let a: char = 'x'; Rules: The contents must represent exactly one Unicode scalar value. A character literal must not span multiple lines. The source file is interpreted as UTF-8. Escapes Inside a character literal, \\ introduces an escape sequence. Supported escapes in the current implementation: \\n \u2014 U+000A (line feed) \\r \u2014 U+000D (carriage return) \\t \u2014 U+0009 (tab) \\0 \u2014 U+0000 (NUL) \\\\ \u2014 backslash \\' \u2014 single quote \\\" \u2014 double quote \\xNN \u2014 a code point given as exactly two hex digits \\u{...} \u2014 a code point given as 1\u20136 hex digits Unicode rules: The decoded code point must be a Unicode scalar value: range 0x0000..=0x10FFFF, excluding the surrogate range 0xD800..=0xDFFF. For \\u{...}, values outside that range are rejected. Semantics Evaluating a character literal produces a char value whose numeric value is the decoded Unicode code point. In Silk, that code point is carried as a u32 scalar. This is an implementation detail; the language-level rule is \u201ca char is a Unicode scalar value\u201d. Examples ASCII and punctuation fn main () -> int { let comma: char = ','; if comma == ',' { return 0; } return 1; } Unicode: literal UTF-8 vs \\u{...} fn main () -> int { let a: char = '\u00e9'; let b: char = '\\u{00E9}'; if a == b { return 0; } return 1; } Escape sequences fn main () -> int { if '\\n' != '\\x0A' { return 1; } if '\\r' != '\\x0D' { return 2; } if '\\t' != '\\x09' { return 3; } if '\\0' != '\\x00' { return 4; } if '\\\\' != '\\u{005C}' { return 5; } if '\\'' != '\\x27' { return 6; } if '\\\"' != '\"' { return 7; } return 0; } Common Pitfalls Using double quotes: \"x\" is a string, not a char. Use 'x'. Writing more than one character: 'ab' is invalid; use \"ab\". Source encoding surprises: prefer \\u{...} for non-ASCII characters when you want the source spelling to be stable across editors/fonts. Confusing \\xNN between char and string: for char, \\xNN denotes a code point value, Related Documents Relevant Tests Unicode char equality and \\u{...} escape: Returning and comparing char values: Escape coverage:"
    },
    {
      "id": "language/concurrency",
      "title": "Concurrency",
      "section": "language",
      "summary": "Concurrency in Silk is built around two orthogonal function modifiers:",
      "text": "Concurrency Concurrency in Silk is built around two orthogonal function modifiers: async \u2014 marks a function as pausable/awaitable (concurrency), task \u2014 marks a function as safe to execute on a worker pool (parallelism), plus structured concurrency blocks (async { ... } and task { ... }) intended to provide structured concurrency. The runtime manages a thread pool to execute tasks. The compiler is intended to enforce task-safety rules when values cross task boundaries (Send/Sync-like constraints). Core Keywords: async and task async Marks a function as awaitable (pausable). Primary domain (design): I/O-bound concurrency on an event loop/executor. task Marks a function as task-safe and eligible to be executed as a parallel task on a worker pool. Primary domain (design): CPU-bound parallelism and offloading blocking work. In the intended design, calling a task fn is non-blocking and produces a task handle. await await <expr> is the surface syntax for unwrapping a Promise(T) handle. In Silk: await Promise(T) unwraps the completed promise and yields T. await Promise(Task(T)) yields Task(T) (which can then be consumed via yield / yield ). await Task(T) is rejected; use yield / yield for task values. Task/Promise Handle Ownership In Silk, Task(T) and Promise(T) are single-use handles: A Promise(T) handle may be awaited at most once. await consumes the handle. A Task(T) handle may be drained/joined at most once via yield (and yield on a temporary task expression drains/joins as well). Handles are non-copyable: you may not copy a handle into another binding or use it as a normal value expression. A consumed handle may not be used again (including attempting to await it a second time, or attempting to yield it a second time). Consuming a handle that was created outside the current loop body is rejected In Silk (a loop may iterate multiple times). These rules are enforced at compile time and exist to prevent double-free and use-after-free bugs in the current runtime lowering, where await frees the underlying handle storage after join/unwrap. Handle Lifetime and Cleanup In Silk, Task(T) and Promise(T) handles are stored in heap-allocated handle memory: await unwraps a promise and then frees the promise handle storage. yield drains/joins a task and then frees the task handle storage. If a handle is not consumed (await/yield ), the compiler inserts automatic cleanup when the handle binding is overwritten or goes out of scope: Task(T) cleanup joins the worker thread and then frees the handle storage. Promise(T) cleanup frees the handle storage. Because the current runtime subset uses OS threads (no coroutine transform or event loop), this automatic cleanup can block the current OS thread when it joins a task. yield yield is the task-side counterpart to await. In the intended model for tasks: A task fn ... -> T produces a Task(T) handle when called. Inside the task body, yield <expr>; sends a value (convertible to T) to the task\u2019s receiver and continues execution. return <expr>; sends the final task value (of type T) and terminates the task. Outside the task, yield <taskhandle> blocks until the task produces its next value and yields it. yield <taskhandle> drains all remaining task values and then joins the worker thread for cleanup, yielding a collected T[] in value position. yield <taskhandle>; as a statement forwards all remaining values from the right-hand task to the enclosing task\u2019s receiver and then joins/cleans up the drained task. In Silk: yield is a blocking OS-thread operation (like the rest of the current concurrency runtime). yield is permitted only inside task fn / async task fn bodies and inside task { ... } / task loop { ... } blocks. The statement forms (yield <value>; and yield <taskhandle>; forwarding) require an enclosing task function (task fn / async task fn), since they send values to the task\u2019s receiver. Collected Array Ownership In Silk, yield and await produce a heap-allocated collection of values (T[]) for convenience. This is a current behavior: the compiler inserts deterministic cleanup for these collections when their bindings are overwritten or go out of scope, the returned T[] value must not be copied, and must not escape its defining scope until a stable owning collection type is specified. Structured Concurrency Blocks and Loops async { ... }, task { ... }, async loop { ... }, and task loop { ... } introduce structured regions intended for scheduler-backed concurrency and ensure all work started in the region completes before exit. In Silk, these forms parse and type-check, but they do not yet introduce any runtime scheduling; they currently behave like a normal lexical block. Future Work: Runtime and Safety The long-term design is to provide: a well-defined Task(T) handle type, scheduler-backed lowering of task calls into non-blocking spawns, await that unwraps promises and propagates errors/contracts, yield / yield that receive/drain tasks without blocking the OS thread, structured blocks (async { ... } / task { ... }) that provide well-delimited lifetimes, static rules for data-race prevention and safe sharing across tasks."
    },
    {
      "id": "language/const-functions",
      "title": "Const Functions (`const fn`)",
      "section": "language",
      "summary": "Silk supports compile-time evaluation of certain expressions to produce compile-time constants. `const fn` (and `const pure fn`) declarations opt a function into this compile-time evaluation system so that it can be called from",
      "text": "Const Functions (const fn) Summary Silk supports compile-time evaluation of certain expressions to produce compile-time constants. const fn (and const pure fn) declarations opt a function into this compile-time evaluation system so that it can be called from compile-time contexts (for example, a const binding initializer). Syntax const is a function modifier: const fn add (a: int, b: int) -> int { return a + b; } const pure fn add2 (a: int, b: int) -> int { return a + b; } Notes: const pure fn is simply a const fn that also opts into the pure rules (see function-disciplines.md). const fn is a compile-time-only function: it may be called only from compile-time contexts (for example const initializers and Formal Silk specifications), it is not emitted as a runtime/linkable symbol in executable, object, or library outputs. Compile-Time Values In this document, a \u201ccompile-time value\u201d is a value that the compiler can produce and manipulate during compile-time evaluation. (initial implementation target): scalar primitives: bool fixed-width integers (i8, u8, i16, u16, i32, u32, i64, u64) int f32, f64 char Instant, Duration Planned (not yet supported for const fn In Silk): string values (string literals are supported directly in const bindings), aggregate values (struct/enum/optional/slice/array) as return values, function values as compile-time values (for higher-order const evaluation). Rules The defines a deliberately small \u201cconst-eval VM\u201d surface. A const fn must fit within this surface. Signature rules In Silk, a const fn: must not be task or async, must not declare a typed-error contract (-> T ErrorType...), must have a non-void return type that is a compile-time value type, must have parameters whose types are compile-time value types. Body rules In Silk, a const fn: must not allocate (new) and must not use regions/with, must not contain panic statements, must not declare const local bindings, may call only other const fn declarations, is restricted to a small expression subset over scalar values: literals and local names (parameters and let bindings; no global const reads in Silk), as casts between supported scalar types, unary operators: -, ~, !, binary operators: arithmetic: +, -, (division/modulo are not part of the const-eval subset), bitwise: &, , ^, <<, >>, comparisons: ==, !=, <, <=, >, >=, if expressions (if cond { a } else { b }). assignments to local names: =, +=, -=, =, plus ++/--. Control flow is limited to: if / else statements, while loops with boolean conditions, break / continue, return statements. Calling Const Functions The initial intended compile-time use site is const bindings: const fn add (a: int, b: int) -> int { return a + b; } const answer: int = add(20, 22); fn main () -> int { return answer; } Const functions may also be imported/exported across modules/packages like runtime declarations, but they are still compile-time-only: importing a const fn does not make it callable from runtime code. \u201cNo Static Storage\u201d Rule Const functions do not create new static storage. In particular: compile-time execution may compute scalar values and fold them into constants, compile-time execution must not allocate heap memory, compile-time execution must not synthesize new global read-only data (for example, it cannot build a new string at compile time in Silk). String literals are still backed by read-only static storage, but they are introduced by the literal syntax itself (see literals-string.md), not by the const fn evaluator. Evaluation Limits Compile-time evaluation must terminate. The current implementation enforces an instruction budget and a call-depth budget when executing const fn bodies at compile time; evaluation that exceeds these budgets is rejected as not compile-time evaluable."
    },
    {
      "id": "language/dependent-types",
      "title": "Dependent Types (Const Parameters and Type-Level Computation)",
      "section": "language",
      "summary": "This document specifies Silk\u2019s intended support for \u201cdependent-type-like\u201d patterns where types mention compile-time values (most notably integers).",
      "text": "Dependent Types (Const Parameters and Type-Level Computation) This document specifies Silk\u2019s intended support for \u201cdependent-type-like\u201d patterns where types mention compile-time values (most notably integers). declaration parameter lists on struct, impl, and fn, type application in type positions (for example VectorN(int, 1024)), but the compiler does not yet implement constraint checking, inference, or monomorphization/code generation for parameterized declarations. In the current compiler subset, generic parameter lists and applied types are rejected during Const Parameters Const parameters are compile-time values that appear in parameter lists with a type annotation: struct VectorN(T, N: int) { / ... / } Where: T is a type parameter, and N: int is a const parameter whose value must be known at compile time. The initial supported const-argument form in type application is integer literals (for example VectorN(int, 1024)). Type-Level Computation The language intends to allow certain expressions over const parameters in type positions (design-only): fn concat(T, M: int, N: int; a: VectorN(T, M), b: VectorN(T, N)) -> VectorN(T, M + N) { // ... } This requires: a notion of const expressions at the type level, evaluation rules (and overflow behavior) for those expressions, and a compilation strategy (typically monomorphization) that produces concrete layouts and code for each instantiated type. Function Parameter Lists (CT/RT Split) Generic functions use a single parameter list split by a top-level ; inside the parentheses: fn id(T; x: T) -> T { return x; } fn g(T;) -> T { / CT-only, rare / } fn h(x: int) -> int { return x; } // RT-only This split is parsed and preserved by the front-end, but generic functions are rejected by the current checker until monomorphization is implemented Relationship to Arrays and Collections Const parameters are intended to power: fixed-size arrays (T[N]), dependent-length collections (for example VectorN(T, N)), and compile-time-checked indexing/slicing APIs. These features require additional language and runtime support beyond the current compiler subset."
    },
    {
      "id": "language/literals-duration",
      "title": "Duration Literals",
      "section": "language",
      "summary": "The `Duration` and `Instant` types have specialized literal support.",
      "text": "Duration Literals The Duration and Instant types have specialized literal support. Syntax Duration literals are written as a decimal integer or decimal float immediately followed by a unit suffix: Examples: 10ns 250us 5ms 1s 1.5s 2min 1h The unit suffix is part of the literal token; the lexer must not split it into an integer token followed by an identifier. Units The current implementation recognizes the following suffixes: ns \u2014 nanoseconds us \u2014 microseconds ms \u2014 milliseconds s \u2014 seconds min \u2014 minutes h \u2014 hours d \u2014 days Semantics Duration literals evaluate to a Duration value represented as an i64 nanosecond count. For integer forms (e.g. 5ms), the value is scaled exactly. For floating-point forms (e.g. 1.5s), the value is scaled and then rounded toward zero to an integral nanosecond count. If the scaled value does not fit in i64, compilation fails. Compiler requirements: Implement lexing rules that distinguish unit suffixes from identifiers. Map duration literals to the Duration type with correct unit scaling. Ensure constant-evaluation behavior (rounding, overflow) matches the spec."
    },
    {
      "id": "language/errors",
      "title": "Errors",
      "section": "language",
      "summary": "For unrecoverable logic bugs and contract violations, Silk uses **typed errors** (`error`, `panic`, and `T | ErrorType...`), specified in",
      "text": "Errors For unrecoverable logic bugs and contract violations, Silk uses typed errors (error, panic, and T ErrorType...), specified in Design Goals Error signaling is explicit and typed (no hidden global error state). Error paths are part of normal control flow, not out-of-band exceptions. The verifier can reason about both success and error paths symmetrically. The C99 ABI must be able to represent error outcomes in a stable, documented way. Recoverable Errors (Recommended Pattern) Silk distinguishes between: Recoverable errors (invalid user input, I/O failures, parse failures): model these as normal values, typically using std::result::Result(T, E) or an optional (T?). Typed errors (T ErrorType... + panic): reserved for unrecoverable contract violations and logic bugs that should not be silently ignored (see Example: Recovering from URL parse errors std::url exposes a recoverable parsing API (std::url::parse) that returns a tagged result (std::url::URLResult), so callers can report an error and keep going without aborting. A runnable example that wraps URLResult into std::result::Result and parses all command-line arguments is in: examples/featureerrorsrecoverableurlparse.slk Error Representation From the overall language design: Silk favors explicit types such as: optionals (T? / Option(T)) for \u201cmay be present / may be absent\u201d values. domain-specific error types (enums or structs) for richer error reporting. Functions that can fail should surface that in their type signatures: either by returning a value that encodes both success and error (e.g. an optional or a nominal error-aware type), or by returning an error-only type where success is absence of error. The naming and shapes of error-carrying types are defined by this language spec and by standard library APIs, but the compiler must: treat them as regular, first-class types, enforce that callers handle them appropriately (e.g. via pattern matching, explicit checks). Interaction with Control Flow Error-aware types integrate with control flow constructs: if / match can be used to branch on error vs. success cases. Pattern matching can destructure enum-based error types, exposing error codes or payloads. Optionals (T?) can be used where \u201cabsence\u201d is a common error shape; they compose with ?. and ?? to keep code concise while still explicit. The compiler must: ensure that branches that depend on error conditions are type-checked, support exhaustiveness checks when matching on error enums/types. Verification and Errors Formal Silk constructs (#require, #assure, #assert, #invariant, #variant, #monovariant) apply equally to: success paths (e.g. postconditions describing the returned value), error paths (e.g. guarantees about when and how certain errors can occur). The verifier should be able to: treat error-carrying types as ordinary values with invariants, prove that certain errors cannot happen given preconditions, or, conversely, require explicit handling of error cases when the proof cannot eliminate them. ABI and FFI Considerations On the C99 side: For external functions declared via ext, any error behavior must be captured in the Silk-side function type and corresponding C signature (e.g. error-return codes, nullable pointers, or explicit error structs). The compiler must: preserve error-related information across the FFI boundary, avoid implicit, hidden error channels (such as untracked global error codes) in favor of explicit parameters or return values. Assertions (assert) assert is a debugging/safety construct intended to catch programmer mistakes. It is not part of Silk\u2019s typed error model and is not a replacement for returning optionals or Result(...). Syntax (initial): assert <Expr>; assert (<Expr>, <message>?); Rules: The condition expression must type-check as bool. The optional message, when present, must type-check as string. Runtime behavior : By default (release builds), if the condition evaluates to false, execution traps immediately (a panic-like abort). In the current linux/x8664 backend this is implemented as an invalid-instruction trap. In debug builds (silk build --debug / -g) on linux/x8664, a failed assertion prints a panic header, the optional message (when present), and a stack trace to stderr when available (via glibc backtracesymbolsfd) before aborting. Notes: Failed assertions are currently isolated by the silk test runner (each test runs in its own process). Future work may allow reporting failed assertions without process isolation (for example by lowering assert to a typed error in test contexts)."
    },
    {
      "id": "language/flow-expression-statements",
      "title": "Expression Statements",
      "section": "language",
      "summary": "Expression statements allow expressions to be used for their side effects.",
      "text": "Expression Statements Expression statements allow expressions to be used for their side effects. Syntax An expression statement is an expression followed by a semicolon: expr; Semantics The expression is evaluated exactly once. The result value (if any) is discarded. Current implementation restrictions For the compiler, an expression statement is only valid when the expression is either: a call expression (a function call), or an assignment / compound assignment expression. an increment/decrement expression (++x, x++, --x, x--). All other expression statements are rejected. This restriction will be relaxed as more of the expression language is lowered and code-generated. Examples (accepted in Silk): fn main () -> int { std::io::println(\"hello\"); let mut x: int = 0; x = 1; x += 2; x++; return 0; } Examples (rejected in Silk): fn main () -> int { 1 + 2; // rejected: non-call/non-assignment expression statement (E2002) return 0; } Guidance If you computed a value and you want to keep it, bind it: fn main () -> int { let x: int = 1 + 2; return x; } If you want a value for control flow, prefer an expression form that produces a Compiler requirements The compiler must: Distinguish between expressions that can appear as statements and those that cannot (if the spec imposes restrictions). Preserve evaluation order consistent with the language\u2019s semantics."
    },
    {
      "id": "language/ext",
      "title": "External Declarations (`ext`)",
      "section": "language",
      "summary": "Silk\u2019s external declaration feature lets Silk code call foreign functions and access foreign variables.",
      "text": "External Declarations (ext) Silk\u2019s external declaration feature lets Silk code call foreign functions and access foreign variables. The core construct is the ext definition, which declares: external C functions and their Silk function types, or external C variables and their Silk types. The compiler and runtime perform marshalling between Silk\u2019s internal representations and the C ABI, following a documented mapping. Declaring an External Binding Example: ext foo = fn (string) -> void; ext bar = u32; Here: foo is a C function named foo with the given Silk function type. bar is a C variable of type u32. Binding a Different External Symbol Name Sometimes you want the Silk binding name to differ from the linked external symbol name (for example, when writing wrapper modules that want to expose stable public API names without colliding with imported libc names). Syntax: // The binding name is cmalloc, but the linked symbol is malloc. ext cmalloc \"malloc\" = fn (i64) -> u64; ext cfree \"free\" = fn (u64) -> void; Rules: The identifier after ext is the Silk binding name (used for imports and calls from Silk code). The optional string literal is the external symbol name used for linking (native) or as the import name (wasm). If the string literal is omitted, the external symbol name is the same as the binding name. Avoiding Shadowing (Global ::...) If an ext binding is declared in the global namespace (a module with no package ...; or header-form module ...; declaration) and a local declaration shadows it (for example, a wrapper function named malloc), use the global-name prefix to force lookup of the global binding: return ::malloc(bytes); The global-name prefix is not limited to ext: it also applies to type names and enum variant paths in expression and type positions (for example, ::Foo, ::Foo{...}, or ::E::Variant), always forcing resolution in the global (unnamed) package. Verification and ext (Silk rule) External declarations have no body available to the verifier. Therefore: It is a compile-time error to attempt to verify an ext declaration. It is a compile-time error for verified code (code whose compilation requires proofs) to call an ext function or read an ext variable. This intentionally limits verification across the ext boundary. Opaque Struct Handles Opaque structs are intended for representing foreign pointers/handles safely. They strengthen type safety at the language boundary by preventing accidental mixups between different handle types and by disallowing invalid operations in Silk. Declare an opaque handle type with a fieldless struct declaration: // runtime.slk struct StringBuilder; ext sbnew = fn () -> &StringBuilder; ext sbappend = fn (&StringBuilder, string) -> void; ext sbdestroy = fn (&StringBuilder) -> void; Use the handle by importing the type name and the ext functions: import { StringBuilder, sbnew, sbappend, sbdestroy } from \"./runtime.slk\"; fn main () -> int { let sb: &StringBuilder = sbnew(); sbappend(sb, \"hello\"); sbdestroy(sb); // Using sb after destroy is UNDEFINED BEHAVIOR (dangling foreign pointer). return 0; } Rules: The handle type must be used behind & (&StringBuilder), not by value. Opaque structs cannot be instantiated and do not support member access. Safety: You are responsible for managing the lifetime of foreign handles. Most C APIs provide explicit create/destroy functions; always call the destruction function when you are done. Using a handle after destruction is undefined behavior; the compiler does not currently enforce this at compile time. Notes on executable ext calls (current linux/x8664 implementation): When an executable uses ext calls or ext variable reads, the compiler emits a dynamically-linked ELF64 executable (PIE-style ETDYN with PTINTERP, .dynamic, .rela.dyn, and a .got). External symbols are resolved by the platform dynamic loader. Dependencies can be declared via the CLI (silk build --needed <soname> ...) or via the C99 embedding API (silkcompileraddneededlibrary), and runtime search paths can be declared via --runpath / silkcompileraddrunpath. ABI Contract (Overview) The language defines two closely related views of the ABI: A \u201cfat pointer\u201d internal representation for string and regexp: conceptually: struct string { ptr: ptr, len: i64 } where ptr is a UTF\u20118 pointer. conceptually: struct regexp { ptr: ptr, len: i64 } where ptr is an engine-owned bytecode pointer. A C ABI contract (e.g. via silk.h) using an explicit struct: typedef struct { char ptr; int64t len; } SilkString; A mapping to an LLVM type used internally by the compiler: %silk.string = type { i8, i64 } When calling conventional C APIs, the compiler may pass a const char derived from this structure, with the guarantee that the underlying data is null\u2011terminated. This distinction is important: Internal/runtime ABI: operates on { ptr, len } structs (SilkString). Compatibility calls to typical C libraries: may expose const char for parameters declared as string in Silk ext declarations, with the compiler extracting the ptr. Primitive Type Mapping The spec includes a table mapping Silk primitive types to C types, for example: i8, u8 \u2192 int8t, uint8t i16, u16 \u2192 int16t, uint16t i32, u32 \u2192 int32t, uint32t i64, u64 \u2192 int64t, uint64t int \u2192 int64t (current linux/x8664 baseline; do not assume C int) f32 \u2192 float f64 \u2192 double bool \u2192 bool (or Bool) char \u2192 uint32t (UTF\u201132) string \u2192 SilkString ({ char ptr; int64t len; }) regexp \u2192 SilkString ({ char ptr; int64t len; }, opaque bytecode view) void \u2192 void Notes: For FFI with APIs that use a C int (for example many POSIX syscalls), prefer i32/u32 in your ext declarations rather than int. The stable C99 ABI does not use compiler-specific int128 or float128 types for these primitives; it uses explicit { lo, hi } structs so the ABI is portable and can be expressed in strict C99. These mappings must be reflected exactly in the C99 ABI. Strings and Passing Convention For strings, the spec makes the following points: Silk\u2019s string is represented internally as a { ptr, len } pair. For ext calls to typical C APIs: the compiler can extract ptr and pass it as a const char , the data is guaranteed to be null\u2011terminated so standard C string functions are safe. For regex bytecode values (regexp): Silk\u2019s regexp is represented internally as a { ptr, len } pair with the same slot layout as string, but the bytes are not text and are not required to be null\u2011terminated. At ABI boundaries, regexp uses the same C shape as SilkString, but C code must treat it as an opaque (ptr, len) byte span (not a C string). For the embedding ABI (libsilk.a): We treat SilkString ({ char ptr; int64t len; }) as the primary C representation of Silk string values. Functions exported by libsilk.a will use SilkString in their signatures wherever strings cross the boundary. This layered design allows: idiomatic FFI to existing C libraries using const char , a precise, length\u2011carrying ABI (SilkString) for embedding the compiler/runtime. Safety & Ownership The external interface rules must ensure: No C code can violate Silk\u2019s invariants about ownership and lifetimes. Any shared data representation (strings, structs, arrays, closures) is documented and stable. Typed Errors and the ext boundary Typed errors (error, panic, and T ErrorType...) must not cross the ext boundary. Rules: ext function types must not use in their return types. Silk-to-C ABI surfaces must not expose in exported function signatures. Shims should convert typed errors into explicit error codes, optionals, or domain-specific error types, or terminate in a platform-appropriate way. The current compiler rejects ext declarations that include , and rejects exporting error-producing functions to C ABI outputs. The spec also includes a \u201cStructs, Arrays, and Closures (Complex Types)\u201d subsection for FFI. As the implementation proceeds, this document must be extended to: describe how user\u2011defined structs map to C structs (respecting the layout rules in structs-impls-layout.md), define how arrays and slices are represented across the boundary, document any stable closure representation, if exposed in the C ABI. Structs (Initial ABI Subset) The full language design includes rich user-defined structs and nested aggregates. The current compiler implementation supports only a small subset of structs in code generation: structs with 0+ fields of supported value types (scalar primitives, string, nested structs, and supported optionals) in function bodies and internal helper calls, on linux/x8664, passing and returning these structs by value at ABI boundaries using a scalar-slot lowering model: a struct value lowers to N scalar \u201ceightbyte\u201d slots in field order, and each slot is classified as INTEGER (integer-like scalars such as int, fixed-width integers, bool, char, Instant, Duration) or SSE (f32/f64), exported function parameters accept these slots as separate parameters; for 1\u20132 slot structs this is ABI-compatible with a by-value C struct parameter for the 8-byte-field subset, while for packed structs with smaller fields ABI compatibility with an equivalent C struct layout is not yet implemented/validated; for 3+ slot structs downstream C callers should declare separate parameters for the slots, exported function returns support 1+ slot structs; 1\u20132 slot results return in rax/rdx and/or xmm0/xmm1 accordingly, while 3+ slot results return indirectly via a hidden sret pointer. This subset is intended as a stepping stone toward fully general struct layout and SysV ABI classification (including packed layout for smaller fields such as f32 and small integers, nested structs, and larger aggregates returned via hidden sret pointers). Optionals (Initial ABI Subset) The full language design includes rich optional patterns (?., match, nested optionals, etc.). The current compiler implementation supports only a limited optional subset in code generation: optionals whose payload type is a supported scalar, string, or a supported ABI-safe struct (i.e. after slot-flattening, all scalar slots are i64/u64/f64), construction via None and Some(value), unwrapping via ?? with short-circuit fallback evaluation, and nested optionals (T??) for the same supported payload subset, including unwrapping T?? to T? via ??. At ABI boundaries in the current linux/x8664 subset, optionals are lowered as a Bool tag followed by the payload scalar slots in order: (tag, payload) for scalar payload optionals, (tag, ptr, len) for string?, (tag, slot0, slot1, ...) for struct? where the payload lowers to N scalar slots. For nested optionals (T??) in this subset, the payload slots are the full inner optional representation (for example int?? lowers as (tag0, tag1, i64 payload)). For exported functions, these slots consume the normal scalar argument and result locations (registers then stack), and 3+ scalar results return via a hidden sret pointer. Compiler requirements: Implement ext declarations as specified. Map Silk types to C types per the ABI document. Enforce the documented passing conventions and ownership rules for external-call strings and other bridged types."
    },
    {
      "id": "language/flow-overview",
      "title": "Flow Control Overview",
      "section": "language",
      "summary": "Flow control describes how Silk programs sequence work, branch, loop, and exit. This concept spans several surface constructs and their static rules (typing, scoping, and diagnostics).",
      "text": "Flow Control Overview Flow control describes how Silk programs sequence work, branch, loop, and exit. This concept spans several surface constructs and their static rules (typing, scoping, and diagnostics). Core Constructs if / else loop loops while loops for loops match expressions return break continue blocks and statement composition expression statements Each construct has defined syntax, typing, and evaluation semantics which the compiler must implement. Principles These rules help keep control flow explicit and statically checkable: Conditions are boolean: if and while require a bool condition (no integer \u201ctruthiness\u201d). Bodies are blocks: flow constructs use { ... } blocks as their bodies. Statements are terminated: most statement forms end with ; (for example let, return, break, continue, panic, assert, and expression statements). Quick Examples Branching: fn main () -> int { let x: int = 1; if x == 0 { return 0; } else { return 1; } } Looping: fn main () -> int { let mut i: int = 0; while i < 3 { i += 1; } return 0; } Matching: fn main () -> int { let x: int? = Some(7); let y: int = match x { None => 0, Some(v) => v, }; return y; } See the dedicated documents: flow-if-else.md flow-loop.md flow-while.md flow-for.md flow-match.md flow-return.md flow-break.md flow-continue.md flow-blocks-statements.md flow-expression-statements.md"
    },
    {
      "id": "language/grammar",
      "title": "Formal Grammar Spec",
      "section": "language",
      "summary": "This document contains the formal grammar and lexical specification for Silk as used by the compiler implementation.",
      "text": "Formal Grammar Spec This document contains the formal grammar and lexical specification for Silk as used by the compiler implementation. Lexical Structure (Overview) The lexer operates over: Whitespace and comments (trivia): spaces, tabs, newlines; line comments starting with // and continuing to the end of the line; doc line comments start with /// and follow the same lexical rules; block comments starting with / and ending with the next / (non\u2011nesting); doc block comments start with / and also end at the next /. Both doc-comment forms are still trivia for the parser (they do not affect the syntax tree), but tooling may preserve and parse their text for Identifiers: sequences of Unicode letters, digits, and , with language-specific rules for leading characters. Keywords: packages and imports: package, module, import, file imports: from, control flow: if, else, loop, while, for, in, match, return, panic, break, continue, assert, await, yield, declarations and mutability: export, public, private, default, const, let, var, mut, fn, test, theory, type, types and declarations: struct, enum, error, interface, impl, as, raw, extends, pure, task, async, memory and regions: move, region, with, new, other operators: sizeof, alignof, offsetof, typename, optionals and literals: None/none, Some, true, false, null, verification and external declarations: ext, and Formal Silk directives #const, #require, #assure, #assert, #invariant, #variant, #monovariant, #theory, other keywords as listed in the spec. Keywords are lexed as distinct tokens, but in name positions (for example qualified-name segments like std::test, function/method names, and member access like value.test) the parser accepts keywords anywhere an identifier is expected. The #require / #assure / #assert / #invariant / #variant / #monovariant / #const / #theory forms are not comments; they are first-class lexical tokens that participate in the normal expression grammar and are handled by the verifier. A directive token begins with # followed by optional horizontal whitespace and the directive name (so #require and # require are equivalent spellings). When these sequences appear inside a // line comment or anywhere inside a / ... / block comment, the surrounding comment is treated as trivia and the directive spellings are ignored by the lexer. Literals: numeric, duration, boolean, character, string, regexp, aggregate (see literals-.md). String literals have two surface forms: \"...\" (escape sequences), ` ... (raw/no-escape). Regular expression literals have a JavaScript-style surface form: Disambiguation is context-sensitive (like JavaScript): the parser only recognizes a regex literal in expression-start positions where a Primary expression may begin; otherwise / is parsed as the division operator. Because // starts a line comment, an empty regex literal // is not a valid token sequence; use /(?:)/ for an explicit empty pattern. Operators and delimiters: The lexer must implement longest-token rules for ambiguous prefixes (e.g. ... vs ..= vs ..). Lexical Grammar for Whitespace and Comments For the purposes of the grammar, whitespace and comments are treated as trivia that may appear between any two tokens and are ignored by the parser: Trivia ::= (Whitespace LineComment BlockComment)+ Whitespace ::= ' ' '\\t' '\\r' '\\n' LineComment ::= '//' LineCommentChar Newline? LineCommentChar ::= any character except '\\n' Newline ::= '\\n' BlockComment ::= '/' BlockCommentChar '/' BlockCommentChar ::= any character except the end of input Block comments are not nesting: a / sequence inside an existing BlockComment has no special meaning and is treated as part of the comment text until the first following /. Doc-style comments such as / ... / are just syntactic sugar for BlockComment at the lexical level. High-Level Grammar Skeleton At a high level, the language can be structured as: Compilation unit: Module ::= (PackageDecl ModuleDecl)? ImportDecl TopLevelDecl Top-level declarations: TopLevelDecl ::= PackageDecl ModuleDecl ImportDecl InlineModuleDecl UsingDecl ReExportDecl DefaultExportDecl ExportableDecl TestDecl ExportableDecl ::= FnDecl LetDecl TypeDecl StructDecl EnumDecl InterfaceDecl ImplDecl ExtDecl ... Packages and imports: The surface syntax for packages, imports, and exports is specified in detail in the currently implemented subset: PackageDecl ::= 'package' PackagePath ';' ModuleDecl ::= 'module' PackagePath ModuleAsOpt ';' InlineModuleDecl ::= ExportModifier 'module' NameToken '{' InlineModuleItem '}' InlineModuleItem ::= InlineModuleDecl UsingDecl ExportableDecl NameToken ::= Identifier Keyword PackagePath ::= NameToken ('::' NameToken) ModuleAsOpt ::= ('as' QualifiedName TypeArgListOpt) \u03b5 ImportDecl ::= 'import' ImportSpec ';' ImportSpec ::= ImportPath FileImportSpec FileDefaultImportSpec AmbientFileImportSpec ImportPath ::= ('::')? NameToken ('::' NameToken) ImportFrom ::= StringLiteral PackagePath AmbientFileImportSpec ::= StringLiteral FileImportSpec ::= '{' ImportBindingListOpt '}' 'from' ImportFrom FileDefaultImportSpec ::= NameToken 'from' ImportFrom ImportBindingListOpt ::= ImportBindingList \u03b5 ImportBindingList ::= ImportBinding (',' ImportBinding) ','? ImportBinding ::= NameToken ('as' NameToken)? ReExportDecl ::= 'export' '{' ReExportBindingListOpt '}' ';' ReExportBindingListOpt ::= ReExportBindingList \u03b5 ReExportBindingList ::= ReExportBinding (',' ReExportBinding) ','? ReExportBinding ::= NameToken ('as' NameToken)? DefaultExportDecl ::= 'export' 'default' NameToken ';' UsingDecl ::= 'using' Identifier '=' QualifiedName ';' 'using' QualifiedName UsingAsOpt ';' UsingAsOpt ::= ('as' Identifier) \u03b5 ExportModifier ::= 'export'? FnExportModifier ::= ('export' ('default')?)? For top-level declarations that can be exported, the ExportModifier appears before the declaration keyword (currently fn, let, ext, type, struct, enum, theory, error, and interface): FnDecl ::= FnSpecs FnExportModifier FnModifierOpt 'fn' FnGenericParamListOpt FnNameOpt FnSignature FnBody FnBody ::= Block ';' FnModifierOpt ::= FnModifier FnModifier ::= 'const' 'pure' 'task' 'async' FnGenericParamListOpt ::= GenericParamList \u03b5 FnNameOpt ::= NameToken \u03b5 FnSpecs ::= (FnPrecondition FnPostcondition FnContractTheory) FnPrecondition ::= '#require' Expr ';' FnPostcondition ::= '#assure' Expr ';' FnContractTheory ::= '#theory' Identifier '(' ArgListOpt ')' ';' Formal Silk theories may be declared either at top level (exportable) or inline inside blocks (non-exportable): TheoryDecl ::= TheorySpecs ExportModifier 'theory' Identifier '(' TheoryParamsOpt ')' '{' TheoryBodyItem '}' TheorySpecs ::= (TheoryPrecondition TheoryPostcondition) TheoryPrecondition ::= '#require' Expr ';' TheoryPostcondition ::= '#assure' Expr ';' TheoryParamsOpt ::= TheoryParams \u03b5 TheoryParams ::= TheoryParam (',' TheoryParam) ','? TheoryParam ::= Identifier ':' Type TheoryBodyItem ::= SpecConstStmt SpecTheoryStmt TheoryRequires TheoryInvariant TheoryEnsures TheoryVariant TheoryRequires ::= '#require' Expr ';' TheoryInvariant ::= '#invariant' Expr ';' TheoryEnsures ::= '#assure' Expr ';' TheoryVariant ::= '#variant' Expr ';' FnSignature ::= '(' FnParamsOpt ')' ResultTypeOpt FnParamsOpt ::= FnParams \u03b5 FnParams ::= GenericParamSectionOpt ';' ParamListOpt ParamList GenericParamSectionOpt ::= GenericParamSection \u03b5 GenericParamSection ::= GenericParam (',' GenericParam) ','? ParamListOpt ::= ParamList \u03b5 ParamList ::= Param (',' Param) Param ::= VarArgsOpt MutOpt Identifier TypeAnnotationOpt DefaultArgOpt VarArgsOpt ::= '...' \u03b5 DefaultArgOpt ::= ('=' Expr) \u03b5 ResultTypeOpt ::= ('->' TypeNoPipe TypedErrorTypesOpt)? TypedErrorTypesOpt ::= (' ' TypeNoPipe)+ \u03b5 Notes: When a top-level ; appears inside the function parameter list, it splits compile-time parameters (type/const parameters) from run-time value parameters. The compile-time side uses GenericParam syntax (T and N: int) and does not permit mut. FnNameOpt is currently permitted only for default-exported functions (export default fn (...) { ... }). For non-default functions, the fn identifier is required. Default export statements (export default Name;) always name an existing symbol; they do not permit anonymous exports. The run-time side uses ordinary Param syntax (mut x: T or x: T, with the type annotation optional in Silk). If there is no ;, the entire list is treated as run-time parameters. Default arguments are supported in function parameter lists: any parameter may provide a default expression (x: int = 1), defaulted parameters must be trailing (once a parameter has a default, all subsequent parameters must also have defaults) because call syntax is positional-only in the current language subset, and in the current implementation, default expressions are restricted to a constant/literal expression subset (no name references), so they can be inlined at call sites during lowering. a parameter declared as T? with a default has two effective behaviors in the current implementation subset: if the default expression has type T, the parameter has effective type T (the argument may be omitted at call sites, but the callee sees a non\u2011optional value), if the default expression is None/Null, the parameter remains T? (the argument may be omitted, and callers may still pass optional values explicitly). Varargs parameters are supported: a varargs parameter is declared by prefixing the final parameter with ... (for example fn f(x: int, ...rest: int) { ... }), only one varargs parameter is permitted per function and it must be final, In Silk, varargs parameters: must have an explicit type annotation, may not be mut, and may not have a default expression. The from string literal is a module specifier (either \"...\" or ... ): strings starting with ./, ../, or an absolute path are treated as file specifiers and resolve to a module by file path, strings starting with std/ are treated as std-root file specifiers and resolve to a module by file path under the configured stdlib root, other strings are treated as package specifiers and resolve to a package BindingDecl ::= ('const' 'let' MutOpt 'var') Identifier TypeAnnotationOpt InitializerOpt ';' LetDecl ::= ExportModifier BindingDecl TypeAnnotationOpt ::= (':' Type)? InitializerOpt ::= ('=' Expr)? Type aliases are supported: TypeDecl ::= ExportModifier 'type' TypeDeclKindOpt Identifier '=' Type ';' TypeDeclKindOpt ::= TypeDeclKind \u03b5 TypeDeclKind ::= 'struct' 'enum' 'error' 'interface' 'fn' 'pure' 'fn' test declarations are supported as Zig-inspired top-level test blocks: TestDecl ::= 'test' StringLiteral? Block FFI declarations are also part of the language grammar: ExtDecl ::= ExportModifier 'ext' NameToken ExtExternNameOpt '=' Type ';' ExtExternNameOpt ::= StringLiteral \u03b5 When ExtExternNameOpt is present, it sets the linked external symbol name. This allows Silk code to bind a local name that differs from the C/FFI symbol name (for example to avoid name collisions in wrapper modules). The current compiler implementation supports external declarations (ext) whose type is either: a FunctionType (external functions, callable from Silk), or a supported scalar type (external variables, readable as values in Silk). the compiler requires an initializer for runtime bindings (let/var) and for compile-time constant bindings (const). Uninitialized declarations like let x: int; / const x: int; are parsed but rejected by Additionally, const initializers must be compile-time evaluable; otherwise In practice, prefer: let x: int = 0; for a zero value, or let x: T? = None; for an \u201cempty\u201d optional. Struct declarations are also accepted by the current parser: StructDecl ::= ExportModifier 'struct' Identifier GenericParamListOpt StructExtendsOpt ';' ExportModifier 'struct' Identifier GenericParamListOpt StructExtendsOpt '{' StructFieldListOpt '}' StructExtendsOpt ::= ('extends' QualifiedName) \u03b5 GenericParamListOpt ::= GenericParamList \u03b5 GenericParamList ::= '(' GenericParamListInnerOpt ')' GenericParamListInnerOpt ::= GenericParamListInner \u03b5 GenericParamListInner ::= GenericParam (',' GenericParam) ','? GenericParam ::= Identifier (':' Type)? ('=' Type)? StructFieldListOpt ::= StructFieldList \u03b5 StructFieldList ::= StructField (',' StructField) ','? StructField ::= Identifier ':' Type StructFieldDefaultOpt StructFieldDefaultOpt ::= ('=' Expr) \u03b5 Enum declarations are part of the core language design. They are specified in EnumDecl ::= ExportModifier 'enum' Identifier GenericParamListOpt '{' EnumVariantListOpt '}' EnumVariantListOpt ::= EnumVariantList \u03b5 EnumVariantList ::= EnumVariant (',' EnumVariant) ','? EnumVariant ::= Identifier EnumVariantPayloadOpt EnumVariantPayloadOpt ::= ('(' TypeListOpt ')') \u03b5 Interface and impl declarations are part of the language design and are parsed by the front-end as the syntax is implemented: InterfaceDecl ::= ExportModifier 'interface' Identifier GenericParamListOpt InterfaceExtendsOpt '{' InterfaceItem '}' InterfaceExtendsOpt ::= ('extends' QualifiedName) \u03b5 InterfaceMethodDecl ::= 'fn' NameToken FnSignature ';' InterfaceItem ::= InterfaceMethodDecl UsingDecl ImplDecl ::= 'impl' QualifiedName GenericParamListOpt ImplAsOpt '{' ImplMemberDecl '}' ImplAsOpt ::= ('as' QualifiedName TypeArgListOpt) \u03b5 ImplMemberDecl ::= FnDecl UsingDecl (within an impl block, export is reserved for static members with no self receiver; instance method visibility uses public/private) Note: const-parameter-style generics (N: int parameters and integer literal type arguments like Foo(u8, 1024)) remain tracked work; the front-end parses these surface forms but the current implementation focuses on type parameters and monomorphization for type arguments. Exception: the nominal optional form Option(T) is recognized as sugar for T? and is accepted in Silk. Types: Type ::= UnionType UnionType ::= TypeNoPipe (' ' TypeNoPipe) TypeNoPipe ::= BaseType TypeSuffix TypeSuffix ::= TypeSuffixElem TypeSuffix \u03b5 TypeSuffixElem ::= OptionalTypeSuffix ArrayTypeSuffix OptionalTypeSuffix ::= '?' '??' ArrayTypeSuffix ::= '[' ']' '[' ArrayLen ']' ArrayLen ::= IntLiteral Identifier BaseType ::= ReferenceType FunctionType '(' Type ')' SimpleType ReferenceType ::= '&' BaseType FunctionType ::= 'fn' '(' TypeListOpt ')' ResultTypeOpt TypeListOpt ::= TypeList \u03b5 TypeList ::= Type (',' Type) SimpleType ::= PrimitiveType NamedType PrimitiveType ::= 'bool' 'i8' 'u8' 'i16' 'u16' 'i32' 'u32' 'i64' 'u64' 'i128' 'u128' 'int' 'f32' 'f64' 'f128' 'char' 'string' 'void' 'Instant' 'Duration' NamedType ::= QualifiedName TypeArgListOpt TypeArgListOpt ::= ('(' TypeArgListInnerOpt ')') \u03b5 TypeArgListInnerOpt ::= TypeArgListInner \u03b5 TypeArgListInner ::= TypeArg (',' TypeArg) ','? TypeArg ::= Type IntLiteral This means that type annotations such as string? or int?? are parsed into nested optional types. For simple nominal optionals, the parser also recognizes Option(T) and desugars it to the same internal representation as T?. Borrowed reference types (&T) are now parsed in type annotations. Array/slice types (T[], T[N]) are parsed and type-checked in Silk (with element-type restrictions), and are part of the implemented expression grammar via array literals ([a, b, c]) and indexing (xs[i]). Function types (fn (T, ...) -> R) are parsed as part of the Type grammar, and function values are supported in the current lowering subset (including capturing Statements: Stmt ::= LetStmt SpecConstStmt SpecAssertStmt SpecTheoryDeclStmt SpecTheoryStmt AsyncBlockStmt TaskBlockStmt ExprStmt IfStmt LoopStmt WhileStmt ForStmt MatchStmt ReturnStmt PanicStmt AssertStmt BreakStmt ContinueStmt LetStmt ::= ('const' 'let' MutOpt 'var') LetBinder TypeAnnotationOpt InitializerOpt ';' LetBinder ::= Identifier '' LetTupleBinder LetStructBinder LetArrayBinder LetEnumBinder LetTupleBinder ::= '(' LetTupleBinderItemsOpt ')' LetTupleBinderItemsOpt ::= LetTupleBinderItem (',' LetTupleBinderItem) ','? \u03b5 LetTupleBinderItem ::= Identifier '' LetStructBinder ::= '{' LetStructBinderItemsOpt '}' LetStructBinderItemsOpt ::= LetStructBinderItem (',' LetStructBinderItem) ','? \u03b5 LetStructBinderItem ::= Identifier ('as' (Identifier ''))? LetArrayBinder ::= '[' LetArrayBinderItemsOpt ']' LetArrayBinderItemsOpt ::= LetArrayBinderItem (',' LetArrayBinderItem) ','? \u03b5 LetArrayBinderItem ::= Identifier '' LetEnumBinder ::= QualifiedName '(' LetEnumBinderItemsOpt ')' LetEnumBinderItemsOpt ::= LetEnumBinderItem (',' LetEnumBinderItem) ','? \u03b5 LetEnumBinderItem ::= Identifier '' SpecConstStmt ::= '#const' Identifier '=' Expr ';' SpecAssertStmt ::= '#assert' Expr ';' SpecTheoryDeclStmt ::= '#theory' Identifier '(' TheoryParamsOpt ')' '{' TheoryBodyItem '}' SpecTheoryStmt ::= '#theory' Identifier '(' ArgListOpt ')' ';' AsyncBlockStmt ::= 'async' Block TaskBlockStmt ::= 'task' Block MutOpt ::= 'mut' \u03b5 ExprStmt ::= Expr ';' IfStmt ::= 'if' Expr Block ('else' (IfStmt Block))? LoopStmt ::= LoopPrefixOpt 'loop' Block LoopPrefixOpt ::= 'async' 'task' \u03b5 WhileStmt ::= WhileSpecs 'while' Expr Block WhileSpecs ::= (LoopInvariant LoopVariant LoopMonovariant) LoopInvariant ::= '#invariant' Expr ';' LoopVariant ::= '#variant' Expr ';' LoopMonovariant ::= '#monovariant' Expr ';' ForStmt ::= ForInStmt ForCStmt ForInStmt ::= 'for' ForBinder 'in' Expr (RangeOp Expr)? Block ForCStmt ::= 'for' '(' ForInit ';' Expr ';' Expr ')' Block ForInit ::= ('const' 'let' MutOpt 'var') Identifier TypeAnnotationOpt '=' Expr ForBinder ::= Identifier '' RangeOp ::= '..' '..=' BlockStmt ::= Block Block ::= '{' Stmt '}' ReturnStmt ::= 'return' ExprOpt ';' ExprOpt ::= Expr? PanicStmt ::= 'panic' QualifiedName StructLiteralSuffixOpt ';' AssertStmt ::= 'assert' Expr ';' 'assert' '(' Expr (',' Expr)? ')' ';' BreakStmt ::= 'break' ';' ContinueStmt ::= 'continue' ';' WithStmt ::= 'with' Identifier Block 'with' WithBytes Block 'with' WithBytes 'from' Identifier WithFromSliceOpt Block WithBytes ::= IntLiteral '(' IntLiteral ')' WithFromSliceOpt ::= '[' IntLiteral '..' IntLiteralOpt ']' \u03b5 IntLiteralOpt ::= IntLiteral \u03b5 MatchStmt ::= 'match' Expr '{' MatchStmtArmListOpt '}' MatchStmtArmListOpt ::= MatchStmtArmList \u03b5 MatchStmtArmList ::= MatchStmtArm (',' MatchStmtArm) ','? MatchStmtArm ::= MatchStmtPattern '=>' Block OptionalPattern ::= 'None' 'Some' '(' (Identifier '') ')' MatchStmtPattern ::= OptionalPattern '' Identifier (Identifier '') ':' QualifiedName StructLiteralSuffixOpt ::= StructLiteralSuffix \u03b5 match is implemented in two separate forms: match as an expression (arms are expressions; see MatchExpr below), match as a statement (arms are blocks), used for typed errors as In the current implementation, the match statement form is restricted to a call-expression scrutinee and the patterns listed above. Expressions: Expressions follow a conventional precedence hierarchy, as implemented in src/parser.zig: Expr ::= Assign Assign ::= Coalesce (AssignOp Assign)? AssignOp ::= '=' '+=' '-=' '=' '/=' Coalesce ::= LogicalOr ('??' Coalesce)? LogicalOr ::= LogicalAnd (' ' LogicalAnd) LogicalAnd ::= BitOr ('&&' BitOr) BitOr ::= BitXor (' ' BitXor) BitXor ::= BitAnd ('^' BitAnd) BitAnd ::= Equality ('&' Equality) Equality ::= TypeTest (('==' '!=') TypeTest) TypeTest ::= Relational ('is' Type)? Relational ::= Shift (('<' '<=' '>' '>=') Shift) Shift ::= AddSub (('<<' '>>') AddSub) AddSub ::= MulDiv (('+' '-') MulDiv) MulDiv ::= Unary (('' '/' '%') Unary) Unary ::= ('!' '~' '-' 'mut' 'move' 'new' 'await' 'yield' 'sizeof' 'alignof' 'offsetof' 'typename' '&' '' '++' '--') Unary Postfix Postfix ::= Primary PostfixSuffix PostfixSuffix ::= CallSuffix FieldSuffix OptionalFieldSuffix StructLiteralSuffix IndexSuffix SliceSuffix CastSuffix TrySuffix IncDecSuffix CallSuffix ::= '(' CallArgsOpt ')' FieldSuffix ::= '.' NameToken OptionalFieldSuffix ::= '?.' NameToken StructLiteralSuffix ::= '{' StructInitListOpt '}' IndexSuffix ::= '[' Expr ']' SliceSuffix ::= '[' SliceBoundOpt '..' SliceBoundOpt ']' SliceBoundOpt ::= Expr \u03b5 CastSuffix ::= 'as' RawOpt Type CastSliceLenOpt CastSliceLenOpt ::= '(' Expr ')' \u03b5 RawOpt ::= 'raw' \u03b5 TrySuffix ::= '?' IncDecSuffix ::= '++' '--' StructInitListOpt ::= StructInitList \u03b5 StructInitList ::= StructInit (',' StructInit) ','? StructInit ::= NameToken (':' Expr)? CallArgsOpt ::= CallArgs \u03b5 CallArgs ::= GenericArgListOpt ';' ArgListOpt ArgList GenericArgListOpt ::= GenericArgList \u03b5 GenericArgList ::= GenericArg (',' GenericArg) ','? GenericArg ::= Type IntLiteral ArgListOpt ::= ArgList \u03b5 ArgList ::= Expr (',' Expr) Note: the parser treats mut <expr>, new <expr>, await <expr>, await <expr>, yield <expr>, yield <expr>, sizeof <expr>, alignof <expr>, offsetof(Type, fieldpath), typename <expr>, and prefix ++<expr> / --<expr> as unary expressions. Note: CastSliceLenOpt is permitted only when Type is a slice type (T[]) and RawOpt is \u03b5 (it is used by unsafe pointer\u2192slice casts like ptr as u8[](len)). The type checker currently permits mut <expr> only in call arguments (and method receivers) when the corresponding parameter is declared mut and is: a borrowed reference type (mut r: &T), or a slice type (mut s: T[]). The move <expr> unary form is used for explicit ownership transfer; in the it is restricted to move <name> where <name> is a local binding. The type checker currently permits new <expr> only when it can determine a concrete reference result type of the form &Struct. In the current implementation this happens either: from an expected &Struct type context (for example let x: &Packet = new Packet{ ... }; or as a call argument whose parameter type is &Struct) from the operand itself when it names the struct type (for example let x = new Packet{ ... }; or let x = new Packet(...);) new is supported only in function bodies (not in top-level let initializers). Primary ::= IntegerLiteral DurationLiteral FloatLiteral StringLiteral RegexpLiteral CharLiteral 'true' 'false' 'None' 'null' 'Some' '(' Expr ')' ArrayLiteral IfExpr MatchExpr FnExpr '(' Expr ')' InferredStructLiteral QualifiedName RegexpLiteral ::= '/' RegexpBody '/' RegexpFlagsOpt RegexpFlagsOpt ::= Identifier \u03b5 Notes: RegexpBody is scanned by the parser (not the lexer): it is the byte span between the opening and closing /, where the closing delimiter is the first unescaped / that is not inside a character class ([...]). ArrayLiteral ::= '[' ExprListOpt ']' ExprListOpt ::= ExprList \u03b5 ExprList ::= Expr (',' Expr) ','? QualifiedName ::= GlobalPrefixOpt NameToken ('::' NameToken) GlobalPrefixOpt ::= '::' \u03b5 InferredStructLiteral ::= '{' StructInitListOpt '}' FnExpr ::= 'fn' '(' LambdaParamListOpt ')' '->' LambdaBody LambdaParamListOpt ::= LambdaParamList \u03b5 LambdaParamList ::= LambdaParam (',' LambdaParam) ','? LambdaParam ::= Identifier ':' Type LambdaBody ::= Type Block Expr Disambiguation rule (current parser): fn (...) -> Type Block is treated as the block-body form only when the return type is followed immediately by { (starting the block). Otherwise, fn (...) -> Expr is treated as an expression-body function expression and its result type is inferred by the checker. Notes: InferredStructLiteral has the same token-level shape as StructLiteralSuffix (used for Type{ ... }), but appears as a Primary expression with no explicit type name. The type checker requires an expected struct type context to resolve the literal\u2019s target type. To avoid ambiguity with statement blocks, the parser only recognizes InferredStructLiteral when the { ... } contents look like a struct initializer list (or are {}): either the first token after { is } or it is an Identifier followed by : (explicit initializer) or followed by , / } (shorthand initializer). MatchExpr ::= 'match' Expr '{' MatchArmListOpt '}' MatchArmListOpt ::= MatchArmList \u03b5 MatchArmList ::= MatchArm (',' MatchArm) ','? MatchArm ::= MatchExprPattern '=>' Expr MatchExprPattern ::= OptionalPattern EnumVariantPattern ResultPattern IfExpr ::= 'if' Expr IfExprBlock 'else' (IfExpr IfExprBlock) IfExprBlock ::= '{' Expr '}' ResultPattern ::= ('Ok' 'Err') '(' (Identifier '') ')' EnumVariantPattern ::= EnumVariantName EnumVariantBinderListOpt EnumVariantName ::= ('::')? Identifier '::' Identifier ('::' Identifier) EnumVariantBinderListOpt ::= ('(' EnumVariantBinderListInnerOpt ')') \u03b5 EnumVariantBinderListInnerOpt ::= EnumVariantBinderList \u03b5 EnumVariantBinderList ::= EnumVariantBinder (',' EnumVariantBinder) ','? EnumVariantBinder ::= Identifier '' Declarations: Decl ::= ... ErrorDecl ErrorDecl ::= ExportModifier 'error' Identifier '{' StructFieldListOpt '}' This matches the current AST and checker: Primary constructs Literal or Name expressions (or a parenthesized Expr), unary expressions are represented as UnaryExpr with a token kind indicating the operator, binary expressions are represented as BinaryExpr with a token kind indicating the operator, identifiers and qualified names are stored as NameExpr with the full slice of source text (e.g. util::answer), simple function calls such as helper() or util::helper(1, 2) are parsed as call expressions using the Postfix/CallSuffix productions; the current implementation supports calls to named functions, but the type checker and back-end currently restrict which value types can appear at call boundaries; Further expression forms (ranges, etc.) are described in other parser now accepts ?. optional field access (opt?.field) and the initial match` expression form as part of the implemented optional subset, but other expression forms will be added here as they are implemented. Role of This File This document serves as the reference for: lexer implementation (token categories and reserved words), parser implementation (production rules and precedence), pretty-printer or formatter behavior. As the parser and lexer are implemented, this file must be updated with: the exact grammar that the compiler accepts (including any temporary limitations), clarifications or corrections discovered during implementation (recorded here so this file remains canonical), notes about desugaring and how surface constructs map into the internal AST, clear indication of which productions are implemented today vs. planned future work, so that downstream users can see both the full language design and the currently supported subset."
    },
    {
      "id": "language/formal-verification",
      "title": "Formal Silk",
      "section": "language",
      "summary": "Formal Silk is Silk\u2019s compile-time formal verification language. It is written using syntax that does not exist at runtime and is discharged at compile time using the Z3 SMT solver.",
      "text": "Formal Silk Formal Silk is Silk\u2019s compile-time formal verification language. It is written using syntax that does not exist at runtime and is discharged at compile time using the Z3 SMT solver. When Formal Silk syntax is present, compilation generates verification conditions (VCs), proves them with Z3, and fails the build if any VC cannot be proven. This behavior applies to: the silk CLI (silk check, silk test, silk build), and the C ABI build entrypoints (silkcompilerbuild, silkcompilerbuildtobytes). Proof requirements are opt-in by syntax Silk requires proofs only when verification syntax is present in the compiled module set: any use of #... directives (#require, #assure, #assert, #invariant, #variant, #monovariant, #const), and/or any use of where predicates (for example refinement-type binders). Note: where predicates are not implemented yet. When they land, they will also be treated as verification syntax. When verification syntax is present, compilation MUST: 1. generate VCs, 2. prove them using Z3, and 3. fail compilation with clear diagnostics if any VC cannot be proven. When verification syntax is not present, compilation does not require proofs. Z3 linkage and overrides On linux/x8664, Silk always links the vendored Z3 static library (vendor/lib/x64-linux/libz3.a) and its headers (vendor/include). To override the Z3 library at runtime (for example to test against a different Z3 build), provide a dynamic library path: CLI: pass --z3-lib <path>, or CLI/ABI: set SILKZ3LIB in the environment. When --z3-lib is provided, it overrides SILKZ3LIB. Debugging proofs with Z3 (--debug) When a verification condition fails, the compiler reports a normal diagnostic at the failing annotation site. When --debug is passed to silk build or silk test, the verifier also emits additional Z3 debugging output to stderr and writes an SMT-LIB2 reproduction script under .silk/z3/ in the current working directory (or $SILKWORKDIR/z3): .silk/z3/silkz3m<module><n>.smt2 You can replay the query with an external Z3 binary: z3 -smt2 .silk/z3/silkz3m00.smt2 Z3 model The current Formal Silk verifier maps Silk constructs directly to Z3: bool \u2192 Z3 Bool. string \u2192 Z3 String (: literals and equality/inequality comparisons). integer primitives \u2192 fixed-width Z3 bitvectors: i8/u8 \u2192 BV8 i16/u16 \u2192 BV16 i32/u32 \u2192 BV32 i64/u64/int \u2192 BV64 Arithmetic is modular 2^N (wraparound). Ordered comparisons and >> use signed semantics for signed integers (i/int) and unsigned semantics for unsigned integers (u). Supported operators in specification expressions: boolean: !, &&, , ==, != string: ==, != integer: unary: -, ~ arithmetic: +, -, , /, % bitwise: &, , ^, <<, >> comparisons: <, <=, >, >=, ==, != size/layout queries: sizeof, alignof, offsetof (type operands and other statically-sized operands in Silk) Other operators and expression forms are currently rejected in verified code (see \u201cImplementation Status\u201d below). The ext boundary External declarations (ext) have no body available to the verifier. Therefore: The verifier cannot generate VCs about the behavior of ext bodies. In the current verifier subset, calls are supported only to functions that have Formal Silk contracts (see \u201cCalls in verified code\u201d below). ext declarations do not have Formal Silk contracts yet, so verified code cannot call ext functions. The main constructs are: #const \u2014 formal Silk declarations used inside specifications. #require \u2014 precondition. #assure \u2014 postcondition. #assert \u2014 block-local proof obligation. #invariant \u2014 loop or state invariant. #variant \u2014 well-founded termination measure (ranking function). #monovariant \u2014 monotonic measure (non-decreasing or non-increasing). theory / #theory \u2014 reusable, parameterized proof obligations. Key properties: These annotations appear before the function or loop they describe. They are used by the verifier only and incur no runtime cost. Formal Silk declarations (#const) Formal Silk declarations let you name intermediate values for use in specifications. Syntax: const name = <Expr>; Rules: #const is a statement that may appear inside function bodies (inside blocks). The binding is compile-time-only and is not lowered into runtime code. A #const binding is visible only inside specification expressions: function specs (#require, #assure), loop specs (#invariant, #variant, #monovariant). Using a #const name in a runtime expression (e.g. in while conditions or normal let initializers) is a compile-time error. Use a normal let binding for runtime values, and (optionally) introduce a #const alias for specifications. Example: fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; while i < limit { i = i + 1; } return 0; } Function annotations (initial syntax) For functions, the initial surface syntax is: require <Expr>; require <Expr2>; assure <Expr3>; theory TheoryName(args...); fn name (params) -> ResultType { ... } One or more #require, #assure, and contract-theory attachments (#theory Name(args...);) may appear, in any order, immediately before the fn declaration (and before any export modifier). Each annotation is terminated by a semicolon. The compiler front-end: lexes these annotations as dedicated tokens, parses the annotation expressions using the normal expression grammar, type-checks each annotation expression as bool so obvious mistakes are rejected early (specifications are still compile-time-only metadata), attaches them to the corresponding function in the AST as lists of preconditions, postconditions, and contract theories. Loop specifications (#invariant, #variant, #monovariant) follow a similar pattern for loops. Loop annotations (initial syntax) For while loops, the initial surface syntax is: invariant <Expr>; variant <Expr2>; monovariant <Expr3>; while condition { ... } Rules: One or more #invariant annotations, zero or more #monovariant annotations, and at most one #variant annotation may appear immediately before the while keyword. Each annotation is terminated by a semicolon. The compiler front-end: lexes these annotations as directive tokens, parses the annotation expressions using the normal expression grammar, attaches them to the corresponding loop in the AST as invariants, monovariants, and a (single) variant expression. The verifier will interpret: #invariant expressions (type bool In Silk) as properties that must hold: before entering the loop, after each iteration (assuming the body and condition do not diverge), and at break exits (so proofs after the loop may rely on the invariant). #variant expressions as a well-founded measure that must decrease on each iteration (and be non-negative at the loop head), used for termination proofs. #monovariant expressions as measures that must be monotonic on each iteration (either non-decreasing or non-increasing, proved consistently across all continuation paths). Compiler requirements: Parse and represent these annotations in the AST. Integrate with the verifier to check specifications. Ensure that, if verification fails, compilation fails with clear diagnostics. Block assertions (#assert) Formal Silk also supports block-local proof obligations: assert <Expr>; Rules: #assert is a statement that may appear inside function/test bodies (inside blocks). It is compile-time-only metadata and is not lowered into runtime code. The verifier must prove the assertion holds in the current symbolic state at the #assert site. If it cannot be proven, compilation fails. After a #assert succeeds, the asserted expression is assumed to hold for the remainder of the block (so later proofs may rely on it). Theories (theory / #theory) A theory is a reusable, parameterized block of Formal Silk directives that can be applied at points inside a function body to assert properties about the current symbolic state. Syntax Declaration form (top-level): export theory acustomtheory (x: int, y: int) { #const z = x + y; #invariant x != 0 && y != 0; #invariant z > 1; } An inline theory declaration may also appear as a statement inside a function/test block: fn main (x: int, y: int) -> int { #theory localsumnonzero (x: int, y: int) { #const z = x + y; #assure z != 0; } #theory localsumnonzero(x, y); return 0; } Use form (statement inside a function body, or inside another theory body): fn main (x: int, y: int) -> int { #theory acustomtheory(x, y); return 0; } Theories may apply other theories: export theory nonzero (x: int) { #require x != 0; } export theory nonzerosum (x: int, y: int) { #theory nonzero(x); #theory nonzero(y); #assure (x + y) != 0; } Notes: Top-level theory declarations use the theory keyword. Inline (block) theory declarations and theory use sites share the #theory token; the parser disambiguates by the token that follows the argument/parameter list: { ... } starts an inline theory declaration, ; terminates a theory use. A top-level theory declaration may be exported (export theory ...). Exported theories may be imported from other modules and reused. Inline theory declarations inside a block are not exportable/importable; they exist only in the containing block and may be applied via #theory Name(...); after they are declared. A theory body may contain #theory Name(args); statements. These are compile-time-only theory applications; they are checked by the verifier in the current symbolic state at the point they appear in the theory body. Theory recursion is rejected (direct or indirect cycles). Theories are not runtime functions. They can only be applied via #theory use statements; calling a theory with normal call syntax (Name(...)) is a compile-time error. Prefix #require / #assure on theories For ergonomics, a theory declaration may be preceded by #require and/or assure directives: require x >= 0; export theory ensurenonnegativex (x: int) { #assure x >= 0; } These prefix directives are treated as if they were written at the beginning of the theory body. Theories as function contracts A function may attach one or more theories as part of its Formal Silk contract surface by placing #theory Name(args...); directives in the function-spec prelude: import { boundednonnegadd } from \"./theories.slk\"; theory boundednonnegadd(x, y); export fn add (x: int, y: int) -> int { return x + y; } Contract-theory attachments: are compile-time-only metadata (not runtime statements), contribute additional preconditions/postconditions to the function contract: #require become additional function preconditions, #assure and #invariant become additional function postconditions, are used by the verifier to enable contracted calls in verified code (see \u201cCalls in verified code\u201d above), are not permitted before a top-level theory declaration (only #require / #assure may prefix a theory declaration). Importing theories Exported theories may be imported via JS-style named imports and then applied via #theory use statements. Example: // theories.slk export theory ensurepositivex (x: int) { #assure x > 0; } // main.slk import { ensurepositivex as posx } from \"./theories.slk\"; fn main () -> int { let x: int = 1; #theory posx(x); return 0; } Rules: Only exported theories may be imported. A theory use (#theory Name(args);) resolves Name as either: a local theory declared in the same module, or an imported theory name from import { ... } from \"<specifier>\";. Namespace imports (import ns from \"<specifier>\";) do not currently provide theory access, because theory use sites do not accept qualified names (ns::TheoryName) yet. Semantics (initial subset) When a theory is applied (#theory Name(args);): its parameters are bound to the provided argument expressions (as specification expressions), its #const formal declarations are evaluated and are visible only within the theory during checking, each #require <Expr>;, #invariant <Expr>;, and #assure <Expr>; directive in the theory body is treated as a compile-time proof obligation that must hold in the current symbolic state at the use site, each #variant <Expr>; directive in the theory body is treated as a non-negativity obligation (Expr >= 0) at the use site (the theory form does not model decrease across iterations). Theory bodies are verifier-only: Theory argument expressions and theory directive expressions are Formal Silk specification expressions evaluated by the verifier. In Silk, specification expressions do not support function calls or value construction (for example foo(x), Type{...}, arrays, or new). Such expressions are rejected as unsupported Formal Silk. The theory form is compile-time-only and has no runtime semantics."
    },
    {
      "id": "language/function-disciplines",
      "title": "Function Disciplines (`pure`, `task`, `async`)",
      "section": "language",
      "summary": "This document specifies Silk\u2019s intended \u201cfunction discipline\u201d system: how functions declare whether they are pure, asynchronous, or safe to run as parallel tasks.",
      "text": "Function Disciplines (pure, task, async) This document specifies Silk\u2019s intended \u201cfunction discipline\u201d system: how functions declare whether they are pure, asynchronous, or safe to run as parallel tasks. Const functions (const fn) are specified separately in discipline system described here (a const fn may also be declared pure). pure fn parsing and a strict purity checker. Concurrency disciplines (task / async) are parsed and Task(T) / Promise(T) handles plus yield (task values) and await (promise values) are implemented in Silk (await Task(T) is rejected), but the compiler does not yet implement an async event loop, coroutine lowering, or task-safety (Send/Sync) rules. See status. Overview The language design distinguishes: fn \u2014 normal function (may perform effects; blocking). pure fn \u2014 function with no observable side effects (referentially transparent). task fn \u2014 function safe to execute on a worker pool as a parallel task. async fn \u2014 function that may suspend at await points (returns an awaitable). async task fn \u2014 async function executed as a separate task (self-contained worker). Intended Call Rules (Design) The checker is expected to enforce: pure code may call only pure code (and cannot perform I/O or mutation outside local, non-escaping temporaries). task code may call task and pure code, and must satisfy task-safety rules for captured/argument data. async code may await other async operations; it may call pure code and may offload blocking work via explicit adapters . Crossing discipline boundaries is intended to be explicit and diagnostic-driven (for example suggesting the correct adapter/intrinsic). Standard Intrinsics The standard library is expected to provide typed adapters to cross boundaries safely (names and exact signatures are design work): lifting sync work onto a task pool, presenting a task as an async operation, running blocking work from async without stalling the event loop, structured spawn/join primitives. These APIs are not yet present in the in-tree std/ implementation. Implementation Notes Today: pure fn is parsed and checked: a pure fn may call only pure functions; ext is treated as impure, the checker also supports purity inference (\u201cauto-pure\u201d) for ordinary fn declarations and impl methods: when an unannotated function/method has an eligible signature and its body satisfies the purity rules, it is treated as pure for call checking, and may be called from pure code, functions/methods with &T parameters are not eligible for inference (explicit pure fn remains supported for &T parameters in the current subset), pure cannot be combined with task or async In Silk, a pure fn may not have mut parameters, a pure fn may not declare mutable locals (var or let mut) and may not perform mutation via assignment, a pure fn may not allocate (new) in Silk, a pure fn may not have a typed-error contract (-> T Error...) and may not contain panic statements. task fn, async fn, and async task fn are parsed and preserved in the AST. Calls across disciplines are now reflected in expression types: calling a task fn yields Task(T), calling an async fn yields Promise(T), calling an async task fn yields Promise(Task(T)), yield sends task values (yield v;) and receives task values (yield t), and yield t drains/collects remaining task values into T[], await unwraps Promise(T) and yields T (await Task(T) is rejected), and await ps unwraps Promise(T)[] into T[]. await <expr> and async { ... } / task { ... } blocks are enforced as async-only constructs: await is only permitted inside async functions (including async task fn), async { ... } / task { ... } blocks are only permitted inside async functions. yield <expr> is enforced as a task-only construct: yield is permitted only inside task functions (task fn / async task fn) and inside task { ... } / task loop { ... } blocks. Lowering/codegen implements task execution using OS threads on linux/x8664 and implements yield/yield for task values plus await for promises. There is not yet a coroutine transformation or event loop; awaiting a Promise(T) currently does not \u201cpark\u201d the OS thread (it is still a synchronous unwrap in Silk). async { ... } / task { ... } blocks are still lexical blocks in the (they do not yet introduce scheduler behavior). Function types are parsed in type positions (notably for ext). Function expressions are implemented as first-class function values: fn (x: int) -> x + 1 (expression body), fn (x: int) -> int { return x + 1; } (block body). Function expressions may not declare &T parameters. Non-capturing function expressions are inferred as pure and are callable from pure code. Capturing closures are supported as a subset: a function expression may reference immutable locals/parameters from an enclosing scope, captures are by-value copies into a heap environment (scalar-only in the ), capturing closures are not pure and are rejected in pure code. Function values (both non-capturing and capturing) are supported end-to-end: they may be passed, returned, stored, and called indirectly."
    },
    {
      "id": "language/generics",
      "title": "Generics (Monomorphized)",
      "section": "language",
      "summary": "This document specifies Silk\u2019s parameterized type and declaration syntax.",
      "text": "Generics (Monomorphized) This document specifies Silk\u2019s parameterized type and declaration syntax. parameterized declarations are monomorphized into concrete, fully specified types and functions at build time (there are no runtime type parameters). Note: Option(T) is a special-case surface form that is treated as sugar for accepted in Silk even as general-purpose type-parameter generics are implemented. Overview Silk supports parameterized declarations by allowing a parameter list on struct, interface, enum, impl, and fn declarations. In Silk: Supported: type parameters (T) and const parameters (N: usize) on struct/interface/enum/impl, type application in type positions (Name(args...)), and generic functions using a compile-time parameter section separated by ; in the signature (fn id(T; x: T) -> T) (including generic methods in impl blocks). Declaration syntax Parameter lists The parameter list uses parentheses: struct Vector(T) { // ... } Rules: T is a type parameter. Type parameters may provide a default type argument using =: interface Serialize(S = string) { ... } defaults must be trailing (once a parameter has a default, all subsequent parameters must also have defaults). Const parameters are written with an explicit type annotation: N: usize const parameters are compile-time integer values and may be used in type positions such as array lengths (T[N]) and type applications. The parameter list may be empty (though it is uncommon): struct Foo() { ... }. Supported declaration forms: struct Name(T, ...) { ... } interface Name(T, ...) { ... } enum Name(T, ...) { ... } impl Name(T, ...) { ... } impl Name(T, ...) as InterfaceName(T, ...) { ... } Applying parameters in types Parameterized types are referenced using the same call-like syntax in type positions: Vector(int) Mutex(Account) Result(int, string) Generic enums (tagged unions) Enums may be parameterized and are monomorphized like generic structs. Because applied types are not used directly as expression qualifiers in the current surface syntax, callers typically introduce a local alias for an instantiation and then use that alias to construct and match variants: enum Result(T, E) { Ok(T), Err(E), } type R = Result(int, string); fn main () -> int { let x: R = R::Ok(123); return match x { R::Ok(v) => v, R::Err() => 0, }; } Default type arguments: When a parameterized declaration provides default type arguments, a use site may omit trailing arguments that have defaults. If all parameters have defaults, the type may be referenced as Name or Name() (both are equivalent to applying the defaults). Type arguments may be: types (e.g. int, &Foo, Option(string)). integer literals for const parameters (e.g. Vector(u8, 1024)). Const arguments are compile-time integer literals and participate in monomorphization identity. Interfaces and applied interface types Interfaces may be generic: interface Channel(T) { fn send(value: T) -> bool; fn recv() -> T?; } An impl ... as ... conformance may apply type arguments to the interface: struct QueueU8 { // ... } impl QueueU8 as Channel(u8) { // ... } Rule: when a generic interface is referenced in a concrete impl X as I(...), all interface type arguments must be fully known at that conformance site. The only exception is when the conformance itself is generic (type parameters are in scope), for example: struct Data(T) { / ... / } interface DataInterface(T) { / ... / } impl Data(T) as DataInterface(T) { // ... } Impl blocks for generic structs If a struct is declared with type parameters, its impl blocks must also declare those parameters: struct Data(T) { / ... / } // OK: impl Data(T) { / ... / } // Error: // impl Data { / ... / } This rule keeps method receiver typing unambiguous and makes monomorphization explicit. Functions (initial parsed surface form) Generic functions require a way to declare type/const parameters distinct from value parameters. The initial parsed surface form is: fn getfirst(T, N: usize; v: &T[N]) -> T { // ... } Where the ; separates generic parameters from value parameters inside the function\u2019s parameter list. Alternate (Go-like) function declaration syntax Silk also supports a Go-like generic header form: fn (T, N: usize) getfirst (v: &T[N]) -> T { // ... } This is sugar for the ; form above; the compiler records the same generic parameter list (T, N: usize) either way. Rules: At most one generic parameter list may be provided: either fn name(T; ...), or fn (T) name (...). Call syntax for generic functions Calls mirror the signature split: let x: int = getfirst(int, 4; &xs); Rules: the ; separates compile-time arguments from runtime value arguments, compile-time arguments are a comma-separated list of: type arguments (int, &Foo, Option(string)), and integer literals for const arguments, runtime arguments are ordinary expressions. the compile-time argument list may be empty when defaults supply all generic parameters, for example iddefault(; 1) uses the default type argument for T in fn iddefault(T = int; x: T) -> T. Call-site type inference (omitting ;) When a call does not include the generic separator (;), the compiler may infer type and const arguments from runtime arguments: fn (X, Y) add (x: X, y: Y) -> X { return x + y as X; } let a = add(1.123, 2); // infers X = f64, Y = int Rules: Both type parameters (T) and const parameters (N: usize) may be inferred. Inference is driven by the runtime argument expressions and any types that are known at the call site: literals (123, 1.0, \"hi\", 'a', true), struct literals (Point { ... }), explicit casts (expr as Type), and name expressions (x) when the binding\u2019s type is known (from an annotation like let x: T = ... or from a simple initializer like a literal/struct literal). Const parameters are inferred only from type structure: array lengths (T[N]), and const arguments in applied types (Buffer(T, N)), when the corresponding runtime argument type provides a concrete value. When inference cannot determine a type argument, compilation fails with an actionable diagnostic. Disambiguate by either: inserting as casts on runtime arguments, or using the explicit ; form (add(f64, int; 1.123, 2)). When inference cannot determine a const argument, disambiguate by using the explicit ; form (takebuf(4; buf)). Implementation notes Monomorphization produces a concrete instance for each referenced instantiation Name(args...). Type names share one namespace within a package: struct, interface, enum, error, and type declarations may not reuse the same name. Name conflicts across generic arities are rejected (for example, struct Foo and struct Foo(T) cannot both exist in the same package namespace). Const parameters are currently restricted to integer primitive types; const values are usable in type positions (for example T[N]) but are not yet exposed as runtime values."
    },
    {
      "id": "language/interfaces",
      "title": "Interfaces",
      "section": "language",
      "summary": "Interfaces allow types to declare that they implement a particular contract. They are the foundation for standard-library \u201cprotocols\u201d such as readers, writers, iterators, and allocators.",
      "text": "Interfaces Interfaces allow types to declare that they implement a particular contract. They are the foundation for standard-library \u201cprotocols\u201d such as readers, writers, iterators, and allocators. Key components: The interface declaration. The struct that implements the interface. The impl ... as ... declaration that ties them together. A module ... as ... declaration for module-level conformance. Interface declarations An interface declares a set of required method signatures. Syntax: interface Element { fn onclick(event: &Event) -> void; } Rules: Interface members are method declarations introduced with fn. Interface methods have no body and end with ;. Parameter types in interface methods should be explicitly annotated (the compiler should not rely on type inference for interface contracts). Interface methods are part of a public contract: interfaces do not have private members, and interface method declarations do not accept visibility modifiers. Generic interfaces Interfaces may declare type parameters: interface Channel(T) { fn send(value: T) -> bool; fn recv() -> T?; } Rules: Generic parameter lists use the same syntax as structs ((T, ...)). Type parameters may provide default type arguments (T = Type). When defaults are present, use sites may omit trailing arguments that have defaults. The interface name is a type constructor and must be applied with the correct number of type arguments where a concrete interface type is required (for example in impl ... as ... declarations). Self in interface signatures Within an interface method signature, the special type name Self refers to the concrete implementing type when checking impl Type as Interface { ... } conformance. Interface inheritance (extends) Interfaces may use extends for single inheritance: interface BaseLogger { fn log(msg: string) -> void; } interface FancyLogger extends BaseLogger { fn warn(msg: string) -> void; } Semantics: An interface that extends another interface inherits all of the base interface\u2019s method signatures. A conformance declaration (impl T as I or module ... as I) must satisfy the full inherited interface surface. Rules: extends is permitted only on interface declarations. Only single inheritance is permitted (at most one extends base). Cycles in extends chains are rejected. A derived interface may not redeclare a method with the same name as an inherited base method. Implementations (impl ... as ...) An implementation block declares that a concrete type implements an interface and provides method bodies. Example: interface Element { fn onclick(event: &Event) -> void; } struct Button { handle: i64; } impl Button as Element { fn constructor(...) -> Button { ... } fn onclick(self: &Button, event: &Event) -> void { ... } } Applied interface types: interface Read(T) { fn read() -> T; } struct ByteSource { / ... / } impl ByteSource as Read(u8) { fn read(self: &ByteSource) -> u8 { / ... / } } Compiler requirements: Represent interface types and impl ... as ... relationships. Enforce that all required interface methods are implemented with compatible signatures. Treat required interface methods as public by definition: impl methods that satisfy an interface requirement may omit public, but they may not be explicitly marked private. Conformance rules (initial implementation): For an interface I { fn m(p0: T0, ...) -> R; }, the corresponding impl must provide a method m whose signature matches after accounting for the receiver: the impl method\u2019s first parameter is the receiver self: &Type (or mut self: &Type), and the remaining parameters and result type must match the interface method. Exception (static protocol, implemented subset): std::interfaces::Deserialize(S) is a static conversion protocol used by as casts. Its conformance does not use a receiver parameter: impl T as std::interfaces::Deserialize(S) provides fn deserialize(value: S) -> Self (no self parameter), calls use T.deserialize(value). Generic interface conformance rule: When the as clause names an applied generic interface type (for example Read(u8)), all type arguments must be fully known at the conformance site, unless the conformance itself is generic and binds those type parameters (for example impl Data(T) as DataInterface(T)). Module conformance (module ... as ...) A module declaration may declare conformance to an interface: interface Logger { fn log(msg: string) -> void; } module myapp::logger as Logger; export fn log (msg: string) -> void { // ... } Conformance rules: For an interface I { fn m(p0: T0, ...) -> R; }, the corresponding module must provide a function m whose signature matches exactly: there is no receiver parameter for module conformance, and the parameter and result types must match the interface method. In Silk, module conformance is checked against the module\u2019s exported functions (written as export fn ...), since those are the module members that are visible across module boundaries. Generic module conformance: A module may declare conformance to an applied generic interface type (for example module myapp::bytes as Read(u8);). All interface type arguments must be fully specified (modules do not bind their own type parameters). Dispatch model (status) objects / vtables) is part of the language design, but is not implemented yet. For the initial compiler/backend subset, interface use is limited to: declaring interfaces and impl blocks, and calling methods directly on concrete types (no interface-typed values at runtime). special-case compiler hooks for specific interfaces (currently std::interfaces::Drop for deterministic cleanup; see"
    },
    {
      "id": "language/cheat-sheet",
      "title": "Language Cheat Sheet",
      "section": "language",
      "summary": "declarations; function types are unmodified in Silk). - expression body: `fn (x: int, y: int) -> x + y` - block body: `fn (x: int, y: int) -> int { return x + y; }` - `struct Name { ... }`, `struct Name extends Base { ... }`",
      "text": "Language Cheat Sheet Types (Surface Forms) Booleans: bool \u2014 true, false. Integers: u8, i8, u16, i16, u32, i32, u64, i64, u128, i128, int. Floats: f32, f64, f128. Char: char. String: string. Time: Instant, Duration. Optional: T? (sugar for Option(T)). References: &T. Arrays / slices: T[], T[N]. Maps / dictionaries: std::map::{HashMap, TreeMap} (standard library). Function types: fn(params) -> R (discipline modifiers apply to function declarations; function types are unmodified in Silk). Function expressions (non-capturing, inferred pure): expression body: fn (x: int, y: int) -> x + y block body: fn (x: int, y: int) -> int { return x + y; } Structs / enums / interfaces: struct Name { ... }, struct Name extends Base { ... } enum Name { ... } interface Name { ... }, interface Name extends Base { ... } Literals Integers: 0, 42, with base/suffixes as per the spec. Floats: 3.14, 1.0e-9. Booleans: true, false. Chars: 'A', escape sequences. Strings: single-line: \"hello\", multi-line: multi-line quoted forms. Durations: numeric + unit, e.g. 10ms, 2s, 5min. Aggregates: arrays: [1, 2, 3], structs: Point { x: 1, y: 2 }. Operators Arithmetic: +, -, , /, %. Bitwise: &, , ^, ~, <<, >>. Comparison: ==, !=, <, <=, >, >=. Logical: !, &&, . Assignment: =, +=, -=, =, /=. Increment/decrement: ++, -- (statement-like void). Optional / nullability: optional chaining: ?., coalescing: ??. Member/scope: ., ::. Ranges: .., ..=, .... Other punctuation: ,, ;, :, ->, =>. Flow Control if cond { ... } else { ... } (statement form) let v = if cond { a } else { b }; (if expression) loop { ... } (infinite loop; exits via break/return). while (cond) { ... } for pattern in iterable { ... } (ranges, builtin arrays/slices). for (init; cond; step) { ... } (C-style loop header). async loop { ... } / task loop { ... } (loop forms in async context). match value { ... } \u2014 pattern matching. return expr; assert expr; or assert(expr, \"message\"); break; continue; Blocks: { stmt }. Expression statements: expr; (where allowed). Executable entrypoint (initial rule): A minimal executable module defines exactly one top-level function: fn main() -> int { return 0; } This main function takes no parameters and returns int. The front-end enforces this shape for executable builds before code generation. Optionals & Mutability Declare optionals: let x: T? = None; or let x: Option(T) = None;. Create values: None, Some(value). Use: user.profile?.email \u2014 optional chaining. email ?? \"default@example.com\" \u2014 coalescing. Mutability: Parameters and references are immutable by default. Grant mutation via mut: in function definition: fn reset(mut r: &Runner) { ... }, at call site (syntax per spec). Structs, Impl Blocks, Interfaces Structs: struct Packet { seq: u32, size: u16, flag: u8 } pure data, well-defined layout. Impl blocks: impl Packet { fn sizebits(self: &Packet) -> u32 { ... } } Interfaces: interface Element { fn onclick(event: &Event) -> void; } impl Button as Element { fn onclick(self: &Button, event: &Event) -> void { ... } } See structs-impls-layout.md and interfaces.md for details. Regions & Buffers Regions (fixed-size allocation context): declare: const region arena: u8[1024]; use: with arena { let p: &Packet = new Packet{ ... }; } anonymous: with 1024 { let p: &Packet = new Packet{ ... }; } Buffers: intrinsic Buffer(T) with (ptr, capacity), unsafe primitive underpinning higher-level collections. Allocation: new uses the active region inside with (see regions.md). Concurrency Function modifiers: fn \u2014 normal. async fn \u2014 await-able; calling yields Promise(T). task fn \u2014 runs in parallel on a worker thread; calling yields Task(T). async task fn \u2014 async + task; calling yields Promise(Task(T)). Structured block: async fn getdashboarddata() -> Dashboard { // Note: the scheduler-backed async { ... } semantics are still design work, // but the compiler implements Task(T)/Promise(T) handles, yield, and await. let mut user: User; let mut orders: Order[]; async { let userpromise = fetchuserprofile(123); let orderspromise = fetchrecentorders(123); user = await userpromise; orders = await orderspromise; } return Dashboard(user, orders); } To receive task values, use yield inside a task context (task { ... } or task fn): task fn worker () -> int { return 42; } async fn main () -> int { let h = worker(); task { let value: int = yield h; return value; } } See concurrency.md for deeper semantics. Formal Silk #const \u2014 formal Silk declarations used inside specifications (not available at runtime). #require \u2014 preconditions. #assure \u2014 postconditions. #assert \u2014 block-local proof obligations. #invariant \u2014 invariants. #variant \u2014 termination measures. #monovariant \u2014 monotonic measures. theory / #theory \u2014 reusable proof obligations. require / #assure appear before functions; #invariant / #variant / #monovariant appear before loops; #const and #assert appear inside blocks. See formal-verification.md. External Declarations & ABI (Quick View) Declare external bindings: ext foo = fn (string) -> void; ext bar = u32; Strings: Silk string is internally { ptr, len }, C side uses SilkString { char ptr; int64t len; } for embedding, ext calls to typical C APIs may pass const char derived from string where appropriate."
    },
    {
      "id": "language/conventions",
      "title": "Language Spec Conventions",
      "section": "language",
      "summary": "keep the language specification consistent and easy to navigate for both:",
      "text": "Language Spec Conventions keep the language specification consistent and easy to navigate for both: first-time readers learning Silk, and returning readers looking up precise rules. Document Structure (Recommended) Concept documents should be structured so readers can answer, quickly: \u201cWhat is this feature for?\u201d \u201cWhat syntax does the compiler accept?\u201d \u201cWhat are the rules and edge cases?\u201d \u201cWhat works in the current compiler today?\u201d Recommended sections: 1. One-paragraph summary 2. Implementation status (if the concept is partially implemented) 3. Surface syntax 4. Semantics (evaluation order, scoping, control-flow behavior) 5. Type checking rules (static requirements and diagnostics) 6. Examples minimal examples (smallest correct usage) realistic examples (how the feature is used in real code) 7. Common pitfalls 8. Related documents Not every concept needs every section, but the goal is that a reader should never have to infer critical rules from examples. \u201cImplementation status\u201d Format When a feature is not fully implemented end-to-end, the concept doc should include an explicit \u201cImplementation status\u201d section near the top. Use concrete statements, not vague language. Prefer describing support in these layers: Parser: which surface forms are accepted. Checker: which typing/validation rules are enforced. Lowering/backends: which forms code-generate end-to-end on supported targets. C ABI / FFI: whether the feature is permitted at exported boundaries. When something is rejected in Silk, include the diagnostic code Examples Examples in language docs should follow these rules: Use 2-space indentation and spaces only. Prefer complete, runnable snippets when possible: fn main () -> int { return 0; } When an example requires multiple files, label them with comments, e.g.: // app/main.slk package app; When an example is intentionally invalid (to show a rule), label it and mention the expected diagnostic. Terminology These terms are used consistently across the spec: Expression: a construct that produces a value and has a type. Statement: a construct evaluated for its effects and sequencing. Block: { stmt }, a scope boundary and the unit of structured control flow. (Whether blocks are also expressions depends on the concept; docs must be explicit.) Current compiler subset: the set of features that parse, type-check, and code-generate end-to-end in the current implementation. Cross-References When describing a rule, link to the most relevant concept doc rather than restating it everywhere. Common cross-links include:"
    },
    {
      "id": "language/literals-overview",
      "title": "Literals Overview",
      "section": "language",
      "summary": "This document provides a high-level overview of literals in Silk, with details split into dedicated documents for each category.",
      "text": "Literals Overview This document provides a high-level overview of literals in Silk, with details split into dedicated documents for each category. For first-time readers, a good path is: 2. this overview (what literal categories exist), 3. the specific literal docs below (syntax, semantics, and supported behavior). Returning readers typically want the \u201cImplementation Status\u201d section near the top of each literal concept doc, plus the \u201cRelevant Tests\u201d links for runnable examples. Literal Categories Silk includes the following literal categories: Numeric literals Duration literals Boolean literals Character literals String literals Regular expression literals Aggregate literals (arrays, structs) Each literal form has well-defined syntax and type inference rules that the compiler must implement. See: literals-numeric.md literals-duration.md literals-boolean.md literals-character.md literals-string.md literals-regexp.md literals-aggregate.md"
    },
    {
      "id": "language/memory-model",
      "title": "Memory Model (Stack, Heap, and Moves)",
      "section": "language",
      "summary": "This document specifies Silk\u2019s intended memory model: how values are allocated, passed, and how (future) heap-managed values interact with the type system.",
      "text": "Memory Model (Stack, Heap, and Moves) This document specifies Silk\u2019s intended memory model: how values are allocated, passed, and how (future) heap-managed values interact with the type system. minimal heap model for new on linux/x8664 and a small lexical move/cleanup model for droppable values: new is supported for allocating non-opaque struct values on the heap and producing an &Struct reference. These heap allocations are managed via reference counting (RC) inserted by the compiler during lowering. Regions and a richer move/borrow model remain design-in-progress. See for current scope. Goals Make allocation behavior explicit and predictable. Prefer stack allocation for most local data. Prevent unsafe implicit lifetime extension (for example implicitly \u201cmoving\u201d stack data into a longer-lived heap allocation). Keep borrow safety a compile-time property (no runtime borrow errors in the safe subset). Stack vs Heap Stack allocation (default) Rule: values created without new are stack values by default. Locals hold their data directly (for example an int or a small POD struct). Passing to functions is by value. For ownership-tracked values, this is a move (the source binding is consumed); for plain scalars it behaves like a copy. Lifetime is lexical (ends when the scope ends). This aligns with the compiler, which is value-oriented and does not implement a general heap allocation model. Heap allocation (new) and boxed values Rule: values created with new live on the heap and are represented as an &Struct reference in user code. The reference value is passed by value (copying the reference representation). The underlying allocation\u2019s lifetime is managed by compiler-inserted reference counting (RC) for values originating from new. Important: this is currently an internal Silk-managed heap for Silk code, not an FFI pointer model. The current implementation does not permit &Struct for non-opaque structs in ext signatures; only &Opaque handles may cross the Details new is supported only in function bodies (top-level let initializers cannot contain new in the current implementation). new is supported only when the checker can determine a concrete reference result type of the form &Struct. In the current implementation this happens in two ways: from an expected type context &Struct (for example let x: &Packet = new Packet{ ... }; or as a call argument where the parameter type is &Struct) from the new operand itself when it names a struct type (for example let x = new Packet{ ... }; or let x = new Packet(...);), which allows let bindings to infer &Packet without an explicit annotation Only non-opaque struct types are supported for new. Reference counting is applied only to &Struct values that originate from new (borrowed stack references are not treated as RC-managed values). The silk build CLI supports --noheap to disable heap allocation for the : heap-backed new (outside a with region) is rejected with E2027, async/task/await/yield and capturing closures are rejected with E2027, ext bindings to libc heap primitives (malloc/calloc/realloc/free/etc) are rejected with E2027 in non-stdlib modules, std::runtime::mem::{alloc,realloc,free} traps when called without an active with region (no implicit heap fallback), region-backed new inside with is still permitted. Region-backed allocation (with + region) In Silk, new may also allocate from a region when an active Inside with <region> { ... }, new allocates from the region\u2019s backing bytes instead of calling the heap allocator. On last-release, region-backed new allocations run drop (when defined), but do not free their backing storage (region memory is not reclaimed by RC). Reference counting rules new initializes the allocation\u2019s RC cell to 1. Copying an RC-managed &Struct binding (for example let q: &T = p;) emits an RC retain (increment). Assigning to an RC-managed &Struct binding (for example p = q; where p is a var) releases the previous value; when the RHS is an RC-managed binding, a retain is emitted before the release to keep self-assignment safe. Exiting a scope emits RC releases (decrement) for RC-managed bindings declared in that scope, including on fallthrough, return, break, and continue. Passing new directly as a call argument to a &Struct parameter allocates a temporary and releases it after the call completes. When an RC release decrements the count to 0, the allocation is freed. Destructors (Drop) In Silk, Silk supports deterministic cleanup for resource-owning struct values via std::interfaces::Drop. A struct type is considered \u201cdroppable\u201d when it provides a method with this surface signature (usually via an interface impl): import std::interfaces; impl T as std::interfaces::Drop { public fn drop (mut self: &T) -> void { ... } } Automatic invocation : Scope exit: values are dropped when they go out of scope (including via fallthrough, break, and continue). Return: on return, the compiler drops all in-scope droppable bindings except any value moved into the return result (for example return value; and return Some(value); treat value as moved in Silk). Overwrite: assigning to an existing value drops the old value before the new value is copied in. Heap last-release: for new allocations managed by compiler-inserted RC, drop is called before freeing the backing allocation when the refcount reaches zero. Notes and limitations: drop is resolved statically (no dynamic dispatch). Values that require deterministic cleanup should be treated as ownership-tracked: consuming a binding moves it and suppresses scope-exit cleanup for that binding, using a moved binding is rejected by the checker, explicit ownership transfer may be written as move <name> (see No Implicit Heap Promotion Planned rule: stack values cannot be implicitly promoted to heap-managed storage. Any promotion must be explicit and must perform a copy. This avoids accidental lifetime extension and makes performance characteristics obvious. The precise syntax for \u201cheap-copy this value\u201d is still under design; any it is implemented. Closure Captures Silk supports capturing closures as a subset of function values. Representation: A function-typed value is a small pair: { funcptr, envptr }. funcptr is a pointer to the closure code. envptr is either 0 (non-capturing) or a pointer to a heap-allocated environment box that stores captured values. Calling convention: When envptr == 0, an indirect call behaves like a normal function-pointer call: funcptr(userargs...). When envptr != 0, the backend passes envptr as a hidden first argument to the closure function: funcptr(envptr, userargs...). Environment allocation and lifetime: Captures are by-value copies of scalar locals/parameters (int, fixed width ints, bool, char, f32, f64, Instant, Duration). The environment box begins with a u64 refcount header, followed by the captured scalar fields in a stable order. Copying a closure value retains the environment (increments refcount) when envptr != 0. Dropping a closure value releases the environment (decrements refcount) when envptr != 0; when the refcount reaches zero the environment box is freed. Limitations: Capturing non-scalar values (including string, structs, arrays/slices, optionals, and Drop types) is rejected in Silk. Captures are immutable snapshots; the does not support capturing by reference or mutating captured state. Relationship to Borrowing and Mutability Borrow checking is intended to be a compile-time property in the safe subset: invalid borrows should be rejected statically. (call-scoped aliasing checks for &T parameters in Silk)."
    },
    {
      "id": "language/mutability",
      "title": "Mutability",
      "section": "language",
      "summary": "Mutability in Silk is \u201csafe by default\u201d: values are immutable unless explicitly marked mutable under clear rules using the `mut` keyword.",
      "text": "Mutability Mutability in Silk is \u201csafe by default\u201d: values are immutable unless explicitly marked mutable under clear rules using the mut keyword. All local bindings are immutable (read\u2011only) by default. const bindings are always immutable (there is no const mut). All function parameters are immutable (read\u2011only) by default. A value parameter may be declared mut to allow reassignment of the parameter binding inside the callee (this does not affect the caller). A borrowed reference parameter (&T) follows a two\u2011part mut borrow contract: the parameter is declared mut, and the call site uses mut <expr> to explicitly create a mutable borrow. A slice parameter (T[]) is a non-owning view; when the callee intends to mutate through a slice view, it also follows a two-part contract: the parameter is declared mut, and the call site uses mut <expr> to explicitly pass a mutable slice view. This two\u2011part system makes mutation explicit and intentional. Local Mutability (let mut) Local bindings introduced with const and let are immutable by default. To allow a local binding to be updated, it must be declared with let mut (or var, which is an alias for let mut): fn main () -> int { let mut x: int = 0; x = 1; x += 2; return x; } Key rules: Only let mut bindings may appear on the left-hand side of an assignment. The left-hand side must refer to an existing binding (an lvalue). The type checker enforces that the assigned value\u2019s type matches the binding\u2019s type. The Principle: Safe by Default Example from the spec: fn readrunner(r: &Runner) { // This is OK: io::print(\"Points: {}\", r.point); // This would be a compile-time error: // r.point = 5; } Key points: Borrowed references (&T) are read\u2011only unless explicitly declared mut. Attempts to mutate through a non\u2011mutable reference are compile\u2011time errors. Granting Permission to Mutate To make mutation possible through a borrowed reference, mut is used both: In the function definition, to declare that the function intends to mutate: fn resetrunner(mut r: &Runner) { r.point = 0; } At the call site, to explicitly pass a mutable argument, acknowledging that the callee is allowed to modify it (syntax defined in the language reference). The compiler uses this to: encode a clear contract that the function may modify its argument, ensure callers are consciously opting into mutation. Compiler Requirements The compiler must: Enforce immutability by default for parameters and references. Require mut at both the declaration and call site for mutable borrows. Surface clear diagnostics when mutation is attempted without proper mut markings. Integrate mutability rules with regions, buffers, and concurrency: disallow patterns that would lead to data races, ensure that aliasing and lifetime rules are respected when mutation is allowed. Current Implementation Restrictions the compiler implements: Local let mut bindings, including assignment and numeric compound assignment. mut value parameters (fn inc(mut x: int) { x = x + 1; }) as a callee-local mutable binding (no call-site mut marker is required). Borrowed reference parameters of the form &Struct for the current supported struct subset. The two-part mut borrow contract for mutable reference parameters: parameter declared mut (e.g. fn bump(mut p: &Pair)), and call site uses mut <expr> (e.g. bump(mut pair)). Field updates through both: local let mut struct bindings (pair.a = 1, pair.b += 2), and mut borrowed reference parameters (p.a = 1, p.b += 2). Local borrowed references (&Struct) as first-class values: via the borrow operator &expr on borrowable lvalues (e.g. &pair, &obj.field), and via implicit borrow coercions in contexts that expect &T (for example let r: &Pair = pair;). These borrows are checked with conservative lexical lifetime rules (they may not escape the scope of the borrowed stack storage). Local bindings of &Struct values that originate from heap allocation (new) or from calls that return &Struct: these &Struct values are refcounted in Silk, copying a &Struct binding (e.g. let g: &File = f;) creates an alias to the same underlying heap allocation and increments the refcount. Borrow Safety Rules Borrowed references (&T) in Silk are safe-by-default and, for now, use conservative lexical lifetime checks: Borrowed references can be created and stored as local values (see above). The callee can mutate a borrowed reference only when: the parameter is declared mut, and the caller uses mut <expr> at the call site. Mutable borrows must be explicit and must originate from a borrowable lvalue: borrowing a local binding requires a writable base (let mut) or an already-mutable view, and field borrows follow the same rule (the base must be writable). Slice views (T[]) are also call-scoped and safe-by-default: A slice value is a non-owning view (pointer + length) and may alias other slice views into the same underlying storage. Slice range borrows are created via: &a[start..end] &a[..end] &a[start..] A mutable slice view is created via mut &a[...] and is restricted: the base must be a borrowable lvalue (a name or a field-access chain rooted at a name), and the base storage must be writable (let mut for fixed arrays / structs, or an already-mutable view such as a mut borrowed reference parameter), or already a mutable slice view. A function parameter of slice type may be declared mut to allow mutation through the slice view, and requires the caller to pass a mutable slice view using mut <expr>. When a slice value is stored in a struct field (xs: T[]), the stored view\u2019s mutability is tracked: storing &a[...] stores a read-only view, and storing mut &a[...] stores a mutable view. A call-site mut <expr> marker does not upgrade a read-only stored view into a mutable one; passing a field as mut requires that the field already holds a mutable view. Aliasing Restrictions (Per Call) Within a single call expression, the compiler enforces conservative aliasing rules to avoid creating multiple mutable views of the same storage: A given binding may be mutably borrowed at most once in a single call. A binding may not be both mutably and immutably borrowed in the same call. Multiple immutable borrows of the same binding are permitted. For slice parameters (T[]), these same per-call aliasing restrictions apply. Additionally, when both borrows are slice range borrows of the same base with integer-literal bounds, the checker permits multiple mutable borrows in the same call when it can prove the two ranges are disjoint (including when the slices are first bound to locals and then passed by name). When borrowing a range from an existing slice binding (for example s: T[]), the checker interprets &s[start..end] as a subrange of the underlying base (offset by s\u2019s known bounds) for the purposes of overlap checks. This disjointness reasoning is currently limited to integer-literal bounds and to slice bindings whose own bounds are known. For &Struct reference-typed local bindings and slice-typed (T[]) local bindings, the compiler also tracks obvious aliasing introduced by copying and ref \u201cshape casts\u201d: Copying a &Struct binding produces an alias (it refers to the same storage). Copying a slice binding (T[]) produces an alias (it refers to the same underlying storage). Casting &S to &T via as under the shape-cast rules produces an alias (it is a retyped view of the same storage). The per-call aliasing restrictions apply across aliases: within a single call expression, you may not take multiple mutable borrows (or both mutable and immutable borrows) of the same underlying reference, even if they are held under different local names. Example (rejected): fn swap(mut a: &Pair, mut b: &Pair) { // ... } fn main () -> int { let mut p: Pair = Pair{ a: 1, b: 2 }; swap(mut p, mut p); // error: two mutable borrows of p in one call return 0; } Example (allowed, immutable): fn sum2(a: &Pair, b: &Pair) -> int { return a.a + a.b + b.a + b.b; } fn main () -> int { let p: Pair = Pair{ a: 1, b: 2 }; return sum2(p, p); // OK: multiple immutable borrows } ABI Notes (Exported/C Boundaries) At C ABI boundaries (export fn), reference types are supported only for opaque handle types (&Opaque / mut &Opaque). Non-opaque &Struct borrows are not ABI-stable; see the ABI and struct layout docs for the current rules."
    },
    {
      "id": "language/literals-numeric",
      "title": "Numeric Literals",
      "section": "language",
      "summary": "Numeric literals produce integer (`int`, `u8`, `i128`, \u2026) and floating-point (`f32`, `f64`, `f128`) values.",
      "text": "Numeric Literals Numeric literals produce integer (int, u8, i128, \u2026) and floating-point (f32, f64, f128) values. In Silk, the sign is an operator: -1 is a unary - expression applied to the integer literal token 1, not a distinct \u201cnegative literal\u201d token. Quick Reference fn main () -> int { let a = 42; // int let b: u8 = 42; // u8 (typed by context) let x: f64 = 1.5; // f64 let y: f32 = 1.5; // f32 (typed by context) let d: Duration = 5ms; let t0: Instant = 0; return 0; } Surface Syntax (Current Lexer) In the current implementation, numeric literal tokens are recognized as: Integer literal: decimal digits ([0-9]+), binary prefix: 0b / 0B followed by binary digits ([01]+), octal prefix: 0o / 0O followed by octal digits ([0-7]+), hex prefix: 0x / 0X followed by hex digits ([0-9a-fA-F]+), legacy octal: 0[0-7]+ (for example 017). Float literal: digits, ., digits ([0-9]+ '.' [0-9]+) Notes: A float literal must have digits on both sides of the .: 1.0 is a float literal. 1. is not a float literal in the current lexer. .5 is not a float literal; write 0.5. Numeric literals must start with a digit in the current lexer. The - sign is not part of the literal token: 1 parses as unary - applied to the integer literal 1. 1.5 parses as unary - applied to the float literal 1.5. A numeric token immediately followed by a duration unit suffix (e.g. 1s, 500ms, 1.5s) is a single Duration literal token, not a number token followed by an identifier. A numeric literal token may not be immediately followed by an identifier start character or an ASCII digit (unless the identifier characters are part of a duration unit suffix). For example: 3in is a lexical error (write 3 in or 3 in as intended), 0b102 is a lexical error (invalid binary digit), 08 is a lexical error in Silk because multi-digit literals starting with 0 are legacy octal (use 0o10 for octal 8, or write 8 for decimal). Type Rules Integer literals Without an expected type, an integer literal has type int. When a context provides an expected type that is: an integer type (u8, i64, int, \u2026), or a time type (Duration, Instant), then the integer literal adopts that expected type. Example: parameter context and \u201cadopt the expected type\u201d fn idu8 (x: u8) -> u8 { return x; } fn main () -> int { // 255 is contextually typed as u8 because idu8 expects u8. let v: u8 = idu8(255); if v != 255 { return 1; } return 0; } Example: time types share an i64-based representation in Silk Instant/Duration values via context: fn main () -> int { let t0: Instant = 0; let d: Duration = 1s; let t1: Instant = t0 + d; let diff: Duration = t1 - t0; if diff != d { return 1; } return 0; } Float literals Without an expected type, a float literal has type f64. When a context provides an expected float type (f32 or f64), the literal adopts that expected type. fn idf32 (x: f32) -> f32 { return x; } fn main () -> int { // 1.5 is contextually typed as f32 because idf32 expects f32. let v: f32 = idf32(1.5); if v != 1.5 { return 1; } return 0; } Common Pitfalls Trying to use suffixes: 42u8 / 1.5f32 are not supported. Use type annotations (let x: u8 = 42;) or casts (42 as u8). Using digit separators: 1000 is not supported yet. Using exponent notation: 1e6 is not supported yet. Writing incomplete floats: write 1.0 (not 1.) and 0.5 (not .5). to convert explicitly when you need to combine integer and float values. Related Documents Relevant Tests Integer literal contextual typing (u8 parameters): Integer wrap behavior in arithmetic: Float literal contextual typing (f32 parameters): Float literal default type (f64): Float arithmetic and comparisons: Duration literals (numeric + unit suffix): Integer literal base prefixes and legacy octal:"
    },
    {
      "id": "language/operators",
      "title": "Operators",
      "section": "language",
      "summary": "This document summarizes the operator set and precedence for Silk.",
      "text": "Operators This document summarizes the operator set and precedence for Silk. Operator Set The language includes the following operators and delimiters: Assignment and compound assignment: =, +=, -=, =, /=. Increment/decrement: ++, -- (prefix and postfix). Arithmetic: +, -, , /, %. In the current implementation: integer operands support +, -, , /, and %, floating-point operands (f32/f64) support +, -, , and / (no %). unary -x is supported for both integer and floating-point operands. time types support a small arithmetic subset: Duration + Duration, Duration - Duration, and unary -Duration, Instant + Duration, Duration + Instant, Instant - Duration, and Instant - Instant (producing a Duration). Bitwise: &, , ^, ~, <<, >>. In the current implementation, bitwise operators are defined for integer operands (int and the fixed-width integer types): &, , ^ perform bitwise AND/OR/XOR on two integer values of the same type and produce a result of that same type. ~x performs bitwise NOT on an integer value and produces a result of that same type. <<, >> shift the left-hand integer operand by an integer shift amount of the same type; >> uses an arithmetic right shift for signed integers (i/int) and a logical right shift for unsigned integers (u). Comparison: ==, !=, <, <=, >, >=. In the current implementation, comparisons are defined for both integer operands and floating-point operands of the same type. In Silk, == and != are also defined for bool operands. In Silk, comparisons are also defined for Duration and Instant when both operands have the same time type. In Silk, == and != are also defined for string operands, comparing the underlying UTF-8 byte sequences for equality (length check + bytewise compare). In Silk, ordered comparisons over string (<, <=, >, >=) are defined as bytewise lexicographic ordering over the underlying UTF-8 byte sequences (unsigned byte comparison, with shorter-prefix ordering when one string is a prefix of the other). In Silk, == and != are also defined for supported optional values (T?, string?, optionals of the supported struct subset, and nested optionals T??): None == None is true, Some(x) == Some(y) compares the payload values for equality (recursively for nested optionals), and != is the logical negation of ==. In the current implementation, None and Some(...) can appear in equality expressions when the other operand has an optional type (for example opt == None and opt == Some(x)), using that other operand\u2019s type to infer the optional payload type. In Silk, == and != are also defined for the performing slot-wise equality over the lowered scalar slots (including embedded strings, nested structs, and optionals); float slots use IEEE-754 equality semantics. Ordered struct comparisons are not implemented. Float comparisons follow IEEE-754 semantics: NaN compares unequal to everything (including itself), and ordered comparisons (<, <=, >, =) are false when either operand is NaN. Logical: !, &&, . In the current implementation: ! is supported for bool operands. Member and scope: ., ::, ?.. In the current implementation: . and :: are supported, and ?. is supported for optional field access on the supported struct Casts: as and as raw (postfix). Syntax: numeric/shape cast: <expr> as <Type>, raw bit-cast: <expr> as raw <Type>. as is an explicit, potentially lossy conversion operator intended for primitive numeric conversions (see \u201cCasts (as)\u201d below). as raw is an explicit bit reinterpretation operator intended for generic storage/marshalling of scalar values (see \u201cRaw casts (as raw)\u201d below). Typed error propagation: ? (postfix). Syntax: <callexpr>?. This propagates typed errors from an error-producing call to the enclosing Ranges: ..., ..=, ... Other punctuation: ?, ??, ->, =>, ,, ;, (, ), {, }, [, ], , :. In the current implementation, ?? is supported for optionals in the current backend subset (including scalar, string, and the current struct subset, plus nested optionals in the supported payload subset; annotations (T?) and as the postfix typed error propagation operator for The lexer and parser must recognize these tokens exactly as specified, and precedence/associativity must match the formal grammar. Assignment Assignment updates an existing binding (an lvalue). Assignment is \u201cstatement-like\u201d: it is parsed as an expression but has type void and is intended to appear as an expression statement. = x = expr evaluates expr and stores the resulting value into x. Rules: The left-hand side must be an assignable lvalue. In the current implementation, it may be: an identifier that refers to a local let mut binding, or a struct field lvalue name.field where name is either: a local let mut binding of a supported POD struct, or a mut borrowed reference parameter (mut name: &Struct). Identifier lvalues must refer to let mut local bindings. The type of expr must match the binding\u2019s type. The assignment expression has type void. Compound assignment (+=, -=, =, /=) Compound assignments are shorthand for \u201cread-modify-write\u201d: x += y is equivalent to x = x + y (and similarly for -=/=//=), with y evaluated exactly once. Rules: The left-hand side must be an assignable lvalue (as described above for =). In the current implementation, compound assignments are supported only for numeric scalar types (integers and f32/f64), including numeric struct fields. The compound assignment expression has type void. Increment and Decrement (++ / --) ++x, x++, --x, and x-- increment or decrement an existing binding by 1. In Silk, increment/decrement expressions are \u201cstatement-like\u201d: they have type void and are intended to appear only as expression statements. Rules: The operand must be an assignable lvalue (the same lvalue rules as =). The operand type must be an integer scalar type (int, i8, u8, i16, u16, i32, u32, i64, u64, size, usize). (isize is accepted as an alias for size.) Prefix and postfix forms are equivalent in Silk (both update the binding and produce void). Conceptual desugaring: x++ and ++x are equivalent to x += 1; x-- and --x are equivalent to x -= 1; sizeof sizeof <operand> produces the size of a type or value in bytes. Result type: sizeof always returns usize. Evaluation mode: When the operand is a type name (a primitive type, struct/enum name, type alias, or qualified type name), sizeof is a compile-time constant. When the operand is a compile-time constant value (literals and other const-evaluable expressions), sizeof is a compile-time constant. When the operand is a runtime value, sizeof is evaluated at runtime. Sized integration: Planned: for runtime values, if the operand type provides an instance method matching std::interfaces::Sized (fn size(self: &Self) -> usize), sizeof value will lower to a call of that method. For type operands, if the operand type provides a static, pure method pure fn size() -> usize, the compiler may fold sizeof Type to that value when the method body is const-evaluable; otherwise it falls back to the compiler\u2019s built-in size model. Built-in size model : each lowered scalar occupies one 8-byte slot. A string value occupies two slots ((u64 ptr, i64 len)), so sizeof string is 16 In Silk. A T[] slice value occupies two slots ((u64 ptr, i64 len)), so sizeof T[] is 16 In Silk. A T[N] fixed array occupies N sizeof(T) bytes in Silk, using the element\u2019s scalar-slot size. Parsing note: Because Name[expr] is also indexing syntax, fixed array type operands should be parenthesized: sizeof (u8[4]). Without parentheses, sizeof u8[4] is parsed as an index expression. Because as binds at postfix precedence, sizeof x as T parses as sizeof (x as T). To cast the result of sizeof, write (sizeof x) as T. alignof alignof <operand> produces the alignment of a type or value in bytes. Result type: alignof always returns usize. Evaluation mode: When the operand is a type name (a primitive type, struct/enum name, type alias, or qualified type name), alignof is a compile-time constant. When the operand is a compile-time constant value (literals and other const-evaluable expressions), alignof is a compile-time constant. When the operand is a runtime value, alignof is evaluated at runtime. Built-in alignment model : Alignments reflect the current scalar-slot lowering model All non-void types currently have alignment 8. alignof void is 1. Parsing notes: As with sizeof, fixed array type operands should be parenthesized: alignof (u8[4]). Without parentheses, alignof u8[4] is parsed as an index expression. Because as binds at postfix precedence, alignof x as T parses as alignof (x as T). To cast the result of alignof, write (alignof x) as T. offsetof offsetof(Type, fieldpath) produces the byte offset of a struct-like field within Type in the current memory layout model. Result type: offsetof always returns usize. Evaluation mode: offsetof is always a compile-time constant. Operands: Type must name a struct or error type (including nested structs). fieldpath is one or more field identifiers separated by . (for example b or inner.header.len). Built-in offset model : Offsets reflect the current scalar-slot lowering model 8-byte cell, and composite fields (nested structs, optionals, strings, etc.) are expanded into their slot sequences in source order. offsetof(Type, field) returns the offset of the first slot of that field\u2019s lowered representation, in bytes. When fieldpath traverses an optional T? field, it refers to the payload layout (the path implicitly skips the tag slot). typename typename <expr> and typename(<expr>) produce a string naming the static type of <expr>. Result type: typename always returns string. Evaluation mode: typename is always a compile-time constant string. Operand notes: When the operand is a bare name that does not resolve to an in-scope runtime binding (for example int, User, or std::wasm::Module), the compiler interprets it as a type name and returns that type\u2019s name. Formatting uses the compiler\u2019s normal type formatting (for example T[], &T, and fn (...) -> ...). For monomorphized generic instantiations, the string is the human-readable display name (not an internal silkmono... symbol). is <expr> is <Type> checks whether the static type of <expr> conforms to <Type>. Result type: is always returns bool. Evaluation mode: is is always a compile-time constant boolean. Rules: The right-hand side must be a type (primitive, nominal struct/enum/error, interface, a function type, or a type alias for one of those). If <Type> is a nominal struct type, expr is Type is true when the expression\u2019s static type is exactly Type or a struct that extends Type. If <Type> is an interface, expr is Interface is true when the expression\u2019s static type declares conformance (impl T as Interface) or when the operand is a module declared module Name as Interface. For primitive types, enum/error types, reference types (&T), slice/array types (T[], T[N]), optionals (T?), and function types, is currently checks exact type equality (after resolving type aliases). Notes: is does not perform runtime tagging or value inspection. For runtime discrimination of union/optional values, use match and the relevant pattern forms. Examples: type Adder = fn (x: int, y: int) -> int; fn myadder (x: int, y: int) -> int { return x + y; } if myadder is Adder { / ... / } struct User { id: u64 = 0 } struct Beep extends User { boop: string = \"\" } let beep = Beep{ boop: \"boop\" }; if beep is User { / ... / } let n = 123; if n is int { / ... / } interface Logger { fn log (value: string) -> void; } module mylogger as Logger { export log (value: string) { / ... / } } if mylogger is Logger { / ... / } Wrapping and Overflow The spec notes \u201cArithmetic Wraps\u201d for certain operators. The checker and code generator must: Implement deterministic wrapping behavior for integer arithmetic where required. Clearly separate wrapping operations from checked or saturating variants (if exposed in the standard library). Casts (as) as is a postfix operator that performs an explicit conversion to a target type. Precedence as binds at postfix precedence (like calls, field access, and ?). For example: a + b as int parses as a + (b as int). To cast the result of new, use parentheses so the cast applies to the heap reference: (new Type{ ... }) as &Other. Without parentheses, new Type{ ... } as &Other parses as new (Type{ ... } as &Other). Supported conversions In Silk, as is supported for primitive scalar conversions: Integer \u2192 Integer (including Instant, Duration, and char): The conversion is deterministic and may be lossy. It is performed by canonicalizing the underlying bits to the destination integer type (width truncation + sign/zero extension as appropriate). For scalar widths up to 64 bits this matches the behavior of ir.CastInt in the current IR; i128/u128 follow the analogous rule over their { lo, hi } lane layout. Float \u2192 Float: f32/f64/f128 conversions using standard IEEE-754 conversion and rounding. Integer \u2192 Float: Converts the integer value to the destination float type (IEEE-754), with rounding when the integer cannot be represented exactly. Float \u2192 Integer: Converts by truncating toward zero. If the source value is NaN, the result is 0. If the source value is outside the destination integer\u2019s representable range, the result saturates to the nearest bound (min/max for signed, 0/max for unsigned). Struct \u2192 Struct (safe \u201cshape cast\u201d): A cast from S to T is permitted when both S and T name non-opaque struct types and their fields match positionally: same field count, and for each index i, the field type of S at i is exactly the same type as the field type of T at i (field names may differ). This is intended for \u201cnewtype-like\u201d wrappers and schema evolution where two structs have the same shape but different field names. Semantics: the cast produces a value copy of the underlying struct slots, retyped as T. The operation does not reorder fields. &Struct \u2192 &Struct (safe \u201cshape cast\u201d for references): A cast from &S to &T is permitted when S and T are compatible under the same Struct \u2192 Struct \u201cshape cast\u201d rules above. Semantics: the cast produces a retyped view of the same referenced storage. It does not allocate and does not copy the underlying struct slots. For refcounted heap references created by new, the cast is still a view only: it must not change which drop implementation runs when the refcount reaches zero. The allocation\u2019s concrete type (tracked through the value, not the view type) determines Drop behavior at the last release. This means the two references alias: reading fields through the cast view observes updates made through the original reference (and vice versa). Because the two references alias, the compiler\u2019s per-call mutable-borrow restrictions treat aliases as the same storage: a single call expression may not take multiple mutable borrows (or both mutable and immutable borrows) of the same underlying reference, even if the aliases are held This cast is intentionally conservative: it is permitted only when the compiler can prove the two referenced struct layouts are identical at the type level (same field types in the same order). It does not permit arbitrary \u201creinterpret pointer\u201d casts. u64 \u2194 T[] / T[N] (unsafe pointer/slice view cast): Silk\u2019s represents raw addresses as u64. For low-level byte-copy routines and runtime interop, as supports explicit conversions between raw addresses and array/slice views: ptr as T[] constructs a T[] slice view where the pointer component is ptr and the length component is a dedicated unknown-length sentinel (in the current implementation, i64.min). The compiler does not validate the pointer value. Indexing and assignment through an unknown-length slice are permitted but unchecked: the runtime performs no index < len bounds check. Operations that require a known length (iteration, slicing, etc.) trap unless an explicit length is provided. ptr as T[](len) constructs a T[] slice view where the pointer component is ptr and the length component is len (element count). slice as u64 extracts the pointer component of a T[] slice. arr as u64 extracts the address of element 0 of a fixed array T[N] (for N == 0, the result is 0). These casts remain unsafe: the compiler does not validate pointer provenance (whether the address is valid for the claimed element type). In Silk, indexed accesses through arrays/slices trap when: the pointer is 0, the pointer is not 8-byte aligned, the explicit length is negative (when provided), the index is out of bounds (index < len) when the slice/array has a known (non-unknown) length. Serialize(T)-backed casts (explicit conversion via serialize()): When the operand type provides a unique instance method named serialize matching the std::interfaces::Serialize(T) surface (fn serialize(self: &Type) -> T), expr as T is permitted and lowers to a call of that method. The conversion is explicit (it does not introduce implicit coercions). The serialize method must be infallible (no typed errors). Purity rules apply: inside pure fn, the serialize method must be pure. Limitation: the compiler must be able to resolve the receiver\u2019s nominal type at the cast site so it can lower the implicit serialize() call. This includes name expressions, field accesses, calls, and array/slice indexing (arr[i] as T) in the current implementation. Deserialize(S)-backed casts (explicit conversion via deserialize(...)): When the target type provides a unique static method named deserialize matching the std::interfaces::Deserialize(S) surface (fn deserialize(value: S) -> Self), expr as Self is permitted and lowers to Self.deserialize(expr). This rule is checked before struct shape casts: when both a deserialize conversion and a shape cast could apply, the deserialize conversion is used. The conversion is explicit (it does not introduce implicit coercions). The deserialize method must be infallible (no typed errors). Purity rules apply: inside pure fn, the deserialize method must be pure. Examples: struct Data { value: string, } struct User { name: string, } fn main () -> int { let data = Data{ value: \"hello\" }; let user = data as User; assert data.value == user.name; return 0; } struct A { value: string, } struct B { value: string, } fn setvalue (mut b: &B, value: string) -> void { b.value = value; } fn main () -> int { let a: &A = new A{ value: \"hello\" }; var b = a as &B; setvalue(mut b, \"world\"); assert a.value == \"world\"; assert b.value == \"world\"; return 0; } Notes: as does not participate in the implicit call-argument coercion mechanism destination struct and is used primarily for stdlib ergonomics). Raw casts (as raw) as raw is a postfix operator that reinterprets the raw bits of a scalar value as another scalar type. It is intended for use in generic collections and low-level marshalling where numeric conversion would be incorrect (notably when storing f32/f64 values in integer-backed storage). Syntax: <expr> as raw <Type> Rules: Both the operand and the target type must be numeric primitive types supported by the backend: 64-bit-slot scalars: i8/u8/i16/u16/i32/u32/i64/u64/int, f32/f64, plus int-like primitives lowered to those scalars such as Duration/Instant and char. 128-bit wide primitives: i128/u128/f128 (two 8-byte lanes; f128 stores the raw IEEE-754 binary128 bit pattern). as raw is not permitted for string, void, &T, optionals, arrays, maps, function types, or structs/enums. Semantics: The operand\u2019s current canonical scalar bits are reinterpreted as the target type\u2019s canonical scalar bits (bit-level truncation/masking for narrower target widths such as u8/u16/u32 and f32). For 128-bit primitives, this is lane-wise: the low lane is copied as u64 bits, the high lane is reinterpreted across u64/i64 as needed, when casting a 128-bit value to a <=64-bit target, the low lane is used, when casting a <=64-bit integer value to i128/u128, the high lane is sign-extended (i128) or zero-extended (u128) in the current subset. No numeric conversion is performed. For example, 1.0 as u64 yields 1, while 1.0 as raw u64 yields the IEEE-754 bit pattern. Examples: let bits: u64 = (1.0 as f32) as raw u64; let f: f32 = bits as raw f32;"
    },
    {
      "id": "language/optional",
      "title": "Optional",
      "section": "language",
      "summary": "The `Optional` type provides a safe way to represent values that may or may not be present, instead of relying on sentinel values such as `null`.",
      "text": "Optional The Optional type provides a safe way to represent values that may or may not be present, instead of relying on sentinel values such as null. The nominal type constructor is Option(T). The shorthand T? is sugar for Option(T) and is the recommended form. Optional values are constructed using Some(...) and None (the compiler also accepts none as an alias of None). The null literal is distinct from None, but may coerce to None when an optional type is expected. Use match, ?. (optional chaining), and ?? (coalescing) to consume optionals. Declaring Optional Types You can declare variables or fields as optional using either: T? (idiomatic suffix form), Option(T) (nominal form). The language design treats these as equivalent. The type system (src/types.zig) models optional types, and the parser now accepts both: the suffix form T? in type annotations, and the nominal form Option(T) for simple cases (a single type argument), which is desugared into the same internal optional representation as T?. For example, the following is valid today and type-checks successfully (note that the current compiler requires let initializers; see fn main () -> int { let a: string? = None; let b: Option(string) = None; return 0; } The current linux/x8664 IR\u2192ELF backend subset now supports a first slice of optional values for a subset of payload types: construct optionals via None and Some(value), access fields of optional structs via optional chaining (opt?.field, producing a FieldType? value), use nested optionals (T??) for a subset of payloads in the current backend (see below), compare supported optionals via == / != (tag + payload equality; nested optionals compare recursively), unwrap optionals via ?? (coalescing) with short-circuit evaluation of the fallback expression, explicitly branch on optionals via the match expression (see and pass/return such optionals between helpers in the supported IR subset. Supported optional payloads in this backend subset include: scalars (bool, char, f32, f64, int, and fixed-width integers), string (lowered as { ptr: u64, len: i64 }), enums (tagged unions) in the current enum backend subset (lowered as (u64 tag, payload0, payload1, ...)), and the supported struct subset (0+ fields of supported value types, In this subset, optionals are represented at IR boundaries as a Bool tag followed by the payload scalars: (Bool tag, payload0, payload1, ...) where tag=0 means None and tag=1 means Some(...). The payload scalar slots follow the same lowering rules as the underlying non-optional type (1 scalar for scalar payloads, 2 scalars for string, N scalars for the current struct subset, and N scalars for enums (including the enum\u2019s own u64 tag slot). Nested optionals (T??) are supported in this backend subset for the same payload subset (scalars, string, enums, and the supported struct subset). In this subset, T?? is represented as an outer optional whose payload is the full inner optional representation: for example int?? lowers as (Bool tag0, Bool tag1, i64 payload). Not yet implemented: optional chaining beyond the current optional-struct field access subset (for example chaining through optional fields, optional method calls, and optional indexing), match over non-optional scrutinee types (and richer pattern forms beyond None/Some(...)), and richer optional forms beyond the backend. Note: optional payload equality (== / !=) is still limited in the current backend subset; comparisons against None are supported broadly, but full payload equality for all optional payload kinds (notably optional-of-enum) is still evolving. For the current C ABI mapping of optionals in exported function signatures Creating Optional Values An optional can be: None \u2014 the empty state. Some(value) \u2014 the value\u2011holding state. Examples from the spec: let age: u32? = None; let age: u32? = Some(30); struct User = { profile: None }; profile: Some({ email: \"some@example.com\", age: Some(30) }) The compiler infers the optional\u2019s element type from context when possible. In the current implementation, equality comparisons provide optional type context for None / Some(...) operands, so forms like opt == None and opt == Some(value) type-check when opt has type T?. None: The Empty State None represents the absence of a value. Spelling note: None may also be written as none (alias). The null literal is a distinct literal that can coerce to None in optional contexts. Key points: None can be assigned to any T?; its concrete T is inferred. In pattern matching and control flow, None corresponds to the empty branch. Some(value): The Value-Holding State Some(value) wraps a concrete value in an Option(T). Key points: The type of Some(value) is T? (or Option(T)). Nested optionals are allowed (e.g. a struct containing fields that are T?). Optional-Coalescing Operator ?? The ?? operator unwraps an optional by providing a fallback value if it is None. From the spec: It \u201ccoalesces\u201d the optional\u2019s value and the default into a single, non\u2011optional result. The expression opt ?? defaultvalue has type T when opt has type T?. When opt has type T??, the expression opt ?? defaultvalue has type T? (it unwraps one optional layer). It composes naturally with optional chaining. Example: let emailaddress: string = user2.profile?.email ?? \"no-email-provided@domain.com\"; Using Optional Values The spec provides several mechanisms for working with optionals: Optional chaining ?.: user.profile?.email yields string?. If any link in the chain is None, the result is None. Coalescing ??: Converts an optional into a non\u2011optional by supplying a default. Explicit checking via match: Pattern\u2011matching on Some(...) / None to handle both cases explicitly. Compiler Requirements The compiler must: Support T? and Option(T) as equivalent surface forms. Ensure that Some / None usage is type\u2011correct. Track optionality in the type system and enforce checks when unwrapping. Implement ?. and ?? with the short\u2011circuit semantics described above. Support match on Option(T) and integrate optionals with flow control and error reporting."
    },
    {
      "id": "language/packages-imports-exports",
      "title": "Packages, Imports, and Exports",
      "section": "language",
      "summary": "This document specifies the initial surface syntax for packages, imports, and exports in Silk. The semantics are intentionally minimal for now and will be extended as the compiler\u2019s resolver and linker mature.",
      "text": "Packages, Imports, and Exports This document specifies the initial surface syntax for packages, imports, and exports in Silk. The semantics are intentionally minimal for now and will be extended as the compiler\u2019s resolver and linker mature. Terminology Source file: a single .slk source file. Package: a named collection of source files that share a namespace (declared via package ...;). Module declaration: a module ...; header that declares a namespace and a compile-time-only module value, and may declare interface conformance via as. Module set: the set of source files the compiler is compiling together for a given command. Package imports can only resolve to packages that exist in this module set. Named import: import { A, B as C } from \"...\"; (introduces unqualified names). Default import: import X from \"...\"; (binds either a default export symbol or a namespace, depending on what is imported). Namespace import: a default import that binds a module or package namespace; you access its members as X::Name. Packages A Silk program is organized into packages and source files. Each source file may declare the package it belongs to using a package declaration at the top of the file: package myapp::core; Rules: Each module MAY declare at most one package declaration. When present, the package declaration MUST appear before all other top-level declarations in the module; it is the first declaration in the file. Package names are sequences of identifiers separated by ::. As a special case, the keyword task is permitted as a ::-qualified segment so std::task is a valid package name. std::strings std::task myapp::core example The standard library lives under the reserved std:: namespace, for example std::strings, std::memory, etc. If a source file omits a package declaration, it is treated as belonging to an implementation-defined default package (for example, the \u201cmain\u201d package for an executable). The exact rules for default packages will be specified as multi-module builds are implemented. In the current silk CLI implementation, when building a package via a package manifest (silk.toml), source files that omit package default to the Modules (module) module declares a named module namespace and a compile-time-only module value. Syntax: module myapp::core; module myapp::core as SomeInterface; Rules: A source file MAY declare at most one module declaration. A source file MAY declare at most one of: a package declaration, or a module declaration. When present, the module declaration MUST appear before all other top-level declarations in the source file; it is the first declaration in the file. Module names follow the same ::-qualified naming rules as packages. Modules are compile-time-only values: there is no runtime representation for a module value. If a module declares as <Interface>, the compiler MUST validate that the module satisfies the interface surface as specified in Inline modules (module Name { ... }) In addition to the source file header form (module ...;), Silk supports inline modules as a nested-namespace mechanism inside a file: package mypackage; export module innermodule { export fn hello () -> string { return \"hello world\"; } } Rules : Inline modules MUST appear at top level (not inside function blocks). The inline module name is a single identifier. The body is a brace-delimited list of top-level declarations; inline modules may be nested. package, header-form module ...;, and import declarations are not permitted inside an inline module body. Declarations inside an inline module are referenced from outside using :: qualification (innermodule::hello()). Within an inline module body, unqualified name lookup for inline-module declarations is not implemented yet in Silk; use explicit :: qualification. export module Name { ... } exports the namespace: exported declarations inside it become part of the containing package\u2019s export surface with their names prefixed by Name:: (for example innermodule::hello), nested export module declarations extend the prefix (for example outer::inner::name). Source File Header Ordering (Mandatory) In each source file, top-level declarations must appear in this order: 1. Optional package or module declaration (package ...; or module ...;). 2. Zero or more import declarations, as a contiguous block. 3. All other top-level declarations. This ordering is enforced by the parser/resolver and keeps dependency structure easy to understand and tooling-friendly. Imports Source files may refer to other packages or modules via import declarations: package myapp::core; import std::strings; fn main () -> int { return 0; } Rules: import declarations MUST appear at top level (not inside functions or blocks). All import declarations in a module, if any, MUST appear after the optional package declaration (if present) and before any other kind of top-level declaration. In other words, imports form a contiguous block at the beginning of the module immediately following the optional package. An import path is a sequence of identifiers separated by ::, matching the package naming rules above (including the std::task special case). As with expression/type qualified names, an import path MAY start with :: to explicitly name the global namespace (the unnamed package). import declarations identify dependencies and bring exported symbols from the imported package into scope in the importing module, subject to the visibility rules below. In the current implementation: importing a package makes its exported let bindings with explicit type annotations visible as ordinary, unqualified names in the importing module (for example, import util; followed by answer refers to util::answer when util exports let answer: int = 42;), imported exported let bindings are also reachable via qualified names of the form pkg::name (for example, util::answer after import util;); both unqualified (answer) and qualified (util::answer) forms are accepted for now, but the qualified form reflects the intended package-namespaced style, exported functions (export fn) are callable across packages for the compiler\u2019s current backend subset: within a package, top-level functions form a shared namespace across all modules in that package (so functions in one module may call functions defined in another module of the same package), when a module imports a package, that package\u2019s export fn declarations become callable from the importing module, both unqualified (foo()) and qualified (util::foo()) call forms are accepted initially for imported exports, matching the current constant-import behavior, though the qualified form reflects the intended package-namespaced style, this callable subset is limited to the compiler\u2019s current code generation subset (supported parameters/results, direct calls, and structured control flow supported by the IR\u2192ELF backend on linux/x8664), struct type names (struct declarations) from imported packages are visible in the importing module for the current supported struct subset: the qualified form pkg::Struct is always accepted when pkg is imported, the unqualified form Struct is accepted when it is unambiguous across the module\u2019s imports and does not conflict with a locally defined struct name, when multiple imported packages define the same struct name, the unqualified form is rejected as ambiguous and the qualified form must be used, enum type names (enum declarations) from imported packages are visible in the importing module for the current supported enum subset: the qualified form pkg::Enum is always accepted when pkg is imported, the unqualified form Enum is accepted when it is unambiguous across the module\u2019s imports and does not conflict with a locally defined type name, enum variants are referenced relative to the enum name (Enum::Variant or pkg::Enum::Variant), if an imported package does not exist, resolution fails before type-checking (see the resolver). a leading :: on a qualified name forces lookup in the global namespace (the unnamed package), bypassing any same-named declarations in the current package or imported packages. This is intended as an explicit escape hatch for shadowing (for example, calling ::malloc(...) when the current module also defines or exports malloc). The prefix is valid in both expression and type positions, including: values: ::malloc(...), types and struct literals: ::Foo and ::Foo{...}, enum variant paths/patterns: ::E::Variant. Qualified Symbol Imports In addition to importing whole packages, a module may import a single symbol by fully qualifying it: import std::io::println; import std::url::URL; import ::malloc; Semantics: If the import path matches a package name present in the module set, it is a package import (import std::io;). Otherwise, it is treated as a qualified symbol import: the compiler finds the longest package-name prefix of the path, the remaining suffix is the symbol name within that package (it may contain :: due to exported inline modules), the symbol is introduced into the importing module under its final path segment (for example, println for import std::io::println;). When the import path begins with ::, the symbol is resolved from the global namespace (the unnamed package) and is not subject to package export gating. import { Name } from \"...\"; remains the preferred form when you need to rename imports (as) or import from a file path. Global namespace (::name) rules : The global namespace is the package formed by modules that have no package ...; or header-form module ...; declaration (their package name is empty). ::Name resolves Name from that global namespace, if a matching declaration exists in the current module set. ::Outer::Inner::Name resolves Outer::Inner::Name from that same global namespace (for example, names nested under inline modules in a global module). Global names are only accessible via the explicit :: prefix; there is no implicit \u201cprelude import\u201d of global symbols. Future extensions may introduce aliasing (e.g. import std::strings as str;) and more fine-grained import forms. Such features will be documented here before they are implemented. Example: a two-module package program Two modules can share a package name and export symbols for other packages to use. // util.slk package util; export let answer: int = 41; export fn add1 (x: int) -> int { return x + 1; } // app.slk package app; import util; fn main () -> int { // In the current implementation, both unqualified and qualified access are // accepted after importing a package. Prefer the qualified form to make the // origin explicit. if util::add1(util::answer) != 42 { return 1; } return 0; } Package imports resolve against the module set In the current implementation, a package import can only resolve if the package exists in the current module set. This matters most when you use package specifiers (from \"nspkg\") or when you expect a package import to find a package that is not otherwise present. Tooling note (the silk CLI): The language semantics are still \u201cimports resolve against the module set\u201d. The CLI grows the module set by loading additional source files. In addition to auto-loading std::... packages from the stdlib root, the CLI MAY load non-std:: packages from a package search path when a bare package specifier is imported (e.g. import api from \"myapi\";). The package search path is configured via SILKPACKAGEPATH (PATH-like: roots separated by : on POSIX). A package name like myapi::core maps to the filesystem candidate <root>/myapi/core/silk.toml. The first matching manifest in search order is used. Qualified imports that include extra :: segments (e.g. myapi::core::Thing) are treated as qualified symbol imports: the CLI resolves the longest package prefix that exists (myapi::core, then myapi) and loads that package into the module set. Example: bringing a package into the module set via a file import, then importing the package namespace: // main.slk import { answer as ignored } from \"./supportpkgnspkg.slk\"; // declares package nspkg; import pkg from \"nspkg\"; // now resolves because nspkg exists in the module set fn main () -> int { return pkg::add1(pkg::answer); } If you omit the file import (or otherwise fail to include a module that declares package nspkg;), the package import fails with E1001 (\u201cunknown imported package\u201d). From the CLI, the usual fix is to ensure the missing package\u2019s module(s) are part of the command\u2019s module set (for example by passing their .slk files to silk check / silk build, or by adding a file import). See Import Specifier Imports (JS-style) In addition to import pkg::name; package imports, Silk supports JS-style import forms that use a string literal import specifier after from. The current JS-style forms are: Named imports: import { Name } from \"<specifier>\"; Default imports / namespace imports: import Name from \"<specifier>\"; Ambient imports: import \"<specifier>\"; An import specifier string is interpreted in one of three ways: File specifier: the string begins with ./ or ../, or is an absolute path. These imports resolve to a module by file path. Std-root file specifier: the string begins with std/. These imports resolve to a module by file path under the configured stdlib root (see the Package specifier: any other string. These imports resolve to a package by name (for example \"ui\" or \"std::strings\"). Note: in Silk, package specifiers are matched literally against package names present in the module set. In practice this means the specifier must be a valid Silk package path (identifiers separated by ::, with task permitted as a :: segment). This mirrors the common JS convention that relative file imports must start with ./ or ../. Silk additionally reserves the std/ prefix for stdlib source imports resolved via the configured stdlib root. Example (namespace-style imports): import ui from \"ui\"; // package namespace import helpers from \"./helpers.slk\"; // file module namespace (if no default export) fn main () -> void { let opts: &ui::WindowOptions = new ui::WindowOptions(); helpers::dosomething(); } Ambient imports An ambient import loads a module into the module set without introducing any imported names into local scope: import \"./myapi.slk\"; import \"std/io\"; Notes: Ambient imports use the same specifier interpretation rules as other specifier-based imports: ./ / ../ / absolute paths are resolved as file imports, std/<path> is resolved under the configured stdlib root, other strings are treated as package specifiers (for example \"ui\" or \"std::strings\"). Ambient imports do not bind a namespace or import any symbols. If you need to call a function or reference a type from the imported module, use a named import, a default import (namespace import), or a package import. Ambient imports are useful for declaring dependencies that exist only to: satisfy prototype/definition conformance rules (see below), or ensure a module is present in the module set so its types and methods are available for type checking and monomorphization. Named imports Named imports import selected exported names directly into the importing module: import { StringBuilder, writeu8 as writeByte } from \"./runtime.slk\"; Notes: There is no combined import foo, { bar } from \"...\"; form in the current grammar. Use separate import declarations. For non-std/ file specifiers, include the .slk extension explicitly. (Only std/... specifiers get .slk appended automatically in the current implementation.) Rules: File imports MUST appear in the same import-declaration block as package imports: after the optional package declaration and before any other top-level declaration. The from keyword is part of the import syntax. The from specifier may be either: a string literal (from \"./file.slk\", from \"std/io\", from \"nspkg/sub\"), or a package path (from std::io;, from nspkg::sub;). If the specifier is a file specifier, it is resolved relative to the importing file\u2019s directory. ./ and ../ path segments are permitted. (Absolute paths are permitted for tooling, but downstream projects should prefer relative imports.) If the specifier is a std-root file specifier (\"std/<path>\" or \"std/<path>.slk\"), it is resolved relative to the configured stdlib root and then treated as a file import. If the .slk extension is omitted, it is appended during std-root resolution. If the specifier is a package specifier, it is interpreted as a package name (using the same ::-separated syntax as package declarations) and is resolved via the package graph. The imported module MAY declare a package or omit it. File specifiers refer to the target module by file path, not by package name. Exported names for named imports: Named imports can import: exported values: export fn, export let, and exported ext bindings, and type names: struct, enum, error, and interface declarations (treated as visible across module boundaries in the current implementation), exported type aliases: export type ...;, and exported Formal Silk theories: export theory declarations (importable so they can be applied via #theory Name(args);). impl blocks do not introduce importable names directly, but loading the imported module makes its methods available for method-call checking on the corresponding types. Name binding rules: Each entry in the { ... } list names one imported symbol. as can be used to rename an imported symbol (Name as Alias). For values (fn / let / ext), this introduces a value alias. For type names (struct / enum / error / interface) and exported type aliases (export type), this introduces a local type alias (transparent: it does not create a new type identity). For Formal Silk theories (export theory), this introduces a theory alias. Imported names are introduced into the importing module as unqualified names (matching the existing behavior for package imports). Importing an unknown name from a file is an error. Importing the same value name from multiple file imports without aliasing is an error. Importing a value name that is already visible in the module (for example via same-package scope or a package import) is treated as a no-op in the current implementation unless it conflicts with a local declaration in the importing module. Importing a type name that is already visible in the module is treated as a no-op in the current implementation. Default imports and namespace imports A module may declare a single default export and importing modules may bind that default export with a JS-style default import: // module.slk package module; export default fn () -> int { return 1 + 2; } // main.slk import foo from \"./module.slk\"; fn main () -> int { let value = foo(); if (value != 3) { return 1; } return 0; } Rules: Default exports are module-level and are consumed by default imports (import Name from \"<specifier>\";). A default export may be declared in either of two ways: a default-exported function declaration: export default fn ... (the function name is optional only in this form), or a default-export statement: export default Name; (names an in-scope symbol in the current module). Default exports may target any top-level symbol kind that can be referenced by name: functions (fn), top-level bindings (let / const / var), external bindings (ext), type aliases (type), nominal types (struct, enum, error, interface), Formal Silk theories (theory). Each module MAY declare at most one default export. A default export is distinct from named exports: export default fn add () -> int { ... } declares a default export whose internal name is add within the module, but it does not implicitly create a named export of add for other modules. To export it as a named export, write export fn add ... (or add an explicit named export form once one exists in the language). The function name after fn is optional only for default exports. When the name is omitted (export default fn () -> ...), the function is anonymous in the surface language and can only be referenced by importing it via a default file import. Default imports have two behaviors depending on whether a default export exists: If the imported module declares export default, the local name binds to that default-exported symbol. If the imported module does not declare a default export, the default import becomes a namespace import: the local name refers to the imported module\u2019s namespace and its exported names are accessed via foo::Name. In other words: if there is no explicit default export, the module\u2019s namespace is treated as the default export. When a default import binds a default export, it introduces a single unqualified name into the importing module: if the default export is callable (a fn or an ext function), it binds a callable value name (foo()), if the default export is a type (struct/enum/error/interface/type), it binds a type name usable in type positions (and as the head of struct literals), if the default export is a Formal Silk theory, it binds a theory name that may be applied via #theory foo(args...);, if the default export is a non-callable value (let/const/var or a non-function ext), it binds a value name. When a default import binds a namespace, it does not introduce any unqualified imported names; you must use foo::Name to access exported names. Using a namespace import name as a callable (e.g. foo()) is an error; add an explicit export default to the imported module or use a named import. Package namespace imports: For a package specifier (for example import ui from \"ui\";), the default import binds the package\u2019s default export when the package declares one. Otherwise, it binds a namespace and exported names are accessed via ui::Name. Exports Top-level declarations can be marked as exported using the export modifier: package myapp::core; export fn main () -> int { return 0; } export let answer: int = 42; Rules: export is not allowed inside blocks; it applies only to module-level declarations. Inside impl blocks, public controls method visibility and export is reserved for static members. The initial implementation supports export on: functions (export fn ...), including a declaration-only prototype form (export fn name(...) -> T;) used for header-style interface modules, let and const bindings (export let ..., export const ...). ext declarations (export ext name = ...;), Formal Silk theories (export theory Name(...) { ... }), type aliases (export type Name = ...;), struct declarations (export struct Name { ... }), enum declarations (export enum Name { ... }), error declarations (export error Name { ... }), interface declarations (export interface Name { ... }), static members inside impl blocks (impl T { export fn ... } with no self receiver). The export modifier marks a declaration as part of the package\u2019s externally visible surface. The exact visibility rules across packages (including how exports appear in the resolver and back-end symbol tables) will be specified and implemented alongside the package graph in In the current implementation, most type names are treated as visible across module boundaries once the relevant module(s) are loaded into the module set. The export modifier is still recorded on type declarations so the package/export model can be tightened later without changing source. Prototype exports (export fn ...;) In addition to ordinary function definitions (export fn ... { ... }), a module may declare a prototype (a declaration without a body) by terminating the signature with ;: module bar; export fn foo (value: string) -> int; This is the Silk analogue of a C/C++ header prototype or a TypeScript .d.ts declaration file: Other modules may import the prototype (named import or namespace import) and type-check calls against its signature. The prototype itself does not provide an implementation. The symbol must be provided at link time by: another Silk source file in the same package that defines export fn foo ... { ... }, and/or an object/archive input that defines the symbol (for example a .o/.a produced by a C compiler). Prototype declarations may include Formal Silk contract annotations (#require / #assure / contract #theory uses). This is the visible contract surface for callers; when the implementation is precompiled and the function body is not available in the module set, callers still type-check and may verify call sites against the prototype\u2019s contract surface. When both a prototype declaration and a source-level implementation are present in the same build/module set, the compiler enforces: the signatures match, and the implementation package explicitly imports the prototype module (via a file import) so the relationship is declared in source. Example (consumer imports the prototype): import { foo } from \"./ibar.slk\"; export fn main () -> int { return foo(\"hello\"); } Example (implementation imports the prototype and provides the body): module bar; import \"./ibar.slk\"; // ambient import; used for conformance only export fn foo (value: string) -> int { return 0; } This pattern is equivalent in intent to describing the export surface as an interface and declaring module conformance (module ... as ...), but it is file-based and designed to support separate compilation + link-style workflows. Re-export declarations (export { ... };) In addition to export fn ... and export let ..., Silk supports exporting an already in-scope name via a re-export declaration: import { myfunction } from \"./module.slk\"; export { myfunction }; This is the idiomatic way to build \u201cbarrel\u201d modules that forward selected exports from other modules. Rules : A re-export declaration must appear at top level and ends with ;. Each entry in the { ... } list names a local in-scope symbol. The entry may rename the exported name: export { localName as ExportedName };. Re-exported names are part of the module/package export surface, so other modules may import them via import { Name } from \"./barrel.slk\";. In the current implementation, export { ... } supports values and exported Formal Silk theories (theory declarations). It does not export type names. Common Pitfalls Forgetting semicolons: package and import declarations end with ; (parse error, E0001). Imports not at the top: imports must come immediately after the optional package declaration and before any other top-level declaration (E0001). Assuming package imports find code automatically: a package import can only resolve if the package exists in the module set (fix by adding the relevant .slk files to the build, or by file-importing them; missing packages are E1001). Calling a namespace import: if import foo from \"./mod.slk\"; binds a namespace (because there is no default export), then foo() is invalid; use foo::Name or add export default (E2018). Name collisions with named imports: when importing from multiple modules, use as to rename one binding (E2004). Relevant Tests Package import + unqualified/qualified access: Namespace imports (file and package): Named imports + aliasing: Re-exports (export { ... };): Default exports: Importing types and using exported methods:"
    },
    {
      "id": "language/refinement-types",
      "title": "Refinement Types",
      "section": "language",
      "summary": "Refinement types are types annotated with logical predicates that constrain the set of values they may represent. They are a tool for making illegal states unrepresentable and for turning certain classes of bugs into compile-time",
      "text": "Refinement Types Refinement types are types annotated with logical predicates that constrain the set of values they may represent. They are a tool for making illegal states unrepresentable and for turning certain classes of bugs into compile-time errors. current compiler subset. Today, Silk provides verification annotations (#require, #assure, #assert, #invariant, #variant, #monovariant) and formal Silk declarations (#const) Note: in Silk, any use of a where predicate is verification syntax. When where predicates are implemented, their presence will require proof (VC generation + Z3 discharge) for the compiled module set, per Overview A refinement type consists of: a base type (for example int, string, &T, or a struct), and a predicate that must hold for all values of the refinement type. The predicate is written in Silk\u2019s specification expression language (the same expression grammar used by #require / #assure). Proposed Surface Syntax One intended surface form is a record-like binder with a where clause: type NonEmptyString = { s: string where std::length(s) > 0 }; Notes: type aliases are not implemented yet (this is design work). The binder name (s) is a name for the value being constrained, usable inside the predicate. Checking Model The compiler/verifier discharges refinement predicates using: constant-folding and local reasoning for literals and simple expressions, facts established by control-flow (guards) when the verifier can prove them, facts provided by contracts (#require / #assure) and invariants (#invariant), and, where necessary, explicit evidence via helper constructors or lemmas. When the compiler cannot prove a predicate, the program should fail to compile with a diagnostic that: points to the predicate that could not be proven, and suggests how to provide evidence (guard, constructor, or contract). Relationship to #require / #assure Refinement types and function contracts are meant to compose: A parameter of a refinement type encodes a precondition at the type level. A refinement return type encodes a postcondition at the type level. Example (design-only): type NonZeroInt = { n: int where n != 0 }; fn safedivide(numer: int, denom: NonZeroInt) -> int { return numer / denom; } Implementation Notes In the current implementation: there is no type alias declaration, there is no where clause in types, and there is no verifier that can prove user-defined predicates. The existing verification directives (#require, #assure, #assert, invariant, #variant, #monovariant) are parsed, type-checked as bool where appropriate, and preserved as metadata, but they do not yet affect code generation."
    },
    {
      "id": "language/regions",
      "title": "Regions",
      "section": "language",
      "summary": "Regions provide a fixed-size, **statically allocated** block of memory that can be used as an allocation context for `new`.",
      "text": "Regions Regions provide a fixed-size, statically allocated block of memory that can be used as an allocation context for new. Regions are represented at runtime as a first-class Region handle value. A Region value may be passed to functions, stored in structs, and exported. Syntax Region handle type Region is a primitive value type representing a region allocation context. Conceptually, a Region value contains: a base pointer to the backing bytes, a pointer to a mutable cursor cell (shared by copies of the handle), and a byte limit used for overflow checking. Copying a Region value copies the handle; copies refer to the same backing store and cursor. Declaring a region A region declaration has the surface form: const region arena: u8[1024]; Rules: const region is a declaration form (it is not a type). A region declaration has no initializer. The type annotation specifies the region backing size and must be a fixed byte array type: u8[N]. The declared name is bound as a Region value. Using a region: with with establishes a region allocation context for the enclosed block. 1) Bind an existing region with <region> { ... } activates a named region binding: struct Packet { x: int } fn main () -> int { const region arena: u8[1024]; with arena { let p: &Packet = new Packet{ x: 1 }; // ... } return 0; } The <region> name may refer to any Region-typed binding, including a region parameter passed to a function: struct Packet { x: int } fn allocin (r: Region) -> int { with r { let p: &Packet = new Packet{ x: 1 }; return p.x; } } 2) Use an anonymous region with an explicit byte budget with <bytes> { ... } (or with(<bytes>) { ... }) creates an anonymous region backed by <bytes> writable bytes and activates it for the block: struct Packet { x: int } fn main () -> int { with 1024 { let p: &Packet = new Packet{ x: 1 }; // ... } return 0; } Rules: <bytes> must be a positive integer literal. 3) Use a slice of an existing region (from) with <bytes> from <region> { ... } creates an anonymous region backed by the first <bytes> bytes of <region>: struct Packet { x: int } fn main () -> int { const region arena: u8[2048]; with 1024 from arena { let p: &Packet = new Packet{ x: 1 }; // ... } return 0; } You may also specify a byte slice of the source region: with 1024 from arena[64..] { // uses bytes 64..(64 + 1024) of arena } with 1024 from arena[64..1088] { // uses bytes 64..1088 of arena } Rules: <bytes> must be a positive integer literal. <region> must name a Region value that has a compile-time-known backing size In Silk (for example a const region declaration). Slice bounds use byte offsets (the region backing store is u8[N]). <start> / <end> must be non-negative integer literals. When an explicit <end> is present, it is exclusive ([start..end]). The from slice must contain at least <bytes> writable bytes: with <bytes> from r { ... } requires <bytes> <= sizeof(r). with <bytes> from r[start..end] { ... } requires <bytes> <= end - start. with <bytes> from r[start..] { ... } requires <bytes> <= sizeof(r) - start. Semantics Region-backed new Within a with <region> { ... } block: any new allocation performed by the compiler\u2019s new lowering uses the active region as its backing store, allocations are 8-byte aligned in the current implementation subset, if the region does not have enough remaining space, the program traps. Outside of a with block, new uses the current heap model described in Region-backed raw allocation (std::runtime::mem::alloc) Within the dynamic extent of a with <region> { ... } block (including calls performed while the block is active): std::runtime::mem::alloc(n) allocates an n-byte payload from the active region (8-byte aligned) and reserves an additional 8-byte header immediately before the returned pointer (used by the runtime to distinguish region-backed and heap-backed pointers and to record the allocation size), if the region does not have enough remaining space, the program traps. Implication for with <bytes> limits: each alloc(n) consumes at least n + 8 bytes of region capacity (plus any alignment padding from 8-byte alignment). Region-backed raw allocations are bump-allocated. In the current runtime model: std::runtime::mem::free is a no-op for region-backed pointers, std::runtime::mem::realloc reallocates by allocating a new region block and copying bytes (it never calls libc realloc on a region-backed pointer). Nested with Nested with blocks use the innermost active region: with a { with b { // new uses region b here. } } Reclaiming Region Memory Regions are bump allocators: each allocation advances a cursor within the backing byte buffer. Because region-backed new allocations are still RC-managed in the current subset and do not free backing bytes on last-release, reclaiming region memory requires resetting the region cursor so the backing bytes can be reused. Current behavior: with <region> { ... } activates the region but does not reset its cursor. allocations across multiple with <region> blocks accumulate and can eventually overflow and trap. with <bytes> { ... } creates an anonymous region and resets its cursor to 0 on entry so repeated execution of the block starts from an empty region. with <bytes> from <region>[...] { ... } creates an anonymous region backed by a subrange of <region> and resets its cursor to the slice start on entry. Important limitation: The compiler does not yet enforce \u201cregion allocations must not escape the with block\u201d. Because anonymous-region cursors are reset on entry, code must treat pointers/&Struct values allocated inside with <bytes> { ... } and with <bytes> from ... { ... } as block-scoped. Exports Region declarations may be exported and imported like other top-level bindings: export const region globalarena: u8[4096]; Exporting a region exports a Region handle that refers to the same backing bytes and cursor cell. Importing a region binds a Region value that may be used with with like a locally declared region."
    },
    {
      "id": "language/literals-regexp",
      "title": "Regular Expression Literals",
      "section": "language",
      "summary": "Regular expression literals represent `regexp` values: compiled regular expression bytecode that can be used by `std::regex` helpers.",
      "text": "Regular Expression Literals Regular expression literals represent regexp values: compiled regular expression bytecode that can be used by std::regex helpers. The regex literal syntax is modeled after JavaScript: /pattern/flags Syntax Delimiters and scanning Regex literals are scanned by the parser (not the lexer): the opening delimiter is a single /, the closing delimiter is the first unescaped / that is not inside a character class ([...]), after the closing delimiter, the parser consumes ASCII letters as flags. The parser does not interpret regex escapes: backslash sequences are preserved as bytes for the regex engine. Empty patterns and // Because // introduces a line comment, an empty regex literal // is not a valid token sequence. Use an explicit empty pattern, for example /(?:)/. Flags The supported flag set is intentionally small in Silk: g \u2014 global (recorded; does not change std::regex::matches semantics) i \u2014 ignore case m \u2014 multiline s \u2014 dotAll y \u2014 sticky d \u2014 indices (recorded; not surfaced by std::regex helpers) The type checker rejects: unknown flags, duplicate flags (for example /a/ii). Semantics A regex literal\u2019s value is a non-owning { ptr, len } view (regexp) into compiled bytecode embedded in read-only data. The bytecode format is owned by the runtime regex engine; regexp values are opaque and must be consumed via std::regex. In Silk, matching is defined over the raw bytes of the input string, and match indices are byte offsets. Examples Basic test import std::regex; fn main () -> int { if std::regex::matches(/hello/, \"hello world\") { return 0; } return 1; } Related Documents"
    },
    {
      "id": "language/syntax-tour",
      "title": "Silk Syntax Tour (Soup to Nuts)",
      "section": "language",
      "summary": "This document is an example-driven tour of Silk\u2019s **surface syntax**, from a single-file \u201chello world\u201d through modules/packages, declarations, statements, expressions, and the Formal Silk verification directives.",
      "text": "Silk Syntax Tour (Soup to Nuts) This document is an example-driven tour of Silk\u2019s surface syntax, from a single-file \u201chello world\u201d through modules/packages, declarations, statements, expressions, and the Formal Silk verification directives. This guide complements (not replaces): 0. Minimal Executable Module The smallest executable is a module with a main function: fn main () -> int { return 0; } Notes: Most statements end with ;. Blocks are { stmt }. The entrypoint for an executable build is main returning int (see 1. Lexical Basics Whitespace and comments Whitespace (spaces, tabs, newlines) is generally allowed between tokens. Comments: // Line comment / Block comment (non-nesting) / /// Line doc comment / Block doc comment @example silk fn main -> int { return 0; } / fn main () -> int { return 0; } Identifiers and qualified names Names are often qualified with ::: package myapp::core; import std::strings; fn main () -> int { let s: string = std::strings::trim(\" hi \"); return 0; } Formal Silk directive tokens (#...) Formal Silk directives like #require and #invariant are not comments. They are real tokens and are parsed as part of the language (see require x >= 0; assure result == x + 1; fn inc (x: int) -> int { return x + 1; } 2. Source File Structure: package/module, import, then declarations 1. Optional package ...; or module ...; 2. Zero or more import ...; declarations as a contiguous block 3. All other top-level declarations (fn, let, struct, enum, impl, \u2026) package // app/main.slk package app; fn main () -> int { return 0; } module (compile-time-only module values) // crypto/sha256.slk module crypto::sha256; Modules can declare interface conformance (design surface is implemented): // drivers/uart.slk module drivers::uart as Device; 3. Imports and Exports Package imports package app; import std::strings; fn main () -> int { let s: string = trim(\" hi \"); // may be visible unqualified in the let t: string = std::strings::trim(\" hi \"); return 0; } File imports (from \"...\") Named import: // main.slk import { answer as theanswer } from \"./util.slk\"; fn main () -> int { return theanswer; } Default import (binds a default export if present, otherwise a namespace): // module.slk export default fn () -> int { return 3; } // main.slk import foo from \"./module.slk\"; fn main () -> int { return foo(); } Named exports and re-exports Export a declaration directly: // util.slk export let answer: int = 42; export fn add1 (x: int) -> int { return x + 1; } Re-export an in-scope name: // api.slk import { answer } from \"./util.slk\"; export { answer as theanswer }; 4. Top-Level Declarations (Overview + Examples) This section shows the core top-level declaration forms: bindings: const, let, var functions: fn (plus pure/async/task) type aliases: type types: struct, enum, interface, impl, error external declarations: ext tests: test Formal Silk: theory (and #... directives) 4.1 Bindings: const, let, let mut, var Example (requires initializers; see E2015): fn main () -> int { const answer: int = 42; let x: int = answer; let mut y: int = 0; var z: int = 1; // var is an alias for let mut y = y + 1; z += 2; return x + y + z; } Notes: const initializers must be compile-time evaluable in Silk (see E2041). Only let mut/var bindings are assignable lvalues (see Destructuring let bindings are supported for struct values: struct User { id: u64, name: string } let (id, name) = User{ id: 123, name: \"alice\" }; struct Record { id: u64, data: string } let { data as d, id as i } = Record{ id: 456, data: \"other\" }; Array destructuring is also supported: let records: Record[] = [{ id: 123, data: \"a\" }, { id: 456, data: \"b\" }]; let [a, b] = records; Enum destructuring is also supported: import std::result; fn main () -> int { type R = std::result::Result(int, int); let Ok(value) = R.ok(7); return value; } 4.2 Functions: fn (plus pure, async, task) Basic function declaration: fn add (x: int, y: int) -> int { return x + y; } pure fn inc (x: int) -> int { return x + 1; } task fn worker () -> int { return 7; } async fn main () -> int { task { let t = worker(); // Task(int) let value: int = yield t; return value; } } Parameters: mut, defaults, and varargs Mutable reference parameters require mut both in the signature and at the struct Pair { a: int, b: int } fn bumpa (mut p: &Pair) -> void { p.a += 1; } fn main () -> int { let mut p: Pair = Pair{ a: 1, b: 2 }; bumpa(mut p); return p.a; } Default arguments (restricts default expressions to a constant/literal subset): fn add2 (x: int, y: int = 2) -> int { return x + y; } fn log (fmt: string, ...args: std::fmt::Arg) -> void { std::io::println(fmt, args); } Generic function parameter split (;) (Design, parsed but rejected) Generic functions use ; to separate compile-time parameters from value parameters: // Design (currently rejected with E2016). fn getfirst(T, N: int; xs: &T[N]) -> T { return xs[0]; } 4.3 Function expressions (lambdas) Example (non-capturing expression body): fn main () -> int { let add = fn (x: int, y: int) -> x + y; return add(1, 2); } Example (block body with explicit return type): fn main () -> int { let add = fn (x: int, y: int) -> int { return x + y; }; return add(1, 2); } 4.4 Type aliases: type Basic alias: type I = int; type struct UserId = int; type fn IntAdder = fn(int, int) -> int; type pure fn PureIntAdder = fn(int, int) -> int; 4.5 Structs: struct and impl Struct declarations (fields use name: Type, optional default with =): struct Point { x: int = 0, y: int = 0, } Struct literals: fn main () -> int { let p1: Point = Point{ x: 1, y: 2 }; let x = p1.x; // Shorthand field init (x means x: x): let y: int = 3; let p2: Point = Point{ x, y }; return x + p2.y; } Inferred struct literals require an expected struct type context: fn main () -> int { let p: Point = { x: 1, y: 2 }; return p.x + p.y; } Heap allocation (new) produces a &Struct reference in Silk: struct Boxed { value: int } fn main () -> int { let b: &Boxed = new Boxed{ value: 7 }; return b.value; } impl Point { public fn sum (self: &Point) -> int { return self.x + self.y; } } fn main () -> int { let p: Point = Point{ x: 1, y: 2 }; return p.sum(); } // Design shape (field/layout rules and limits are documented). struct Base { x: int = 0 } struct Derived extends Base { y: int = 0 } 4.6 Enums: enum + match expression enum Color { Red, Rgb(u8, u8, u8), } fn toint (c: Color) -> int { return match c { Color::Red => 0, Color::Rgb(r, g, b) => (r as int) + (g as int) + (b as int), }; } 4.7 Interfaces and impl ... as ... interface Counter { fn inc() -> void; fn get() -> int; } struct Cell { value: int = 0 } impl Cell as Counter { fn inc (mut self: &Cell) -> void { self.value += 1; } fn get (self: &Cell) -> int { return self.value; } } 4.8 Typed errors: error, panic, T ErrorType..., match statement, ? Error type declaration: error OutOfBounds { index: int, len: int } Error-producing signatures use : fn getat (xs: &u8[], index: int) -> u8 OutOfBounds { if index < 0 index >= std::length(xs) { panic OutOfBounds { index: index, len: std::length(xs) }; } return xs[index]; } Handling typed errors uses the match statement form: fn main () -> int { match (getat([1, 2, 3], 10)) { value => { return value as int; }, err: OutOfBounds => { std::abort(); } } } Propagating errors from calls uses postfix ?: // Example when main declares a compatible error set. fn main () -> int OutOfBounds { let x: u8 = getat([1, 2, 3], 0)?; return x as int; } 4.9 External declarations: ext export ext puts = fn(string) -> int; export ext cabort \"abort\" = fn() -> void; export ext errno \"errno\" = int; Note: C variadics (printf-style ...) via ext are not implemented yet; see 4.10 Tests: test test \"addition works\" { if (1 + 2) != 3 { std::abort(); } } 4.11 Formal Silk theories: theory Top-level theory (exportable/importable): export theory nonzero (x: int) { #require x != 0; } Apply a theory inside a function: import { nonzero } from \"./theories.slk\"; fn main () -> int { let x: int = 1; #theory nonzero(x); return 0; } Inline (block-local) theories use the same #theory token and are disambiguated from theory use by { ... } (inline declaration) vs ; (use): fn main (x: int, y: int) -> int { #theory localsumnonzero (x: int, y: int) { #const z = x + y; #assure z != 0; } #theory localsumnonzero(x, y); return 0; } 5. Types (Surface Forms) Primitive types bool, i8/u8, i16/u16, i32/u32, i64/u64, int, f32/f64, char, string, void, Instant, Duration Optional types fn main () -> int { let a: int? = None; let b: int? = Some(7); let c: int = b ?? 0; return c; } Nested optionals use ?? in type position (T?? means \u201coptional of optional\u201d): fn main () -> int { let x: int?? = Some(Some(1)); let y: int? = x ?? None; return (y ?? 0); } Optional match expressions are the explicit form of optional consumption: fn main () -> int { let x: int? = Some(7); let y: int = match x { None => 0, Some(v) => v, }; return y; } References fn sum (p: &Point) -> int { return p.x + p.y; } Arrays and slices fn main () -> int { let xs: int[] = [1, 2, 3]; return xs[0]; } Fixed-length arrays use T[N]: fn main () -> int { let xs: int[3] = [1, 2, 3]; return xs[2]; } Function types type IntBinOp = fn(int, int) -> int; fn main () -> int { let add: IntBinOp = fn (x: int, y: int) -> x + y; return add(1, 2); } Applied types and generics Generic parameter lists on struct/interface/impl are implemented: struct Box(T) { value: T } fn main () -> int { let b: Box(int) = { value: 1 }; return b.value; } const parameters/arguments and generic functions). 6. Statements (Inside Blocks) if / else fn main () -> int { let x: int = 1; if x == 0 { return 0; } else { return 1; } } loop, while, for fn main () -> int { let mut i: int = 0; while i < 3 { i += 1; } return i; } fn main () -> int { let mut sum: int = 0; for i in 0 .. 5 { sum += i; } return sum; } C-style for header: fn main () -> int { let mut sum: int = 0; for (let mut i: int = 0; i < 5; i += 1) { sum += i; } return sum; } break, continue, return fn main () -> int { let mut i: int = 0; loop { i += 1; if i < 3 { continue; } break; } return i; } assert and panic fn main () -> int { assert 1 + 2 == 3; assert(2 + 2 == 4, \"math is broken\"); return 0; } panic OutOfBounds { index: 1, len: 0 }; match statement (typed errors) pattern forms. async { ... } and task { ... } Structured blocks (implemented as lexical blocks in Silk; see async fn main () -> int { async { // async region } task { // task region } return 0; } Concurrency operators: await, await , yield, yield await unwraps Promise(T) values inside async fn: async fn add2 (x: int) -> int { return x + 2; } async fn main () -> int { let p = add2(1); // Promise(int) let v: int = await p; return v; } await awaits a collection of promises and yields a collected T[]: async fn add1 (x: int) -> int { return x + 1; } async fn main () -> int { let values: int[] = await [add1(1), add1(2), add1(3)]; return values[0] + values[1] + values[2]; } yield / yield interact with Task(T) values (used inside task regions in the): task fn producer (n: int) -> int { var i: int = 0; while i < n { yield i; i += 1; } return n; } async fn main () -> int { task { let t = producer(2); // Task(int) let values: int[] = yield t; return values[0] + values[1] + values[2]; } } 7. Expressions (Precedence + Demonstrations) Silk expressions follow a conventional precedence hierarchy. For the exact Literals and other primary expressions fn main () -> int { // Booleans. let b: bool = true; // Integers and floats. let i: int = 42; let u: u8 = 0xFF; let f: f64 = 3.14; // Characters and strings. let ch: char = 'A'; let s1: string = \"hello\"; let s2: string = raw \\n no escapes; // Durations. let d: Duration = 10ms; // Optionals. let opt: int? = Some(i); let x: int = opt ?? 0; // Arrays. let xs: int[] = [1, 2, 3]; assert b; assert x == 42; assert xs[0] == 1; assert u == 0xFF; assert s1 == \"hello\"; assert s2 == raw \\n no escapes; assert ch == 'A'; assert (f as int) == 3; assert (d as int) == (d as int); // d exists to demonstrate duration literal syntax. See docs/language/literals-duration.md. return 0; } Postfix forms: calls, fields, indexing, casts, ?, ++/-- struct Point { x: int, y: int } fn main () -> int { let xs: int[] = [10, 20, 30]; let a: int = xs[0]; let b: int = (a + 1) as int; let c: int = Point{ x: 1, y: 2 }.x; return b + c; } as and as raw as performs explicit numeric/shape casts and as raw performs raw bit casts fn main () -> int { let bits: u64 = (1.0 as f32) as raw u64; let f: f32 = bits as raw f32; return f as int; } Unary forms: !, ~, -, new, await, yield, mut, ++/-- fn main () -> int { let mut x: int = 0; ++x; x++; if !(x == 2) { return 1; } return 0; } mut <expr> is permitted only where a mutable borrow is required (most commonly, in call arguments and method receivers): struct Pair { a: int, b: int } fn bump (mut p: &Pair) -> void { p.a += 1; } fn main () -> int { let mut p: Pair = Pair{ a: 0, b: 0 }; bump(mut p); return p.a; } Arithmetic, bitwise, comparisons, and boolean operators fn main () -> int { let a: int = 1 + 2 3; let b: int = (a << 1) 1; if (b >= 0) && (b != 0) { return b; } return 0; } Optional operators: ?. and ?? struct User { email: string } fn main () -> int { let user: User? = Some(User{ email: \"a@b.c\" }); let email: string = user?.email ?? \"unknown\"; if email == \"a@b.c\" { return 0; } return 1; } Typed error propagation: postfix ? on calls fn main () -> int OutOfBounds { let x: u8 = getat([1, 2, 3], 0)?; return x as int; } 8. Formal Silk (Verification) Syntax Formal Silk is Silk\u2019s compile-time verification surface (Z3-backed). It uses directive tokens that attach to functions and loops: function contracts: #require, #assure, #theory loop contracts: #invariant, #variant, #monovariant formal Silk declarations: #const block-local proof obligations: #assert reusable proof bundles: theory / #theory current restrictions. Contracts on functions require x >= 0; assure result == x + 1; fn inc (x: int) -> int { return x + 1; } Loop invariants, variants, and monovariants fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; #monovariant i; while i < limit { i += 1; } return 0; } Theories (theory / #theory) export theory addcommutes (x: int, y: int) { #assure (x + y) == (y + x); } theory addcommutes(x, y); fn add (x: int, y: int) -> int { return x + y; } 9. Next References If you want more detail on a specific construct, jump to:"
    },
    {
      "id": "language/doc-comments",
      "title": "Silkdoc (Documentation Comments)",
      "section": "language",
      "summary": "This document specifies **Silkdoc**, Silk\u2019s documentation-comment format. Silkdoc comments are intended for tools (documentation generators, editors, and the language server). They **do not** affect program semantics.",
      "text": "Silkdoc (Documentation Comments) This document specifies Silkdoc, Silk\u2019s documentation-comment format. Silkdoc comments are intended for tools (documentation generators, editors, and the language server). They do not affect program semantics. The goal is a familiar JSdoc feel with Silk/TypeScript-style type annotations. Comment Forms Two doc-comment forms are recognized: Block doc comments: / ... / Line doc comments: one or more consecutive lines starting with /// In both forms, doc comments attach to the next declaration when they appear immediately before it with only whitespace/comments between them. Initial implementation scope: Doc comments attach to top-level declarations (package, module, import, fn, theory, let, struct, ext, interface, impl). Doc comments also attach to: methods inside impl Type { ... } blocks, and method signatures inside interface Name { ... } blocks. For function declarations, doc comments attach even when one or more formal verification annotations (#require / #assure) appear between the doc comment and the fn keyword. Doc comments inside function bodies are treated as ordinary comments (not attached to anything). Attaching doc comments to struct fields, parameters, and locals is future work. Content Model A doc comment contains: free-form text (Markdown-friendly) describing the declaration, and optional tags starting with @. The free-form text is everything before the first tag line. Any non-tag lines that appear after the first tag line are ignored unless they are part of a multi-line tag body (for example @example or @remarks). Leading convention For block doc comments, the conventional leading is ignored: / Hello world / Tools strip the leading (and one following space when present) before parsing. Tags Tags begin at the start of the logical line after stripping comment prefixes. @param Declare a parameter description. Syntax: @param <name>: <Type> <description...> @param <name> <description...> Example: / Appends one byte to the vector, growing as needed. @param self: &std::vector::Vector(u8) The receiver. @param value: u8 The byte to append. / @returns Describe the return value. Syntax: @returns <Type> <description...> @returns <description...> @throws Describe an error/exception-like condition. Syntax: @throws <Type> <description...> @throws <description...> Note: the language does not yet have a stable error type; @throws is documentation-only until Result(T, E) and error conventions are fully implemented. @external Indicate that a declaration is an external FFI binding (its implementation is provided outside Silk). This tag is typically used to document ext function declarations. Syntax: @external @example Provide an example snippet. The tag may optionally declare a language for Markdown fenced code blocks. Syntax: @example <one or more lines of example text> @example silk <one or more lines of code> The example body continues until the next tag line or the end of the doc comment. Other tags The initial toolchain may also recognize: @since <text...> @deprecated <text...> @remarks <text...> (may span multiple lines like @example) @see <text...> (repeatable) Additional tags must be documented here before they are relied on by tooling. Formal Silkdoc tags Silkdoc can document Formal Silk constructs without affecting verification. These tags are documentation-only (they do not prove anything and do not introduce Formal Silk obligations). @requires Document one precondition for a declaration (typically mirroring #require on a function or a theory). Syntax: @requires <Expr...> This tag is repeatable. @assures Document one postcondition for a declaration (typically mirroring #assure on a function or a theory). Syntax: @assures <Expr...> This tag is repeatable. @asserts Document one internal proof obligation (typically mirroring a #assert inside a function or theory body). Syntax: @asserts <Expr...> This tag is repeatable. @theory Document one theory attachment or use (typically mirroring #theory Name(args...);). Syntax: @theory <Name(args...)...> This tag is repeatable. Manpage-oriented tags The toolchain uses a small set of optional doc tags to generate man(7) pages from source comments (silk doc --man and silk man). These tags are documentation-only and do not affect program semantics. @misc Declare a conceptual documentation block intended for man section 7. Syntax: @misc <label> <summary...> @misc <label> Notes: The <label> is an opaque identifier used by tooling for discovery (for example silk man <label>). It should be stable and globally unique within a package (recommendation: use a pkg::topic label). The optional <summary...> provides a one-line description for the manpage NAME section. When omitted, tools may derive a summary from the first line of the free-form description text. @cli Declare that a doc comment describes a command-line interface, intended for man section 1. Syntax: @cli <name> @cli When <name> is omitted, tools derive the command name from context (for example the module name or executable name provided by the build system). @synopsis Provide one or more synopsis lines for a CLI manpage. Syntax: @synopsis <one or more lines of synopsis text> The synopsis body continues until the next tag line or the end of the doc comment. @option Declare a command-line option for a CLI manpage. This tag is repeatable. Syntax: @option <prototype...> @option <prototype...> <description...> Examples: @option -h, --help Show help and exit. @option --out <path> Write output to <path>. @command Declare a subcommand for a CLI manpage. This tag is repeatable. Syntax: @command <name> <description...> Markdown Rendering The documentation generator renders doc comments to Markdown using: the free-form text as the leading description (paragraphs preserved), @param entries as a \u201cParameters\u201d list, @returns as a \u201cReturns\u201d section, @throws as a \u201cThrows\u201d section, @requires, @assures, @asserts, and @theory as dedicated sections (one bullet per tag instance), @example blocks as fenced code blocks. The generator must keep formatting stable (deterministic output) so that documentation diffs are meaningful."
    },
    {
      "id": "language/literals-string",
      "title": "String Literals",
      "section": "language",
      "summary": "String literals represent `string` values: immutable, length-tracked sequences of bytes that are typically interpreted as UTF-8 text.",
      "text": "String Literals String literals represent string values: immutable, length-tracked sequences of bytes that are typically interpreted as UTF-8 text. Use strings for: filenames and paths, user-visible messages, structured formats (JSON, CSV, etc), and general \u201ctext\u201d data. If you need a single Unicode scalar value, use char literals Semantics The value of a string literal is a sequence of bytes. By convention and by intent, string values represent UTF-8 text, but some escape forms (notably \\xNN) can construct byte sequences that are not valid UTF-8. Avoid this unless you are intentionally working with raw bytes. String literals are immutable. Unless otherwise specified for a particular FFI surface, string literals do not implicitly include a trailing \\0 byte; length is carried explicitly. Single-Line Strings Single-line string literals: Use standard quote-delimited syntax. Support escape sequences as described below. Raw Strings (Backtick) Raw string literals are delimited by backticks: ` ... They may include newlines directly. They do not process escape sequences: \\n is two bytes ('\\' and 'n'). They still normalize embedded \\r\\n / \\r in the source text to \\n. Escape Sequences Double-quoted string literals support the same escape spellings as character literals: \\\\ (backslash) \\\" (double quote) \\' (single quote) \\n (newline, U+000A) \\r (carriage return, U+000D) \\t (tab, U+0009) \\0 (NUL byte, U+0000) \\xNN (byte escape, two hex digits) \\u{...} (Unicode scalar value escape, 1\u20136 hex digits) When decoding \\u{...} escapes, the compiler must reject non-scalar Unicode values (for example surrogate code points). Multi-Line Strings Multi-line strings: Allow embedding newlines directly in the literal. Must be represented and encoded identically to string values produced at runtime. Line Ending Normalization When decoding string literals, the compiler must normalize: \\r\\n to \\n \\r to \\n This applies both to embedded newlines in multi-line literals and to escaped forms such as \\r. Note: a sequence of two escapes like \"\\r\\n\" is still two escapes. In the current implementation, \\r escapes become \\n, so \"\\r\\n\" produces two line feed bytes (\"\\n\\n\"). Examples Basic string literal fn main () -> int { let s: string = \"hello\"; if s == \"hello\" { return 0; } return 1; } Escapes and byte escapes fn main () -> int { // Quote and backslash escapes. if \"\\\"\" != \"\\x22\" { return 1; } if \"\\\\\" != \"\\u{005C}\" { return 2; } // Control escapes. if \"\\t\" != \"\\x09\" { return 3; } if \"\\n\" != \"\\x0A\" { return 4; } if \"\\r\" != \"\\n\" { return 5; } // \\r is normalized to \\n in the . // NUL bytes are permitted; strings are length-tracked (not NUL-terminated). if \"\\0\" != \"\\x00\" { return 6; } // Unicode escapes insert UTF-8 bytes for that scalar. if \"\u00e9\" != \"\\u{00E9}\" { return 7; } return 0; } Multi-line string literal (embedded newline) fn main () -> int { let multi: string = \"a b\"; // Equivalent to using a \\n escape. if multi != \"a\\nb\" { return 1; } return 0; } Raw multiline string literal (backticks) fn main () -> int { let multi: string = a b; if multi != \"a\\nb\" { return 1; } // Backslashes are literal bytes in raw strings. if a\\nb != \"a\\\\nb\" { return 2; } return 0; } Common Pitfalls Expecting NUL termination: \"hi\" does not include an implicit \\0. Use \\0 explicitly when you need it, and prefer APIs that are length-aware. Using \\xNN for non-ASCII characters: \\xNN inserts a raw byte, not a Unicode scalar. Use \\u{...} for text. Assuming multi-line indentation stripping: multi-line strings include all bytes between the quotes, including indentation spaces. Related Documents Relevant Tests Core string equality and ordering: Escape coverage: Raw/backtick coverage: The compiler must: Implement lexing and parsing for both \"...\" and ... . Normalize line endings and escapes according to the spec. Ensure compatibility with the FFI SilkString` representation."
    },
    {
      "id": "language/structs-impls-layout",
      "title": "Structs, Impl Blocks, and Memory Layout",
      "section": "language",
      "summary": "Structs and impl blocks are separated:",
      "text": "Structs, Impl Blocks, and Memory Layout Structs and impl blocks are separated: struct declarations define pure data layout. impl blocks attach behavior to types without changing their layout. struct Declarations Structs define a composite data type made of named fields: struct Packet { sequence: u32, size: u16, flag: u8, } Key rules: Structs contain only data members. Memory layout and padding are well-defined so that FFI and ABI rules can rely on them. Generic structs Structs may declare type parameters: struct Data(T) { value: T, } Rules: A generic struct Name(T, ...) introduces a type constructor Name. Outside a generic context, uses of the type must be fully applied (for example Data(u8)), not bare Data. A declaration name may not be reused across different generic arities (for example struct Foo { ... } and struct Foo(T) { ... } cannot both exist in the same namespace). Field Default Initializers Struct fields may include an optional default initializer expression: struct Point { x: int = 0, y: int = 0, } When a struct literal omits a field, the compiler initializes the field from its default expression. In Silk, default field expressions use the same restriction as default function arguments: no name references, and no new. Example: struct Point { x: int = 0, y: int = 0, } fn main () -> int { let p = Point{ x: 5 }; return p.y; // defaults to 0 } Single Inheritance (extends) Silk supports single inheritance for struct declarations via extends. Surface syntax: struct Base { x: int, y: int = 0, } struct Derived extends Base { z: int, } Semantics: A derived struct inherits all fields of its base struct. The derived struct\u2019s field sequence is: 1) all base fields (in declaration order), then 2) all derived fields (in declaration order). Field access on the derived struct can refer to inherited base fields directly (d.x, d.y). Default field initializers are inherited: a Derived{ ... } literal may omit inherited fields that have defaults in the base struct. Type checking rules: extends is permitted only on non-opaque struct declarations. The base name must resolve to a struct type in the compiled module set. Cycles in extends chains are rejected. A derived struct may not declare a field whose name conflicts with an inherited field name. Notes: extends does not imply implicit subtyping in Silk: there is no implicit coercion from Derived to Base (or &Derived to &Base) yet. Opaque Structs (FFI Handles) Opaque structs are a special form of struct declaration intended for safely representing foreign pointers/handles from C APIs. Syntax: // Declares an opaque handle type. struct MyFFIHandle; An opaque struct has no fields and no Silk-defined layout. It exists only as a nominal handle type that can be passed around safely. Rules: Opaque structs cannot be instantiated (no struct literals). Opaque structs do not support field/member access (. / ?.). Opaque structs must not be used by value in type positions (locals, parameters, results). Only the reference form &MyFFIHandle is allowed. These rules increase safety at the language boundary: Eliminates type confusion: distinct handle types such as &DatabaseHandle and &FileHandle are not interchangeable. Prevents invalid operations in Silk: Silk code cannot read/write fields or assume a size/layout for the foreign type. Safety and Undefined Behavior (UB) Opaque handles do not carry lifetime information. You are responsible for calling the corresponding destruction/free function provided by the foreign library. Using an opaque handle after it has been destroyed is undefined behavior. The compiler does not currently enforce this at compile time. ABI and Lowering In Silk, an &Opaque value is lowered as a single pointer scalar (u64 on the current linux/x8664 target), rather than as a struct-of-pointers like &struct borrows. Memory Layout (Intended Contract) The long-term Silk design is for struct layout to match conventional C layout rules for the corresponding field types on the target: Sequential layout: fields appear in memory in the exact order they are declared in the struct definition. Alignment and padding: each field is placed at an offset that is a multiple of the field type\u2019s required alignment. The compiler inserts padding bytes where necessary. Final padding: the overall struct size is padded to a multiple of the struct\u2019s alignment (typically the maximum alignment of its fields), so arrays of the struct keep each element correctly aligned. Example (typical C layout on linux/x8664): struct Packet { sequence: u32, // 4 bytes size: u16, // 2 bytes flag: u8, // 1 byte } Conceptually, this layout would be: sequence at offset 0 (4 bytes) size at offset 4 (2 bytes) flag at offset 6 (1 byte) 1 byte of tail padding at offset 7 to make the total size a multiple of 4 Total size: 8 bytes (alignment 4). Memory Layout the compiler does not implement packed C-like struct layout yet. Instead, it uses a scalar slot model: A struct value is lowered into a sequence of scalar \u201cslots\u201d in source order, after recursively expanding certain composite field types: string contributes two slots: (u64 ptr, i64 len). nested non-opaque structs contribute their slot sequence. optionals contribute (bool tag, payload slots...), where payload slots follow the lowering of the underlying non-optional type. When a struct is stored in memory (stack locals and heap boxes), each slot is stored in a separate 8-byte cell. This means sub-64-bit fields (bool, i8/u8, i32/u32, f32, char, etc.) are not packed yet. Values are still typed as their declared scalar kinds (the checker and IR track widths/sign), but the physical in-memory representation is widened to one 8-byte slot per scalar. This design keeps lowering/codegen simple and lets the compiler support nested aggregates without committing to a final packed layout. The trade-off is that the in-memory representation is not ABI-compatible with a C struct unless the struct is restricted to ABI-safe 64-bit slots. Example : the Packet above is lowered as 3 scalar slots and occupies 24 bytes when stored in memory (3 \u00d7 8-byte cells), even though the intended C-like packed layout would be 8 bytes. ABI and Code Generation The Silk language design includes full support for user-defined structs, nested aggregates, and FFI-safe ABI mapping. The current compiler/backend implementation supports only a narrow, explicitly documented subset: Only \"plain\" structs with 0+ fields are supported by codegen. Empty structs (struct Empty {}) are currently represented as a single placeholder u64 slot in the scalar-slot model. Fields may be: scalar primitive types (bool, fixed-width integers, int, char, f32/f64, Instant, Duration), string (lowered as { ptr: u64, len: i64 }), nested (non-opaque) structs, and optionals (T?) of supported payload types. At ABI boundaries (exported functions and ext declarations), structs must be ABI-safe: after slot-flattening, all slots must be i64/u64/f64 (for example string fields are ABI-safe because they lower to (u64, i64), but bool, char, and f32 fields are not). Such structs are passed and returned by value by lowering them to their scalar slots in order and following the System V AMD64 ABI rules for those scalar slots: integer-like slots consume general-purpose argument slots (rdi, rsi, rdx, rcx, r8, r9, then the stack), f32/f64 slots consume XMM argument slots (xmm0..xmm7, then the stack), 1\u20132 slot results use rax/rdx for integer-like slots and xmm0/xmm1 for float slots, with mixed aggregates using both, 3+ slot results return indirectly via a hidden sret pointer passed in rdi (caller-allocated return buffer), with the callee storing each scalar slot sequentially and returning the pointer in rax. Note: at the C ABI surface, exported functions accept ABI-safe structs by flattening parameters to their scalar slots in order. For 1\u20132 slot structs this is ABI-compatible with passing an equivalent by-value C struct parameter, while for 3+ slot structs downstream C callers should declare separate scalar parameters for the slots. Struct returns with 3+ slots use sret and are ABI-compatible with returning an equivalent C struct by value. This subset is intentionally small so that we can validate the end-to-end type pipeline (parsing \u2192 checking \u2192 lowering \u2192 IR\u2192ELF codegen) while keeping ABI behavior consistent with C for the supported cases. impl Blocks impl blocks attach functions and methods to existing types without affecting memory layout. The intent is to provide \u201chigh-level\u201d APIs without baking behavior into struct layout. In the initial implementation, impl blocks are syntax and type-checking structure; code generation treats methods as ordinary functions that follow the same calling conventions as other Silk functions. Generic impl blocks If a type is declared with type parameters (struct or enum), its impl blocks must also declare those type parameters: struct Data(T) { value: T } // OK: impl Data(T) { fn get(self: &Self) -> T { return self.value; } } // Error: // impl Data { ... } This rule makes monomorphization explicit and ensures method receivers are not ambiguous when the type is specialized. Syntax impl List { // Ordinary static method (no receiver). fn init (cap: i64) -> List { ... } // Heap constructor used by new List(...) (special name, receiver + void). fn constructor (mut self: &Self, cap: i64) -> void { ... } // Instance method (receiver as first parameter). public fn len (self: &List) -> i64 { ... } // Mutating instance method (mutable receiver). public fn push (mut self: &List, value: u8) -> void { ... } } Rules: An impl block attaches methods to exactly one nominal type name (a struct or an enum). Multiple impl blocks may exist for the same type name; the compiler merges their methods (subject to duplicate-name rules). Methods inside an impl block are fn declarations (with bodies). The receiver, when present, is the first parameter and must be a borrowed reference to the impl type (self: &Type or mut self: &Type). Within an impl block, the special type name Self may be used anywhere a type name is accepted, and is treated as an alias for the impl type. For example, self: &Self is equivalent to self: &Type, and -> Self is equivalent to -> Type. Static methods omit the receiver parameter. Method visibility: Methods are private by default: a method declared without an explicit visibility modifier is callable only within the defining impl { ... } block. public fn marks a method as callable from outside the defining impl block. private fn is permitted to make intent explicit. export is reserved for static members (no self receiver) and is not permitted on instance methods; use public fn instead. When an impl block declares conformance to an interface (impl T as I), the interface\u2019s required methods are public by definition: the corresponding impl methods may omit public, but they may not be explicitly marked private. The method named constructor is treated specially: it is only meaningful for struct types (it backs new Type(...)); enums do not support constructor methods in Silk, it is public by default, when explicitly marked private, it is callable only within the defining impl { ... } block, it may be declared multiple times in a single impl block (an overload set), its overload set includes constructor declarations across all merged impl blocks for the type, it is invoked by heap allocation (new Type(...)) and by certain new Type(args...) invokes the unique overload whose receiver is mut self: &Type, whose return type is void, and whose non-receiver parameter list matches args... after applying the normal call-argument type-checking rules, if multiple overloads are applicable, the compiler prefers overloads that do not rely on implicit call-argument coercions (notably the U -> &T constructor coercion for &T parameters); if multiple overloads remain tied, the call is rejected as ambiguous. Call syntax The surface call syntax uses field-access + call: Instance method call: value.method(arg0, arg1, ...) Static method call: Type.method(arg0, arg1, ...) Semantically, method calls behave like ordinary function calls where the receiver is passed as an explicit first argument. Static-method receiver sugar: If value.method(...) does not resolve to an instance method (a method whose first parameter is a receiver self: &Type / mut self: &Type), the compiler may resolve it as a call to a visible static method of the receiver type by inserting the receiver as the first argument: Type.method(value, ...). This supports fluent chaining for value-consuming helper APIs like std::result::Result.unwrapor: let r: R = / ... /; let x: int = r.unwrapor(0); // sugar for R.unwrapor(r, 0) Mutability rule: If the method receiver is self: &Type, the call site passes a read-only borrow of the receiver (for example value.method(...)). If the method receiver is mut self: &Type, the call site must pass a mutable borrow of the receiver. When the receiver is a name binding that is mutable (let mut value = ...) or a mutable reference binding (for example a mut self: &Type receiver), the compiler treats value.method(...) as a mutable receiver call (no (mut value) wrapper required). The explicit (mut value).method(...) form is permitted but is no longer required for name receivers. limitations: Mutable receiver calls must use a name receiver; mutable borrows from non-name receiver expressions (for example make().push(1)) are rejected. Non-mut receivers may be arbitrary expressions (including calls), so chaining like url.href().asstring() is permitted. Compiler requirements: Keep data layout and behavior separate in the IR. Preserve struct layout exactly for ABI and FFI. Enforce rules for opaque structs and UB as described in this document and the ABI spec."
    },
    {
      "id": "language/testing",
      "title": "Testing",
      "section": "language",
      "summary": "This document specifies the initial **language-level testing** surface for Silk.",
      "text": "Testing This document specifies the initial language-level testing surface for Silk. The goal is a Zig-like authoring experience (tests live next to the code they exercise) with a simple CLI runner that emits modern TAP output for downstream consumption. test declarations A test declaration is a top-level block of statements that the compiler can compile and execute under silk test. Syntax: test \"name\" { // statements... } The string name is optional: test { // statements... } Rules: test declarations MAY appear: at top level (like fn and let), and nested inside another test block (scoped subtests). A test block introduces its own scope (like a function body). Nested test blocks are executed inline, in source order, as part of the enclosing test\u2019s execution. They may be used for hierarchical grouping and shared setup. test blocks may use let, var, control flow, and call functions/methods using the same expression subset as normal code. return; is allowed inside a test block (equivalent to ending the test early). return <expr>; is not allowed. Doc comments: Doc comments (/ ... / and /// ...) attach to a test declaration the same way they attach to other top-level declarations. Running tests (silk test) The silk test command: loads a module set (like silk check / silk build), discovers all test declarations in the module set, and executes them, emitting TAP output. TAP output The initial runner uses TAP version 13 formatting: TAP version 13 1..N ok <n> - <name> not ok <n> - <name> Assertions inside tests In silk test builds, failed assertions do not abort the process. Instead: A failed assert records a test failure and execution continues. If the assertion has no explicit message, the compiler uses the assertion condition text as the message (e.g. assert value != 123; uses value != 123). The test executable exits non-zero if any failures were recorded so TAP output reflects failures. The current runner still isolates top-level tests in separate processes, but a single test case may now accumulate multiple failures. std::test (standard test helpers) The standard library provides std::test helpers for test-only assertions that record failures without aborting: expect(ok: bool, message: string? = None); expectequal(expected: X, actual: Y) -> bool; expecterror(err: E?) -> bool; Note: std::test helpers carry a Formal Silk contract requiring BUILDMODE == \"test\" via std::formal.requirestestmode() so downstream verification can model them as test-only APIs."
    },
    {
      "id": "language/type-unions",
      "title": "Type Unions (`T1 | T2 | ...`)",
      "section": "language",
      "summary": "Silk supports **type unions** in type annotations. A union type represents a value that is exactly one of several **member types**.",
      "text": "Type Unions (T1 T2 ...) Silk supports type unions in type annotations. A union type represents a value that is exactly one of several member types. This feature exists to model small, explicit \u201cone-of-these-types\u201d outcomes without requiring a dedicated nominal enum declaration for every case. See also: is reserved for typed-error contracts), Surface Syntax Union types use between member types: let x: Foo Bar; struct S { v: u8 bool } type U = Foo Bar Baz; Return types (important disambiguation) In function declarations, unparenthesized after -> is reserved for typed errors (SuccessType ErrorType...). To write a union as a function\u2019s return type, the union must be parenthesized: fn f () -> (Foo Bar); fn g () -> (Foo Bar) SomeTypedError; This disambiguation is required so the parser and checker can treat typed-error contracts as authoritative. Rules The initial implementation intentionally supports only unions whose member types have a safe, well-defined representation in the current compiler/backend subset. A union type T1 T2 ... Tn is permitted when all member types are in the supported union-member set: Primitive scalar types in { bool, char, i8, u8, i16, u16, i32, u32, i64, u64, int, usize, size, Instant, Duration } (isize is accepted as an alias for size), and/or Nominal POD structs (including error types) and nominal POD enums that lower to a scalar-slot representation in Silk (no opaque structs). Unions may freely mix primitive and nominal members in this subset. For primitive members, the current native backend requires that each member type be distinguishable at injection sites. In practice, that means a union may not contain two primitive types that lower to the same backend scalar representation (for example int i64, usize u64, char u32, Duration i64). This restriction is specific to the backend and may be relaxed once union injection uses full type identity rather than a backend-scalar heuristic. Notes: Nested unions are flattened: (A B) C is the same union as A B C. Duplicate member types are rejected. Semantics A value of a union type is a tagged value: It stores a runtime tag identifying which member type is active. It stores the payload value in a uniform representation compatible with all members in Silk. Representation In the current native backend subset, unions are lowered as: (u64 tag, u64 payload0, ..., u64 payload(N-1)) where N is the maximum scalar-slot count across the union\u2019s member types (primitive members contribute 1). Member payload values are stored/loaded via raw-bit casts (castraw) to and from the u64 payload slots. Unused payload slots are zero-filled on injection and on widening coercions. Union-to-union coercions (supersets) When a context expects a union type Usup, a value of a union type Usub may be used if Usub\u2019s member set is a subset of Usup\u2019s member set. The compiler remaps the runtime tag to the destination union\u2019s tag numbering when needed so pattern matches on the destination union remain correct. If Usup\u2019s payload is larger than Usub\u2019s payload (because Usup contains a member with a larger scalar-slot representation), the payload is widened by copying existing payload slots and zero-filling the newly-added slots. Construction (injection) When a context expects a union type, a value whose type is one of the union\u2019s member types may be used directly and is injected into the union. Examples: struct A { x: int } struct B { x: int } type U = A B; fn main () -> int { let a: A = A{ x: 1 }; let u: U = a; // inject A into U return 0; } Matching (match) Union values are consumed via match expressions using typed binder patterns: type U = A B; let out: int = match u { a: A => a.x, b: B => b.x, }; Rules: The scrutinee must have a union type. Patterns are restricted to name: Type (or : Type) where Type is one of the union member types. Matches must be exhaustive: exactly one arm per member type (order does not matter)."
    },
    {
      "id": "language/typed-errors",
      "title": "Typed Errors (`error`, `panic`, and `T | ErrorType...`)",
      "section": "language",
      "summary": "Silk\u2019s typed error system exists to eliminate the \u201ctrust gap\u201d between a function\u2019s signature and its real behavior. There are no hidden exceptions and no implicit panic channel: if a function can terminate due to a logic bug /",
      "text": "Typed Errors (error, panic, and T ErrorType...) Silk\u2019s typed error system exists to eliminate the \u201ctrust gap\u201d between a function\u2019s signature and its real behavior. There are no hidden exceptions and no implicit panic channel: if a function can terminate due to a logic bug / contract violation, it must say so in its signature, and the compiler must enforce it. This document specifies the surface syntax and checker rules for typed errors. The compiler supports error declarations, panic statements, error-aware return types (T ErrorType...), and the match statement form for handling typed errors (including the Terminal Arm Rule), plus the postfix ? propagation operator for error-producing calls. Overview An error represents an unrecoverable logic bug or contract violation. A function that can panic must declare that in its return type using : fn getat(xs: &u8[], index: int) -> u8 OutOfBounds; A typed error is triggered with panic, which terminates the current function and propagates the error to the caller. Typed errors are handled explicitly via match (statement form), and any arm that handles an error must end in a terminal statement. This model is intentionally closer to \u201ctyped, explicit non-local errors\u201d than to try/catch exceptions or an implicit panic mechanism. Recoverable errors are values (not typed errors) Typed errors are intentionally not the primary mechanism for routine runtime failures such as: invalid user input, parsing failures, I/O failures. Those should typically be modeled as ordinary values using std::result::Result or optionals (T?) so callers can handle them and continue normal execution. See: (recoverable URL parsing example). Declaring Error Types (error) Syntax: error OutOfBounds { index: int, len: int } Rules: error Name { ... } declares a nominal, struct-like type that represents an unrecoverable logic bug / contract violation. An error declaration has the same field rules as struct in the current compiler subset (scalar fields; see An error type may also be used as data (returned, stored, logged) when it is not part of a T ... error contract. The compiler treats error as a distinct nominal type category (separate from struct) but reuses the same field/layout rules in Silk. Error-Producing Function Signatures (T ErrorType...) A function declares that it may panic by adding one or more error types after its success type using . Examples: fn getat(xs: &u8[], index: int) -> u8 OutOfBounds { ... } fn parse() -> Packet? PacketTooLarge { ... } fn init() -> void InitFailure { ... } Note on disambiguation: In function declarations, an unparenthesized sequence after -> is always parsed as a typed-error contract. To return a union type from a function, parenthesize the union: fn f () -> (A B); fn g () -> (A B) SomeError; Rules: The leftmost type is the single success type. Each type on the right side of must name a declared error type. The list of error types in a signature is the complete contract: the implementation may not panic with any other error type. Implementation notes: The current compiler models typed errors as a distinct \u201cerror set\u201d attached to the function signature and to expressions that may panic. The success type is still a normal Silk type (including optionals). Triggering a Typed Error (panic) Syntax: panic OutOfBounds { index: index, len: std::length(xs) }; Rules: panic constructs a value of the named error type and immediately terminates the current function, propagating the error to the caller. A panic X { ... }; statement is only legal inside a function whose signature includes X (directly or indirectly via propagation). Implementation notes: panic is a statement (not an expression) in Silk. Propagating Typed Errors (?) The postfix ? operator propagates a typed error from an error-producing call expression to the caller without requiring an explicit match at every call site. Syntax: let value: T = errorcall(...)?; Semantics: If the call succeeds, call()? evaluates to the call\u2019s success value. If the call panics with a declared error type, call()? immediately returns from the current function, propagating the same error to the caller. Rules: ? is only legal inside a function that declares an error contract (-> SuccessType ErrorType...). The callee\u2019s error set must be a subset of the enclosing function\u2019s error set. Otherwise the call must be handled explicitly with a match statement that maps the error into the caller\u2019s contract. ? is only meaningful on an error-producing call expression (a call whose signature includes ErrorType...). Applying ? to an infallible call is a type-check error. Implementation notes: In the current compiler, call()? is lowered as \u201ccall + tag dispatch; on error return the appropriate error payload; on success yield the value\u201d, using the same encoding as the match statement lowering. Handling Typed Errors (match statement + Terminal Arm Rule) When the scrutinee expression of a match statement may panic (i.e. its signature includes ), the compiler activates a special rule for error arms. Match statement form match (createpacket(usersize)) { Some(packet) => { io::println(\"ok\"); }, None => { io::println(\"no packet\"); }, err: PacketTooLarge => { log::critical(\"invalid packet size requested\", err); std::abort(); } } Terminal Arm Rule If the scrutinee expression has an error contract (T ErrorType...), then for any arm that matches an error type, the arm\u2019s block must end with a terminal statement. Terminal statements are: panic <ErrorType> { ... }; (propagate or map to another error) std::abort(); std::halt(); std::reboot(); Implementation notes: std::abort() is lowered as a terminal action: in the native backend subset, this is routed through the platform abort() so the process terminates with SIGABRT, in non-debug builds on linux/x8664, the compiler disables core dumps (prctl(PRSETDUMPABLE, 0, 0, 0, 0)) before calling abort() to keep abort fast, on backends/targets where abort() is unavailable, it is lowered to the backend\u2019s Trap primitive. std::halt() and std::reboot() are currently lowered to Trap in the native backend subset. This rule is intentionally context-dependent: it is triggered by the error contract of the scrutinee expression, not by the fact that a type is declared with error. Error types as data (no Terminal Arm Rule) If a function returns an error type as a normal value (no in its signature), the special rule does not apply: fn inspectissues() -> PacketTooLarge; match (inspectissues()) { err: PacketTooLarge => { log::warn(\"non-critical issue\", err); // Allowed to complete normally because the scrutinee is not a T .... } } match statements over Result-like values (recoverable) The match statement form can also be used to destructure common recoverable result shapes such as std::result::Result(T, E). When the scrutinee expression is a call expression whose result type is either: std::result::Result(T, E) (an enum with Ok(T) and Err(E) variants), or a \u201cResult-like\u201d struct with fields: value: T? err: E? where E is an error type, then the checker accepts binder patterns of the form: name => { ... } / => { ... } for the success payload (binds name as T), err: E => { ... } for the error payload (binds err as E). The Terminal Arm Rule does not apply in this form because the scrutinee is not a T ErrorType... typed-error expression; the error is a normal returned value. Runtime invariant (struct form, current backend): exactly one of value and err must be Some(...). If the invariant is broken, execution traps. Implementation notes: The current compiler supports a match subset for optionals as an expression (match x { None => expr, Some(v) => expr }). The match expression also supports Ok(...) / Err(...) patterns for Typed error handling uses the statement form of match with block arms. Restrictions pure fn pure fn must not introduce or handle typed errors: pure fn may not have a in its return type. pure fn may not contain panic statements. The checker enforces these rules in Silk (see ext boundary Typed errors must not cross the external boundary. External shims must translate typed errors into: explicit error return codes, nullable pointers / optionals, explicit error structs/enums, or a terminal action appropriate for the platform. (and rejects exported C ABI surfaces with ) in the current implementation. Related proposals Open/variadic error sets for higher-order adapters (E...). return <error> as shorthand for panic <error> (AP131)."
    },
    {
      "id": "language/types",
      "title": "Types",
      "section": "language",
      "summary": "This document specifies the Silk type system used by the compiler front-end and type checker.",
      "text": "Types This document specifies the Silk type system used by the compiler front-end and type checker. Implementation status : Supported end-to-end: primitives, nominal struct types, optionals (T?), &Struct references (in function parameter types and as local values produced by new / calls that return &Struct), and array/slice types (T[N], T[]) over element types that lower to a fixed scalar-slot sequence In Silk (including array literals, indexing reads, and iterable for loops). Indexed assignment targets (xs[i] = v) are supported for these element types; compound index ops require numeric scalar element types in Silk. Parameterized nominal types (monomorphized): generic struct and interface declarations with type parameters, plus applied types in type positions (Name(u8), Name(string)) for those declarations. Reserved intrinsics: the compiler currently exposes reserved, stdlib bring-up intrinsics for working with the string ABI (silkstringptr, silkstringlen, and silkstringfromptrlen); these are not yet a stable user API and exist primarily to unblock std::fmt, std::io, and std::args while slice/iterator features are still evolving. Special-case: the nominal optional form Option(T) is accepted and desugared to T? in type annotations (it is not a general generics feature). Parsed but rejected by the current checker: const parameters and integer and the removed builtin map type form (map(K, V)) (E2017; use std::map::{HashMap, TreeMap} instead). Defined in the native backend subset: 128-bit scalar primitives (i128, u128, f128). these primitives lower to two 8-byte slots (lo: u64, hi: u64). f128 uses the IEEE\u2011754 binary128 bit pattern stored across those slots. On linux/x8664 in the current backend implementation, f128 arithmetic and some as casts lower to bundled runtime helper calls and rely on libgccs.so.1 for float128 builtins. Typed errors (error, panic, and T ErrorType...) are specified in contracts as an effect on function return types and expressions. Separately, type unions (T1 T2 ...) are supported in type annotations return types, union returns must be parenthesized (-> (A B)) because unparenthesized after -> is reserved for typed-error contracts. Quick Reference The core categories are: Booleans: bool Examples: true, false. Notes: logical values. Integers (fixed width): u8, i8, u16, i16, u32, i32, u64, i64, u128, i128 Examples: let n: i32 = 42;. Notes: signed/unsigned bit-widths. Integer (platform): int Examples: let n: int = 1;. Notes: implementation/default integer. Pointer-width integers: usize, size Examples: let n: usize = 1;, let n: size = -1;. Notes: unsigned/signed integer types whose width matches the target architecture pointer width (for example 64-bit on linux/x8664). Compatibility: isize is accepted as an alias for size. Floats: f32, f64, f128 Examples: let x: f64 = 3.14;. Notes: IEEE\u2011754. Char: char Examples: 'A'. Notes: Unicode scalar. String: string Examples: \"hello\". Notes: immutable text; multi\u2011line strings supported. Regexp: regexp Examples: /hello/i. Notes: compiled regular expression bytecode; a non-owning { ptr, len } view analogous to string. Regex literals compile at compile time; runtime Region handle: Region Examples: fn f (r: Region) -> int { with r { ... } }. Void / Unit: void Examples: fn foo () -> void {}. Notes: functions that return nothing. Time Types: Instant, Duration Examples: let i: Instant = std::now();. Notes: specialized i64-based types for time measurement. Optional: T? Examples: User?, i32?. Notes: None / none is the canonical empty value; null may also be used when an optional type is expected and coerces to None. Use match, ?., ??. None (value): Examples: None / none (represented as None in code samples). Notes: the distinguished empty value; typed as T?. The null literal is a distinct literal that can coerce to None when an optional type is Reference (borrow): &T Examples: &User. Notes: reference type; in Silk, &Struct may appear in parameter types and as local values when produced by new or by calls that return &Struct. Mutability follows the mut borrow contract and per-call Arrays / Slices: T[], T[N] Examples: i32[], byte[32]. Notes: dynamic slice vs fixed length (compile\u2011time N). In the current compiler/backend subset, arrays/slices are supported only when the element type lowers to a fixed scalar slot sequence in the current scalar-slot memory model (for example primitive scalars, string, and supported current scalar-slot memory model. in Silk, fixed array lengths are limited to N <= 4096. Indexing xs[i] traps when i is out of bounds in Silk. Function Types: fn(params) -> R Examples: fn(i32) -> i32. Notes: function types are part of the type grammar and function-typed values are supported as function values (including capturing closures) in the compiler. Concurrency disciplines (task / async) are implemented on function positions do not currently include discipline modifiers. Capturing Closures: Notes: capturing closures are supported as function values with an environment; see \u201cFunction Types and Closures\u201d below for restrictions. Structs (nominal): Surface: struct Name { ... } then Name(...). Examples: Point, Option(T). Notes: user\u2011defined records; may be parameterized. Enums (sum types): Surface: enum Name { ... }. Notes: nominal tagged unions as described in the spec. Type unions: Surface: T1 T2 ... (type annotations). Notes: a tagged \u201cone-of-these-types\u201d type for a small, explicitly defined The compiler must represent these types faithfully in its internal type system and in the C99 ABI mappings, and it must follow the exact surface syntaxes indicated above when parsing and printing types. Type Aliases (type) Silk supports compile-time-only type aliases via type declarations. Syntax examples: type Int32 = i32; type struct Bar = Foo; type fn IntAdder = fn(int, int) -> int; type pure fn PureIntAdder = fn(int, int) -> int; export type struct PublicBar = Foo; Semantics : A type alias introduces a new name for an existing type; it does not introduce a distinct nominal type. The type checker MUST treat uses of the alias name as equivalent to the alias target type (the alias is transparent). Type aliases may be used anywhere a type is expected (parameter/result types, local annotations, struct fields, as casts, etc.). Cycles in type aliases are rejected (E2058). Kind tags: A type declaration may optionally specify a kind tag, for example type struct Name = Foo; or type pure fn Name = fn(...) -> ...;. When present, the compiler MUST validate that the resolved alias target matches the declared kind (E2059). Import/export: type aliases may be exported (export type ...;) and imported as type names Implicit Call-Argument Coercions In Silk, Silk supports a small, opt-in implicit coercion mechanism for function call arguments. This exists to keep the current standard library ergonomic while generics and richer overload systems are still evolving. There are two related mechanisms: 1. Coercion to a nominal struct value T (by-value parameters and varargs elements) via exported static ctor-like methods. 2. Coercion to a borrowed reference &T (read-only &T parameters) via a constructor method that initializes a compiler-generated stack temporary. 1) Coercion to T via exported static ctor-like methods Rule (informal): When a function call argument type does not match a parameter type, and the parameter is a nominal struct type T, the compiler may rewrite the argument to a call of an exported, static ctor-like method on T. This also applies to varargs elements (...args: T). Supported ctor-like method names (destination type opts in by defining these): T.int(value: int) -> T T.i128(value: i128) -> T T.u64(value: u64) -> T T.u128(value: u128) -> T T.f64(value: f64) -> T T.f128(value: f128) -> T T.bool(value: bool) -> T T.char(value: char) -> T T.string(value: string) -> T T.regexp(value: regexp) -> T T.Region(value: Region) -> T Selection (source type \u2192 constructor): Signed integer primitives (i8/i16/i32/i64/int/size/isize/Instant/Duration) \u2192 int Signed wide integer primitive (i128) \u2192 i128 Unsigned integer primitives (u8/u16/u32/u64/usize) \u2192 u64 Unsigned wide integer primitive (u128) \u2192 u128 Float primitives (f32/f64) \u2192 f64 Wide float primitive (f128) \u2192 f128 bool \u2192 bool char \u2192 char string \u2192 string regexp \u2192 regexp Region \u2192 Region Integer width: When the source argument is a fixed-width integer, the compiler inserts an implicit integer cast to match the ctor parameter type before calling the ctor. When the source argument is f32 and the selected ctor parameter type is f64, the compiler inserts an implicit float cast (f32 -> f64) before calling the ctor. Example: struct Counter { value: int, } impl Counter { public fn int (value: int) -> Counter { return Counter{ value: value }; } } fn takes (c: Counter) -> int { return c.value; } fn main () -> int { let x: i32 = 7; return takes(x); // coerces via Counter.int } Notes: Coercions are only attempted when the destination type provides the matching exported static ctor method. Today this primarily exists to support std::fmt::Arg and ergonomic std::io::print/println calls without requiring explicit Arg. wrappers everywhere. 2) Coercion to &T via constructor (stack temporary) Rule (informal): When a call argument does not match a parameter type, and the parameter is a read-only borrowed reference &T to a nominal struct type T, the compiler may create an implicit stack temporary tmp: T, initialize it by invoking tmp.constructor(...), and pass &tmp to the callee. This is intentionally a stack construction mechanism: it does not allocate on the heap, it is compatible with silk build --noheap, and the temporary\u2019s lifetime is the duration of the call (similar to how C++ binds temporaries to const& parameters). Eligibility requirements: The parameter must be &T (not mut &T). The destination type T must provide a visible constructor overload with: receiver mut self: &T, exactly one non-receiver parameter (value: U), return type void. The call argument type must match the selected overload\u2019s U parameter type. If multiple overloads are viable for a given argument, the coercion is ambiguous and rejected (the call must be written with an explicit construction). Example: struct User { name: string, } impl User { fn constructor (mut self: &Self, name: string) -> void { self.name = name; } } fn printuser (user: &User) -> void { std::io::println(\"user.name = {}\", user.name); } fn main () -> int { // Implicitly constructs a temporary User from a string for this call. printuser(\"alice\"); return 0; } Notes: This is an opt-in mechanism: types must provide the matching constructor. If the coercion is ambiguous (multiple viable conversion paths), the compiler rejects the call and requires an explicit construction. Because this coercion participates in ordinary call argument checking, it can make additional overloads applicable (for example a copy-constructor constructor(mut self: &Self, other: &Self) can accept a string argument by first constructing a temporary Self from string). Overload resolution prefers overloads that match without requiring such coercions. Explicit Casts (as) Silk supports explicit casts using the postfix as operator: let x: f64 = 3.14; let n: int = x as int; This operator is intended for explicit, potentially lossy primitive numeric conversions. in Silk it also supports explicit conversions via std::interfaces::Serialize(T) by lowering expr as T to expr.serialize() when the operand type provides a matching serialize method. For structured conversions, it also supports std::interfaces::Deserialize(S) by lowering expr as T to T.deserialize(expr) when the target type provides a matching static deserialize method. The supported conversions and semantics for the compiler are Notes: as is explicit. It does not introduce new implicit coercions. For call-argument ergonomics, see the separate opt-in coercion mechanism described above (\u201cImplicit Call-Argument Coercions\u201d). Nominal & Parameterized Types Nominal types are introduced by declarations (e.g. struct, enum, interface) and are equal only to themselves. Parameterized types are constructed by applying a type constructor to type arguments. The compiler must: Treat nominal types as distinct even if their field layout is identical. In the full language design, support parameterized types in all contexts where the spec permits them. in Silk, type-parameter generics are supported for nominal declarations (struct / interface) and for applied types in type positions (Name(u8)). Const parameters and integer-literal type arguments (Name(N: int), Name(u8, 1024)) remain tracked work and are rejected (E2016). The Option(T) optional sugar described above remains supported for the . Parameterized type syntax (initial surface form) The initial surface syntax for applying type arguments is: TypeApply ::= TypeName '(' TypeArgListOpt ')' TypeName ::= Identifier ('::' Identifier) TypeArgListOpt ::= TypeArgList \u03b5 TypeArgList ::= TypeArg (',' TypeArg) ','? TypeArg ::= Type IntLiteral Examples: Foo(int, 1024) Mutex(Account) Result(int, string) Notes: A TypeArg may be a type (e.g. int, &Foo, Option(string)) or a compile-time integer literal for const-parameter-style arguments. The full semantics (declaring generic parameters, constraint checking, and monomorphization) are still evolving; the key requirement is that the compiler preserves the argument structure in the AST/type system so later stages can enforce and lower it. Reference Types Reference types describe access to values rather than owning them (e.g. references, borrowed views, or other non-owning handles as specified in this document and related language docs). Key requirements: Distinguish owning vs. non-owning types in the type system. Preserve aliasing and lifetime constraints so that regions, buffers, and FFI safety rules can be enforced. Current implementation notes: &Struct is supported in function parameter types and as local values when produced by heap allocation (new) or by calls that return &Struct. Borrowed &Struct references may also be created from stack values: via the borrow operator &expr on borrowable lvalues, and via implicit borrow coercions in contexts that expect &T (for example let r: &Pair = pair;). These borrows are checked with conservative lexical lifetime rules (they may not escape the scope of the borrowed stack storage). Mutable reference parameters use the two-part mut contract and conservative Function Types and Closures (Implementation Status) the compiler: Parses function types in type positions (most notably for ext declarations). Implements function expressions (lambdas) in expression positions: expression body form: fn (x: int, y: int) -> x + y block body form: fn (x: int, y: int) -> int { return x + y; } Function expressions may not declare &T parameters in Silk. Function expressions are inferred as pure when they are non-capturing: they may call only pure functions, they may not mutate (let mut/var, assignment), they may not allocate (new), they may not use typed error contracts or panic. The checker also supports purity inference (\u201cauto-pure\u201d) for ordinary function declarations and impl methods. When inferred, these functions/methods are treated as pure for call checking and are callable from pure code. Capturing closures are implemented as a subset of function values: a function expression body may reference immutable locals/parameters from an enclosing scope; those values are captured by value into a heap environment, In Silk, only scalar captures are supported (int, fixed width ints, bool, char, f32, f64, Instant, Duration), capturing closures are not pure (they have an environment) and are rejected in pure code in Silk. Function values are supported end-to-end for this subset (non-capturing and capturing): they may be passed as arguments, returned from functions, stored in structs/arrays, and called indirectly. the runtime representation is a pair { funcptr, envptr } as specified Discipline modifiers for function declarations (pure / task / async) are implemented. Function types in type positions do not currently include discipline modifiers."
    },
    {
      "id": "language/varargs",
      "title": "Varargs (Variable Arguments)",
      "section": "language",
      "summary": "Silk supports declaring functions that accept a variable number of trailing arguments (\u201cvarargs\u201d). This is used heavily by `std::io::print` / `std::io::println` for formatted output.",
      "text": "Varargs (Variable Arguments) Silk supports declaring functions that accept a variable number of trailing arguments (\u201cvarargs\u201d). This is used heavily by std::io::print / std::io::println for formatted output. Syntax Varargs are declared by prefixing the final parameter with ...: fn log (fmt: string, ...args: std::fmt::Arg) -> void { std::io::println(fmt, args); } Rules: A function may declare at most one varargs parameter. The varargs parameter must be the final parameter in the list. The varargs parameter must have an explicit type annotation. Varargs parameters are not permitted to be mut In Silk. Varargs parameters may not have a default expression (= ...) in the current subset. Call Semantics At call sites: All non-varargs parameters are matched positionally as usual. Any additional arguments are collected into the varargs parameter. Example: std::io::println(\"hello {s} answer={d}\", \"world\", 42); Here \"world\" and 42 become varargs elements. Forwarding Because Silk does not yet have a general \u201cspread\u201d operator for calls, the current implementation supports forwarding a varargs pack when you pass a varargs binding as the final argument. fn log (fmt: string, ...args: std::fmt::Arg) -> void { // args is forwarded as-is to println. std::io::println(fmt, args); } This is primarily intended for building wrappers that preserve the caller\u2019s argument list without repacking. Representation In Silk, a varargs parameter is lowered as a fixed-size pack value with: len: int \u2014 the number of provided varargs arguments. a0 .. a(N-1) \u2014 storage for up to N arguments (implementation-defined, currently N = 32). The pack is passed by value using the same \u201cflattened scalar slot\u201d ABI as other POD structs. Notes: Accessing aK where K >= len is a logic error (the value is unspecified). Calls supplying more than N varargs arguments are rejected. FFI (C Variadics) This document is about Silk varargs. C variadic functions declared via ext (printf-style ...) are a separate concern and are not implemented yet In Silk."
    },
    {
      "id": "std/conventions",
      "title": "`std::` Conventions",
      "section": "std",
      "summary": "conventions for the Silk standard library. New and refactored `std::` APIs must follow this document; older surfaces may temporarily diverge but must be migrated as they are touched.",
      "text": "std:: Conventions conventions for the Silk standard library. New and refactored std:: APIs must follow this document; older surfaces may temporarily diverge but must be migrated as they are touched. This document exists to keep std:: APIs consistent across modules. Public vs Internal API Only export declarations are considered part of the stable public surface. Non-exported declarations are internal implementation details and may change freely. Internal helper packages may exist under names such as std::internal::... or std::sys::..., but these are not stable surfaces. Naming Packages use std::area naming (std::strings, std::fs, std::net). Types use PascalCase (String, Vector(T), Path, File). Functions and methods use snakecase (readall, push, startswith). Constants use SCREAMINGSNAKECASE. Documentation All user-facing std:: APIs must be documented in source using doc comments public types (struct, enum, error, interface), public functions/methods (including constructors like init, empty, invalid, default), public Formal Silk theories exposed for reuse (for example under std::formal). source-level doc comments are the machine-consumable layer used by silk doc, silk man, and editor tooling (hover and completion documentation). Allocation and Ownership std:: should be explicit about allocation: Prefer allocation-free views (Slice(T), Str) for APIs that can operate on borrowed data. Allocating APIs should accept an explicit allocator (or region) parameter, or clearly document which allocator is used. Avoid hidden global allocation in core functionality. Convenience helpers may exist, but must be clearly marked. String ownership (initial design intent): The built-in string type is a UTF-8 byte sequence represented as a The stdlib provides an owned string builder/container (String) whose memory management is explicit and interoperable with string. Construction and Defaults Public std:: types should be easy to construct correctly, without callers needing to know internal sentinel values or manually fill out large structs. Every public std:: struct should provide an explicit \u201csafe default\u201d constructor: container/builder types should provide empty() (preferred over requiring init(0)), handle/resource types should provide invalid() (or an equivalent clearly-named constructor) and ensure methods either: treat invalid handles as no-ops (for example close/drop), or return a recoverable error (for example InvalidInput) rather than trapping. If a type\u2019s primary constructor requires configuration (capacity, hash function pointers, etc.), provide a convenience constructor that uses a sensible default: for capacity-driven containers: empty() and a parameterized constructor (init(cap) In Silk; consider withcapacity(cap) long-term), for option/config structs: a default() constructor or clearly-named presets (for example readonly() / writeonly()). Drop types must be safe to drop in their default/empty/invalid state and should be idempotent when possible (invalidate the handle/pointer after freeing). Constructors must not silently \u201csucceed\u201d while discarding failures: if init(cap) allocates, it must return a recoverable error (Result(...) or an optional error return) when allocation fails, empty() exists for infallible construction. Errors recoverable error values (T? and std::result::Result(T, E)). Public std:: APIs should follow these rules: Use T? when \u201cabsence\u201d is the only meaningful error case and no additional error information is required (e.g. pop() -> T?). Use a result type when callers need to distinguish multiple error causes. with Ok(T) / Err(E) cases. Prefer that the primary API name returns Result(...) / optional error, rather than exporting parallel result variants. Callers that want to discard error details can: compare an optional error return against None, or for Result(T, E): prefer match (r) when T or E may implement Drop, use ResultType.okvalue(r) / unwrap(r) / unwrapor(r, fallback) / errvalue(r) only when the active payload is copy-safe (does not implement Drop). Avoid exporting parallel opt helpers that hide error information. Do not use bool returns for fallible operations that can fail for multiple reasons; return an optional error (ErrorType?) or Result(T, E) instead. Keep OS/runtime-specific error mechanisms (such as POSIX errno) out of the public surface. Map them into stable, portable error kinds/codes in the top-level std:: module and confine the platform details to std::runtime. Do not expose typed error contracts (T ErrorType...) or panic for routine runtime failures such as I/O errors or parse failures. Prefer Result(...) or an optional error return (ErrorType? where None is success). Do not call assert / std::abort() from std:: APIs. Malformed inputs, invariant violations, and resource exhaustion must be surfaced as recoverable errors. Formal Silk Contracts std:: should actively use Formal Silk to document and enforce invariants in low-level code (buffers, parsing, and pointer/length handling): Prefer reusable theories from std::formal (for example slicewellformed and vectorwellformed) over ad-hoc #require / #assert boilerplate. Contracts must reflect real runtime invariants (avoid over-strong preconditions that callers cannot prove). When handling untrusted inputs, validate at runtime and return a recoverable error value rather than relying on preconditions. that the verifier currently skips std::... modules; contracts in std:: are still valuable as precise documentation and for future verification work. UTF-8 and Text string is defined as UTF-8 bytes. APIs that operate on \u201ccharacters\u201d must be explicit about whether they mean: bytes, Unicode scalar values (char), or grapheme clusters (locale/text-segmentation dependent). By default, indexing/slicing is byte-based and does not validate UTF-8 unless an API explicitly says it does. Platform Baselines Hosted baseline: POSIX behavior for filesystem, networking, and clocks. Freestanding baseline: no OS; only core modules are available. Each hosted API must clearly document which POSIX calls it relies on and which errors are surfaced to callers."
    },
    {
      "id": "std/package-structure",
      "title": "`std::` Module Structure",
      "section": "std",
      "summary": "build integration for `std::`. A first, minimal slice of the build integration is implemented (auto-resolving `std::...` imports from a configurable stdlib root), while most std APIs remain unimplemented.",
      "text": "std:: Module Structure build integration for std::. A first, minimal slice of the build integration is implemented (auto-resolving std::... imports from a configurable stdlib root), while most std APIs remain unimplemented. This document defines how the standard library is organized and how it is made available to user programs. Namespace Model std:: is a reserved namespace root. The standard library is a distribution of modules whose module names begin with std::...: std::strings std::memory std::arrays std::bits std::interfaces std::map std::set std::algorithms std::temporal std::semver std::url std::io std::env std::process std::path std::fs std::net std::tls std::http std::https std::websocket Each source file in the stdlib declares which module it defines using a module declaration: module std::strings; The compiler treats module/package names (including std::...) as part of the std::runtime (Runtime Interface Layer) std::runtime is a dedicated namespace under std:: that defines low-level, platform/environment primitives in a pluggable way. Design intent: Higher-level std::... modules (like std::fs, std::task, std::sync) are written against std::runtime::... interfaces. The shipped stdlib provides a default hosted POSIX backend under std::runtime::posix::... and the corresponding std::runtime::... modules delegate to it. Alternative stdlib roots can provide different runtime implementations (for example Windows or embedded) without changing the public std::... surface. Linking by Default (Requirement) std:: must be linked by default for normal silk build workflows: The compiler provides a default stdlib root (an implementation-defined directory shipped with the compiler distribution). That root is automatically included in the compiler\u2019s package/module search path during builds, so that: import std::strings; resolves without the user having to explicitly pass the stdlib source files on the command line. Notes: This does not imply an implicit import std::...; prelude; importing is explicit. Linking-by-default means \u201cstd:: is available to import\u201d. The compiler should only compile/link the std modules that are reachable from the user\u2019s imports (and any internal dependencies), rather than eagerly compiling all of std::. Swappability (Requirement) The default stdlib must be replaceable by an alternate implementation: The build configuration may override the stdlib root used for resolving std::... imports. A replacement stdlib is expected to provide compatible packages and exported APIs under the same std::... names. The language and C ABI remain stable regardless of stdlib choice; std:: is ordinary Silk code and does not change core semantics. The concrete selection mechanism is a compiler/driver responsibility and must Current toolchain behavior (first slice): Both the silk CLI and the libsilk.a embedding build path resolve std::... imports from a stdlib root selected by: an explicit override (--std-root for silk, or silkcompilersetstdroot for embedders), otherwise SILKSTDROOT (environment variable) when set, otherwise a std/ directory in the current working directory (development default), otherwise ../share/silk/std relative to the current executable (installed default). Mapping is deterministic: std::foo::bar resolves to <stdroot>/foo/bar.slk. Static Archive Distribution (Current Toolchain) For distribution and incremental development, the stdlib can be built into a static archive for a specific target ABI: make stdlib compiles each std//.slk module (including std/runtime/...) to an ELF object via silk build --kind object and archives them into zig-out/lib/libsilkstd.a. This archive is target-specific (e.g. linux/x8664 ELF objects) and should be treated as one artifact per supported target triple/ABI, not as a universally portable library. Current toolchain behavior (linux/x8664): The compiler still loads stdlib Silk sources from the configured stdlib root for parsing/type-checking (so the language-level package graph is validated), but executable code generation treats auto-loaded std::... modules as external and resolves their exported functions from the prebuilt archive when one is available. Archive discovery (in order): std-lib <path> (or --std <path>.a / -std <path>.a) when provided, otherwise SILKSTDLIB (environment variable) when set, zig-out/lib/libsilkstd.a when using the in-repo std/ root (development), ../lib/libsilkstd.a relative to the installed silk executable, common installed-layout heuristics derived from the selected stdlib root. Archive member naming (scheme): to avoid basename collisions (for example std/task.slk and std/runtime/posix/task.slk), archive member names are based on the std-root relative path with / replaced by , and .slk replaced by .o, for example: std/runtime/posix/task.slk \u2192 runtimeposixtask.o. When no suitable archive is found (or on unsupported targets), the compiler falls back to compiling the reachable std sources into the build as part of module-set code generation. nostd disables stdlib auto-loading and therefore also avoids linking the default std archive; users may still explicitly provide their own std::... modules as ordinary inputs when desired. std-root <path> (or --std <path> / -std <path> when <path> does not end in .a) selects an alternate stdlib root, and the corresponding archive is discovered via the same --std-lib / SILKSTDLIB and installed-layout rules. Hosted vs Freestanding The stdlib should be layered: A \u201ccore\u201d subset that does not require OS services (collections, algorithms, string utilities, formatting, etc.). Hosted modules (std::fs, std::net, parts of std::temporal and std::io) that rely on POSIX syscalls or POSIX-like APIs. This layering allows std:: to be used in freestanding environments while still offering a full POSIX-oriented API when available. Versioning and Compatibility The standard library is shipped with the compiler and should be versioned: Public, exported APIs under std::... should follow semantic versioning. A compiler may require a minimum stdlib version, and should report a clear error when an incompatible stdlib root is selected."
    },
    {
      "id": "std/algorithms",
      "title": "`std::algorithms`",
      "section": "std",
      "summary": "implemented yet.",
      "text": "std::algorithms implemented yet. std::algorithms provides common algorithms over collections (primarily std::arrays::Slice(T) and related types). See also: Details A tiny, non-generic subset is implemented in std/algorithms.slk for early bring-up. These helpers operate on concrete scalar types and are intended to be replaced or complemented by generic slice/collection algorithms as soon as the necessary language features exist. module std::algorithms; export fn minint (a: int, b: int) -> int; export fn maxint (a: int, b: int) -> int; export fn clampint (x: int, lo: int, hi: int) -> int; export fn minu64 (a: u64, b: u64) -> u64; export fn maxu64 (a: u64, b: u64) -> u64; export fn clampu64 (x: u64, lo: u64, hi: u64) -> u64; export fn minf64 (a: f64, b: f64) -> f64; export fn maxf64 (a: f64, b: f64) -> f64; export fn clampf64 (x: f64, lo: f64, hi: f64) -> f64; export fn absi64 (x: i64) -> i64; export fn absint (x: int) -> int; export fn absf64 (x: f64) -> f64; export fn minduration (a: Duration, b: Duration) -> Duration; export fn maxduration (a: Duration, b: Duration) -> Duration; export fn mininstant (a: Instant, b: Instant) -> Instant; export fn maxinstant (a: Instant, b: Instant) -> Instant; Scope std::algorithms is responsible for: Searching, sorting, and transformation routines. Designed to work with std::arrays and other iterable types. Initial API Surface (Illustrative) The initial algorithms target Slice(T) since it is the most universal view type for contiguous collections. module std::algorithms; export fn linearsearch (T, s: std::arrays::Slice(T), needle: T) -> int?; export fn binarysearch (T, s: std::arrays::Slice(T), needle: T, cmp: fn(T, T) -> int) -> int?; export fn sort (T, s: std::arrays::Slice(T), cmp: fn(T, T) -> int) -> void; export fn stablesort (T, s: std::arrays::Slice(T), cmp: fn(T, T) -> int) -> void; export fn min (T, s: std::arrays::Slice(T), cmp: fn(T, T) -> int) -> T?; export fn max (T, s: std::arrays::Slice(T), cmp: fn(T, T) -> int) -> T?; Notes: Sorting should be in-place where possible. Stable sorting may require temporary allocations; this should be explicit (accept an allocator) or clearly documented. Future Work dedup, partition, reverse, rotate, shuffle. Iterator-based algorithms once iterators and for are fully implemented."
    },
    {
      "id": "std/args",
      "title": "`std::args`",
      "section": "std",
      "summary": "`std/args.slk` to make early programs ergonomic while `string[]` parameters and richer slice/iterator features are still future work.",
      "text": "std::args std/args.slk to make early programs ergonomic while string[] parameters and richer slice/iterator features are still future work. std::args focuses on the hosted linux/x8664 executable entrypoint shape: fn main (argc: int, argv: u64) -> int { ... } Where argv is a raw pointer to the process argv pointer list (char in C). See also: API The following items are implemented in std/args.slk: module std::args; // Read argv pointers. export fn argvptr (argv: u64, index: int) -> u64; export fn argvcstr (argv: u64, index: int) -> u64; // Inspect NUL-terminated C strings. export fn cstrbyte (cstr: u64, index: int) -> u8; export fn cstrlen (cstr: u64) -> int; // Convert stable C strings to Silk string views (no allocation, no copy). export fn cstrstring (cstr: u64) -> string; export fn argvstring (argv: u64, index: int) -> string; // Convenience wrapper for (argc, argv). struct Args { argc: int, argv: u64, } impl Args { public fn init (argc: int, argv: u64) -> Args; public fn count (self: &Args) -> int; public fn ptr (self: &Args, index: int) -> u64; public fn get (self: &Args, index: int) -> string; } Safety notes cstrlen scans memory until it finds a 0 byte. If the pointer is invalid or the string is not NUL-terminated, behavior is undefined. cstrstring / argvstring return string views into existing memory. They do not copy or allocate, and therefore do not provide ownership. The caller must ensure the pointed-to bytes remain valid for the lifetime of the returned string. For process argv strings this is typically valid for the lifetime of the process. String construction intrinsic The current implementation uses a reserved, compiler-backed intrinsic to construct string values at the ABI/IR level: silkstringfromptrlen(ptr: u64, len: int) -> string This intrinsic is intended only for stdlib bring-up (in particular std::args and C-string bridging) and is not a stable user API."
    },
    {
      "id": "std/arrays",
      "title": "`std::arrays`",
      "section": "std",
      "summary": "for early FFI-friendly bridging; higher-level owning containers live in `std::vector`.",
      "text": "std::arrays for early FFI-friendly bridging; higher-level owning containers live in std::vector. std::arrays provides array and vector-like types built on top of the Buffer(T) See also: Current API A tiny generic subset is implemented in std/arrays.slk to provide a non-owning, FFI-friendly slice representation for early bridging: module std::arrays; import std::interfaces; struct Slice(T) { ptr: u64, len: i64, } impl Slice(T) { public fn init (ptr: u64, len: i64) -> Slice(T); public fn get (self: &Slice(T), index: i64) -> T; public fn set (self: &Slice(T), index: i64, value: T) -> void; public fn at (self: &Slice(T), index: i64) -> T?; public fn tryset (self: &Slice(T), index: i64, value: T) -> bool; public fn first (self: &Slice(T)) -> T?; public fn last (self: &Slice(T)) -> T?; public fn iter (self: &Slice(T)) -> SliceIter(T); } impl Slice(T) as std::interfaces::Len { public fn len (self: &Slice(T)) -> i64; } impl Slice(T) as std::interfaces::IsEmpty { public fn isempty (self: &Slice(T)) -> bool; } struct SliceIter(T) { ptr: u64, len: i64, index: i64, } impl SliceIter(T) { public fn init (slice: Slice(T)) -> SliceIter(T); } impl SliceIter(T) as std::interfaces::Iterator(T) { public fn next (mut self: &SliceIter(T)) -> T?; } // Packed byte views (for byte-oriented OS/FFI APIs). struct ByteSlice { ptr: u64, len: i64, } impl ByteSlice { public fn init (ptr: u64, len: i64) -> ByteSlice; public fn get (self: &ByteSlice, index: i64) -> u8; public fn set (self: &ByteSlice, index: i64, value: u8) -> void; public fn at (self: &ByteSlice, index: i64) -> u8?; public fn tryset (self: &ByteSlice, index: i64, value: u8) -> bool; public fn first (self: &ByteSlice) -> u8?; public fn last (self: &ByteSlice) -> u8?; public fn iter (self: &ByteSlice) -> ByteSliceIter; } impl ByteSlice as std::interfaces::Len { public fn len (self: &ByteSlice) -> i64; } impl ByteSlice as std::interfaces::IsEmpty { public fn isempty (self: &ByteSlice) -> bool; } struct ByteSliceIter { ptr: u64, len: i64, index: i64, } impl ByteSliceIter { public fn init (slice: ByteSlice) -> ByteSliceIter; } impl ByteSliceIter as std::interfaces::Iterator(u8) { public fn next (mut self: &ByteSliceIter) -> u8?; } Notes: This type is a placeholder until the intrinsic Buffer(T) surface and safe view/borrowing rules land end-to-end. In the current API, ptr is represented as a raw u64 address for early FFI-friendly bridging. The constructors enforce basic invariants via #require: len >= 0, and ptr != 0 when len > 0 (a null pointer is permitted only for empty slices). In the shipped stdlib sources, these invariants are also packaged as reusable theories in std::formal (for example slicewellformed(ptr, len)). get / set are intentionally low-level in Silk and are unchecked beyond #require contracts. They are implemented using compiler-backed memory intrinsics routed through std::runtime::mem (see Slice(T) uses the scalar-slot memory model of the compiler: elements occupy sizeof(T) bytes (8 bytes per scalar slot), so multi-slot values like string and non-opaque structs/enums are supported. For byte-oriented APIs that require packed bytes, use ByteSlice. at / tryset are the \u201cchecked\u201d accessors in Silk: at returns None when index is out of bounds, tryset returns false when index is out of bounds. SliceIter(T) provides a minimal sequential iterator for Slice(T) values. It implements std::interfaces::Iterator(T); iteration is by value (copies). Scope std::arrays is responsible for: Slice/view types over contiguous elements. Helpers for fixed-size arrays (T[N]) and for working with slices derived from them. Iteration utilities compatible with the for loop semantics (once for is Core Types (Initial Design) Slice(T) \u2014 a non-owning view over T elements (ptr + len). std::vector::Vector(T) \u2014 the owning, growable sequence type. Fixed-size arrays (T[N]) are part of the language design; std::arrays provides helpers and algorithms that operate on them via Slice(T) views. Illustrative sketch (non-authoritative): std::arrays::Slice(T) for views, and std::vector::Vector(T) for owning growth. Indexing and Bounds The stdlib should provide both: checked accessors that return T? (or a result) on out-of-bounds, and unchecked accessors for verified code paths. The exact behavior must be consistent across the stdlib; see"
    },
    {
      "id": "std/bits",
      "title": "`std::bits`",
      "section": "std",
      "summary": "and byte-order helper subset is implemented in `std/bits.slk` for the current backend subset.",
      "text": "std::bits and byte-order helper subset is implemented in std/bits.slk for the current backend subset. std::bits provides common bit \u201ctwiddling\u201d helpers: byte swaps (bswap), bit rotations (rotl, rotr), and bit counts (popcount, clz, ctz). See also: API module std::bits; export pure fn bswapu16 (x: u16) -> u16; export pure fn bswapu32 (x: u32) -> u32; export pure fn bswapu64 (x: u64) -> u64; export pure fn rotlu32 (v: u32, shift: u32) -> u32; export pure fn rotru32 (v: u32, shift: u32) -> u32; export pure fn rotlu64 (v: u64, shift: u32) -> u64; export pure fn rotru64 (v: u64, shift: u32) -> u64; export pure fn popcountu32 (x: u32) -> u32; export pure fn clzu32 (x: u32) -> u32; export pure fn ctzu32 (x: u32) -> u32; export pure fn popcountu64 (x: u64) -> u32; export pure fn clzu64 (x: u64) -> u32; export pure fn ctzu64 (x: u64) -> u32; Rotation semantics rotlu32 / rotru32 mask the shift amount by 31. rotlu64 / rotru64 mask the shift amount by 63. This means all shift values are valid and rotations do not rely on any target-specific shift masking behavior. Count semantics popcount counts the number of 1-bits. clz counts leading zeros. ctz counts trailing zeros. For clz and ctz, when the input is 0 the function returns the full bit width (32 or 64). Example import std::bits; fn main () -> int { let x: u32 = std::bits::rotlu32(1, 5); if x != ((1 as u32) << 5) { return 1; } let y: u64 = std::bits::bswapu64(4660); // 0x0000000000001234 if y == 0 { return 2; } return 0; }"
    },
    {
      "id": "std/buffer",
      "title": "`std::buffer`",
      "section": "std",
      "summary": "intrinsic `Buffer(T)` type for low-level, unsafe contiguous memory access (see",
      "text": "std::buffer intrinsic Buffer(T) type for low-level, unsafe contiguous memory access (see In the current stdlib, std::buffer provides a packed byte buffer (BufferU8) plus width-oriented buffer aliases built on std::vector::Vector(T) for common scalar element types. This keeps buffer usage ergonomic without relying on per-type Vec stand-ins. See also: Current API std::buffer provides: BufferU8: an owning, growable packed byte buffer (byte-addressed ptr, with len and cap measured in bytes). width-oriented scalar buffer aliases built on std::vector::Vector(T) for convenience in Silk. BufferU8 module std::buffer; import std::arrays; import std::memory; struct BufferU8 { ptr: u64, cap: i64, len: i64, } impl BufferU8 { public fn init (cap: i64) -> std::result::Result(BufferU8, std::memory::AllocFailed); public fn empty () -> BufferU8; public fn push (mut self: &BufferU8, value: u8) -> std::memory::OutOfMemory?; public fn pushbytes (mut self: &BufferU8, bytes: std::arrays::ByteSlice) -> std::memory::OutOfMemory?; public fn pop (mut self: &BufferU8) -> u8?; public fn get (self: &BufferU8, index: i64) -> u8; public fn set (mut self: &BufferU8, index: i64, value: u8) -> void; public fn at (self: &BufferU8, index: i64) -> u8?; public fn tryset (mut self: &BufferU8, index: i64, value: u8) -> bool; public fn swapremove (mut self: &BufferU8, index: i64) -> u8?; public fn clear (mut self: &BufferU8) -> void; public fn reserveadditional (mut self: &BufferU8, additional: i64) -> std::memory::OutOfMemory?; public fn asbytes (self: &BufferU8) -> std::arrays::ByteSlice; public fn drop (mut self: &BufferU8) -> void; } Width-oriented aliases module std::buffer; import std::vector; // Signed integers. export type BufferI8 = std::vector::Vector(i8); export type BufferI16 = std::vector::Vector(i16); export type BufferI32 = std::vector::Vector(i32); export type BufferI64 = std::vector::Vector(i64); // Unsigned integers. export type BufferU16 = std::vector::Vector(u16); export type BufferU32 = std::vector::Vector(u32); export type BufferU64 = std::vector::Vector(u64); // Floating point. export type BufferF32 = std::vector::Vector(f32); export type BufferF64 = std::vector::Vector(f64); Notes: BufferU8 is a packed byte buffer. Its ptr can be passed directly to byte-oriented OS/FFI APIs alongside len. BufferU8.init(cap) returns Err(AllocFailed) rather than silently returning an empty buffer when allocation fails. Use BufferU8.empty() for infallible construction. growth paths (reserveadditional, push, pushbytes) surface allocation failure as std::memory::OutOfMemory? (including internal size arithmetic overflow; leaves the buffer unchanged on failure). The width-oriented aliases are still backed by std::vector::Vector(T) in the, so their underlying storage follows the"
    },
    {
      "id": "std/crypto",
      "title": "`std::crypto`",
      "section": "std",
      "summary": "primitives backed by the system `libsodium` library on the hosted `linux/x86_64` baseline.",
      "text": "std::crypto primitives backed by the system libsodium library on the hosted linux/x8664 baseline. The long-term goal is: a cohesive, ergonomic std::crypto API surface that is suitable for Silk programs, a thin, auditable mapping to libsodium primitives (no bespoke crypto), pervasive use of Formal Silk contracts/theories to document and verify: buffer shape invariants (len >= 0, non-null when non-empty), constant-size requirements (keys/nonces/MAC sizes), \u201cno aliasing required\u201d rules where relevant. Security note: Formal Silk can help specify shape invariants and prevent a large class of memory/length bugs, but it does not prove cryptographic security. Linkage and Toolchain Integration On linux/x8664 with the glibc dynamic loader (ld-linux), silk build automatically adds libsodium.so.23 as a DTNEEDED dependency when a program imports libsodium-backed extern symbols (for example via import std::crypto;). This mirrors the existing behavior for libc.so.6 so downstream users do not have to pass --needed libsodium.so.23 for normal hosted builds. Byte Buffers The current std::vector/std::buffer element model stores each generic element in an 8-byte slot (even for u8), so std::vector::Vector(u8) is not a packed byte array suitable for OS/FFI byte-oriented APIs. For byte-oriented APIs, the stdlib provides packed byte types: std::arrays::ByteSlice \u2014 a non-owning { ptr, len } view over packed bytes (len in bytes). std::buffer::BufferU8 \u2014 an owning { ptr, cap, len } packed byte buffer (cap/len in bytes). std::crypto expresses byte-oriented inputs and outputs in terms of these types (instead of exposing raw (ptr, len) pairs directly in public APIs). The underlying raw allocation and load/store operations are provided by std::runtime::mem. Current API (Initial) The initial std::crypto module is organized as: std::crypto (core helpers and libsodium init) std::crypto::random (CSPRNG) std::crypto::hash (generic hashing) std::crypto::aead (AEAD: ChaCha20-Poly1305 IETF and XChaCha20-Poly1305 IETF) std::crypto::secretbox (secret-key authenticated encryption) std::crypto::box (public-key authenticated encryption) std::crypto::sign (signatures) Key design rules: public APIs avoid sodium prefixes; libsodium symbol names remain in private ext declarations, APIs accept explicit output buffers (typically mut out: &std::buffer::BufferU8), and may grow those buffers via reserveadditional when needed, where libsodium requires out-parameters and the current language subset cannot take the address of a stack scalar, APIs may require caller-provided scratch bytes (for example by requiring extra capacity in a BufferU8 beyond the returned len), functions return recoverable error values: ErrorType? where None is success, std::result::Result(T, ErrorType) where Ok(T) is success and Err(ErrorType) is failure (use Result(bool, ErrorType) for fallible predicates). AEAD (std::crypto::aead) The current AEAD surface provides two constructions: ChaCha20-Poly1305 (IETF) \u2014 chacha20poly1305ietf XChaCha20-Poly1305 (IETF) \u2014 xchacha20poly1305ietf For each construction: size queries: keybytes(), noncebytes(), tagbytes() (each returns i64) sealing: seal(mut c: &std::buffer::BufferU8, m: std::arrays::ByteSlice, ad: std::arrays::ByteSlice, nonce: std::arrays::ByteSlice, key: std::arrays::ByteSlice) -> std::crypto::CryptoError? returns None on success, otherwise Some(CryptoError) sets c.len = ciphertextlen on success requires extra capacity (ciphertextlen + 8) for libsodium\u2019s clenp out-parameter scratch in Silk opening: open(mut m: &std::buffer::BufferU8, c: std::arrays::ByteSlice, ad: std::arrays::ByteSlice, nonce: std::arrays::ByteSlice, key: std::arrays::ByteSlice) -> std::crypto::CryptoError? returns None on success, otherwise Some(CryptoError) sets m.len = messagelen on success requires extra capacity (messagelen + 8) for libsodium\u2019s mlenp out-parameter scratch in Silk Associated data is optional: callers may pass ad = { ptr: 0, len: 0 }. key derivation (kdf, pwhash), streaming (secretstream), constant-time and secure-memory helpers (mprotect, mlock, guarded alloc), full libsodium surface coverage where it makes sense for std::."
    },
    {
      "id": "std/env",
      "title": "`std::env`",
      "section": "std",
      "summary": "`std::env` provides access to process environment variables.",
      "text": "std::env std::env provides access to process environment variables. The current implementation targets a hosted POSIX baseline (Linux/glibc) and is implemented on top of the pluggable std::runtime::env interface. WASI support is partially implemented: get works, while set remains unsupported (see \u201cPlatform notes\u201d). API module std::env; import std::process; import std::strings; enum SetVarErrorKind { InvalidKey, OutOfMemory, Unknown } error SetVarFailed { code: int } export fn get (key: string) -> string?; export fn set (key: string, value: string) -> SetVarFailed?; export fn cwd () -> string?; export fn homedir () -> string?; export fn tempdir () -> string; // Working-directory helpers that query the OS (not the environment). export fn getcurrentdir () -> std::process::GetCwdResult; export fn setcurrentdir (path: string) -> std::process::ChdirFailed?; get std::env::get(key) returns: Some(value) when the variable exists, otherwise None. The returned string is a view into the underlying runtime environment storage. It does not copy. On POSIX, get does not allocate. On WASI, get may allocate once on first use to cache an environment snapshot (WASI requires caller-provided buffers for environget). Callers should treat the view as valid only until the environment is mutated (for example by calling std::env::set). On WASI Preview 1, environment mutation is not supported by the runtime, so values returned by get remain valid for the process lifetime. Example: import std::env; import { println } from \"std/io\"; fn main () -> int { let vopt = std::env::get(\"FOO\"); match (vopt) { Some(v) => println(\"FOO = {}\", v), None => println(\"FOO does not exist\"), }; return 0; } set std::env::set(key, value) updates the current process environment. Errors are reported as an optional error value (SetVarFailed?). SetVarFailed does not expose platform errno values. Use SetVarFailed.kind() to classify failures into SetVarErrorKind values. Example: import std::env; import { println } from \"std/io\"; fn main () -> int { if std::env::set(\"FOO\", \"BAR\") != None { println(\"failed to set FOO\"); return 1; } return 0; } Platform notes POSIX (default shipped stdlib): implemented via getenv(3) and setenv(3). WASI: get is implemented via WASI Preview 1 environsizesget / environget and caches the returned environment buffer for the process lifetime, set is not supported on WASI Preview 1 and always fails (returns Some(SetVarFailed{ code: ... }) with kind() == Unknown). getcurrentdir / setcurrentdir are implemented via the virtual cwd layer backing std::process::getcwd / std::process::chdir (they do not mutate $PWD). Directory helpers std::env also provides a tiny subset for common directory queries. cwd std::env::cwd() returns the current working directory as a string?. Current implementation: returns std::env::get(\"PWD\"). This is a pure environment-variable view and may be missing or stale if the process environment is not kept in sync with the real working directory. On wasm32-wasi, $PWD is often unset and does not track the virtual cwd used by std::process::chdir; prefer getcurrentdir when you need the runtime working directory. getcurrentdir std::env::getcurrentdir() returns the current working directory as an owned std::strings::String. This is an alias for std::process::getcwd() and queries the OS, not the process environment. Ownership: Callers must drop the returned String when finished. setcurrentdir std::env::setcurrentdir(path) changes the current working directory. This is an alias for std::process::chdir(path). homedir std::env::homedir() returns the user\u2019s home directory as a string?. Current implementation: returns std::env::get(\"HOME\"). tempdir std::env::tempdir() returns a temporary-directory path as a string. Current implementation: 1. uses TMPDIR when set, 2. otherwise uses TMP or TEMP when set, 3. otherwise returns \"/tmp\"."
    },
    {
      "id": "std/flag",
      "title": "`std::flag`",
      "section": "std",
      "summary": "line argument parser modeled after Go\u2019s `flag` package, but shaped to match `std::` conventions (explicit `Result(...)` errors, no leaky out-params, and a clear separation between flags, positionals, and `--` rest arguments).",
      "text": "std::flag line argument parser modeled after Go\u2019s flag package, but shaped to match std:: conventions (explicit Result(...) errors, no leaky out-params, and a clear separation between flags, positionals, and -- rest arguments). std::flag is intended for programs that use the native hosted entrypoint: fn main (argc: int, argv: u64) -> int { ... } and the current std::args::Args view. See also: Design goals Typed flags: parse bool, int, i64, u64, and string values. Typed positionals: declare and parse positional arguments (required and optional), separate from flags. rest: support -- to stop parsing flags and expose the remaining arguments as a \u201crest\u201d list for forwarding to subcommands/tools. Stable errors: return a structured FlagFailed value (no errno, no sentinel returns, no hidden error state). No hidden allocation: the parser stores only string views into the original argv bytes; it does not copy argument strings. Parsing rules Given an argv slice args[start..] (typically start = 1 to skip argv[0]): terminates flag parsing; arguments after -- are captured as rest and are never interpreted as flags. While parsing flags: tokens beginning with -- match long names (--name, --name=value), tokens beginning with - match either a long name or a declared alias (-name, -name=value, -a, -a=value), a lone - terminates flag parsing and starts positional mode (the - token itself is captured as the first positional), the first token that does not begin with - starts positional mode. While in positional mode: tokens are captured as positionals (even if they begin with -), may still appear to start rest. This matches the common \u201cflags first, then args\u201d convention and avoids misclassifying negative numbers once positional mode begins. Public API (initial) module std::flag; import std::args; import std::result; enum FlagErrorKind { ... } struct FlagFailed { code: int, argindex: int, detail: i64, } impl FlagFailed { public fn kind (self: &FlagFailed) -> FlagErrorKind; public fn argopt (self: &FlagFailed, args: &std::args::Args) -> string?; public fn arg (self: &FlagFailed, args: &std::args::Args) -> string; } struct BoolOptions { name: string, alias: string, defaultvalue: bool, usage: string } struct IntOptions { name: string, alias: string, defaultvalue: int, usage: string } struct I64Options { name: string, alias: string, defaultvalue: i64, usage: string } struct U64Options { name: string, alias: string, defaultvalue: u64, usage: string } struct StringOptions { name: string, alias: string, defaultvalue: string, usage: string } struct FlagSet { ... } struct BoolFlag { index: i64 } struct IntFlag { index: i64 } struct I64Flag { index: i64 } struct U64Flag { index: i64 } struct StringFlag { index: i64 } struct PosString { index: i64 } struct PosInt { index: i64 } struct PosI64 { index: i64 } struct PosU64 { index: i64 } struct ParsedArgs { ... } export type ParseResult = std::result::Result(ParsedArgs, FlagFailed); export type BoolFlagResult = std::result::Result(BoolFlag, FlagFailed); export type IntFlagResult = std::result::Result(IntFlag, FlagFailed); export type I64FlagResult = std::result::Result(I64Flag, FlagFailed); export type U64FlagResult = std::result::Result(U64Flag, FlagFailed); export type StringFlagResult = std::result::Result(StringFlag, FlagFailed); export type PosStringResult = std::result::Result(PosString, FlagFailed); export type PosIntResult = std::result::Result(PosInt, FlagFailed); export type PosI64Result = std::result::Result(PosI64, FlagFailed); export type PosU64Result = std::result::Result(PosU64, FlagFailed); Notes: Flag/positional \u201chandles\u201d (BoolFlag, PosString, \u2026) are small, copyable indices into the owning FlagSet. This keeps the API explicit and avoids exporting raw pointers. Handle structs have safe defaults (their index field defaults to an invalid sentinel). FlagSet.get methods treat invalid handles as \u201cmissing\u201d and return zero values (false, 0, or \"\") rather than reading out of bounds. Usage strings may be retrieved from the owning FlagSet via getflagusage(handle.index) and getpositionalusage(handle.index) when building usage/help output (or via handle.usage(fs)). ParsedArgs provides views of: all positional tokens after flags (including the -- rest segment), and raw rest tokens (after --). Typed values are retrieved from the FlagSet via the returned handles. Flag declarations prefer options structs (BoolOptions, IntOptions, ...). Options structs use defaultvalue because default is a reserved keyword. Example import std::args; import std::flag; import { println } from \"std/io\"; fn main (argc: int, argv: u64) -> int { let a = std::args::Args.init(argc, argv); let mut fs = std::flag::FlagSet.init(); let verboser = (mut fs).bool({ name: \"verbose\", alias: \"v\", defaultvalue: false, usage: \"enable verbose logging\" }); let outr = (mut fs).string({ name: \"out\", alias: \"\", defaultvalue: \"out.txt\", usage: \"output path\" }); let inputr = (mut fs).positionalstring(\"input\", \"input file\"); if verboser.iserr() { (mut fs).drop(); return 2; } if outr.iserr() { (mut fs).drop(); return 2; } if inputr.iserr() { (mut fs).drop(); return 2; } let verbose: std::flag::BoolFlag = match (verboser) { Ok(v) => v, Err() => {}, }; let out: std::flag::StringFlag = match (outr) { Ok(v) => v, Err() => {}, }; let input: std::flag::PosString = match (inputr) { Ok(v) => v, Err() => {}, }; let parsedr = (mut fs).parseargs(a, 1); match (parsedr) { Err(e) => { println(\"flag parse error: kind={} at argv[{}]: {}\", e.kind(), e.argindex, e.arg(a)); (mut fs).drop(); return 2; }, Ok(p) => { if fs.getbool(verbose) { println(\"out={}\", fs.getstring(out)); } println(\"input={}\", fs.getposstring(input)); // -- rest args (for forwarding). var i: int = 0; while i < p.restcount() { println(\"rest[{}]={}\", i, p.rest(a, i)); i += 1; } (mut fs).drop(); return 0; } } }"
    },
    {
      "id": "std/fmt",
      "title": "`std::fmt`",
      "section": "std",
      "summary": "in `std/fmt.slk` and is intentionally scoped to the current compiler/backend subset (no generics, no runtime interface dispatch).",
      "text": "std::fmt in std/fmt.slk and is intentionally scoped to the current compiler/backend subset (no generics, no runtime interface dispatch). std::fmt provides a shared, Zig-std.fmt-style format-string syntax and a small formatting engine used by std::io::print / std::io::println. See also: Format String Syntax (Zig-compatible subset) A format string is a string containing literal text and placeholders. Escaping braces {{ renders a literal { }} renders a literal } Placeholders Placeholders are written with { ... }: {} \u2014 formats the next argument (sequential). {0} \u2014 formats argument 0 (positional). {d} \u2014 formats the next argument using a specifier (here: decimal). {0x} \u2014 formats argument 0 using a specifier (here: hex lower). Placeholders may also include format options after a colon :: {:10} \u2014 width 10 (default alignment). {:>10} \u2014 width 10, right-aligned. {:=^10} \u2014 width 10, center-aligned, filled with =. {:04} \u2014 width 4, zero-padded (special case: leading 0 implies fill='0'). Precision is written after a dot: {e:.5} \u2014 scientific formatting with precision 5 (when supported by the value type). Grammar (informal) Within { ... }: optional argument selector: digits: 0, 1, 2, ... bracketed index: [0], [1], ... (reserved for future named arguments; the current implementation accepts only numeric indices) optional specifier string (examples: d, x, s, c, e) optional : followed by: optional fill + alignment: < left, ^ center, > right fill is any single byte placed immediately before the alignment character (example: ^) optional width: digits (10), or bracketed index ([1]) to take the width from another argument optional . and optional precision: digits (.3), or bracketed index (.[1]) to take the precision from another argument Current API Because the language does not yet have generics, the current API uses an explicit argument carrier type (Arg). With language-level varargs, the formatter now accepts a variable number of arguments (up to the current compiler\u2019s varargs limit). Arg std::fmt::Arg is a POD carrier used by std::io printing: Arg.missing() \u2014 missing argument placeholder. Arg.int(value: int) \u2014 signed integer argument. Arg.i128(value: i128) \u2014 signed 128-bit integer argument. Arg.u64(value: u64) \u2014 unsigned integer / pointer-sized argument. Arg.u128(value: u128) \u2014 unsigned 128-bit integer argument. Arg.f64(value: f64) \u2014 floating-point argument (both f32 and f64 coerce to this ctor). Arg.f128(value: f128) \u2014 128-bit floating-point argument. Arg.bool(value: bool) \u2014 boolean argument. Arg.char(value: char) \u2014 Unicode scalar argument (formatted as UTF-8 bytes for {c} / {u}; invalid codepoints render as U+FFFD). Arg.string(value: string) \u2014 string argument. Arg.regexp(value: regexp) \u2014 regexp argument (currently formatted as placeholder text). Arg.Region(value: Region) \u2014 region argument (currently formatted as placeholder text). Compiler convenience: the compiler supports an opt-in implicit call-argument coercion mechanism for struct types that provide exported static ctor methods (int/i128/u64/u128/f64/f128/bool/char/string/regexp/Region). std::fmt::Arg implements these ctors, so callers can pass primitives directly to std::io::print / std::io::println without explicit Arg. wrappers. Supported specifiers The current formatter supports: s \u2014 string d \u2014 decimal number (int/u64/i128/u128 and f64/f128) b \u2014 binary integer o \u2014 octal integer x \u2014 lowercase hex integer X \u2014 uppercase hex integer e \u2014 scientific f64/f128 c \u2014 Unicode scalar (char) rendered as UTF-8 bytes u \u2014 Unicode scalar (char) rendered as UTF-8 bytes any \u2014 alias for default formatting in Silk When the specifier is empty ({}), a default is chosen based on the argument kind. Zig-compat note: when a width is specified (and non-zero), signed integers include an explicit sign for non-negative values (for example \"{:4}\" formats 123 as \"+123\"). Limitation: formatting signed integers (int/i128) in non-decimal bases (b/o/x/X) requires non-negative values. Float formatting is implemented for f64 In Silk: {} / {d} format as decimal by default, with an automatic scientific fallback for very small / very large magnitudes. {e} formats in scientific notation. precision (.{N}) controls the number of digits after the decimal point (default: 6), and width/alignment apply like other formatting kinds. Hex float formatting ({x} on floats) and full debug formatting ({any} recursing through arbitrary types) remain future work. f128 formatting is implemented by converting values to f64 for formatting, so output precision is limited to f64 precision in Silk. High-Level Formatting (format) std::fmt provides a high-level convenience for producing formatted strings: import { println } from \"std/io\"; import format from \"std/fmt\"; import std::fmt; import std::strings; import std::result; type StringAllocResult = std::result::Result(std::strings::String, std::fmt::Error); fn main () -> int { const a = 1; const b = 2; let hellor: StringAllocResult = format(\"hello {}\", \"world\"); if hellor.iserr() { return 1; } let mut hello: std::strings::String = match (hellor) { StringAllocResult::Ok(v) => v, StringAllocResult::Err() => std::strings::String.empty(), }; let sumr: StringAllocResult = format(\"a + b = {}\", a + b); if sumr.iserr() { (mut hello).drop(); return 2; } let mut sum: std::strings::String = match (sumr) { StringAllocResult::Ok(v) => v, StringAllocResult::Err() => std::strings::String.empty(), }; println(\"{}\", hello.asstring()); println(\"sum of {}\", sum.asstring()); (mut sum).drop(); (mut hello).drop(); return 0; } Signature: export default fn format (fmt: string, ...args: Arg) -> std::result::Result(std::strings::String, std::fmt::Error); Notes: format is also available as a named export (import { format } from \"std/fmt\";). The returned std::strings::String is an owned, NUL-terminated string buffer. When heap-backed, it is freed on Drop (calls std::runtime::mem::free). Use String.asstring() to obtain a borrowed string view. For bounded allocations, format into caller-owned storage with formattobufferu8."
    },
    {
      "id": "std/formal",
      "title": "`std::formal`",
      "section": "std",
      "summary": "that encode common proof obligations (non-negativity, bounds checks, and basic container invariants).",
      "text": "std::formal that encode common proof obligations (non-negativity, bounds checks, and basic container invariants). These theories are intended to: de-duplicate repetitive #require / #assure clauses across the standard library, and give downstream code a small set of \u201cstandard lemmas\u201d for Z3-backed verification. theory semantics. Importing and using theories Theories are imported with named imports and applied via #theory: import { nonnegativei64, boundsi64 } from \"std/formal\"; theory nonnegativei64(len); theory boundsi64(index, len); fn getat (index: i64, len: i64) -> i64 { return index; } Initial theory set The current std::formal module exports (at minimum) the following theories: nonnegativei64(x: i64) \u2014 proves/assumes x >= 0. nonnullu64(ptr: u64) \u2014 proves/assumes ptr != 0. boundsi64(index: i64, len: i64) \u2014 proves/assumes 0 <= index < len. slicewellformed(ptr: u64, len: i64) \u2014 proves/assumes: len >= 0 len == 0 ptr != 0 vectorwellformed(ptr: u64, len: i64, cap: i64) \u2014 proves/assumes: len >= 0 cap >= 0 len <= cap cap == 0 ptr != 0"
    },
    {
      "id": "std/filesystem",
      "title": "`std::fs`",
      "section": "std",
      "summary": "filesystem API backed by `std::runtime::fs`. It exposes a low-level `File` handle and byte-oriented I/O primitives, staying within the current compiler\u2019s feature set.",
      "text": "std::fs filesystem API backed by std::runtime::fs. It exposes a low-level File handle and byte-oriented I/O primitives, staying within the current compiler\u2019s feature set. The public std::fs surface does not expose POSIX errno. Runtime-specific details live under std::runtime. See also: Platform notes Hosted baseline (linux/x8664): std::runtime::fs delegates to std::runtime::posix::fs and uses POSIX syscalls. wasm32-wasi: std::runtime::fs is backed by std::runtime::wasi::fs and requires the embedder to provide at least one preopened directory. Paths are interpreted as relative to the first preopened directory found via fdprestatget (sandbox root): absolute paths (/foo/bar) are interpreted relative to the sandbox root, relative paths (foo/bar) are resolved against a virtual working directory managed by std::process::chdir / std::process::getcwd, . and .. segments are normalized; .. cannot escape above the sandbox root. API A hosted POSIX baseline exists today in std/fs.slk. The low-level OS bindings are provided via std::runtime::fs (which defaults to a POSIX implementation in the shipped stdlib). module std::fs; export fn exists (path: string) -> bool; export fn canread (path: string) -> bool; export fn canwrite (path: string) -> bool; export fn canexec (path: string) -> bool; enum FSErrorKind { OutOfMemory, NotFound, PermissionDenied, AlreadyExists, NotADirectory, IsADirectory, InvalidInput, UnexpectedEof, Unknown, } struct FSFailed { code: int, requested: i64, } impl FSFailed { public fn kind (self: &FSFailed) -> FSErrorKind; } export type FSError = FSFailed; export type FSIntResult = std::result::Result(int, FSFailed); export type FSI64Result = std::result::Result(i64, FSFailed); export type FSErrorIntResult = std::result::Result(int, FSError); export type FSBufferU8Result = std::result::Result(std::buffer::BufferU8, FSError); export type FSStringResult = std::result::Result(std::strings::String, FSError); struct OpenOptions { read: bool, write: bool, create: bool, truncate: bool, append: bool, mode: int, } impl OpenOptions { public fn readonly () -> OpenOptions; public fn writeonly () -> OpenOptions; public fn readwrite () -> OpenOptions; public fn createtruncate (mode: int) -> OpenOptions; public fn createappend (mode: int) -> OpenOptions; } enum SeekWhence { Start, Current, End, } // A file descriptor wrapper. struct File { fd: int, } export type FileResult = std::result::Result(File, FSFailed); impl File { // Construct an invalid/closed file handle (fd = -1). public fn invalid () -> File; // Open a file (portable options, hosted baseline implementation). public fn open (path: string, opts: OpenOptions) -> FileResult; public fn openread (path: string) -> FileResult; public fn openwrite (path: string) -> FileResult; public fn create (path: string, mode: int) -> FileResult; public fn append (path: string, mode: int) -> FileResult; public fn isvalid (self: &File) -> bool; public fn close (mut self: &File) -> FSFailed?; // Byte I/O (hosted baseline). public fn read (self: &File, buf: std::arrays::ByteSlice) -> FSIntResult; public fn readexact (self: &File, buf: std::arrays::ByteSlice) -> FSFailed?; public fn write (self: &File, buf: std::arrays::ByteSlice) -> FSIntResult; public fn seek (self: &File, offset: i64, whence: SeekWhence) -> FSI64Result; public fn tell (self: &File) -> FSI64Result; public fn size (self: &File) -> FSI64Result; public fn sync (self: &File) -> FSFailed?; public fn truncate (self: &File, len: i64) -> FSFailed?; // Convenience helpers. public fn readtoend (self: &File, mut out: &std::buffer::BufferU8) -> FSErrorIntResult; public fn writeall (self: &File, buf: std::arrays::ByteSlice) -> FSFailed?; } // Files are closed on scope exit and on overwrite. impl File as std::interfaces::Drop { public fn drop (mut self: &File) -> void; } // Convenience helpers for common whole-file operations. export fn readfile (path: string) -> FSBufferU8Result; export fn readfilestring (path: string) -> FSStringResult; export fn writefile (path: string, buf: std::arrays::ByteSlice, mode: int) -> FSIntResult; export fn appendfile (path: string, buf: std::arrays::ByteSlice, mode: int) -> FSIntResult; export fn writefilestring (path: string, contents: string, mode: int) -> FSIntResult; export fn appendfilestring (path: string, contents: string, mode: int) -> FSIntResult; export fn copyfile (src: string, dst: string, mode: int) -> FSErrorIntResult; // Path-based helpers (None on success). export fn unlink (path: string) -> FSFailed?; export fn rename (oldpath: string, newpath: string) -> FSFailed?; export fn mkdir (path: string, mode: int) -> FSFailed?; export fn rmdir (path: string) -> FSFailed?; export fn mkdirall (path: string, mode: int) -> FSError?; Notes: These functions call POSIX/libc access(2) via ext. Executable outputs import external libc symbols. On linux/x8664 with the glibc dynamic loader (ld-linux), silk automatically adds libc.so.6 as a DTNEEDED dependency when external symbols are present, so --needed libc.so.6 is not required for typical std::fs use. This applies to other std::fs POSIX bindings as well (open(2), read(2), close(2), etc.). std::fs maps runtime failures into a portable FSErrorKind set; the raw platform error mechanism (for example POSIX errno) is not part of the public API. The mapping from the platform mechanism into stable FSFailed.code values is performed by std::runtime::fs. mkdirall is a convenience helper for mkdir -p behavior. In the current hosted subset it treats EEXIST as success and does not distinguish an existing directory from an existing non-directory at the same path. Scope std::fs is responsible for: File and directory creation, deletion, and enumeration. Basic metadata operations. , std::fs APIs still accept raw string paths. Hosted baseline: POSIX paths are treated as opaque byte sequences (not necessarily UTF-8). APIs that accept string paths must specify encoding behavior. The initial baseline assumes UTF-8 on POSIX but does not require it for all operations. Core Types (Initial Design) Path / PathBuf for path manipulation (borrowed vs owned). File for open file handles. Dir / directory iteration. Metadata for stat-like information. Illustrative sketch: module std::fs; export enum FsError { NotFound, PermissionDenied, AlreadyExists, NotADirectory, IsADirectory, InvalidPath, Unknown, } export struct OpenOptions { read: bool, write: bool, create: bool, truncate: bool, } export fn open (path: string, opts: OpenOptions) -> Result(File, FsError); export fn readtostring (alloc: std::memory::Allocator, path: string) -> Result(std::strings::String, FsError); Future Work Symlink support and canonicalization. File watching (platform-dependent)."
    },
    {
      "id": "std/ggml",
      "title": "`std::ggml`",
      "section": "std",
      "summary": "`std::ggml` exposes the ggml tensor library to Silk programs. The long-term goal is to make ggml the standard tensor backend for Silk\u2019s ML-oriented standard library surface.",
      "text": "std::ggml std::ggml exposes the ggml tensor library to Silk programs. The long-term goal is to make ggml the standard tensor backend for Silk\u2019s ML-oriented standard library surface. Upstream: Repository: ggml-org/ggml Pinned version: v0.9.5 Goals Provide a safe, Silk-native wrapper layer over the ggml C API. Keep raw access available for power users (with explicit unsafe/pointer APIs). Make building/linking predictable by treating ggml as a core vendored dependency (similar to libsodium/mbedTLS/libssh2/sqlite in the hosted baseline). ABI / FFI Notes The current Silk backend subset uses a scalar-slot memory model for structs ext), passing C structs by value is only ABI-safe when the struct\u2019s flattened slots are all i64/u64/f64. For FFI with upstream C APIs, note that Silk\u2019s int currently maps to i64 on linux/x8664. The std::ggml bindings therefore use i32 for ggml\u2019s C int/enum values (type codes, status values, indices, and thread counts) to match the upstream ABI. ggml includes several C entrypoints that accept small structs by value (notably ggmlinit(struct ggmlinitparams)), where the C layout includes bool and sizet. This is not ABI-safe to call directly from Silk in Silk. Therefore, std::ggml uses a tiny C shim layer (built as part of the toolchain) to expose ABI-safe wrapper functions for the few by-value-struct APIs. Build + Dependency Workflow zig build deps is responsible for fetching/building ggml and staging: headers into vendor/include/ (for shim compilation), static archives into vendor/lib/x64-linux/ (for linking), On linux/x8664, silk build automatically links the staged ggml archives when std::ggml is included in the module set. If the archives are missing, the build fails with an actionable error pointing to zig build deps. When linking .o / .a inputs, silk build also auto-links ggml if any input references silkggmlinit (for example, when a prebuilt static library was produced from Silk code that uses std::ggml). This keeps downstream consumers from needing to import std::ggml purely to satisfy link/runtime dependencies. The current auto-linked archives are: libggml.a, libggml-base.a, libggml-cpu.a, and libsilkggmlshims.a. Because ggml is built as C++ on the hosted baseline, the produced executables and shared libraries also depend on the system C++ runtime (libstdc++) and math library (libm); silk build adds these as DTNEEDED entries when it auto-links ggml. Intended Surface (Initial) The initial surface is intentionally small: create/free a ggml context, create basic tensors, compute a graph, basic tensor inspection helpers. The module is expected to grow incrementally as we map more of the upstream API into a stable Silk wrapper layer."
    },
    {
      "id": "std/http",
      "title": "`std::http`",
      "section": "std",
      "summary": "HTTP/1.1 request/response parsing and a small blocking client/server connection API on top of `std::net::TcpStream`.",
      "text": "std::http HTTP/1.1 request/response parsing and a small blocking client/server connection API on top of std::net::TcpStream. See also: RFC 7230 / RFC 7231 (HTTP/1.1 message syntax and semantics) Scope (Current) HTTP/1.1 request line and response status line parsing. Case-insensitive header scanning (header(name)). Body handling via Content-Length (read/write). Blocking I/O over std::net::TcpStream. Not implemented (yet): Chunked transfer encoding (Transfer-Encoding: chunked). HTTP/2 or HTTP/3. Streaming bodies (incremental read/write APIs). Automatic decompression, redirects, cookies, proxies, etc. Public API module std::http; import std::net; import std::result; import std::strings; export let DEFAULTMAXHEADERBYTES: i64 = 16384; // Errors use a small set of integer kind codes. export let ERRIO: int = 1; export let ERRTOOLARGE: int = 2; export let ERRBADMESSAGE: int = 3; export let ERRUNSUPPORTEDTRANSFERENCODING: int = 4; export let ERRBADCONTENTLENGTH: int = 5; export let ERROUTOFMEMORY: int = 6; export error Error { kind: int, } // Parsed HTTP request backed by owned bytes. struct Request { / opaque / } export type RequestResult = std::result::Result(Request, Error); impl Request { public fn parse (input: string) -> RequestResult; public fn method (self: &Request) -> string; public fn target (self: &Request) -> string; public fn version (self: &Request) -> string; public fn header (self: &Request, name: string) -> string?; public fn body (self: &Request) -> string; } // Parsed HTTP response backed by owned bytes. struct Response { / opaque / } export type ResponseResult = std::result::Result(Response, Error); impl Response { public fn parse (input: string) -> ResponseResult; public fn version (self: &Response) -> string; public fn statuscode (self: &Response) -> int; public fn reason (self: &Response) -> string; public fn header (self: &Response, name: string) -> string?; public fn body (self: &Response) -> string; } // A blocking connection wrapper that can read/write one message at a time. struct Connection { / opaque / } impl Connection { public fn fromstream (stream: std::net::TcpStream) -> Connection; public fn isvalid (self: &Connection) -> bool; public fn close (mut self: &Connection) -> Error?; // Client helpers. public fn writerequest (self: &Connection, method: string, target: string, host: string, body: string) -> Error?; public fn readresponse (mut self: &Connection) -> ResponseResult; // Server helpers. public fn readrequest (mut self: &Connection) -> RequestResult; public fn writeresponse (self: &Connection, status: int, reason: string, body: string) -> Error?; } Notes: This API is currently blocking and uses Connection: close by default. Parsed messages own their backing bytes and return borrowed string views into those bytes; the returned views are valid until the message is dropped. Example (Client) import std::http; import std::net; fn trap (T;) -> T { std::abort(); } export fn main () -> int { // Plain HTTP to a loopback server (no DNS in the current stdlib). let addr = net::SocketAddrV4.loopback(8080); let streamr = net::TcpStream.connect(addr); if streamr.iserr() { return 1; } let stream: net::TcpStream = match (streamr) { net::TcpStreamResult::Ok(v) => v, net::TcpStreamResult::Err() => trap(net::TcpStream;), }; let mut conn = http::Connection.fromstream(stream); let werr: http::Error? = conn.writerequest(\"GET\", \"/\", \"localhost\", \"\"); if werr != None { (mut conn).close(); return 2; } let respr = (mut conn).readresponse(); if respr.iserr() { (mut conn).close(); return 3; } let resp: http::Response = match (respr) { http::ResponseResult::Ok(v) => v, http::ResponseResult::Err() => trap(http::Response;), }; = resp.statuscode(); (mut conn).close(); return 0; } Validation Rules Content-Length must parse as a non-negative decimal value. When Transfer-Encoding is present and not equal to \"identity\", parsing fails with ERRUNSUPPORTEDTRANSFERENCODING. Request/response header blocks are limited by DEFAULTMAXHEADERBYTES (and per-connection configuration where applicable)."
    },
    {
      "id": "std/https",
      "title": "`std::https`",
      "section": "std",
      "summary": "small HTTPS client/server connection API on top of `std::tls` (mbedTLS) and `std::net::TcpStream`.",
      "text": "std::https small HTTPS client/server connection API on top of std::tls (mbedTLS) and std::net::TcpStream. See also: RFC 2818 (HTTP over TLS) Scope (Current) Blocking TLS handshake using std::tls::Session. HTTPS request/response I/O using the same message model as std::http. Not implemented (yet): Certificate verification (CA store), hostname verification, and SNI/ALPN configuration beyond current defaults. Non-blocking integration with an async runtime. Public API module std::https; import std::http; import std::net; import std::result; export let ERRCONNECT: int = 1; export let ERRTLS: int = 2; export let ERRIO: int = 3; export let ERRHTTP: int = 4; export let ERROUTOFMEMORY: int = 5; export error Error { kind: int, } struct Connection { / opaque / } export type ConnectionResult = std::result::Result(Connection, Error); impl Connection { // Establish TCP, then perform a TLS client handshake. public fn connect (addr: std::net::SocketAddrV4) -> ConnectionResult; public fn isvalid (self: &Connection) -> bool; public fn close (mut self: &Connection) -> Error?; public fn writerequest (self: &Connection, method: string, target: string, host: string, body: string) -> Error?; public fn readrequest (mut self: &Connection) -> http::RequestResult; public fn writeresponse (self: &Connection, status: int, reason: string, body: string) -> Error?; public fn readresponse (mut self: &Connection) -> http::ResponseResult; } struct Server { / opaque / } export type ServerResult = std::result::Result(Server, Error); impl Server { // Listen on TCP, accept, then perform a TLS server handshake with the provided // certificate and private key (PEM). public fn listen (addr: std::net::SocketAddrV4, backlog: int, certpem: string, keypem: string) -> ServerResult; public fn isvalid (self: &Server) -> bool; public fn localport (self: &Server) -> std::net::NetIntResult; public fn accept (mut self: &Server) -> ConnectionResult; public fn close (mut self: &Server) -> Error?; } Notes: This API is blocking and intended for the hosted POSIX baseline. For now, TLS configuration uses current defaults and does not verify certificates; this will be tightened as std::tls grows."
    },
    {
      "id": "std/interfaces",
      "title": "`std::interfaces`",
      "section": "std",
      "summary": "non-generic standard-library interfaces (\u201cprotocols\u201d) that can be used today to express common capabilities across `std::` types.",
      "text": "std::interfaces non-generic standard-library interfaces (\u201cprotocols\u201d) that can be used today to express common capabilities across std:: types. Dynamic interface dispatch (trait objects / vtables) is part of the language design, but is not implemented yet. in Silk, interfaces are used for: declaring interface contracts, and compile-time conformance checking via impl Type as Interface { ... }. one compiler-backed convention: std::interfaces::Drop is used for automatic cleanup of values at well-defined points (see \u201cDrop semantics\u201d below). See also: API std/interfaces.slk currently defines the following interfaces: module std::interfaces; interface Drop { fn drop () -> void; } interface Len { fn len () -> i64; } interface Capacity { fn capacity () -> i64; } interface IsEmpty { fn isempty () -> bool; } interface Sized { fn size () -> usize; } interface Clear { fn clear () -> void; } interface ReserveAdditional { fn reserveadditional (additional: i64) -> std::memory::OutOfMemory?; } interface WriteU8 { fn writeu8 (value: u8) -> std::memory::OutOfMemory?; } interface ReadU8 { fn readu8 () -> u8?; } interface Iterator(T) { fn next () -> T?; } interface Serialize(S = string) { fn serialize () -> S; } interface Deserialize(S = string) { fn deserialize (value: S) -> Self; } Notes: Most of these interfaces intentionally avoid generics; they are meant to be usable within the . Serialize and Deserialize are generic, but default their representation type parameter to string so the common case does not require explicit type arguments. ReserveAdditional and WriteU8 return std::memory::OutOfMemory? so allocation-backed types can report allocation failure as a recoverable value instead of trapping. Iterator(T) is modeled after Rust\u2019s Iterator and represents a sequential producer of values. Implementations typically use a receiver of the form public fn next (mut self: &Type) -> T?, so calling next requires an explicit mutable borrow at the call site: (mut it).next(). for x in it { ... } can also be used when it.next() -> T?; the loop evaluates the iterator expression once and calls next() repeatedly until Most interfaces use an implicit receiver: the interface method signature omits self, and the corresponding impl method includes self as its Exception: Deserialize(S) is a static protocol used by as casts; its impl method does not take a self receiver and is called as Type.deserialize(value). Planned: Sized will be used by the sizeof operator for value operands: when a concrete type provides fn size(self: &T) -> usize, sizeof value Serialize is also recognized by the as cast operator: when a type provides serialize(self: &T) -> S, an explicit cast Deserialize is also recognized by the as cast operator: when a type provides deserialize(value: S) -> Self, an explicit cast Drop semantics std::interfaces::Drop is recognized by the compiler as the standard way for a type to release resources it owns (file descriptors, heap allocations, OS handles, etc.). A type is considered \u201cdroppable\u201d when it provides a method with this surface signature: impl T as std::interfaces::Drop { public fn drop (mut self: &T) -> void { ... } } Automatic invocation : Scope exit: when a struct value binding goes out of scope (including via fallthrough, break, and continue), the compiler calls drop before the storage is discarded. Return: on return, the compiler drops all in-scope droppable bindings except any value moved into the return result (for example return value; and return Some(value); treat value as moved in Silk). Overwrite: when a struct value binding is overwritten via assignment, the compiler calls drop on the old value before copying in the new value. Heap last-release: for compiler-managed new allocations (&T with RC), the compiler calls drop before freeing the backing allocation when the refcount reaches zero. Notes and limitations: drop is resolved statically (no dynamic dispatch). drop should invalidate the value so calling it multiple times is safe. The language does not yet implement a general move/ownership model; do not rely on copying Drop types to be safe until move/copy semantics are specified and enforced. cleanup is performed. Example (Conformance) import std::interfaces; struct Counter { value: i64, } impl Counter as std::interfaces::Len { public fn len (self: &Counter) -> i64 { return self.value; } }"
    },
    {
      "id": "std/io",
      "title": "`std::io`",
      "section": "std",
      "summary": "are implemented in `std/io.slk` via `std::runtime::io`; buffered and async I/O remain future work.",
      "text": "std::io are implemented in std/io.slk via std::runtime::io; buffered and async I/O remain future work. std::io provides console and basic stream I/O. Hosted baseline: POSIX file descriptors and blocking I/O. Future extensions may include async integration. See also: Current API The current stdlib provides basic unbuffered stdio primitives (stdin reads and stdout/stderr writes), plus a small formatting surface (implemented without libc varargs; formatted bytes are written via std::runtime::io::write): module std::io; enum IOErrorKind { OutOfMemory, BadFileDescriptor, NotFound, PermissionDenied, WouldBlock, Interrupted, BrokenPipe, InvalidInput, Unknown, } struct IOFailed { code: int, requested: i64 } export type IOResult = std::result::Result(int, IOFailed); export type IOError = IOFailed; export type IOErrorIntResult = std::result::Result(int, IOError); export fn read (fd: int, buf: std::arrays::ByteSlice) -> IOResult; export fn write (fd: int, buf: std::arrays::ByteSlice) -> IOResult; export fn writeall (fd: int, buf: std::arrays::ByteSlice) -> IOFailed?; export fn readtoend (fd: int, mut out: &std::buffer::BufferU8) -> IOErrorIntResult; export fn readstdin (buf: std::arrays::ByteSlice) -> IOResult; export fn writestdout (buf: std::arrays::ByteSlice) -> IOResult; export fn writestderr (buf: std::arrays::ByteSlice) -> IOResult; export fn puts (s: string) -> IOFailed?; export fn print (fmt: string, ...args: std::fmt::Arg) -> PrintFailed?; export fn println (fmt: string, ...args: std::fmt::Arg) -> PrintFailed?; export fn eprint (fmt: string, ...args: std::fmt::Arg) -> PrintFailed?; export fn eprintln (fmt: string, ...args: std::fmt::Arg) -> PrintFailed?; Notes: print/println accept Zig-std.fmt-style format strings (see the current compiler\u2019s varargs limit). eprint/eprintln are the stderr equivalents of print/println. IOFailed.code is a stable stdlib error code; callers should prefer IOFailed.kind(). Invalid buffer arguments report IOErrorKind::InvalidInput. readtoend returns IOErrorIntResult (Ok(totalbytes) or Err(IOFailed)), where allocation failure is reported as IOErrorKind::OutOfMemory and IOFailed.requested. For ergonomics, std::fmt::Arg opts into the compiler\u2019s implicit passing primitive values (int/fixed-width ints, usize/size, f32/f64, bool, char, string, regexp, Region) directly when calling functions that expect Arg parameters (including varargs), so you can write println(\"hello {}\", \"world\") without explicit Arg. wrappers. Executable outputs import external libc symbols. On linux/x8664 with the glibc dynamic loader (ld-linux), silk automatically adds libc.so.6 as a DTNEEDED dependency when external symbols are present, so --needed libc.so.6 is not required for typical hosted std::io use. string parameters in ext calls are lowered as C-string pointers in the current backend subset (the backing bytes include a trailing NUL terminator; Silk string length excludes it). Example (formatted printing): import std::io; fn main () -> int { std::io::println(\"hello {s} answer={d}\", \"world\", 42); return 0; } Example (stdin \u2192 stdout echo using unbuffered reads/writes): import std::io; import std::arrays; import std::runtime::io; import std::runtime::mem; fn main () -> int { let buf: u64 = std::runtime::mem::alloc(64); if buf == 0 { return 2; } while true { let r: std::io::IOResult = std::io::readstdin(std::arrays::ByteSlice{ ptr: buf, len: 64 }); if r.iserr() { std::runtime::mem::free(buf); return 3; } let n: int = match (r) { std::io::IOResult::Ok(v) => v, std::io::IOResult::Err() => 0, }; if n == 0 { break; } let werr: std::io::IOFailed? = std::io::writeall(std::runtime::io::STDOUTFD, std::arrays::ByteSlice{ ptr: buf, len: n as i64 }); if werr != None { std::runtime::mem::free(buf); return 4; } } std::runtime::mem::free(buf); return 0; } Scope std::io is responsible for: Standard input, output, and error streams. Simple printing and formatted output APIs. Core Interfaces (Initial Design) The stdlib should standardize reader/writer interfaces: module std::io; export enum IOErrorKind { // Stable error kinds (portable subset). PermissionDenied, NotFound, BrokenPipe, WouldBlock, UnexpectedEof, Unknown, } export interface Writer { write: fn(self: &Writer, bytes: std::arrays::Slice(u8)) -> Result(int, IOErrorKind); flush: fn(self: &Writer) -> IOErrorKind?; } export interface Reader { read: fn(self: &Reader, dst: std::arrays::Slice(u8)) -> Result(int, IOErrorKind); } The concrete representation of interfaces will evolve with the language; the key point is that std::fs and std::net can reuse the same I/O traits. Convenience API stdout/stderr: print/println and eprint/eprintln (formatted output). unbuffered primitives: readstdin, writestdout, writestderr. future (design): stdout() / stderr() / stdin() handle-returning helpers built on a stable reader/writer interface. Future Work Buffered I/O wrappers (BufReader, BufWriter). Async-aware adapters once the async runtime (event loop + coroutine lowering) is implemented; std::task exists today but provides only blocking helpers."
    },
    {
      "id": "std/json",
      "title": "`std::json`",
      "section": "std",
      "summary": "stringifier suitable for Silk programs.",
      "text": "std::json stringifier suitable for Silk programs. Primary goals: Correct, spec-driven parsing of RFC 8259 JSON (objects, arrays, strings, numbers, booleans, null). A memory model that works well with the compiler: parse produces an index-based DOM stored inside a Document, arrays/objects use integer \u201cnext\u201d links (no &T struct fields). High performance by default: borrowed parsing avoids allocating for unescaped strings and numbers by slicing into the input string, strings are only allocated when they contain escapes that must be decoded. Deterministic output: compact stringify and configurable stringifypretty. Data Model The DOM is represented by an index table owned by a Document: A Document owns: node tables (tag, payload fields, sibling links), optional owned allocations for decoded strings and owned-number lexemes. JSON values are referred to by ValueId (an i64 node index). In Silk, struct fields do not support reference types (&T / &T?) and std::vector::Vector(T) is scalar-slot-oriented (raw-cast storage). std::json therefore stores its DOM as scalar tables and uses index links for arrays/objects. Arrays and Objects Arrays store a firstchild id and each element node stores a next id. Objects store a firstmember id and each member node stores: a key string view, a value ValueId, a next member id. Strings Parsed string values are exposed as decoded UTF-8 string views: when the source contains no escapes, the string is borrowed from the input (zero-copy), when the source contains escapes, the decoded bytes are stored in an owned allocation tracked by the Document and the view points to that allocation. Supported escapes: \\\\, \\\", \\/, \\b, \\f, \\n, \\r, \\t \\uXXXX (including surrogate pairs). Numbers std::json preserves the number lexeme (as a string view) and also provides helpers to interpret it as i64 and/or f64 when needed. Parsing Two parse modes are provided as Document methods: Borrowed: doc.parse(s) borrows unescaped strings and number lexemes from s. The caller must ensure s outlives any string views read from doc. Owned: doc.parseowned(s) copies all strings and number lexemes into allocations tracked by doc (independent of s). Both methods: clear the Document first, return ParseResult (Ok(root) on success, Err(ParseError) on error), and record the result on the Document: doc.isok() reports success, doc.rootvalue() returns the root ValueId on success, doc.err contains the parse error details (kind, byte offset, and 1-based line/column). Allocation failures are also reported as ordinary parse errors: on out-of-memory, parse returns Err(ParseError{ kind: ERROUTOFMEMORY, ... }) and sets doc.err.kind to ERROUTOFMEMORY. In Silk, Document is typically used as a heap reference: import std::json; let mut doc: &Document = new Document(); let rootr: std::json::ParseResult = (mut doc).parse({\"a\":1}); Stringifying stringify(doc, value) returns Result(String, OutOfMemory) containing compact JSON. stringifypretty(doc, value, indent) returns Result(String, OutOfMemory) containing pretty-printed JSON with a fixed number of spaces per indent level. streaming tokenization (SAX-style) for very large inputs, a writer interface that can stream output without building a whole string, JSON Pointer helpers (RFC 6901) for querying nested values."
    },
    {
      "id": "std/limits",
      "title": "`std::limits`",
      "section": "std",
      "summary": "This module provides shared numeric limits for Silk primitive types.",
      "text": "std::limits This module provides shared numeric limits for Silk primitive types. The initial surface is intentionally small and focuses on min/max bounds for fixed-width integer primitives (useful for validating conversions and host APIs that cap sizes to a particular width, such as i32). API module std::limits; export const I8MIN: i8; export const I8MAX: i8; export const U8MAX: u8; export const I16MIN: i16; export const I16MAX: i16; export const U16MAX: u16; export const I32MIN: i32; export const I32MAX: i32; export const U32MAX: u32; export const I64MIN: i64; export const I64MAX: i64; export const U64MAX: u64; export const I128MIN: i128; export const I128MAX: i128; export const U128MAX: u128; export const INTMIN: int; export const INTMAX: int; Example Validating that a host-facing length fits in i32: import std::limits; fn validatelen (len: i64) -> bool { return len >= 0 && len <= (std::limits::I32MAX as i64); }"
    },
    {
      "id": "std/map",
      "title": "`std::map` \u2014 Maps and Dictionaries",
      "section": "std",
      "summary": "`std::map` provides the standard associative container surfaces:",
      "text": "std::map \u2014 Maps and Dictionaries std::map provides the standard associative container surfaces: HashMap(K, V) \u2014 an unordered map backed by a hash table. TreeMap(K, V) \u2014 an ordered map backed by a red-black tree. targets the compiler and will grow as the language gains first-class move/Drop semantics for values stored inside heap-backed data structures. Design Goals Provide a consistent, ergonomic key\u2192value container story in std:: without relying on a builtin map(K, V) type form. Make allocation behavior explicit and compatible with regions (with) and noheap. Keep the API close in spirit to C++\u2019s std::unorderedmap and std::map (operations, complexity expectations, and terminology), adapted to Silk. Important Limitations In Silk: HashMap(K, V) and TreeMap(K, V) store keys and values by value, but do not automatically run Drop for stored keys/values when entries are overwritten or removed. HashMap(K, V) stores keys and values in the compiler\u2019s scalar-slot layout (sizeof(K) / sizeof(V) bytes, multiples of 8 in the current subset). This supports multi-slot value types such as string and non-opaque structs/enums over supported primitives. TreeMap(K, V) is still limited by its current node layout and, for now, should be treated as single-slot storage (keys/values that lower to a single u64 slot). These containers are intended for \u201cplain\u201d value types: primitive scalars, string views, and small POD structs over those primitives. Avoid storing refcounted &Struct heap references or owned Drop-managed structs (for example std::strings::String) as keys/values until the compiler has complete Drop integration for values stored inside container memory. These limits are expected to be relaxed as the compiler grows a complete memory model for container element drops. HashMap (HashMap(K, V)) Construction HashMap requires user-supplied hashing and equality functions (similar to the custom Hash and KeyEqual types of C++ std::unorderedmap): import std::map; import std::result; import std::memory; type Map = std::map::HashMap(u64, int); type InitResult = std::result::Result(Map, std::memory::AllocFailed); fn hashu64 (k: u64) -> u64 { return k; } fn equ64 (a: u64, b: u64) -> bool { return a == b; } fn main () -> int { let initr: InitResult = Map.init(16, hashu64, equ64); if initr.iserr() { return 1; } let mut m: Map = match (initr) { InitResult::Ok(v) => v, InitResult::Err() => Map.empty(hashu64, equ64), }; let putr = (mut m).put(1, 10); if putr.iserr() { (mut m).drop(); return 2; } let v: int = m.get(1) ?? 0; (mut m).drop(); return v; } HashMap.init(cap, ...) validates the requested capacity: cap < 0 returns AllocErrorKind::InvalidInput. very large cap values that would overflow internal sizing arithmetic return AllocErrorKind::Overflow. Core API HashMap(K, V) provides: fn empty (hash: fn(K) -> u64, eq: fn(K, K) -> bool) -> HashMap(K, V); fn init (cap: i64, hash: fn(K) -> u64, eq: fn(K, K) -> bool) -> std::result::Result(HashMap(K, V), std::memory::AllocFailed); fn len (self: &HashMap(K, V)) -> i64; fn isempty (self: &HashMap(K, V)) -> bool; fn capacity (self: &HashMap(K, V)) -> i64; fn containskey (self: &HashMap(K, V), key: K) -> bool; fn get (self: &HashMap(K, V), key: K) -> V?; fn put (mut self: &HashMap(K, V), key: K, value: V) -> std::result::Result(V?, std::memory::OutOfMemory); Inserts or replaces and returns the previous value, if present. fn remove (mut self: &HashMap(K, V), key: K) -> V?; fn iter (self: &HashMap(K, V)) -> HashMapIter(K, V); fn clear (mut self: &HashMap(K, V)) -> void; fn reserveadditional (mut self: &HashMap(K, V), additional: i64) -> std::memory::OutOfMemory?; fn drop (mut self: &HashMap(K, V)) -> void; Releases the table backing memory. Complexity expectations: average O(1) for get/put/remove when the hash distribution is good, worst case O(n) in adversarial collision patterns. TreeMap (TreeMap(K, V)) TreeMap is an ordered map. It requires an ordering function. Core API TreeMap(K, V) provides: fn init (cmp: fn(K, K) -> int) -> TreeMap(K, V); Contract: cmp(a, b) < 0 iff a < b; cmp(a, b) == 0 iff keys are equal. fn len (self: &TreeMap(K, V)) -> i64; fn isempty (self: &TreeMap(K, V)) -> bool; fn containskey (self: &TreeMap(K, V), key: K) -> bool; fn get (self: &TreeMap(K, V), key: K) -> V?; fn put (mut self: &TreeMap(K, V), key: K, value: V) -> std::result::Result(V?, std::memory::OutOfMemory); fn remove (mut self: &TreeMap(K, V), key: K) -> V?; fn iter (self: &TreeMap(K, V)) -> TreeMapIter(K, V); fn clear (mut self: &TreeMap(K, V)) -> void; fn drop (mut self: &TreeMap(K, V)) -> void; Complexity expectations: O(log n) lookup/insert/remove. Iteration Both maps provide iteration through an iterator interface: HashMapIter(K, V) implements std::interfaces::Iterator(Entry(K, V)). TreeMapIter(K, V) implements std::interfaces::Iterator(Entry(K, V)). The produced item type is: struct Entry(K, V) { key: K, value: V, } Notes: Iteration is by value (copies out key and value). HashMap iteration order is unspecified. TreeMap iteration yields entries in ascending key order (as defined by cmp)."
    },
    {
      "id": "std/math",
      "title": "`std::math`",
      "section": "std",
      "summary": "algebra utilities intended for graphics and general-purpose computation.",
      "text": "std::math algebra utilities intended for graphics and general-purpose computation. The initial focus is: vectors and matrices (fixed-size and dynamic-dimension), predictable, SIMD-friendly layouts (contiguous storage for dynamic forms), safe shape-checking APIs for dynamic operations. Longer-term, std::math will also grow: fast SIMD implementations for hot operations, trig and transcendental functions (sin/cos/exp/log), higher-precision scalar support (f128, u128) for advanced numeric work and future tensor integration. The primitives are part of the supported native backend subset; std::math will add f128-based surfaces incrementally as needed. See also: Module Structure std::math (this file) is the user-facing entrypoint. std::math::vector contains vector types and operations. std::math::matrix contains matrix types and operations. Error Model Dynamic-dimension operations return Result(T, MathFailed) when shapes are incompatible (for example adding vectors of different lengths). Current API (Initial Subset) module std::math; import std::math::vector; import std::math::matrix; // Re-export core types for ergonomic imports. export type Vec2f = std::math::vector::Vec2f; export type Vec3f = std::math::vector::Vec3f; export type Vec4f = std::math::vector::Vec4f; export type Vec2d = std::math::vector::Vec2d; export type Vec3d = std::math::vector::Vec3d; export type Vec4d = std::math::vector::Vec4d; export type VectorF32 = std::math::vector::VectorF32; export type VectorF64 = std::math::vector::VectorF64; export type Mat2f = std::math::matrix::Mat2f; export type Mat3f = std::math::matrix::Mat3f; export type Mat4f = std::math::matrix::Mat4f; export type Mat2d = std::math::matrix::Mat2d; export type Mat3d = std::math::matrix::Mat3d; export type Mat4d = std::math::matrix::Mat4d; export type MatrixF32 = std::math::matrix::MatrixF32; export type MatrixF64 = std::math::matrix::MatrixF64; export type MathError = std::math::vector::MathFailed; export type F32Result = std::math::vector::F32Result; export type F64Result = std::math::vector::F64Result; export type BoolResult = std::math::vector::BoolResult; export type VectorF32Result = std::math::vector::VectorF32Result; export type VectorF64Result = std::math::vector::VectorF64Result; export type MatrixF32Result = std::math::matrix::MatrixF32Result; export type MatrixF64Result = std::math::matrix::MatrixF64Result; std::math::vector (initial subset): module std::math::vector; import std::result; import std::vector; export enum MathErrorKind { InvalidInput, ShapeMismatch, OutOfMemory, } export error MathFailed { kind: MathErrorKind, } export struct Vec2f { x: f32, y: f32 } export struct Vec3f { x: f32, y: f32, z: f32 } export struct Vec4f { x: f32, y: f32, z: f32, w: f32 } export struct Vec2d { x: f64, y: f64 } export struct Vec3d { x: f64, y: f64, z: f64 } export struct Vec4d { x: f64, y: f64, z: f64, w: f64 } impl Vec2f { public fn add (self: &Vec2f, rhs: Vec2f) -> Vec2f; public fn sub (self: &Vec2f, rhs: Vec2f) -> Vec2f; public fn scale (self: &Vec2f, s: f32) -> Vec2f; public fn dot (self: &Vec2f, rhs: Vec2f) -> f32; public fn hadamard (self: &Vec2f, rhs: Vec2f) -> Vec2f; public fn lengthsquared (self: &Vec2f) -> f32; public fn distancesquared (self: &Vec2f, rhs: Vec2f) -> f32; public fn lerp (self: &Vec2f, rhs: Vec2f, t: f32) -> Vec2f; } impl Vec3f { public fn add (self: &Vec3f, rhs: Vec3f) -> Vec3f; public fn sub (self: &Vec3f, rhs: Vec3f) -> Vec3f; public fn scale (self: &Vec3f, s: f32) -> Vec3f; public fn dot (self: &Vec3f, rhs: Vec3f) -> f32; public fn cross (self: &Vec3f, rhs: Vec3f) -> Vec3f; public fn hadamard (self: &Vec3f, rhs: Vec3f) -> Vec3f; public fn lengthsquared (self: &Vec3f) -> f32; public fn distancesquared (self: &Vec3f, rhs: Vec3f) -> f32; public fn lerp (self: &Vec3f, rhs: Vec3f, t: f32) -> Vec3f; } impl Vec4f { public fn add (self: &Vec4f, rhs: Vec4f) -> Vec4f; public fn sub (self: &Vec4f, rhs: Vec4f) -> Vec4f; public fn scale (self: &Vec4f, s: f32) -> Vec4f; public fn dot (self: &Vec4f, rhs: Vec4f) -> f32; public fn hadamard (self: &Vec4f, rhs: Vec4f) -> Vec4f; public fn lengthsquared (self: &Vec4f) -> f32; public fn distancesquared (self: &Vec4f, rhs: Vec4f) -> f32; public fn lerp (self: &Vec4f, rhs: Vec4f, t: f32) -> Vec4f; } impl Vec2d { public fn add (self: &Vec2d, rhs: Vec2d) -> Vec2d; public fn sub (self: &Vec2d, rhs: Vec2d) -> Vec2d; public fn scale (self: &Vec2d, s: f64) -> Vec2d; public fn dot (self: &Vec2d, rhs: Vec2d) -> f64; public fn hadamard (self: &Vec2d, rhs: Vec2d) -> Vec2d; public fn lengthsquared (self: &Vec2d) -> f64; public fn distancesquared (self: &Vec2d, rhs: Vec2d) -> f64; public fn lerp (self: &Vec2d, rhs: Vec2d, t: f64) -> Vec2d; } impl Vec3d { public fn add (self: &Vec3d, rhs: Vec3d) -> Vec3d; public fn sub (self: &Vec3d, rhs: Vec3d) -> Vec3d; public fn scale (self: &Vec3d, s: f64) -> Vec3d; public fn dot (self: &Vec3d, rhs: Vec3d) -> f64; public fn cross (self: &Vec3d, rhs: Vec3d) -> Vec3d; public fn hadamard (self: &Vec3d, rhs: Vec3d) -> Vec3d; public fn lengthsquared (self: &Vec3d) -> f64; public fn distancesquared (self: &Vec3d, rhs: Vec3d) -> f64; public fn lerp (self: &Vec3d, rhs: Vec3d, t: f64) -> Vec3d; } impl Vec4d { public fn add (self: &Vec4d, rhs: Vec4d) -> Vec4d; public fn sub (self: &Vec4d, rhs: Vec4d) -> Vec4d; public fn scale (self: &Vec4d, s: f64) -> Vec4d; public fn dot (self: &Vec4d, rhs: Vec4d) -> f64; public fn hadamard (self: &Vec4d, rhs: Vec4d) -> Vec4d; public fn lengthsquared (self: &Vec4d) -> f64; public fn distancesquared (self: &Vec4d, rhs: Vec4d) -> f64; public fn lerp (self: &Vec4d, rhs: Vec4d, t: f64) -> Vec4d; } // Dynamic-dimension vector (owning). export struct VectorF32 { data: std::vector::Vector(f32), } export struct VectorF64 { data: std::vector::Vector(f64), } export type VectorF32Result = std::result::Result(VectorF32, MathFailed); export type F32Result = std::result::Result(f32, MathFailed); export type VectorF64Result = std::result::Result(VectorF64, MathFailed); export type F64Result = std::result::Result(f64, MathFailed); export type BoolResult = std::result::Result(bool, MathFailed); impl VectorF32 { public fn empty () -> VectorF32; public fn init (len: i64) -> VectorF32Result; public fn len (self: &VectorF32) -> i64; public fn asslice (self: &VectorF32) -> std::arrays::Slice(f32); public fn get (self: &VectorF32, index: i64) -> f32; public fn set (mut self: &VectorF32, index: i64, value: f32) -> void; public fn fill (mut self: &VectorF32, value: f32) -> void; public fn add (self: &VectorF32, rhs: &VectorF32) -> VectorF32Result; public fn sub (self: &VectorF32, rhs: &VectorF32) -> VectorF32Result; public fn addinplace (mut self: &VectorF32, rhs: &VectorF32) -> BoolResult; public fn subinplace (mut self: &VectorF32, rhs: &VectorF32) -> BoolResult; public fn scale (self: &VectorF32, s: f32) -> VectorF32Result; public fn scaleinplace (mut self: &VectorF32, s: f32) -> void; public fn dot (self: &VectorF32, rhs: &VectorF32) -> F32Result; } impl VectorF64 { public fn empty () -> VectorF64; public fn init (len: i64) -> VectorF64Result; public fn len (self: &VectorF64) -> i64; public fn asslice (self: &VectorF64) -> std::arrays::Slice(f64); public fn get (self: &VectorF64, index: i64) -> f64; public fn set (mut self: &VectorF64, index: i64, value: f64) -> void; public fn fill (mut self: &VectorF64, value: f64) -> void; public fn add (self: &VectorF64, rhs: &VectorF64) -> VectorF64Result; public fn sub (self: &VectorF64, rhs: &VectorF64) -> VectorF64Result; public fn addinplace (mut self: &VectorF64, rhs: &VectorF64) -> BoolResult; public fn subinplace (mut self: &VectorF64, rhs: &VectorF64) -> BoolResult; public fn scale (self: &VectorF64, s: f64) -> VectorF64Result; public fn scaleinplace (mut self: &VectorF64, s: f64) -> void; public fn dot (self: &VectorF64, rhs: &VectorF64) -> F64Result; } std::math::matrix (initial subset): module std::math::matrix; import std::result; import std::vector; import std::math::vector; export type MathFailed = std::math::vector::MathFailed; export type MathErrorKind = std::math::vector::MathErrorKind; export type F32Result = std::math::vector::F32Result; export type BoolResult = std::math::vector::BoolResult; export type VectorF32Result = std::math::vector::VectorF32Result; export struct Mat2f { m00: f32, m01: f32, m10: f32, m11: f32 } export struct Mat3f { / row-major / } export struct Mat4f { / row-major / } export struct Mat2d { m00: f64, m01: f64, m10: f64, m11: f64 } export struct Mat3d { / row-major / } export struct Mat4d { / row-major / } impl Mat2f { public fn identity () -> Mat2f; public fn mulvec2 (self: &Mat2f, v: std::math::vector::Vec2f) -> std::math::vector::Vec2f; public fn mulmat2 (self: &Mat2f, rhs: Mat2f) -> Mat2f; public fn transpose (self: &Mat2f) -> Mat2f; } impl Mat3f { public fn identity () -> Mat3f; public fn mulvec3 (self: &Mat3f, v: std::math::vector::Vec3f) -> std::math::vector::Vec3f; public fn mulmat3 (self: &Mat3f, rhs: Mat3f) -> Mat3f; public fn transpose (self: &Mat3f) -> Mat3f; } impl Mat4f { public fn identity () -> Mat4f; public fn translation (tx: f32, ty: f32, tz: f32) -> Mat4f; public fn scale (sx: f32, sy: f32, sz: f32) -> Mat4f; public fn mulvec4 (self: &Mat4f, v: std::math::vector::Vec4f) -> std::math::vector::Vec4f; public fn mulmat4 (self: &Mat4f, rhs: Mat4f) -> Mat4f; public fn transpose (self: &Mat4f) -> Mat4f; } impl Mat2d { public fn identity () -> Mat2d; public fn mulvec2 (self: &Mat2d, v: std::math::vector::Vec2d) -> std::math::vector::Vec2d; public fn mulmat2 (self: &Mat2d, rhs: Mat2d) -> Mat2d; public fn transpose (self: &Mat2d) -> Mat2d; } impl Mat3d { public fn identity () -> Mat3d; public fn mulvec3 (self: &Mat3d, v: std::math::vector::Vec3d) -> std::math::vector::Vec3d; public fn mulmat3 (self: &Mat3d, rhs: Mat3d) -> Mat3d; public fn transpose (self: &Mat3d) -> Mat3d; } impl Mat4d { public fn identity () -> Mat4d; public fn translation (tx: f64, ty: f64, tz: f64) -> Mat4d; public fn scale (sx: f64, sy: f64, sz: f64) -> Mat4d; public fn mulvec4 (self: &Mat4d, v: std::math::vector::Vec4d) -> std::math::vector::Vec4d; public fn mulmat4 (self: &Mat4d, rhs: Mat4d) -> Mat4d; public fn transpose (self: &Mat4d) -> Mat4d; } // Dynamic-dimension matrix (row-major, owning). export struct MatrixF32 { rows: i64, cols: i64, data: std::vector::Vector(f32), // length = rows cols } export struct MatrixF64 { rows: i64, cols: i64, data: std::vector::Vector(f64), // length = rows cols } export type MatrixF32Result = std::result::Result(MatrixF32, MathFailed); export type MatrixF64Result = std::result::Result(MatrixF64, MathFailed); impl MatrixF32 { public fn empty () -> MatrixF32; public fn init (rows: i64, cols: i64) -> MatrixF32Result; public fn asslice (self: &MatrixF32) -> std::arrays::Slice(f32); public fn fill (mut self: &MatrixF32, value: f32) -> void; public fn at (self: &MatrixF32, row: i64, col: i64) -> F32Result; public fn set (mut self: &MatrixF32, row: i64, col: i64, value: f32) -> BoolResult; public fn add (self: &MatrixF32, rhs: &MatrixF32) -> MatrixF32Result; public fn sub (self: &MatrixF32, rhs: &MatrixF32) -> MatrixF32Result; public fn scale (self: &MatrixF32, s: f32) -> MatrixF32Result; public fn addinplace (mut self: &MatrixF32, rhs: &MatrixF32) -> BoolResult; public fn subinplace (mut self: &MatrixF32, rhs: &MatrixF32) -> BoolResult; public fn scaleinplace (mut self: &MatrixF32, s: f32) -> void; public fn mul (self: &MatrixF32, rhs: &MatrixF32) -> MatrixF32Result; // matmul public fn mulvec (self: &MatrixF32, rhs: &std::math::vector::VectorF32) -> VectorF32Result; public fn transpose (self: &MatrixF32) -> MatrixF32Result; } impl MatrixF64 { public fn empty () -> MatrixF64; public fn init (rows: i64, cols: i64) -> MatrixF64Result; public fn asslice (self: &MatrixF64) -> std::arrays::Slice(f64); public fn fill (mut self: &MatrixF64, value: f64) -> void; public fn at (self: &MatrixF64, row: i64, col: i64) -> F64Result; public fn set (mut self: &MatrixF64, row: i64, col: i64, value: f64) -> BoolResult; public fn add (self: &MatrixF64, rhs: &MatrixF64) -> MatrixF64Result; public fn sub (self: &MatrixF64, rhs: &MatrixF64) -> MatrixF64Result; public fn scale (self: &MatrixF64, s: f64) -> MatrixF64Result; public fn addinplace (mut self: &MatrixF64, rhs: &MatrixF64) -> BoolResult; public fn subinplace (mut self: &MatrixF64, rhs: &MatrixF64) -> BoolResult; public fn scaleinplace (mut self: &MatrixF64, s: f64) -> void; public fn mul (self: &MatrixF64, rhs: &MatrixF64) -> MatrixF64Result; // matmul public fn mulvec (self: &MatrixF64, rhs: &std::math::vector::VectorF64) -> VectorF64Result; public fn transpose (self: &MatrixF64) -> MatrixF64Result; } Notes on f128 / u128 std::math intends to expose higher precision scalars for numeric work and tensor integration. The language primitives i128 / u128 / f128 are now part of the supported native backend subset; std::math currently focuses on f32 and f64 surfaces and will add higher-precision variants incrementally as needed."
    },
    {
      "id": "std/memory",
      "title": "`std::memory`",
      "section": "std",
      "summary": "implemented yet.",
      "text": "std::memory implemented yet. std::memory provides allocation interfaces and low-level memory utilities. It sits at the bottom of most other std modules. See also: API A small subset is implemented in std/memory.slk for early compiler bring-up. These helpers are pure and operate on scalar types only, plus a shared allocation-failure error type used across std::. module std::memory; export error OutOfMemory { requested: i64 } enum AllocErrorKind { OutOfMemory, InvalidInput, Overflow, Unknown, } export error AllocFailed { code: int, requested: i64, } impl AllocFailed { public fn kind (self: &AllocFailed) -> AllocErrorKind; } export fn allocfailed (kind: AllocErrorKind, requested: i64) -> AllocFailed; export fn ispoweroftwou64 (x: u64) -> bool; export fn alignupu64 (value: u64, alignment: u64) -> u64; export fn aligndownu64 (value: u64, alignment: u64) -> u64; export fn divceilu64 (n: u64, d: u64) -> u64; Notes: align functions require alignment to be a power of two. OutOfMemory is the shared error type returned by allocation-backed containers and builders (for example std::vector::Vector and std::strings::StringBuilder) when capacity growth cannot allocate. AllocFailed is a small, stable \u201cconstructor failed\u201d error used by APIs like BufferU8.init / Vector(T).init where invalid inputs (negative capacities, overflow) must be distinguished from out-of-memory. Scope std::memory is responsible for: Defining allocator interfaces used by other std:: modules. Providing safe wrappers around region allocation and the intrinsic Buffer(T) type (where possible). Providing low-level memory operations (memcpy, memcmp, zeroing, etc.). Defining common allocation error conventions (OutOfMemory, etc.). Non-goals (initially): A full garbage collector (explicit allocation is the design baseline). Region inference beyond the region model already described in the language docs. Intrinsics and Their Std Surface The language defines: The buffer document enumerates intrinsic operations under the std::buffer:: namespace (allocation, read/write, drop, view/slice). The std::memory design assumes those operations exist and that higher-level containers in std::arrays and std::strings are layered on top. Allocator Interface (Initial Design) The stdlib needs a first-class allocator abstraction so that: containers can be written without hardcoding a global heap, freestanding builds can provide their own allocator, hosted builds can use an OS-backed allocator. Illustrative sketch: module std::memory; export enum AllocError { OutOfMemory, } export interface Allocator { // Allocate n elements of type T. alloc: fn(T, n: int) -> Result(Buffer(T), AllocError); // Resize an existing allocation. realloc: fn(T, buf: Buffer(T), oldn: int, newn: int) -> Result(Buffer(T), AllocError); // Free an allocation. free: fn(T, buf: Buffer(T), n: int) -> void; } The exact interface depends on how generics and interfaces are represented in the implemented language. The key requirement is that containers can accept an allocator value and use it consistently. Common Utilities std::memory should provide low-level routines that are useful across the stdlib: copy(dst, src, n) move(dst, src, n) set(dst, byte, n) zero(dst, n) equal(a, b, n) These should have both safe and \u201cunchecked\u201d variants where appropriate, so that verified code can elide bounds checks while still keeping safety explicit."
    },
    {
      "id": "std/networking",
      "title": "`std::net`",
      "section": "std",
      "summary": "helper subset plus hosted **IPv4/IPv6 TCP** and **IPv4/IPv6 UDP** socket APIs are implemented in `std/net.slk`. Async/event-loop integration remains future work.",
      "text": "std::net helper subset plus hosted IPv4/IPv6 TCP and IPv4/IPv6 UDP socket APIs are implemented in std/net.slk. Async/event-loop integration remains future work. std::net provides networking primitives on POSIX systems. See also: API A small, non-socket subset exists in std/net.slk for early bring-up: module std::net; export fn bswapu16 (x: u16) -> u16; export fn bswapu32 (x: u32) -> u32; export fn htons (x: u16) -> u16; export fn ntohs (x: u16) -> u16; export fn htonl (x: u32) -> u32; export fn ntohl (x: u32) -> u32; struct Ipv4Addr { value: int, } impl Ipv4Addr { public fn fromoctets (a: int, b: int, c: int, d: int) -> Ipv4Addr; public fn fromu32 (value: int) -> Ipv4Addr; public fn value (self: &Ipv4Addr) -> int; public fn a (self: &Ipv4Addr) -> int; public fn b (self: &Ipv4Addr) -> int; public fn c (self: &Ipv4Addr) -> int; public fn d (self: &Ipv4Addr) -> int; public fn isloopback (self: &Ipv4Addr) -> bool; } // Compatibility wrappers (free functions). export fn ipv4 (a: int, b: int, c: int, d: int) -> Ipv4Addr; export fn ipv4fromu32 (value: int) -> Ipv4Addr; export fn ipv4value (addr: Ipv4Addr) -> int; export fn ipv4a (addr: Ipv4Addr) -> int; export fn ipv4b (addr: Ipv4Addr) -> int; export fn ipv4c (addr: Ipv4Addr) -> int; export fn ipv4d (addr: Ipv4Addr) -> int; export fn ipv4isloopback (addr: Ipv4Addr) -> bool; Notes: This is currently implemented as a byte-swap for the linux/x8664 little-endian hosted baseline. Hosted TCP API std::net exposes a small TCP API for hosted targets via the pluggable runtime interface std::runtime::net: module std::net; enum NetErrorKind { BadFileDescriptor, PermissionDenied, WouldBlock, Interrupted, ConnectionRefused, TimedOut, AddressInUse, AddressNotAvailable, NetworkUnreachable, HostUnreachable, NotConnected, BrokenPipe, InvalidInput, OutOfMemory, Unknown, } error NetFailed { code: int, requested: i64 } export type NetIntResult = std::result::Result(int, NetFailed); struct SocketAddrV4 { ipvalue: int, port: int, } impl SocketAddrV4 { public fn fromipv4value (ipvalue: int, port: int) -> SocketAddrV4; public fn fromoctets (a: int, b: int, c: int, d: int, port: int) -> SocketAddrV4; public fn loopback (port: int) -> SocketAddrV4; public fn ip (self: &SocketAddrV4) -> Ipv4Addr; public fn port (self: &SocketAddrV4) -> int; } struct Ipv6Addr { hi: u64, lo: u64, } impl Ipv6Addr { public fn fromu64s (hi: u64, lo: u64) -> Ipv6Addr; public fn fromsegments (s0: u16, s1: u16, s2: u16, s3: u16, s4: u16, s5: u16, s6: u16, s7: u16) -> Ipv6Addr; public fn hi (self: &Ipv6Addr) -> u64; public fn lo (self: &Ipv6Addr) -> u64; public fn isloopback (self: &Ipv6Addr) -> bool; public fn isunspecified (self: &Ipv6Addr) -> bool; } struct SocketAddrV6 { iphi: u64, iplo: u64, port: int, scopeid: int, } impl SocketAddrV6 { public fn fromipv6u64s (iphi: u64, iplo: u64, port: int, scopeid: int) -> SocketAddrV6; public fn fromipv6 (ip: Ipv6Addr, port: int, scopeid: int) -> SocketAddrV6; public fn loopback (port: int) -> SocketAddrV6; public fn ip (self: &SocketAddrV6) -> Ipv6Addr; public fn port (self: &SocketAddrV6) -> int; public fn scopeid (self: &SocketAddrV6) -> int; } struct TcpStream { fd: int, } export type TcpStreamResult = std::result::Result(TcpStream, NetFailed); impl TcpStream { public fn invalid () -> TcpStream; public fn isvalid (self: &TcpStream) -> bool; public fn connect (addr: SocketAddrV4) -> TcpStreamResult; public fn connectv6 (addr: SocketAddrV6) -> TcpStreamResult; public fn close (mut self: &TcpStream) -> NetFailed?; public fn read (self: &TcpStream, buf: std::arrays::ByteSlice) -> NetIntResult; public fn write (self: &TcpStream, buf: std::arrays::ByteSlice) -> NetIntResult; public fn writeall (self: &TcpStream, buf: std::arrays::ByteSlice) -> NetFailed?; public fn writestring (self: &TcpStream, s: string) -> NetFailed?; public fn shutdownread (self: &TcpStream) -> NetFailed?; public fn shutdownwrite (self: &TcpStream) -> NetFailed?; public fn shutdown (self: &TcpStream) -> NetFailed?; } struct TcpListener { fd: int, } export type TcpListenerResult = std::result::Result(TcpListener, NetFailed); impl TcpListener { public fn invalid () -> TcpListener; public fn isvalid (self: &TcpListener) -> bool; public fn listen (addr: SocketAddrV4, backlog: int) -> TcpListenerResult; public fn listenv6 (addr: SocketAddrV6, backlog: int) -> TcpListenerResult; public fn accept (self: &TcpListener) -> TcpStreamResult; public fn localport (self: &TcpListener) -> NetIntResult; public fn localportv6 (self: &TcpListener) -> NetIntResult; public fn close (mut self: &TcpListener) -> NetFailed?; } Notes: This API is currently blocking (no non-blocking sockets/event loop yet). The current implementation targets hosted linux/x8664 via std::runtime::net (POSIX sockets); wasm32-wasi has no Preview 1 sockets, so the runtime stubs return error values. TcpStream/TcpListener wrap raw file descriptors; avoid copying these values until the language has move-only handle types. If you want to discard error details, prefer match (r) when the Result payload may implement Drop (for example TcpStream / TcpListener), since ResultType.okvalue(r) copies the Result payload in Silk. Hosted UDP API std::net also exposes a small UDP API for hosted targets. The API is datagram-oriented but remains blocking. module std::net; struct UdpSocket { fd: int, domain: int, } export type NetError = NetFailed; export type UdpSocketResult = std::result::Result(UdpSocket, NetFailed); struct UdpRecvFrom { n: int, addr: SocketAddr, } export type UdpRecvFromResult = std::result::Result(UdpRecvFrom, NetError); struct SocketAddr { domain: int, ipvalue: int, iphi: u64, iplo: u64, port: int, scopeid: int, } impl SocketAddr { public fn fromv4 (addr: SocketAddrV4) -> SocketAddr; public fn fromv6 (addr: SocketAddrV6) -> SocketAddr; public fn isv4 (self: &SocketAddr) -> bool; public fn isv6 (self: &SocketAddr) -> bool; public fn v4 (self: &SocketAddr) -> SocketAddrV4?; public fn v6 (self: &SocketAddr) -> SocketAddrV6?; public fn port (self: &SocketAddr) -> int; } impl UdpSocket { public fn invalid () -> UdpSocket; public fn isvalid (self: &UdpSocket) -> bool; public fn bindv4 (addr: SocketAddrV4) -> UdpSocketResult; public fn bindv6 (addr: SocketAddrV6) -> UdpSocketResult; public fn connectv4 (addr: SocketAddrV4) -> UdpSocketResult; public fn connectv6 (addr: SocketAddrV6) -> UdpSocketResult; public fn localport (self: &UdpSocket) -> NetIntResult; public fn close (mut self: &UdpSocket) -> NetFailed?; // Connected I/O (uses read(2) / write(2)). public fn read (self: &UdpSocket, buf: std::arrays::ByteSlice) -> NetIntResult; public fn write (self: &UdpSocket, buf: std::arrays::ByteSlice) -> NetIntResult; // Unconnected datagrams. public fn sendto (self: &UdpSocket, addr: SocketAddr, buf: std::arrays::ByteSlice) -> NetIntResult; public fn recvfrom (self: &UdpSocket, buf: std::arrays::ByteSlice) -> UdpRecvFromResult; } Notes: sendto / recvfrom require the socket domain to match addr.domain (AFINET for IPv4, AFINET6 for IPv6). Scope std::net is responsible for: Sockets and basic protocols. Integration with concurrency primitives (async, task). Core Types (Initial Design) IpAddr (V4 / V6) and SocketAddr. TcpStream, TcpListener, UdpSocket. Illustrative sketch: module std::net; export enum NetError { ConnectionRefused, TimedOut, AddressInUse, NetworkUnreachable, WouldBlock, Unknown, } export fn tcpconnect (addr: SocketAddr) -> Result(TcpStream, NetError); export fn tcplisten (addr: SocketAddr) -> Result(TcpListener, NetError); Blocking vs Async The initial hosted baseline may be blocking I/O. Once the language\u2019s async model is implemented, std::net should provide: non-blocking sockets + integration with an event loop, async fn wrappers for common operations, integration with task offloading for blocking adapters (design target: std::task::runblocking(); until that exists, users can explicitly use a task fn wrapper around blocking calls). Future Work DNS resolution, TLS integration (as optional packages)."
    },
    {
      "id": "std/number",
      "title": "`std::number`",
      "section": "std",
      "summary": "This module provides small, dependency-light number parsing and formatting helpers.",
      "text": "std::number This module provides small, dependency-light number parsing and formatting helpers. The initial surface focuses on: stable, strict parsing from string to numeric types, and formatting numeric values into owned std::strings::String outputs. API Parsing Parsing functions return Result(T, ParseFailed) for explicit error handling. module std::number; export enum ParseErrorKind { InvalidInput, Overflow, OutOfMemory, Unknown, } export error ParseFailed { code: int, offset: int, } export type AtodResult = std::result::Result(f64, ParseFailed); export type Atou64Result = std::result::Result(u64, ParseFailed); export type Atoi64Result = std::result::Result(i64, ParseFailed); export type Atou32Result = std::result::Result(u32, ParseFailed); export type Atoi32Result = std::result::Result(i32, ParseFailed); export type Atou128Result = std::result::Result(u128, ParseFailed); export type Atoi128Result = std::result::Result(i128, ParseFailed); export fn atod (s: string) -> AtodResult; export fn atou64 (s: string) -> Atou64Result; export fn atoi64 (s: string) -> Atoi64Result; export fn atou32 (s: string) -> Atou32Result; export fn atoi32 (s: string) -> Atoi32Result; export fn atou128 (s: string) -> Atou128Result; export fn atoi128 (s: string) -> Atoi128Result; Notes: atou parses base-10 unsigned integers; atoi parses base-10 signed integers with an optional leading +/-. The integer parsers accept as a digit separator between digits (for example 1000000). atod is strict: the entire input must be consumed (no trailing bytes). ParseFailed.offset is a byte offset into the original input. atod may report OutOfMemory if the runtime needs temporary storage. Formatting Formatting functions allocate and return owned std::strings::String values. export fn dtoa (value: f64) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); export fn u64toa (value: u64) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); export fn i64toa (value: i64) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); export fn u32toa (value: u32) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); export fn i32toa (value: i32) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); export fn u128toa (value: u128) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); export fn i128toa (value: i128) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); Related Documents"
    },
    {
      "id": "std/path",
      "title": "`std::path`",
      "section": "std",
      "summary": "`std::path` provides path manipulation utilities.",
      "text": "std::path std::path provides path manipulation utilities. Design goals (modeled after Rust std::path and Node.js path): Borrowed vs owned: string values are non-owning views; std::path::PathBuf is an owned, growable path buffer for building paths incrementally. POSIX-first: the initial shipped implementation uses / as the separator and does not implement Windows drive/UNC path rules yet. Allocation-aware: functions that produce new paths return owned std::strings::String values (callers must drop them). API module std::path; import std::strings; export let SEP: string = \"/\"; export let DELIMITER: string = \":\"; // Owned path buffer (like Rust PathBuf). struct PathBuf { ptr: u64, cap: i64, len: i64, } impl PathBuf { public fn empty () -> std::result::Result(PathBuf, std::memory::OutOfMemory); public fn fromstring (s: string) -> std::result::Result(PathBuf, std::memory::OutOfMemory); public fn asstring (self: &PathBuf) -> string; public fn clear (mut self: &PathBuf) -> void; public fn push (mut self: &PathBuf, part: string) -> std::memory::OutOfMemory?; public fn pop (mut self: &PathBuf) -> bool; } // Inspection. export fn isabsolute (path: string) -> bool; // Building and normalization. export fn join (a: string, b: string) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); export fn normalize (path: string) -> std::result::Result(std::strings::String, std::memory::OutOfMemory); // Inspection helpers (views into the input string). export fn dirname (path: string) -> string; export fn basename (path: string) -> string; export fn extname (path: string) -> string; export fn stem (path: string) -> string; Notes: On POSIX, the root path \"/\" has no basename, so basename(\"/\") == \"\". Separator and delimiter SEP is the path component separator. On POSIX it is \"/\". DELIMITER is the environment-variable path list delimiter. On POSIX it is \":\" (for example PATH=/bin:/usr/bin). Ownership and allocation Functions that return std::strings::String allocate an owned buffer. Callers must drop returned owned strings when finished: import std::path; import std::strings; fn main () -> int { match std::path::join(\"/tmp\", \"file.txt\") { mut p => { // ... (mut p).drop(); return 0; }, err: std::memory::OutOfMemory => { return 1; } } } normalize std::path::normalize(path) rewrites a path into a canonical form for the hosted POSIX subset: collapses repeated / separators, removes . components, resolves .. components when possible, removes trailing / separators (except for the root path), preserves a leading / for absolute paths, returns \".\" for empty relative results and \"/\" for empty absolute results. Notes: This is a lexical normalization. It does not access the filesystem and does not resolve symlinks. Platform notes POSIX (default shipped stdlib): / separator and : delimiter. Windows: not implemented yet (drive letters, UNC paths, \\ separators). join note std::path::join(a, b) follows Rust Path::join semantics: when b is absolute, the result is normalize(b) (the base a is discarded)."
    },
    {
      "id": "std/process",
      "title": "`std::process`",
      "section": "std",
      "summary": "`std::process` provides access to process-level operations that are not tied to environment variables, such as the current working directory.",
      "text": "std::process std::process provides access to process-level operations that are not tied to environment variables, such as the current working directory. The current implementation targets a hosted POSIX baseline (Linux/glibc) and is implemented on top of the pluggable std::runtime::process interface. WASI support is partially implemented (see \u201cPlatform notes\u201d). API module std::process; import std::result; import std::strings; enum ChdirErrorKind { InvalidInput, NotFound, NotADirectory, PermissionDenied, Unknown } error ChdirFailed { code: int } enum GetCwdErrorKind { OutOfMemory, NotFound, PermissionDenied, Unknown } error GetCwdFailed { code: int, requested: i64 } export type GetCwdError = GetCwdFailed; export type GetCwdResult = std::result::Result(std::strings::String, GetCwdError); export fn chdir (path: string) -> ChdirFailed?; export fn getcwd () -> GetCwdResult; Child processes (std::process::child) std::process::child provides hosted child-process execution (spawn/wait/kill) and high-level output capture. For convenience, std::process re-exports the high-level std::process::child surface so downstream users can write: import std::process; let mut cmd = std::process::Command.init(\"/bin/echo\"); cmd.arg(\"hello\"); let outr = cmd.output(); See the std::process::child source (std/process/child.slk) for the exact, current API surface. getcwd std::process::getcwd() returns the current working directory as an owned std::strings::String. Ownership: Callers must drop the returned String when finished. Errors are reported as a recoverable result: getcwd has signature -> GetCwdResult, on success: value = Some(String), err = None, on failure: value = None, err = Some(GetCwdFailed{ code, requested }) (use GetCwdFailed.kind() to distinguish failure kinds). GetCwdFailed does not expose platform errno values. Use GetCwdFailed.kind() to classify failures into GetCwdErrorKind values. chdir std::process::chdir(path) changes the process working directory. Errors are reported as an optional error value: chdir has signature -> ChdirFailed?, it returns None on success, it returns Some(ChdirFailed{ code }) when the underlying runtime operation fails. ChdirFailed does not expose platform errno values. Use ChdirFailed.kind() to classify failures into ChdirErrorKind values. Notes: chdir does not update environment variables like PWD. Use std::process::getcwd() to query the real current directory. Platform notes POSIX (default shipped stdlib): implemented via getcwd(3) and chdir(2). Child processes (POSIX): implemented via fork(2) + exec + waitpid(2) with pipe-based stdio and poll-based output capture. WASI (Preview 1): getcwd and chdir are implemented via a virtual working directory. std::process::child operations remain unsupported."
    },
    {
      "id": "std/readline",
      "title": "`std::readline`",
      "section": "std",
      "summary": "`std::readline` provides a small, ergonomic readline-style API for reading a single line of user input with interactive editing and history when stdin is connected to a TTY.",
      "text": "std::readline std::readline provides a small, ergonomic readline-style API for reading a single line of user input with interactive editing and history when stdin is connected to a TTY. The shipped implementation is based on the bundled linenoise sources under src/linenoise.{c,h} and is exposed through the bundled runtime support archive (libsilkrt). Overview Typical use: import std::readline; export fn main () -> int { let r = readline.readline(\"> \"); match (r) { Ok(lineopt) => match (lineopt) { Some(line) => { // ... (mut line).drop(); return 0; }, None => return 0, // EOF }, Err() => { // Ctrl-C or other failures. return 1; }, } } API Reading readline(prompt: string = \"\", addhistory: bool = true) -> Result(String?, ReadLineFailed) Ok(Some(line)) on success, Ok(None) on EOF, Err(ReadLineFailed) on failure. Mode flags setmultiline(enabled: bool) -> void \u2014 enable multi-line editing. setmaskmode(enabled: bool) -> void \u2014 enable password masking (). clearscreen() -> void \u2014 clear the terminal screen. printkeycodes() -> void \u2014 print key codes for debugging. History historyadd(line: string) -> bool \u2014 returns false when the line is not added (duplicates, history disabled, or internal allocation failure). historysetmaxlen(maxlen: int) -> bool \u2014 set the max retained entries. historyload(path: string) -> Result(bool, ReadLineFailed) Ok(true) when loaded, Ok(false) when the file does not exist, Err(ReadLineFailed) on other failures. historysave(path: string) -> ReadLineFailed? \u2014 None on success. Errors ReadLineFailed uses stable std::io-style error codes. Use ReadLineFailed.kind() to classify common cases: Interrupted \u2014 returned for Ctrl-C. OutOfMemory \u2014 allocation failure (including --noheap builds with no installed runtime allocator). InvalidInput \u2014 invalid path/prompt lengths or internal overflow guards. Unknown \u2014 other failures. Semantics TTY vs. non-TTY: when stdin is a TTY, input is edited interactively (arrow keys, history), when stdin is not a TTY (piped input), the implementation reads a line from stdin without interactive editing; prompts are not displayed in this mode. EOF: Ok(None) is returned on end-of-input (Ctrl-D on an empty line in TTY mode, or EOF on stdin in non-TTY mode). Ownership: readline returns an owned std::strings::String. Drop it when finished. Keybindings (TTY mode) Keybindings are implemented by the bundled linenoise line editor. Exact behavior depends on the terminal, but common bindings include: Left/Right arrows \u2014 move by one character (UTF-8 aware). Up/Down arrows \u2014 navigate history. Home/End \u2014 move to start/end of line. Backspace/Delete \u2014 delete characters. Ctrl+W \u2014 delete previous word (space-delimited). Ctrl+Left / Ctrl+Right \u2014 move by word (identifier/punctuation runs). Alt+Left / Alt+Right \u2014 move by word (when the terminal sends xterm-style CSI modifier sequences). Alt+B / Alt+F \u2014 move by word (Meta key sequences: ESC b / ESC f). Implementation Notes Internal linenoise heap usage is routed through the silkrtmallocbytes allocator surface so embedders can override allocations via silkrtsetallocator (include/silkrt.h). The returned line is copied into an owned allocation compatible with std::runtime::mem::free / std::strings::String.drop() (payload pointer includes the standard 8-byte header used by the hosted runtime). Limitations linenoise completion/hints callbacks are not exposed yet (they require a stable callback/FFI story for passing function pointers between Silk and C). The non-blocking linenoiseEdit API is not exposed yet."
    },
    {
      "id": "std/regex",
      "title": "`std::regex`",
      "section": "std",
      "summary": "This module provides regular expression helpers built on top of:",
      "text": "std::regex This module provides regular expression helpers built on top of: the regexp primitive (compiled regex bytecode view), and a boxed/owned RegExp type for runtime-compiled patterns. Regex literals are part of the language surface: /pattern/flags produces a regexp value, compiled at compile time (see API The initial std::regex surface is intentionally small and focuses on: basic matching (matches, exec, matchfirst), searching and iteration (search, iter), runtime compilation (RegExp.compile(...)), explicit ownership via the RegExp boxed type. module std::regex; export const EXECMATCH: int = 1; export const EXECNOMATCH: int = 0; export const EXECERRMEMORY: int = -1; export const EXECERRTIMEOUT: int = -2; export const EXECERRINVALIDINPUT: int = -3; export struct ExecResult { // Use std::regex::EXEC constants. code: int, start: int, end: int, } export fn exec (re: regexp, input: string) -> ExecResult; export fn matches (re: regexp, input: string) -> bool; export fn ismatch (re: regexp, input: string) -> bool; // compatibility alias export fn search (re: regexp, input: string, start: int) -> ExecResult; export fn matchfirst (re: regexp, input: string) -> string?; export struct MatchIter { re: regexp, input: string, inputlen: i64, offset: int, done: bool, } export fn iter (re: regexp, input: string) -> MatchIter; export error CompileFailed { code: int, } export struct RegExp { // Owned compiled bytecode. value: regexp, } impl RegExp { public fn empty () -> RegExp; public fn compile (pattern: string, flags: string) -> std::result::Result(RegExp, CompileFailed); public fn asregexp (self: &RegExp) -> regexp; } impl RegExp as std::interfaces::Drop { public fn drop (mut self: &RegExp) -> void; } Notes: The regexp primitive is a non-owning { ptr, len } view; regex literals embed compiled bytecode in rodata, and RegExp owns heap-allocated bytecode. ExecResult.start / end are byte offsets into the input string. ExecResult implements std::interfaces::Len (len() -> i64), returning the matched byte length (end - start) when code == EXECMATCH and 0 otherwise. test and match are reserved keywords in Silk; this module uses matches and matchfirst instead. MatchIter provides next() -> ExecResult? and can be consumed with for m in std::regex::iter(re, input) { ... }. matches are yielded as ExecResult values with code == EXECMATCH, a runtime error (code < 0) is yielded once and then the iterator ends, empty matches advance by 1 byte to guarantee progress. Related Documents"
    },
    {
      "id": "std/result",
      "title": "`std::result`",
      "section": "std",
      "summary": "`std::result` standardizes the common \u201csuccess or error\u201d return shape so that APIs across `std::` compose cleanly.",
      "text": "std::result std::result standardizes the common \u201csuccess or error\u201d return shape so that APIs across std:: compose cleanly. Result(T, E) Result(T, E) models a recoverable \u201csuccess or error\u201d outcome. Representation Result(T, E) is a tagged union: enum Result(T, E) { Ok(T), Err(E), } Core API module std::result; enum Result(T, E) { Ok(T), Err(E), } impl Result(T, E) { public fn ok (value: T) -> Result(T, E); public fn err (err: E) -> Result(T, E); public fn isok (self: &Result(T, E)) -> bool; public fn iserr (self: &Result(T, E)) -> bool; public fn unwrapor (value: Result(T, E), fallback: T) -> T; public fn okvalue (value: Result(T, E)) -> T?; public fn unwrap (value: Result(T, E)) -> T?; public fn errvalue (value: Result(T, E)) -> E?; } Notes: Result does not provide aborting unwrap helpers; use unwrap() / okvalue() / errvalue() (or a match) to recover the payload. unwrap() is a non-aborting alias of okvalue() and returns T?. isok() / iserr() borrow the Result and are safe for all payload types. unwrapor() / okvalue() / unwrap() / errvalue() currently take the Result by value as a current workaround (the language does not yet support by-value receivers for instance methods). This copies the active payload and is only safe when the active payload does not implement Drop. For Result values that may hold Drop payloads (for example String, BufferU8, TcpStream), prefer match (r) to extract values safely. Callback-based combinators (for example map / andthen) are deferred until the IR backend supports non-scalar function-typed parameters and results. match supports a shorthand for Result destructuring: when the scrutinee type is Result(T, E), patterns Ok(v) / Err(e) are accepted as shorthand for R::Ok(v) / R::Err(e) where R is the scrutinee enum type. Callers typically introduce a local alias for the instantiated enum so the alias name can be used as a qualifier for constructors and patterns when a type context is not available: import std::result; type R = std::result::Result(int, string); fn main () -> int { let x: R = R.ok(123); if x.iserr() { return 1; } if R.unwrapor(x, 0) != 123 { return 2; } return 0; } In type-directed contexts, Ok(...) / Err(...) can be used without a qualifier. For example: import std::result; error Oops { code: int } fn foo (oops: bool) -> std::result::Result(int, Oops) { if (oops) { return Err(Oops{ code: 123 }); } return Ok(0); }"
    },
    {
      "id": "std/runtime",
      "title": "`std::runtime`",
      "section": "std",
      "summary": "`std::runtime` defines a *runtime interface layer* that sits underneath the rest of the standard library.",
      "text": "std::runtime std::runtime defines a runtime interface layer that sits underneath the rest of the standard library. The goal is to make OS- and environment-specific primitives pluggable while keeping the public std::... APIs stable. The default std shipped with the compiler targets a hosted POSIX baseline, but other environments (Windows, non-POSIX, embedded, sandboxed runtimes) should be able to provide their own runtime implementation by supplying an alternate stdlib root with compatible std::runtime::... modules. Motivation std::fs, std::task, std::sync, and other OS-facing std modules need low-level primitives (files, clocks, threads, syscalls). Those primitives differ significantly across platforms. Keeping these differences confined to std::runtime::... avoids scattering ext and platform #if style logic across the entire stdlib. Structure The std runtime is organized as: std::runtime::<area> \u2014 a stable interface module used by the rest of std. std::runtime::posix::<area> \u2014 the default POSIX-backed implementation used by the compiler\u2019s shipped stdlib on hosted targets. Example: std::runtime::fs is the interface used by std::fs. std::runtime::posix::fs provides the POSIX implementation using ext calls like open(2), read(2), and close(2). In the shipped stdlib today: std::runtime::mem delegates to std::runtime::posix::mem, std::runtime::fs delegates to std::runtime::posix::fs (hosted baseline; on wasm32-wasi the compiler rewrites this to std::runtime::wasi::fs, which implements a filesystem subset using WASI Preview 1 preopened directories and resolves relative paths against a virtual cwd), std::runtime::io delegates to std::runtime::posix::io (hosted baseline; on wasm32-wasi the compiler rewrites this to std::runtime::wasi::io, which implements stdio primitives and maintains a POSIX-shaped errno cell for higher-level wrappers like std::runtime::process), std::runtime::task delegates to std::runtime::posix::task, std::runtime::sync delegates to std::runtime::posix::sync, std::runtime::time delegates to std::runtime::posix::time, std::runtime::env delegates to std::runtime::posix::env, std::runtime::process delegates to std::runtime::posix::process (hosted baseline; on wasm32-wasi the compiler rewrites this to std::runtime::wasi::process, which implements exit via WASI procexit and chdir/getcwd via a virtual cwd layer), std::runtime::net delegates to std::runtime::posix::net (hosted sockets), std::runtime::regex is implemented via bundled runtime support (libsilkrt) and is used by std::regex, std::runtime::unicode is implemented via bundled runtime support (libsilkrt) and is used by std::unicode, std::runtime::number is implemented via bundled runtime support (libsilkrt) and is used by std::number, std::runtime::readline is implemented via bundled runtime support (libsilkrt) and is used by std::readline. The long-term shape is still that std::runtime::<area> remains the stable interface point, while platform backends (such as std::runtime::posix::<area> and std::runtime::windows::<area>) can exist as separate modules in an alternate stdlib root without changing higher-level std::... modules. Interface Design Rules The std::runtime::... surface is allowed to be low-level and unsafe: raw pointers, integer error codes, and OS-specific constants are acceptable. When an operation can fail, prefer returning the error code as a value (via std::result::Result(T, int) or an optional error int?) so callers do not need to pair a sentinel return with a separate errno() query. Higher-level, ergonomic, and allocation-aware APIs belong in std::... modules (for example std::fs::File.readtoend). std::runtime::... modules should avoid exposing platform-specific struct layouts directly to Silk code when possible; prefer integer-like handles and pointer-plus-size patterns. The stable contract is the Silk-level signature in std::runtime::..., not the specific ext spellings used by the POSIX backend. Low-level primitives should be localized: libc allocator ext bindings (malloc/free/realloc) and compiler-backed raw-memory/string intrinsics (silk) live in std::runtime::posix::mem (and analogous backend mem modules), other runtime backend modules should call those exported wrappers instead of declaring duplicate allocator/intrinsic ext sites. for example, the shipped WASI backends (std::runtime::wasi::io and std::runtime::wasi::time) use std::runtime::wasi::mem for allocation and silk intrinsics. Current Scope Runtime areas in the shipped stdlib: std::runtime::mem \u2014 low-level allocation and compiler-backed intrinsics used by higher-level std modules (alloc/realloc/free, raw load/store, and string view helpers). allocations are routed to that region for the dynamic extent of the with block (including calls into stdlib code): std::runtime::mem::alloc allocates from the active region instead of the heap, std::runtime::mem::realloc reallocates region pointers by allocating a new region block and copying bytes (it never calls libc realloc on a region-backed pointer), std::runtime::mem::free is a no-op for region-backed pointers. pointers returned by std::runtime::mem::alloc are owned by Silk; they must be released with std::runtime::mem::free and are not valid to pass to libc free() directly. std::runtime::build \u2014 build metadata provided by the compiler: isdebug() -> bool returns true when the current artifact was compiled with silk ... --debug (or -g). kind() -> string returns the current build kind (\"executable\", \"object\", \"static\", or \"shared\"). mode() -> string returns the current build mode (\"debug\", \"release\", or \"test\"). version() -> string returns the current package version when building a package, otherwise \"0.0.0\". std::runtime::fs \u2014 filesystem primitives used by std::fs (hosted baseline; on wasm32-wasi the shipped backend supports a small subset using the first preopened directory as a sandbox root, and resolves relative paths against a virtual cwd (std::runtime::wasi::cwd)). std::runtime::io \u2014 low-level stdio primitives used by std::io (on wasm32-wasi, rewritten to std::runtime::wasi::io, which maintains a POSIX-shaped errno cell for wrappers that still query errno()). std::runtime::task \u2014 hosted task/runtime primitives used by std::task (sleep/yieldnow/available parallelism; currently blocking OS-thread operations; delegates to std::runtime::posix::task in the shipped stdlib). std::runtime::sync \u2014 hosted synchronization primitives used by std::sync (mutexes/condvars and allocation helpers; delegates to std::runtime::posix::sync in the shipped stdlib). std::runtime::time \u2014 hosted time primitives used by std::temporal and other std modules: monotonic clock reads (monotonicnowns), Unix wall-clock timestamp reads (unixnowns / unixnowms), delegates to std::runtime::posix::time in the shipped stdlib. std::runtime::env \u2014 hosted environment primitives used by std::env (process environment variables; delegates to std::runtime::posix::env in the shipped stdlib on hosted targets. On wasm32-wasi the compiler rewrites the backend to std::runtime::wasi::env, which implements getenv via environsizesget / environget (caching the environment snapshot for the process lifetime) and leaves setenv unsupported). std::runtime::process \u2014 hosted process primitives used by std::process (current working directory plus child-process primitives for std::process::child; delegates to std::runtime::posix::process in the shipped stdlib on hosted targets. On wasm32-wasi, exit is implemented via procexit, while chdir/getcwd are implemented via a virtual cwd layer (std::runtime::wasi::cwd); hosted child-process operations remain unsupported). std::runtime::net \u2014 hosted networking primitives used by std::net (IPv4/IPv6 TCP + UDP sockets; delegates to std::runtime::posix::net in the shipped stdlib). std::runtime::regex / std::runtime::unicode / std::runtime::number / std::runtime::readline \u2014 non-OS-specific runtime helpers used by std::{regex,unicode,number,readline}. These are implemented via ext bindings to a small bundled runtime support library (libsilkrt) that ships alongside the compiler. the compiler statically links this bundled runtime support into executable and shared-library outputs (no runtime DTNEEDED dependency on libsilkrt). embedders can override internal allocation used by libsilkrt (for example regex runtime compilation) by calling silkrtsetallocator (see include/silkrt.h) before invoking any silkrt entrypoints. This hook affects allocations routed through silkrtmallocbytes / silkrtreallocbytes / silkrtfreebytes; it does not change the allocator used by std::runtime::mem for heap-backed pointers. when building with --noheap, the compiler links libsilkrtnoheap.a instead of libsilkrt.a. In that configuration, libsilkrt performs no default heap allocation unless an embedder installs an allocator via silkrtsetallocator. Follow-ups are expected to introduce additional runtime areas: WASI networking (via WASI sockets or similar proposals) when supported by the toolchain targets. Providing a Custom Runtime To provide your own runtime implementation underneath the standard library, ship an alternate stdlib root that includes compatible std::runtime::... modules. For a CLI-focused walkthrough of selecting a std root and archive, see At a minimum, your stdlib root should provide the runtime areas used by the higher-level std modules you want to reuse. For example, to reuse the shipped std::task and std::sync, provide: std/runtime/task.slk implementing the std::runtime::task interface (availableparallelism, yieldnow, sleepus), std/runtime/sync.slk implementing the std::runtime::sync interface (alloczeroed, heapfree, mutex/condvar ops), and similarly for std::fs (std/runtime/fs.slk) if you reuse std::fs. To reuse std::io, provide std/runtime/io.slk implementing the std::runtime::io interface (STDINFD, STDOUTFD, STDERRFD, read, write, puts, and hosted fd helpers used by std::process::child such as dup2, pipe, poll, and setcloexec). Fallible operations should return errors directly: value-returning operations use std::result::Result(T, int) where Err(int) is a stable, area-specific error code consumed by higher-level std::... wrappers (for example std::io::IOFailed.code), status operations use optional errors (int?), returning None on success and Some(code) on failure. On hosted POSIX, runtime wrappers typically map errno into these stable codes inside std::runtime::<area> so callers do not need to pair sentinel returns with a separate errno() query. To reuse hosted time helpers in std::temporal, provide std/runtime/time.slk implementing the std::runtime::time interface (monotonicnowns, unixnowns, and unixnowms). Selecting the Runtime (Toolchain) Because std::runtime is part of the stdlib source tree, selecting a custom runtime is done by selecting a custom stdlib root: CLI: pass --std-root <path> (and optionally --std-lib <path> to provide a prebuilt std archive), or set SILKSTDROOT / SILKSTDLIB. Embedding ABI: set silkcompilersetstdroot (and optionally set SILKSTDLIB to point at a prebuilt std archive). When no suitable std archive is provided, the compiler can fall back to compiling the reachable std sources as part of the build on supported targets. Building a Custom Std Archive (linux/x8664) For linux/x8664 in the current toolchain, a prebuilt stdlib archive (libsilkstd.a) contains one ELF object per std module. Archive member naming requirement (current scheme): the archive member name is the module path relative to the std root with / replaced by , and .slk replaced by .o, for example: std/runtime/posix/task.slk \u2192 runtimeposixtask.o. The in-repo make stdlib target produces archives with this naming scheme."
    },
    {
      "id": "std/semver",
      "title": "`std::semver`",
      "section": "std",
      "summary": "precedence comparison.",
      "text": "std::semver precedence comparison. This module is intentionally strict and focused: Parses exact Semantic Versioning 2.0.0 strings: MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]. Provides SemVer precedence comparison (cmp) per the SemVer 2.0.0 rules: major/minor/patch are compared numerically. prerelease identifiers are compared per SemVer rules. build metadata is ignored for precedence. Avoids hidden allocation: parse returns a Version that borrows string slices from the input. Public API Parsing parse(input: string) -> ParseResult Returns Ok(Version) on success. Returns Err(ParseError) on error. ParseResult is std::result::Result(Version, ParseError). ParseError.offset is a byte offset into the original input. ParseError.kind() reports a stable error kind. Allocation and lifetimes: parse does not allocate. Version.prerelease and Version.build are string? slices into input. The caller must ensure input remains alive for as long as the returned Version is used. Version values Version has these fields: major: u64 minor: u64 patch: u64 prerelease: string? \u2014 the substring after - (without the -). build: string? \u2014 the substring after + (without the +). Comparison Version.cmp(other: &Version) -> int Returns -1 if self has lower precedence than other. Returns 0 if self and other have equal precedence. Returns 1 if self has higher precedence than other. Notes: Build metadata does not affect precedence, so: 1.0.0+1 and 1.0.0+2 compare equal (cmp == 0), but they are not exactly equal (eq is false). Example import std::semver; fn main () -> int { let r = std::semver::parse(\"1.2.3-alpha.1+build.5\"); if r.iserr() { return 1; } let v: std::semver::Version = match (r) { Ok(v) => v, Err() => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None }, }; if v.major != 1 { return 2; } if v.prerelease == None { return 3; } let ar = std::semver::parse(\"1.0.0-alpha\"); let br = std::semver::parse(\"1.0.0\"); if ar.iserr() { return 4; } if br.iserr() { return 5; } let a: std::semver::Version = match (ar) { Ok(v) => v, Err() => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None } }; let b: std::semver::Version = match (br) { Ok(v) => v, Err() => std::semver::Version{ major: 0, minor: 0, patch: 0, prerelease: None, build: None } }; if a.cmp(b) >= 0 { return 6; } return 0; }"
    },
    {
      "id": "std/set",
      "title": "`std::set` \u2014 Sets",
      "section": "std",
      "summary": "`std::set` provides standard set container surfaces:",
      "text": "std::set \u2014 Sets std::set provides standard set container surfaces: SetMap(T) \u2014 an unordered set backed by an open-addressing hash table. TreeSet(T) \u2014 an ordered set backed by a red-black tree. targets the compiler and will grow as the language gains first-class move/Drop semantics for values stored inside heap-backed data structures. Design Goals Provide a consistent \u201cset of unique values\u201d container story in std:: that mirrors std::map: hashing + equality for SetMap(T), ordering comparison for TreeSet(T). Make allocation behavior explicit and compatible with regions (with) and noheap. Keep terminology and operation shapes close to C++ (std::unorderedset and std::set), adapted to Silk\u2019s current method/optional model. Important Limitations In Silk: SetMap(T) and TreeSet(T) store elements by value, but do not automatically run Drop for stored elements when entries are removed. These sets are intended for \u201cplain\u201d value types: primitive scalars, string views, and small POD structs over those primitives. Avoid storing Drop-managed structs as set elements until the compiler has complete Drop integration for values stored inside container memory. Hash Set (SetMap(T)) Core API SetMap(T) provides: fn empty (hash: fn(T) -> u64, eq: fn(T, T) -> bool) -> SetMap(T); fn init (cap: i64, hash: fn(T) -> u64, eq: fn(T, T) -> bool) -> std::result::Result(SetMap(T), std::memory::AllocFailed); fn len (self: &SetMap(T)) -> i64; fn isempty (self: &SetMap(T)) -> bool; fn capacity (self: &SetMap(T)) -> i64; fn contains (self: &SetMap(T), key: T) -> bool; fn insert (mut self: &SetMap(T), key: T) -> std::result::Result(bool, std::memory::OutOfMemory); Returns true when key was not already present. fn remove (mut self: &SetMap(T), key: T) -> bool; Returns true when key was present and removed. fn iter (self: &SetMap(T)) -> SetMapIter(T); fn clear (mut self: &SetMap(T)) -> void; fn reserveadditional (mut self: &SetMap(T), additional: i64) -> std::memory::OutOfMemory?; fn drop (mut self: &SetMap(T)) -> void; SetMap.init(cap, ...) validates the requested capacity: cap < 0 returns AllocErrorKind::InvalidInput. very large cap values that would overflow internal sizing arithmetic return AllocErrorKind::Overflow. Complexity expectations: average O(1) for contains/insert/remove when the hash distribution is good, worst case O(n) in adversarial collision patterns. Ordered Set (TreeSet(T)) TreeSet(T) is an ordered set. It requires an ordering function. Core API TreeSet(T) provides: fn init (cmp: fn(T, T) -> int) -> TreeSet(T); Contract: cmp(a, b) < 0 iff a < b; cmp(a, b) == 0 iff keys are equal. fn len (self: &TreeSet(T)) -> i64; fn isempty (self: &TreeSet(T)) -> bool; fn contains (self: &TreeSet(T), key: T) -> bool; fn insert (mut self: &TreeSet(T), key: T) -> std::result::Result(bool, std::memory::OutOfMemory); fn remove (mut self: &TreeSet(T), key: T) -> bool; fn iter (self: &TreeSet(T)) -> TreeSetIter(T); fn clear (mut self: &TreeSet(T)) -> void; fn drop (mut self: &TreeSet(T)) -> void; Complexity expectations: O(log n) lookup/insert/remove. Iteration Both sets provide iteration through an iterator interface: SetMapIter(T) implements std::interfaces::Iterator(T). TreeSetIter(T) implements std::interfaces::Iterator(T). Notes: Iteration is by value (copies out each element). SetMap iteration order is unspecified. TreeSet iteration yields values in ascending order (as defined by cmp)."
    },
    {
      "id": "std/sqlite",
      "title": "`std::sqlite`",
      "section": "std",
      "summary": "primitives for the hosted POSIX baseline using the system `libsqlite3` shared library.",
      "text": "std::sqlite primitives for the hosted POSIX baseline using the system libsqlite3 shared library. The initial goals are: a small but usable database/statement API (Database, Stmt), a non-leaking, portable error model (SqliteFailed) that surfaces stable error kinds while retaining SQLite return codes as structured detail, safe defaults (invalid() handles, idempotent drop()), so resource cleanup is reliable even in early-return code. Linkage and Toolchain Integration On linux/x8664 with the glibc dynamic loader (ld-linux), silk build automatically adds libsqlite3.so.0 as a DTNEEDED dependency when a program imports sqlite3 extern symbols (for example via import std::sqlite;). To build the vendored static library artifact used for embedding and future bundling, run zig build deps. This downloads and extracts the pinned SQLite amalgamation source: upstream: https://www.sqlite.org/2026/sqlite-amalgamation-3510200.zip output staging (hosted baseline): vendor/deps/sqlite-amalgamation-3510200/ (source; ignored), vendor/lib/x64-linux/libsqlite3.a (static library; ignored), vendor/include/sqlite3.h + vendor/include/sqlite3ext.h (headers; ignored). Error Model std::sqlite uses std::result::Result(T, E) and optional-error returns for fallible operations that do not return a value. The stable error value is SqliteFailed: module std::sqlite; export error SqliteFailed { code: int, // stable ERR code rc: int, // primary SQLite rc detail: int, // extended rc when available } Callers that want a portable classification should use SqliteFailed.kind(). The raw SQLite return codes remain available for debugging/telemetry. Handles and Lifetimes Database and Stmt are handle types with safe defaults: Database.invalid() / Stmt.invalid() construct invalid handles. drop() is idempotent and safe to call on invalid handles. Borrowed column accessors: Stmt.columntext(col) -> string? and Stmt.columnblob(col) -> ByteSlice? return views into SQLite-owned memory. These views are valid until the next step/reset/finalize on the same statement. Copy helpers: Stmt.columntextcopy copies into std::strings::String. Stmt.columnblobcopy copies into std::buffer::BufferU8. Current API (Initial) The current std::sqlite surface currently lives in std/sqlite.slk and provides: Database: open, openreadonly, openinmemory, exec, prepare, busytimeoutms, changes, lastinsertrowid, Stmt: bindint, bindi64, bindtext, bindblob, step, reset, clearbindings, column accessors, and finalize/drop."
    },
    {
      "id": "std/ssh2",
      "title": "`std::ssh2`",
      "section": "std",
      "summary": "for the hosted POSIX baseline using the system `libssh2` shared library.",
      "text": "std::ssh2 for the hosted POSIX baseline using the system libssh2 shared library. The initial goals are: a small but usable SSH2 client session API (Session, Channel), an SFTP client API (Sftp, SftpHandle) suitable for remote filesystem access, a non-leaking, portable error model that does not expose raw libssh2 error codes as the primary API surface, pervasive use of Formal Silk theories to document and verify byte-buffer invariants for FFI operations. Linkage and Toolchain Integration On linux/x8664 with the glibc dynamic loader (ld-linux), silk build automatically adds libssh2.so.1 as a DTNEEDED dependency when a program imports libssh2 extern symbols (for example via import std::ssh2;). This mirrors existing behavior for libc.so.6, libsodium.so.23, and libmbedtls.so.14 so downstream users do not have to pass needed libssh2.so.1 for normal hosted builds. To build the vendored static library artifact used for embedding and future bundling, run zig build deps. This stages vendor/lib/x64-linux/libssh2.a from vendor/deps/libssh2 (tag libssh2-1.11.1). The current deps workflow builds libssh2 using the OpenSSL backend. Error Model The std::ssh2 API uses std::result::Result(T, E) and a stable Ssh2Failed error value. The underlying libssh2 error code is retained as structured detail (Ssh2Failed.detail) for debugging and telemetry. Non-blocking I/O is surfaced via Ssh2ErrorKind::WouldBlock (mapped from LIBSSH2ERROREAGAIN). Public error/value types in Silk: module std::ssh2; import std::result; enum Ssh2ErrorKind { OutOfMemory, InvalidInput, WouldBlock, InitFailed, SessionFailed, HandshakeFailed, AuthFailed, ChannelFailed, SftpFailed, KnownHostsFailed, AgentFailed, Unknown, } export error Ssh2Failed { code: int, detail: int, } export type Ssh2IntResult = std::result::Result(int, Ssh2Failed); export type Ssh2I64Result = std::result::Result(i64, Ssh2Failed); export type SessionResult = std::result::Result(Session, Ssh2Failed); export type ChannelResult = std::result::Result(Channel, Ssh2Failed); export type SftpResult = std::result::Result(Sftp, Ssh2Failed); export type SftpHandleResult = std::result::Result(SftpHandle, Ssh2Failed); enum KnownHostCheck { Match, Mismatch, NotFound, } export type KnownHostCheckResult = std::result::Result(KnownHostCheck, Ssh2Failed); // Agent iteration uses Ok(Some(identity)) and Ok(None) for end-of-list. export type AgentNextIdentityResult = std::result::Result(AgentIdentity?, Ssh2Failed); Byte Buffers and Formal Silk std::ssh2 expresses byte-oriented inputs and outputs using the standard packed byte types: std::arrays::ByteSlice \u2014 non-owning { ptr, len } byte view. std::buffer::BufferU8 \u2014 owning { ptr, cap, len } packed byte buffer. FFI entrypoints that accept or fill byte buffers use Formal Silk theories such as slicewellformed(ptr, len) to document shape invariants (len >= 0 and non-null when non-empty). Current API (Initial) The current std::ssh2 surface currently lives in a single module std/ssh2.slk (module std::ssh2;) and provides: Session \u2014 init/free, blocking mode, timeouts, handshake, disconnect, and common authentication helpers, Channel \u2014 open session channels, exec/shell/subsystem, read/write/close, and exit status, Sftp / SftpHandle \u2014 basic SFTP operations and directory iteration, KnownHosts \u2014 OpenSSH knownhosts read/check/write helpers (check returns KnownHostCheckResult), Agent \u2014 ssh-agent integration for publickey auth (nextidentity returns AgentNextIdentityResult). This module may be split into submodules as the stdlib grows to keep the code base navigable and to support additional optional dependency backends."
    },
    {
      "id": "std/stream",
      "title": "`std::stream`",
      "section": "std",
      "summary": "for **byte streams** designed to work well with Silk\u2019s `async`/`task` model.",
      "text": "std::stream for byte streams designed to work well with Silk\u2019s async/task model. The core goals of the are: Ergonomic piping between producers and consumers. Backpressure via bounded buffering. Safe chunk ownership across tasks using an owned Bytes type (no borrowed slice lifetime hazards). Runtime note: ReadableStream.read() / WritableStream.write() are blocking OS-thread operations implemented with mutex/condvar primitives. See also: API module std::stream; import std::arrays; import std::buffer; import std::memory; import std::result; export enum StreamErrorKind { OutOfMemory, InvalidInput, Closed, Full, Cancelled, Aborted, RuntimeFailed, Unknown, } export error StreamFailed { code: int, } impl StreamFailed { public fn kind (self: &StreamFailed) -> StreamErrorKind; } // Owned, immutable byte chunks. export struct Bytes { handle: u64, } export type BytesResult = std::result::Result(Bytes, std::memory::AllocFailed); impl Bytes { public fn empty () -> Bytes; public fn isempty (self: &Bytes) -> bool; public fn len (self: &Bytes) -> i64; public fn asslice (self: &Bytes) -> std::arrays::ByteSlice; public fn copyfrom (slice: std::arrays::ByteSlice) -> BytesResult; public fn copyfromstring (s: string) -> BytesResult; public fn takefrombuffer (mut buf: &std::buffer::BufferU8) -> BytesResult; } // Read outcomes. export enum Read { Done, Pending, Chunk(Bytes), } export type ReadResult = std::result::Result(Read, StreamFailed); // Readable end. export struct ReadableStream { handle: u64, } impl ReadableStream { public fn invalid () -> ReadableStream; public fn isvalid (self: &ReadableStream) -> bool; public fn cap (self: &ReadableStream) -> int; public fn len (self: &ReadableStream) -> int; public fn isclosed (self: &ReadableStream) -> bool; public fn read (self: &ReadableStream) -> ReadResult; public fn tryread (self: &ReadableStream) -> ReadResult; public fn cancel (self: &ReadableStream) -> void; public fn destroy (mut self: &ReadableStream) -> void; } // Writable end. export struct WritableStream { handle: u64, } impl WritableStream { public fn invalid () -> WritableStream; public fn isvalid (self: &WritableStream) -> bool; public fn cap (self: &WritableStream) -> int; public fn len (self: &WritableStream) -> int; public fn isclosed (self: &WritableStream) -> bool; public fn write (self: &WritableStream, mut chunk: Bytes) -> StreamFailed?; public fn trywrite (self: &WritableStream, mut chunk: Bytes) -> StreamFailed?; public fn close (self: &WritableStream) -> void; public fn abort (self: &WritableStream, err: StreamFailed) -> void; public fn destroy (mut self: &WritableStream) -> void; } // A paired in-memory stream (writable \u2192 readable). export struct PassThroughStream { readable: ReadableStream, writable: WritableStream, } export type PassThroughResult = std::result::Result(PassThroughStream, StreamFailed); impl PassThroughStream { public fn initdefault () -> PassThroughResult; public fn init (cap: int) -> PassThroughResult; public fn takereadable (mut self: &PassThroughStream) -> ReadableStream; public fn takewritable (mut self: &PassThroughStream) -> WritableStream; } // Transformer output. export type TransformBytesResult = std::result::Result(Bytes, StreamFailed); // A paired transform stage. export struct TransformStream { readable: ReadableStream, writable: WritableStream, transformreadable: ReadableStream, transformwritable: WritableStream, } export type TransformResult = std::result::Result(TransformStream, StreamFailed); impl TransformStream { public fn initdefault () -> TransformResult; public fn init (cap: int) -> TransformResult; public fn initwithcaps (capin: int, capout: int) -> TransformResult; public fn takereadable (mut self: &TransformStream) -> ReadableStream; public fn takewritable (mut self: &TransformStream) -> WritableStream; public fn taketransformreadable (mut self: &TransformStream) -> ReadableStream; public fn taketransformwritable (mut self: &TransformStream) -> WritableStream; } // Pipe a readable into a writable until done. export fn pipeto (mut src: ReadableStream, mut dst: WritableStream) -> std::result::Result(int, StreamFailed); Semantics Backpressure Each stream has a bounded in-memory queue. The cap is expressed in chunks (Bytes values), not bytes: PassThroughStream.init(cap) / TransformStream.init(cap) require cap > 0 (otherwise they return Err(StreamFailed) with kind() == InvalidInput). WritableStream.write() blocks while the queue is full. ReadableStream.read() blocks while the queue is empty (until closed or errored). Close vs cancel vs abort WritableStream.close(): graceful end-of-stream, readers drain remaining buffered chunks and then observe Read::Done. ReadableStream.cancel(): marks the stream cancelled, discards buffered chunks, causes writers to fail with a Cancelled error. WritableStream.abort(err): marks the stream aborted with err, discards buffered chunks, causes readers to return Err(err) from read / tryread. Transform streams TransformStream models a Web Streams-style transform stage. In Silk, std::stream does not attach a transformer callback internally. Instead, TransformStream exposes two bounded pipes and expects you to run the transform loop in a task: input pipe: producers write to writable, transformer reads from transformreadable, output pipe: transformer writes to transformwritable, consumers read from readable. This design composes naturally with task-based structured concurrency: run the transform loop in a task and rely on backpressure to bound memory. Usage patterns Producer \u2192 consumer (tasks) import std::stream; task fn producer (w: std::stream::WritableStream) -> int { ... } task fn consumer (r: std::stream::ReadableStream) -> int { ... } async fn main () -> int { task { let ptr = std::stream::PassThroughStream.initdefault(); if ptr.iserr() { return 1; } let mut pt: std::stream::PassThroughStream = match (ptr) { Ok(v) => v, Err() => std::stream::PassThroughStream{ readable: std::stream::ReadableStream.invalid(), writable: std::stream::WritableStream.invalid(), }, }; let w = (mut pt).takewritable(); let r = (mut pt).takereadable(); let hp = producer(w); let hc = consumer(r); let rp: int = (yield hp)[0]; let rc: int = (yield hc)[0]; if rp != 0 { return rp; } if rc != 0 { return rc; } return 0; } } Transform stage (tasks) TransformStream is a pair of pipes intended to be driven by a transformer task. Typical wiring: producer writes to takewritable(), transformer reads from taketransformreadable() and writes to taketransformwritable(), consumer reads from takereadable(). Piping pipeto is a structured copy loop: closes dst when src ends, aborts/cancels on error. import std::stream; fn runpipeline (src: std::stream::ReadableStream, dst: std::stream::WritableStream) -> int { let r = std::stream::pipeto(src, dst); return match (r) { Ok() => 0, Err() => 1, }; } Notes The uses blocking primitives; it is intended to become suspension-friendly once the async runtime exists. Drop semantics are designed to avoid leaked pipes: dropping ReadableStream cancels the stream (writers start failing), dropping WritableStream closes the stream (readers observe Read::Done after draining). PassThroughStream.takereadable / takewritable exist to make ownership transfer ergonomic in Silk (moving out of struct fields is limited)."
    },
    {
      "id": "std/strings",
      "title": "`std::strings`",
      "section": "std",
      "summary": "implemented in `std/strings.slk` to support early toolchain bring-up; the rest of this document describes the intended long-term API.",
      "text": "std::strings implemented in std/strings.slk to support early toolchain bring-up; the rest of this document describes the intended long-term API. This module provides string utilities and abstractions built on top of the core string type (UTF-8 bytes) and the Buffer(T) intrinsic. See also: Current API The following functions exist today in std/strings.slk and are available to import: module std::strings; export fn eq (a: string, b: string) -> bool; export fn ne (a: string, b: string) -> bool; export fn lt (a: string, b: string) -> bool; export fn le (a: string, b: string) -> bool; export fn gt (a: string, b: string) -> bool; export fn ge (a: string, b: string) -> bool; export fn isempty (s: string) -> bool; export fn orempty (s: string?) -> string; export fn trim (s: string) -> string; export fn trimstart (s: string) -> string; export fn trimend (s: string) -> string; export fn padleft (s: string, minlen: i64, pad: string) -> std::result::Result(String, std::memory::OutOfMemory); export fn padright (s: string, minlen: i64, pad: string) -> std::result::Result(String, std::memory::OutOfMemory); export fn padcenter (s: string, minlen: i64, pad: string) -> std::result::Result(String, std::memory::OutOfMemory); Notes: These are simple wrappers over the language\u2019s built-in string comparisons and optional-coalesce operator (??), chosen because they are implementable in the compiler. This surface will grow alongside language/runtime features required for richer string operations (slicing, iteration, allocation, etc.). In addition, a low-level StringBuilder type exists today for incremental byte construction: struct StringBuilder { ptr: u64, cap: i64, len: i64, } impl StringBuilder { public fn init (cap: i64) -> std::result::Result(StringBuilder, std::memory::AllocFailed); public fn empty () -> StringBuilder; public fn pushu8 (mut self: &StringBuilder, value: u8) -> std::memory::OutOfMemory?; public fn popu8 (mut self: &StringBuilder) -> u8?; public fn getu8 (self: &StringBuilder, index: i64) -> u8; public fn setu8 (mut self: &StringBuilder, index: i64, value: u8) -> void; public fn intostring (mut self: &StringBuilder) -> std::result::Result(String, std::memory::OutOfMemory); } impl StringBuilder as std::interfaces::ReserveAdditional { public fn reserveadditional (mut self: &StringBuilder, additional: i64) -> std::memory::OutOfMemory?; } Notes: StringBuilder builds raw bytes. It can be converted into an owned String via intostring; the resulting String can then yield a borrowed string view via String.asstring(). StringBuilder allocation failure is recoverable: init(cap) returns Err(AllocFailed) when the initial allocation fails (or when cap is invalid), empty() exists for infallible construction, growth paths (pushu8, reserveadditional, intostring) return std::memory::OutOfMemory? / Result(...) and leave the builder unchanged on failure (including internal size arithmetic overflow). StringBuilder conforms to common std::interfaces protocols: Len, Capacity, IsEmpty, Clear, ReserveAdditional, WriteU8, and Drop. An owned String type exists today for dynamically produced strings: struct String { ptr: u64, cap: i64, len: i64, } impl String { public fn empty () -> String; public fn fromstring (s: string) -> std::result::Result(String, std::memory::OutOfMemory); public fn frombufferu8 (mut v: &std::buffer::BufferU8) -> std::result::Result(String, std::memory::OutOfMemory); public fn asstring (self: &String) -> string; public fn pushu8 (mut self: &String, value: u8) -> std::memory::OutOfMemory?; public fn pushstring (mut self: &String, s: string) -> std::memory::OutOfMemory?; public fn pushrepeatu8 (mut self: &String, byte: u8, count: i64) -> std::memory::OutOfMemory?; public fn trim (mut self: &String) -> void; public fn trimstart (mut self: &String) -> void; public fn trimend (mut self: &String) -> void; public fn padleft (mut self: &String, minlen: i64, pad: string) -> std::memory::OutOfMemory?; public fn padright (mut self: &String, minlen: i64, pad: string) -> std::memory::OutOfMemory?; public fn padcenter (mut self: &String, minlen: i64, pad: string) -> std::memory::OutOfMemory?; } Notes: The current String maintains a trailing NUL terminator so the string view it yields is safe to pass to C APIs that expect const char . The current String implementation does not validate UTF\u20118. String.asstring() yields a non-owning view into the String allocation; callers must not use the returned string after the String is dropped. Scope std::strings is responsible for: Construction, slicing, and concatenation. UTF-8-aware utilities (iteration by char, validation when constructing from raw bytes). Interoperability with FFI (SilkString, C-string compatibility). Non-goals (initially): Locale-aware collation and normalization (future work). Full Unicode grapheme segmentation (future work). Core Types (Initial Design) The language provides a built-in string type (an immutable UTF-8 byte sequence). The stdlib adds: Str \u2014 a non-owning view over UTF-8 bytes (useful when the caller wants an explicit view type rather than string). String \u2014 an owning, growable UTF-8 string backed by Buffer(u8) plus a length (a dynamic array of bytes that maintains UTF-8 validity). StringBuilder \u2014 a convenience for incremental construction; typically a thin wrapper around String or a packed byte buffer (for example std::buffer::BufferU8). Key invariants: String must always contain valid UTF-8. When converting a String to a string for FFI, the backing storage must be null-terminated (with the trailing \\0 byte not counted in .len), matching API Sketch (Illustrative) These signatures are illustrative and will be refined alongside the language features required to implement them (references, generics, enums/results, etc.). module std::strings; export struct String { // Invariant: buf[0..len] is valid UTF-8; buf[len] == 0 for C interop. buf: Buffer(u8), len: int, } export fn empty () -> String; export fn fromstring (alloc: std::memory::Allocator, s: string) -> String; export fn fromutf8 (alloc: std::memory::Allocator, bytes: std::arrays::Slice(u8)) -> Result(String, Utf8Error); export fn asstring (s: &String) -> string; export fn lenbytes (s: string) -> int; export fn isempty (s: string) -> bool; export fn startswith (s: string, prefix: string) -> bool; export fn endswith (s: string, suffix: string) -> bool; export fn find (s: string, needle: string) -> int?; export fn concat (alloc: std::memory::Allocator, a: string, b: string) -> String; FFI Interop string values crossing the C ABI use SilkString { ptr, len } as documented std::strings should provide helpers for common interop patterns: Passing string to C APIs that expect const char (use .ptr; Silk\u2019s runtime representation guarantees a trailing NUL). Producing an owned, NUL-terminated string for FFI calls that require the backing storage to outlive the call (e.g. when C stores the pointer). Future Work split, replace, join. UTF-8 scalar iteration (chars()), case mapping, and normalization. Formatting integration (shared with std::io). Implementation must respect the ownership and lifetime rules from"
    },
    {
      "id": "std/sync",
      "title": "`std::sync`",
      "section": "std",
      "summary": "synchronization primitives used by the current `task` lowering on `linux/x86_64`.",
      "text": "std::sync synchronization primitives used by the current task lowering on linux/x8664. This is an intentionally narrow subset intended for early bring-up: It is intentionally small and conservative (a hosted baseline, not a final async runtime). It uses a simple handle-based representation backed by heap-allocated state and runtime-provided synchronization primitives (std::runtime::sync, which defaults to a POSIX/pthread backend in the shipped stdlib). All blocking operations block the current OS thread. See also: API module std::sync; import std::result; enum SyncErrorKind { OutOfMemory, InvalidInput, Closed, Full, RuntimeFailed, Unknown, } export error SyncFailed { code: int, } // A pthread-backed mutex handle. struct Mutex { handle: u64, } impl Mutex { public fn invalid () -> Mutex; public fn isvalid (self: &Mutex) -> bool; public fn init () -> std::result::Result(Mutex, SyncFailed); public fn lock (self: &Mutex) -> SyncFailed?; public fn unlock (self: &Mutex) -> SyncFailed?; public fn destroy (mut self: &Mutex) -> void; } // A pthread-backed condition variable handle. struct Condvar { handle: u64, } impl Condvar { public fn invalid () -> Condvar; public fn isvalid (self: &Condvar) -> bool; public fn init () -> std::result::Result(Condvar, SyncFailed); public fn wait (self: &Condvar, m: &Mutex) -> SyncFailed?; public fn signal (self: &Condvar) -> SyncFailed?; public fn broadcast (self: &Condvar) -> SyncFailed?; public fn destroy (mut self: &Condvar) -> void; } // A bounded channel of T values. struct Channel(T) { handle: u64, } // A non-owning, copyable view of a channel handle. struct ChannelBorrow(T) { handle: u64, } impl Channel(T) { public fn invalid () -> Channel(T); public fn initdefault () -> std::result::Result(Channel(T), SyncFailed); public fn init (cap: int) -> std::result::Result(Channel(T), SyncFailed); public fn borrow (self: &Channel(T)) -> ChannelBorrow(T); public fn cap (self: &Channel(T)) -> int; public fn len (self: &Channel(T)) -> int; public fn isclosed (self: &Channel(T)) -> bool; public fn trysend (self: &Channel(T), value: T) -> SyncFailed?; public fn send (self: &Channel(T), value: T) -> SyncFailed?; public fn tryrecv (self: &Channel(T)) -> T?; public fn recv (self: &Channel(T)) -> T?; public fn close (self: &Channel(T)) -> void; public fn destroy (mut self: &Channel(T)) -> void; } impl ChannelBorrow(T) { public fn send (self: &ChannelBorrow(T), value: T) -> SyncFailed?; } // A simple cancellation token (blocking wait). struct CancellationToken { handle: u64, } // A non-owning, copyable view of a cancellation token handle. struct CancellationTokenBorrow { handle: u64, } impl CancellationToken { public fn invalid () -> CancellationToken; public fn isvalid (self: &CancellationToken) -> bool; public fn init () -> std::result::Result(CancellationToken, SyncFailed); public fn borrow (self: &CancellationToken) -> CancellationTokenBorrow; public fn cancel (self: &CancellationToken) -> void; public fn iscancelled (self: &CancellationToken) -> bool; public fn wait (self: &CancellationToken) -> void; public fn destroy (mut self: &CancellationToken) -> void; } impl CancellationTokenBorrow { public fn cancel (self: &CancellationTokenBorrow) -> void; public fn iscancelled (self: &CancellationTokenBorrow) -> bool; public fn wait (self: &CancellationTokenBorrow) -> void; } Notes: Mutex.init, Condvar.init, and CancellationToken.init return Result(...). Channel(T).init / initdefault return Result(...). Channel(T).invalid() returns an inert handle (handle == 0); operations treat it as closed/empty and return InvalidInput for sends. CancellationToken.invalid() returns an inert handle; it is treated as already cancelled so waits do not block. Handle types are trivially copyable in the current language subset; copying a handle duplicates the pointer. Destroying (or dropping) any copy invalidates the others. When sending a channel handle across a task boundary, prefer passing a non-owning view (ChannelBorrow(T)) obtained via c.borrow() so ownership stays with the original Channel(T). When sending a cancellation token across a task boundary, prefer passing a non-owning view (CancellationTokenBorrow) obtained via tok.borrow() so ownership stays with the original CancellationToken. Condvar.wait(self: &Condvar, m: &Mutex) is called as cv.wait(m) \u2014 the compiler implicitly borrows the m binding for &T parameters (there is no general &expr operator in Silk). Channel(T).recv() returns None once the channel is closed and empty. Channel(T).trysend() returns Some(SyncFailed) when the channel is closed or full. Channel(T).tryrecv() returns None when the channel is empty. Use isclosed() to distinguish between \u201cempty\u201d and \u201cclosed and empty\u201d when needed."
    },
    {
      "id": "std/task",
      "title": "`std::task`",
      "section": "std",
      "summary": "task/runtime utilities on `linux/x86_64`.",
      "text": "std::task task/runtime utilities on linux/x8664. This is not the full async runtime design. There is not yet a coroutine transform or event loop in the compiler/runtime, so yield/yield , await, and the helpers below may block the current OS thread. See also: API module std::task; enum SleepUntilErrorKind { NoMonotonicClock, Unknown } error SleepUntilFailed { code: int } // Return the number of logical CPUs available (>= 1). export fn availableparallelism () -> int; // Hint to the OS scheduler that the current thread can yield. export fn yieldnow () -> void; // Block the current OS thread for at least ms milliseconds. export fn sleepms (ms: int) -> void; // Block the current OS thread for at least d. export fn sleep (d: Duration) -> void; // Block the current OS thread until deadline (monotonic time). export fn sleepuntil (deadline: Instant) -> SleepUntilFailed?; Notes: availableparallelism() is intended to be used by future schedulers and higher-level concurrency utilities. It is implemented using a hosted libc query (getnprocs) and clamps to >= 1. yieldnow() and sleepms() are blocking thread operations (they are not async-aware until an event loop exists). sleepms(ms) is implemented by converting ms to microseconds and calling std::runtime::task::sleepus; large sleeps may be performed in chunks. sleep(d) is a blocking thread operation and is implemented using usleep (microsecond resolution, rounded up). sleepuntil(deadline) is a blocking thread operation and is implemented by reading std::temporal::nowmonotonic() and calling sleep(deadline - now). It returns Some(SleepUntilFailed{ ... }) when a monotonic clock read fails (std::temporal::nowmonotonic() returns Err(...)). Implementation note: In the shipped stdlib, std::task delegates its OS-facing behavior to the pluggable runtime interface std::runtime::task (which defaults to a POSIX backend under std::runtime::posix::task)."
    },
    {
      "id": "std/temporal",
      "title": "`std::temporal`",
      "section": "std",
      "summary": "is implemented in `std/temporal.slk`:",
      "text": "std::temporal is implemented in std/temporal.slk: Instant/Duration convenience helpers, plus pure calendar/time utilities (Date, TimeOfDay, DateTime) that do not depend on OS clocks. A hosted monotonic clock source (nowmonotonic) is implemented via std::runtime::time. The runtime also exposes Unix wall-clock timestamps via unixnowns / unixnowms, but higher-level UTC/local timestamp helpers remain future work. std::temporal provides utilities built around the Instant and Duration model for date/time computations. See also: API The following helpers exist today in std/temporal.slk and are available to import. module std::temporal; export let NANOSECOND: Duration = 1ns; export let MICROSECOND: Duration = 1us; export let MILLISECOND: Duration = 1ms; export let SECOND: Duration = 1s; export let MINUTE: Duration = 1min; export let HOUR: Duration = 1h; export let DAY: Duration = 1d; export fn durationzero () -> Duration; export fn iszero (d: Duration) -> bool; export fn isnegative (d: Duration) -> bool; export fn durationabs (d: Duration) -> Duration; export fn durationtosecstrunc (d: Duration) -> i64; export fn durationfromsecs (seconds: i64) -> Duration; export fn add (t: Instant, d: Duration) -> Instant; export fn sub (t: Instant, d: Duration) -> Instant; export fn since (later: Instant, earlier: Instant) -> Duration; export fn before (a: Instant, b: Instant) -> bool; export fn after (a: Instant, b: Instant) -> bool; enum TemporalErrorKind { OutOfMemory, NoMonotonicClock, InvalidInput, Overflow, Unknown } error TemporalFailed { code: int, requested: i64 } export type InstantResult = std::result::Result(Instant, TemporalFailed); export type TemporalStringResult = std::result::Result(std::strings::String, TemporalFailed); export fn nowmonotonic () -> InstantResult; struct Date { year: int, month: int, day: int } struct TimeOfDay { hour: int, minute: int, second: int, nanosecond: int } struct DateTime { date: Date, time: TimeOfDay } // Validation + construction (pure; returns optional on invalid inputs). Date.tryfromymd(year: int, month: int, day: int) -> Date?; TimeOfDay.tryfromhmsnano(hour: int, minute: int, second: int, nanosecond: int) -> TimeOfDay?; DateTime.tryfromdatetime(date: Date, time: TimeOfDay) -> DateTime?; // Unix conversions (UTC; pure). Days are relative to 1970-01-01. Date.tounixdays(self: &Date) -> i64?; Date.fromunixdays(days: i64) -> Date; Date.isoweekday(self: &Date) -> int?; TimeOfDay.tonanosofday(self: &TimeOfDay) -> i64?; TimeOfDay.fromnanosofday(ns: i64) -> TimeOfDay?; DateTime.tounixtimestampns(self: &DateTime) -> i64?; DateTime.fromunixtimestampns(ns: i64) -> DateTime?; // Formatting/parsing (strict ISO-8601 subsets; allocation in formatting). export fn formatdateiso (d: Date) -> TemporalStringResult; export fn formattimeiso (t: TimeOfDay) -> TemporalStringResult; export fn formatdatetimeiso (dt: DateTime) -> TemporalStringResult; enum ParseErrorKind { InvalidInput, InvalidLength, InvalidDigit, InvalidSeparator, InvalidRange, TrailingInput, Unknown } error ParseError { code: int, offset: i64 } export type DateParseResult = std::result::Result(Date, ParseError); export type TimeParseResult = std::result::Result(TimeOfDay, ParseError); export type DateTimeParseResult = std::result::Result(DateTime, ParseError); export fn parsedateiso (s: string) -> DateParseResult; export fn parsetimeiso (s: string) -> TimeParseResult; export fn parsedatetimeiso (s: string) -> DateTimeParseResult; Scope std::temporal is responsible for: Access to time sources: a monotonic clock for measuring durations (Instant), a wall-clock time source (UTC/local timestamps) for DateTime (future work). Conversions between units and convenience helpers for Duration. Pure calendar/time computations that do not require OS services: validation and construction of Date, TimeOfDay, and DateTime, Unix epoch conversions (days/seconds/nanoseconds), strict ISO formatting/parsing helpers. Clock APIs (Initial Design) The language examples use std::now(); the stdlib should make the clock source explicit: std::temporal currently exposes only a monotonic clock read: Notes: nowmonotonic() must be monotonic (not subject to wall-clock adjustments). Sleeping is exposed via std::task (sleep / sleepuntil) in the current stdlib. Duration Helpers Duration literals exist at the language level. The stdlib adds helpers such as: tomillis(d), tosecs(d) checked arithmetic (checkedadd, checkedmul) where overflow behavior needs to be explicit. Future Work Wall-clock time (nowutc, nowlocal) via higher-level wrappers on top of std::runtime::time::unixnowns / unixnowms. Time zones and DST rules (separate module layered on top of DateTime). Richer formatting/parsing (locale-aware, RFCs) layered on top of std::fmt."
    },
    {
      "id": "std/test",
      "title": "`std::test`",
      "section": "std",
      "summary": "record test failures without aborting the process.",
      "text": "std::test record test failures without aborting the process. These helpers are intended to be used under silk test and integrate with the Each helper also carries a Formal Silk contract requiring BUILDMODE == \"test\" via std::formal.requirestestmode() so downstream verification can model them as test-only APIs. Public API expect expect(ok: bool, message: string? = None); Semantics: When ok is true, expect does nothing. When ok is false, expect records a test failure. When message is Some(...), it is used as the failure message. When message is None, the default message is \"expect failed\". expectequal fn (X, Y) expectequal (expected: X, actual: Y) -> bool; Semantics: Returns true when expected == (actual as X) and records no failure. Returns false when expected != (actual as X) and records a failure. Note: in Silk, equality must be supported for the concrete instantiated types used at the call site. expecterror fn (E) expecterror (err: E?) -> bool; Semantics: Returns true when err is Some(...). Returns false when err is None and records a failure."
    },
    {
      "id": "std/tls",
      "title": "`std::tls`",
      "section": "std",
      "summary": "primitives for the hosted POSIX baseline using the system `mbedTLS` shared libraries.",
      "text": "std::tls primitives for the hosted POSIX baseline using the system mbedTLS shared libraries. The initial goals are: a small but usable std::tls session API for clients and servers, a transport-agnostic I/O model so TLS can be layered over std::net::TcpStream or custom runtimes , end-to-end runnable tests that do not depend on real sockets (to keep the test suite runnable in sandboxed environments). Linkage and Toolchain Integration On linux/x8664 with the glibc dynamic loader (ld-linux), silk build automatically adds libmbedtls.so.14 as a DTNEEDED dependency when a program imports mbedtls extern symbols (for example via import std::tls;). Because libmbedtls.so.14 declares DTNEEDED dependencies on libmbedx509.so.1 and libmbedcrypto.so.7, downstream users typically do not need to list those libraries explicitly. API Error model The current std::tls API uses std::result::Result(T, E) and a stable TlsFailed error value instead of exposing raw mbedTLS error codes. TLS I/O is transport-driven: when using a non-blocking transport (such as MemPipe), operations may report that they would block and must be retried. This is surfaced as a TlsFailed whose kind() is: TlsErrorKind::WouldBlockRead TlsErrorKind::WouldBlockWrite Public error/value types in Silk: module std::tls; import std::result; enum TlsErrorKind { OutOfMemory, InvalidInput, BadCertificate, BadPrivateKey, ConfigFailed, SetupFailed, WouldBlockRead, WouldBlockWrite, TlsFailure, Unknown, } export error TlsFailed { code: int, } export type TlsIntResult = std::result::Result(int, TlsFailed); export type SessionResult = std::result::Result(Session, TlsFailed); Session Session is a TLS state machine configured as either a client or a server. Key operations: Session.client() -> SessionResult \u2014 create a client session with a default configuration suitable for tests. Session.server(certpem: string, keypem: string) -> SessionResult \u2014 create a server session using PEM-encoded certificate and private key. setbiomempipe(bio: u64) -> void \u2014 attach a MemPipe endpoint context via mbedTLS sslsetbio using std::tls::memsend and std::tls::memrecv. setbiofd(fd: int) -> void \u2014 attach a hosted POSIX file descriptor as the underlying stream transport (for example a std::net::TcpStream socket). handshakestep() -> TlsIntResult \u2014 advance the handshake state machine by one call (returns Ok(0) when complete; Err(...) on error). read(buf: std::arrays::ByteSlice) -> TlsIntResult \u2014 read decrypted application bytes. write(buf: std::arrays::ByteSlice) -> TlsIntResult \u2014 write application bytes. writeall(buf: std::arrays::ByteSlice) -> TlsFailed? \u2014 write all application bytes (retries internally on WouldBlockRead / WouldBlockWrite). writestring(s: string) -> TlsFailed? \u2014 convenience helper over writeall. closenotify() -> TlsFailed? \u2014 send a TLS close-notify alert. Session implements std::interfaces::Drop and releases all associated mbedTLS state on drop. MemPipe MemPipe is an in-memory transport used for tests and for embedding scenarios where the TLS peer-to-peer byte stream is modeled explicitly. It provides two endpoint context pointers: clientctx() -> u64 serverctx() -> u64 These pointers can be passed to Session.setbiomempipe(...). Notes and Limitations The current std::tls API is intentionally small; higher-level features (hostname verification, CA stores, ALPN, session resumption, etc.) will be specified and implemented as the language and stdlib grow. The wires Session to transports via MemPipe and hosted POSIX file descriptors (setbiofd). General user-provided transport callbacks are planned but require additional FFI expressiveness beyond the current compiler subset. The initial tests use MemPipe instead of real sockets so make test can run in environments where socket(2) is restricted."
    },
    {
      "id": "std/toml",
      "title": "`std::toml`",
      "section": "std",
      "summary": "builds an index-based DOM suitable for the compiler.",
      "text": "std::toml builds an index-based DOM suitable for the compiler. Primary goals: Correct, spec-driven parsing of TOML v1.0 documents: key/value pairs, dotted keys, tables ([table]) and array-of-tables ([[table]]), strings, integers, floats, booleans, datetimes, arrays, inline tables. A memory model that works well with the: parse produces an index-based DOM stored inside a Document, arrays/tables are represented via integer \u201cnext\u201d links (no &T struct fields). High performance by default: borrowed parsing avoids allocating for simple strings/numbers by slicing into the input string, allocations are only performed for escaped strings and for owned parsing. Data Model The DOM is represented by an index table owned by a Document: A Document owns: node tables (tag, payload fields, sibling links), optional owned allocations for decoded strings and owned lexemes. TOML values are referred to by ValueId (an i64 node index). Tables store a linked list of member nodes (key/value pairs). Arrays store a linked list of element nodes. Strings Basic strings (\"...\") support TOML escapes including Unicode \\\\uXXXX / \\\\UXXXXXXXX. Literal strings ('...') do not interpret escapes. Multiline basic/literal strings (\\\"\\\"\\\"...\\\"\\\"\\\" and '''...''') are parsed, including TOML\u2019s line-ending normalization rules. Parsed string values are exposed as UTF-8 string views: when the source contains no escapes and borrowed parsing is used, the string view points into the input (zero-copy), otherwise, decoded bytes are stored in an owned allocation tracked by the Document. Numbers std::toml preserves numeric lexemes as string views and provides helpers to interpret them as i64 and/or f64 when needed: integers support separators and 0x/0o/0b bases, floats support separators, fractional/exponent forms, and special values. Datetimes TOML datetime values are preserved as lexeme string views. A future version of std::toml will integrate with std::temporal once the necessary infrastructure is stable. Parsing Two parse modes are provided as Document methods: Borrowed: doc.parse(s) borrows unescaped strings and numeric/datetime lexemes from s. The caller must ensure s outlives any string views read from doc. Owned: doc.parseowned(s) copies all strings and lexemes into allocations tracked by doc (independent of s). Both methods: clear the Document first, return ParseResult (Ok(root) on success, Err(ParseError) on error), and record the result on the Document: doc.isok() reports success, doc.rootvalue() returns the root ValueId on success, doc.err contains the parse error details (kind, byte offset, and 1-based line/column). Allocation failures are also reported as ordinary parse errors: on out-of-memory, parse returns Err(ParseError{ kind: ERROUTOFMEMORY, ... }) and sets doc.err.kind to ERROUTOFMEMORY. In the current executable backend subset, Document is typically used as a heap reference: import std::toml; let mut doc: &Document = new Document(); let rootr: std::toml::ParseResult = (mut doc).parse(a = 1); Planned Follow-ups Streaming tokenization (SAX-style) for very large inputs. Canonical TOML emission/serialization once the DOM/query surface stabilizes. Rich datetime parsing and integration with std::temporal."
    },
    {
      "id": "std/unicode",
      "title": "`std::unicode`",
      "section": "std",
      "summary": "This module provides practical Unicode helpers focused on:",
      "text": "std::unicode This module provides practical Unicode helpers focused on: code point classification (whitespace, identifier rules, casing metadata), surfaces that are easy to support in Silk. API module std::unicode; export fn iswhitespace (c: char) -> bool; export fn isidstart (c: char) -> bool; export fn isidcontinue (c: char) -> bool; export fn iscased (c: char) -> bool; export fn iscaseignorable (c: char) -> bool; Notes: These helpers classify a single Unicode scalar value (char). String-level Unicode features (normalization, grapheme segmentation, etc.) are future work and require UTF-8 decoding APIs. Related Documents"
    },
    {
      "id": "std/url",
      "title": "`std::url`",
      "section": "std",
      "summary": "This module focuses on:",
      "text": "std::url This module focuses on: WHATWG URL parsing (absolute and relative-with-base). Canonical URL serialization (href) and origin serialization (origin). Host parsing (domain / IPv4 / IPv6 / opaque) and percent-encoding sets. URLSearchParams-style query parsing and mutation. Public API Parsing parse(input: string) -> URLResult Parses an absolute URL (requires a scheme). parsewithbase(input: string, base: &URL) -> URLResult Parses input as a URL relative to base using WHATWG relative resolution rules. URLResult is std::result::Result(URL, ParseError): Ok(URL) on success. Err(ParseError) on error. Since URL owns heap allocations and implements std::interfaces::Drop, prefer match (r) to extract values rather than URLResult.okvalue(r) / URLResult.errvalue(r). ParseError.offset is a byte offset into the sanitized input: leading/trailing ASCII whitespace is trimmed, ASCII tab/newline bytes are stripped (\\\\t, \\\\n, \\\\r). ParseError.kind is one of the exported ERR constants. Use errormessage(kind) to format a human-readable message. Note: there is also a convenience method URL.parse(input: string) -> URLResult which forwards to std::url::parse. URL record URL is an owned URL record with accessor methods: URL owns heap allocations and implements std::interfaces::Drop; it is released automatically at scope exit and may also be dropped explicitly via (mut url).drop(). href() -> std::result::Result(std::strings::String, std::memory::OutOfMemory) \u2014 canonical serialization of the full URL. origin() -> std::result::Result(std::strings::String, std::memory::OutOfMemory) \u2014 serialized origin (opaque origins serialize as \"null\"). scheme() -> string username() -> string password() -> string host() -> string? \u2014 hostname (no port); None for null hosts. port() -> int? path() -> string query() -> string? \u2014 query without ?. fragment() -> string? \u2014 fragment without #. URLSearchParams URLSearchParams stores a URL-encoded query string and exposes common operations: URLSearchParams owns its query buffer and implements std::interfaces::Drop. URLSearchParams.empty() -> URLSearchParams URLSearchParams.fromstring(s: string) -> std::result::Result(URLSearchParams, std::memory::OutOfMemory) Accepts either \"a=b&c=d\" or \"?a=b&c=d\". tostring() -> std::result::Result(std::strings::String, std::memory::OutOfMemory) \u2014 the encoded query string (no leading ?). len() -> i64 \u2014 number of fields. has(name: string) -> std::result::Result(bool, std::memory::OutOfMemory) get(name: string) -> std::result::Result(std::strings::String?, std::memory::OutOfMemory) \u2014 decoded value (Ok(Some(value))), Ok(None) when absent, or Err(OutOfMemory). append(name: string, value: string) -> std::memory::OutOfMemory? delete(name: string) -> std::memory::OutOfMemory? set(name: string, value: string) -> std::memory::OutOfMemory? sort() -> std::memory::OutOfMemory? \u2014 stable sort by decoded name, then re-serialize. Notes This module does not implement the JavaScript URL object API (setters, live searchParams binding, etc.); it provides a low-level URL record plus helpers that follow the WHATWG parsing and serialization rules."
    },
    {
      "id": "std/uuid",
      "title": "`std::uuid`",
      "section": "std",
      "summary": "identifier primitive with full support for UUID versions **1, 3, 4, 5, 6, 7, and 8** (RFC 4122 + RFC 9562 family).",
      "text": "std::uuid identifier primitive with full support for UUID versions 1, 3, 4, 5, 6, 7, and 8 (RFC 4122 + RFC 9562 family). Goals: a small, auditable implementation (no external dependencies required for parsing/formatting and name-based UUIDs), explicit constructors for each UUID version, ergonomic helpers (parse, format, version/variant inspection), Formal Silk contracts for buffer and shape preconditions. Representation UUID is represented as two u64 words: hi: the first 8 bytes (bytes 0..7) in network order, lo: the last 8 bytes (bytes 8..15) in network order. This matches the canonical string form: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx where the leftmost hex pairs correspond to lower byte indices. Parsing and Formatting The current API supports: parsing: canonical hyphenated form (8-4-4-4-12 hex digits), optional surrounding braces ({...}), optional urn:uuid: prefix, formatting: canonical hyphenated lowercase string form. API notes: std::uuid::parse(s: string) -> std::uuid::ParseResult returns Ok(UUID) on success, otherwise Err(ParseError). ParseError.kind() reports a stable error kind. ParseError.offset reports the byte offset into the original input string. UUID.tostringlower() -> Result(String, OutOfMemory) allocates an owned string. Version and Variant UUID.version() returns the 4-bit version field (0..15). UUID.isrfc4122() checks the RFC 4122/RFC 9562 variant (10xx in the variant field). Supported Versions The std surface provides constructors for: v1: time-based (Gregorian epoch, 100ns ticks) with { timestamp100ns, clockseq, node } inputs. v3: name-based (MD5 over namespace name). v4: random-based (122 random bits + version/variant bits). v5: name-based (SHA-1 over namespace name). v6: reordered time-based (same inputs as v1; timestamp bits reordered for lexical sorting). v7: Unix-epoch time-based (48-bit milliseconds + 74 random bits). v8: custom (caller-provided 128-bit value with version/variant applied). Fallibility: std::uuid::{v1,v3,v5,v6,v7} return std::uuid::UUIDResult (Result(UUID, UUIDFailed)). std::uuid::timestamp100nsfromunixns returns Result(u64, UUIDFailed) and may fail with Overflow. std::uuid::random:: returns std::uuid::UUIDResult and may fail due to InitFailed (libsodium) or NoTime (missing clock). std::uuid::random also provides v1now / v6now / v7now using std::runtime::time::unixnowns / unixnowms so callers can generate UUIDs without passing explicit timestamps. richer formatting options (uppercase, simple hex, braced form, URN form), UUIDv2 (DCE Security) if/when std::process exposes stable UID/GID APIs."
    },
    {
      "id": "std/vector",
      "title": "`std::vector`",
      "section": "std",
      "summary": "vector type `Vector(T)` used broadly across `std::`.",
      "text": "std::vector vector type Vector(T) used broadly across std::. Vector(T) is an owning container with: a contiguous heap allocation, a logical length (len), and a capacity (cap) in elements. the compiler uses a conservative scalar-slot memory model for most scalar values; std::vector is specified in terms of the logical element type T, not a stable packed byte layout. In particular, in the Vector(T) stores elements using the scalar-slot layout of T (each slot is 8 bytes). Each element occupies sizeof(T) bytes (a multiple of 8 in Silk), so multi-slot values like string and non-opaque structs/enums are supported. This is still not a packed byte representation: for example sizeof(u8) == 8 In Silk, so Vector(u8) stores one byte per 8-byte slot. Use std::buffer::BufferU8 when packed bytes matter. Where byte-exact layout matters (I/O buffers, strings), the stdlib uses std::buffer::BufferU8, a packed byte buffer whose ptr points to byte-addressed memory and whose len/cap are in bytes. See also: Current API module std::vector; import std::arrays; import std::interfaces; struct Vector(T) { ptr: u64, cap: i64, len: i64, } impl Vector(T) { public fn init (cap: i64) -> std::result::Result(Vector(T), std::memory::AllocFailed); public fn empty () -> Vector(T); public fn push (mut self: &Vector(T), value: T) -> std::memory::OutOfMemory?; public fn pop (mut self: &Vector(T)) -> T?; public fn get (self: &Vector(T), index: i64) -> T; public fn set (mut self: &Vector(T), index: i64, value: T) -> void; public fn at (self: &Vector(T), index: i64) -> T?; public fn tryset (mut self: &Vector(T), index: i64, value: T) -> bool; public fn swapremove (mut self: &Vector(T), index: i64) -> T?; public fn extendfromslice (mut self: &Vector(T), s: std::arrays::Slice(T)) -> std::memory::OutOfMemory?; public fn asslice (self: &Vector(T)) -> std::arrays::Slice(T); public fn iter (self: &Vector(T)) -> std::arrays::SliceIter(T); } impl Vector(T) as std::interfaces::Len { public fn len (self: &Vector(T)) -> i64; } impl Vector(T) as std::interfaces::Capacity { public fn capacity (self: &Vector(T)) -> i64; } impl Vector(T) as std::interfaces::IsEmpty { public fn isempty (self: &Vector(T)) -> bool; } impl Vector(T) as std::interfaces::Clear { public fn clear (mut self: &Vector(T)) -> void; } impl Vector(T) as std::interfaces::ReserveAdditional { public fn reserveadditional (mut self: &Vector(T), additional: i64) -> std::memory::OutOfMemory?; } impl Vector(T) as std::interfaces::Drop { public fn drop (mut self: &Vector(T)) -> void; } Notes: Vector(T) is intentionally low-level in Silk: init(cap) returns Err(AllocFailed) when allocation fails or when cap is invalid. prefer Vector.empty() over Vector.init(0) for a clear \u201cdefault\u201d constructor. growth paths (reserveadditional, push, extendfromslice) surface allocation failure as std::memory::OutOfMemory? (including internal size arithmetic overflow; leaves the vector unchanged on failure). Bounds checks are expressed as #require contracts (and reusable std::formal theories) for verifier tooling; they are not runtime checks in the current compiler subset. at / tryset are \u201cchecked\u201d accessors: at returns None when index is out of bounds, tryset returns false when index is out of bounds. swapremove removes an element by swapping in the last element (O(1), order not preserved)."
    },
    {
      "id": "std/websocket",
      "title": "`std::websocket`",
      "section": "std",
      "summary": "WebSocket implementation on top of `std::net::TcpStream` (client + server handshake, framing, ping/pong, close, fragmentation).",
      "text": "std::websocket WebSocket implementation on top of std::net::TcpStream (client + server handshake, framing, ping/pong, close, fragmentation). See also: RFC 6455: The WebSocket Protocol (wire format + handshake) Overview std::websocket is a protocol layer that upgrades an HTTP/1.1 connection to a WebSocket and then sends/receives WebSocket frames. Design goals : Work for hosted POSIX builds using std::net. Be fully interoperable with other WebSocket implementations (browsers, Node.js, etc.) for the supported feature set: version 13 handshake, masked client\u2192server frames, unmasked server\u2192client frames, fragmentation and continuation frames, ping/pong, close. Provide a small, blocking server that accepts one connection at a time. Non-goals (for now): HTTP server integration beyond the upgrade handshake (no HTTP routing layer). TLS (wss://) integration (use std::tls + a future adapter layer). Per-message compression (RSV1 / permessage-deflate). Public API module std::websocket; import std::net; import std::arrays; import std::result; import std::strings; // Message opcodes (subset). export let OPCODETEXT: int = 1; export let OPCODEBINARY: int = 2; // Handshake errors. export let ERRHANDSHAKEIO: int = 1; export let ERRHANDSHAKETOOLARGE: int = 2; export let ERRHANDSHAKEBADREQUEST: int = 3; export let ERRHANDSHAKEMISSINGKEY: int = 4; export let ERRHANDSHAKEBADVERSION: int = 5; export let ERRHANDSHAKEBADACCEPT: int = 6; export let ERRHANDSHAKEOUTOFMEMORY: int = 7; export error HandshakeError { kind: int, } export type WebSocketResult = std::result::Result(WebSocket, HandshakeError); export type WebSocketServerResult = std::result::Result(WebSocketServer, HandshakeError); // Protocol/runtime errors during frame processing. export let ERRPROTOCOLIO: int = 1; export let ERRPROTOCOLCLOSED: int = 2; export let ERRPROTOCOLBADFRAME: int = 3; export let ERRPROTOCOLTOOLARGE: int = 4; export let ERRPROTOCOLOUTOFMEMORY: int = 5; export error ProtocolError { kind: int, } export type MessageResult = std::result::Result(Message, ProtocolError); struct Message { opcode: int, // OPCODETEXT or OPCODEBINARY data: std::strings::String, // owned bytes (UTF-8 for text) } struct WebSocket { // opaque handle } impl WebSocket { // Server-side: perform the HTTP upgrade handshake on an accepted TCP stream. public fn accept (stream: std::net::TcpStream) -> WebSocketResult; // Client-side: connect and perform the HTTP upgrade handshake. public fn connect (addr: SocketAddrV4, host: string, path: string) -> WebSocketResult; public fn isvalid (self: &WebSocket) -> bool; public fn close (mut self: &WebSocket) -> ProtocolError?; // Read the next complete application message (text or binary). // Ping frames are answered automatically and do not surface as messages. public fn readmessage (mut self: &WebSocket) -> MessageResult; // Send a single unfragmented message. public fn writetext (self: &WebSocket, text: string) -> ProtocolError?; public fn writebytes (self: &WebSocket, bytes: std::arrays::ByteSlice) -> ProtocolError?; } struct WebSocketServer { // opaque handle } impl WebSocketServer { public fn listen (addr: SocketAddrV4, backlog: int) -> WebSocketServerResult; public fn isvalid (self: &WebSocketServer) -> bool; public fn localport (self: &WebSocketServer) -> std::net::NetIntResult; public fn accept (mut self: &WebSocketServer) -> WebSocketResult; public fn close (mut self: &WebSocketServer) -> HandshakeError?; } Notes: This API is currently blocking. Handle types wrap OS resources; avoid copying WebSocket / WebSocketServer values until the language has move-only handles. Protocol Rules Enforced The implementation enforces the following RFC 6455 requirements: Client\u2192server frames must be masked; server\u2192client frames must not be masked. Reserved bits (RSV1/2/3) must be zero (compression/extensions are not supported). Control frames (ping/pong/close): are not allowed to be fragmented (FIN = 1), must have payload length \u2264 125. Close frames trigger an attempted close reply and then the connection is treated as closed from the API\u2019s perspective."
    },
    {
      "id": "std/js-ecma",
      "title": "ECMAScript FFI (`std::js::ecma`)",
      "section": "std",
      "summary": "This module defines a small, environment-agnostic interface for interacting with an ECMAScript engine from Silk.",
      "text": "ECMAScript FFI (std::js::ecma) This module defines a small, environment-agnostic interface for interacting with an ECMAScript engine from Silk. Scope constraints: ECMAScript only: this module intentionally exposes no DOM/Web APIs, no Node.js APIs, and no host-environment globals beyond what ECMAScript itself requires to exist on the global object. It is intended as a shared substrate for future tooling such as silk bindgen (for example: Web IDL \u2192 Silk bindings when targeting WASM and calling out to a JavaScript host). High-Level API The public Silk surface is centered around: Context \u2014 an execution context / realm handle. Value \u2014 a JS value handle (primitives and objects). Error \u2014 a typed error representing host failures or thrown JS exceptions. The API is intentionally minimal but ergonomic: obtain a default context (Context.defaultctx()), access the global object (ctx.global()), get/set properties (ctx.get(obj, name), ctx.set(obj, name, value)), call functions and constructors (ctx.call(...), ctx.construct(...)), convert common primitives (ctx.bool(...), ctx.f64(...), ctx.stringutf8(...)), convert values to UTF\u20118 (ctx.toutf8string(value)). Naming Conventions (camelCase vs snakecase) JavaScript global objects use camelCase naming conventions for functions and methods, but Silk style is snakecase. std::js::ecma exposes snakecase names for JavaScript intrinsics. Additionally, acronyms within a method name are all lower case. For example, JavaScript decodeURI is exposed as Silk decodeuri. jssys-Modeled Surface (ECMAScript Intrinsics) On top of the minimal Context/Value/Error API, std::js::ecma provides names for common ECMAScript-standard globals (modeled after Rust\u2019s jssys). Important constraints: No environment APIs: no DOM/Web APIs, no Node.js APIs, and no other host-specific globals. These bindings are intentionally shallow: they define stable names and small helpers; most behavior is accessed via get/call against the underlying JS values. Provided Names Modules / global objects: Atomics Intl JSON Math Reflect WebAssembly (when provided by the host) Struct-style JS value wrappers: Array, Object, Function, Number, Boolean, Symbol, JsString Promise, Proxy Map, Set, WeakMap, WeakSet, WeakRef RegExp, Date Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, UriError ArrayBuffer, SharedArrayBuffer, DataView Typed arrays: Int8Array, Int16Array, Int32Array, Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array BigInt: BigInt Iteration protocol: Iterator, IteratorNext, Iter, IntoIter, ArrayIter, ArrayIntoIter, AsyncIterator, Generator Conversion placeholder: TryFromIntError Global functions (snakecase): decodeuri, decodeuricomponent encodeuri, encodeuricomponent escape, unescape eval global isfinite parsefloat, parseint tryiter The \u201cSilk Ext JavaScript Standard Interface\u201d This std module is implemented on top of a required set of ext symbols that must be provided by the embedding environment. Two common implementation strategies: WASM host: provide the symbols as imported wasm functions (the compiler maps ext foo = ...; to env.foo). Native embedder: provide the symbols in a linked library that uses an engine such as JavaScriptCore, QuickJS, or V8. Handle Model All handles are represented as u64 at the ABI boundary: ctx: u64 \u2014 a context handle (must be non-zero). value: u64 \u2014 a value handle (must be non-zero). 0 is reserved as an invalid handle and is used as the failure sentinel for u64-returning operations. Implementers define the concrete meaning of handles (pointers, indices into a table, tagged integers, etc.) but MUST keep them stable for as long as the handle is \u201cretained\u201d by Silk. Error Reporting Contract Operations that can fail either: return 0 (for u64 results), or return non-zero (for int results), and in that case the implementation MUST set a per-context \u201clast error\u201d record retrievable via silkjserrorcode / silkjserrortakeexception. Error codes are stable integers: 0 \u2014 no error / unknown (should not be observed after a failing call) 1 \u2014 a JS exception was thrown (silkjserrortakeexception returns the thrown value) 2 \u2014 out of memory / allocation failure in the host 3 \u2014 invalid handle / wrong realm / misuse detected by the host 4 \u2014 not implemented by this host Notes: For iterator helpers (e.g. tryiter), implementations SHOULD return a canonical, stable handle for undefined and null per-context so equality checks against silkjsundefined / silkjsnull work as expected. Required External Symbols (v0) These symbols are required by std::js::ecma (external names are fixed and stable): // Context / lifetime ext silkjsctxdefault = fn () -> u64; ext silkjsretain = fn (u64, u64) -> void; ext silkjsrelease = fn (u64, u64) -> void; // Error retrieval (after a failing call) ext silkjserrorcode = fn (u64) -> int; ext silkjserrortakeexception = fn (u64) -> u64; // Common primitives ext silkjsundefined = fn (u64) -> u64; ext silkjsnull = fn (u64) -> u64; ext silkjsbool = fn (u64, bool) -> u64; ext silkjsi64 = fn (u64, i64) -> u64; ext silkjsf64 = fn (u64, f64) -> u64; ext silkjsstringutf8 = fn (u64, string) -> u64; // Global + property access ext silkjsglobal = fn (u64) -> u64; ext silkjsget = fn (u64, u64, string) -> u64; ext silkjsset = fn (u64, u64, string, u64) -> int; // Calls ext silkjscall = fn (u64, u64, u64, u64, i64) -> u64; ext silkjsconstruct = fn (u64, u64, u64, i64) -> u64; // String extraction ext silkjstostring = fn (u64, u64) -> u64; ext silkjsstringutf8len = fn (u64, u64) -> i64; ext silkjsstringutf8write = fn (u64, u64, u64, i64) -> i64; Notes: In Silk, passing a Silk string to ext lowers as a NUL-terminated const char . Therefore silkjsstringutf8 expects UTF\u20118 without embedded NUL bytes. The write function copies raw UTF\u20118 bytes (no NUL terminator) into the destination buffer and returns the number of bytes written. Future Work Expected follow-ups as silk bindgen becomes concrete: richer conversions (arrays, maps, typed arrays / ArrayBuffer via a separate environment-specific layer), promise integration (job queue hooks), structured cloning / JSON convenience helpers on top of ECMAScript intrinsics, a codegen layer that maps Web IDL types onto std::js::ecma calls."
    },
    {
      "id": "std/overview",
      "title": "Standard Library Overview (`std::`)",
      "section": "std",
      "summary": "intended API and structure. A minimal in-tree stdlib source tree also exists under `std/` (used by the toolchain to satisfy `import std::...;`).",
      "text": "Standard Library Overview (std::) intended API and structure. A minimal in-tree stdlib source tree also exists under std/ (used by the toolchain to satisfy import std::...;). As of the compiler, the in-tree stdlib includes a small but functional set of utilities implemented purely in Silk (including monomorphized, type-parameter generics for core collection types), plus a tiny hosted POSIX baseline for OS-facing modules (std::fs, std::task, std::sync, std::io) implemented via the std::runtime interface layer (the shipped POSIX runtime backend uses ext and therefore requires linking libc for executable outputs). The Silk standard library, std::, provides foundational functionality built on top of the language core (regions, buffers, concurrency, etc.). It is intended to be: Linked by default for normal builds driven by silk. Swappable: an alternative std:: implementation can be selected at build time, without changing the language or the C ABI. POSIX-first for OS interactions (initial hosted baseline), while still supporting freestanding/embedded builds via a smaller \u201ccore\u201d subset. See also: Core Areas (Initial) These are the minimum required areas for the initial standard library distribution: std::buffer \u2014 typed, width-oriented buffer utilities built on top of std::strings \u2014 UTF-8 text utilities and owned string building. std::math \u2014 linear algebra utilities (vectors/matrices) for graphics and std::crypto \u2014 cryptography primitives (hosted baseline via libsodium; see std::uuid \u2014 UUID primitives (v1/v3/v4/v5/v6/v7/v8) with parsing/formatting std::semver \u2014 Semantic Versioning (SemVer 2.0.0) parsing and precedence std::json \u2014 JSON parsing and stringifying (borrowed and owned DOM parsing; std::toml \u2014 TOML parsing (borrowed and owned DOM parsing; std::memory \u2014 allocation interfaces and low-level memory utilities. std::arrays \u2014 slice/view types and helpers for fixed arrays. std::bits \u2014 bit manipulation helpers (byte swaps, rotates, bit counts; see std::vector \u2014 typed growable vectors (Vector(T)), used broadly across std::map \u2014 associative containers (hash maps and ordered maps; see std::set \u2014 set containers (hash sets and ordered sets; see std::algorithms \u2014 common algorithms over slices/collections. std::temporal \u2014 Instant/Duration utilities and calendar/time helpers. std::readline \u2014 interactive line editor for CLI programs (TTY mode) built on std::io \u2014 basic I/O (readers/writers, formatting, stdout/stderr). std::fmt \u2014 shared formatting layer used by std::io and string builders. std::fs \u2014 filesystem access (POSIX baseline). std::net \u2014 networking primitives (POSIX baseline). std::http \u2014 HTTP/1.1 parsing + blocking client/server on top of std::net std::https \u2014 HTTPS (HTTP over TLS) on top of std::tls + std::net std::websocket \u2014 RFC 6455 WebSocket (handshake + framing) on top of std::net std::tls \u2014 TLS client/server primitives (POSIX baseline via mbedTLS; see std::ssh2 \u2014 SSH2 client primitives (POSIX baseline via libssh2; see std::sqlite \u2014 SQLite database primitives (POSIX baseline via SQLite; see std::interfaces \u2014 shared std interface contracts (\u201cprotocols\u201d) such as std::formal \u2014 reusable Formal Silk theories (\u201cstandard lemmas\u201d) used by corresponding language doc). The exact shapes of types and functions will evolve as the language and backend grow; these docs are the source of truth for the intended std:: surface."
    },
    {
      "id": "std/idl-web",
      "title": "Web IDL (`std::idl::web`)",
      "section": "std",
      "summary": "This module provides a Web IDL parser plus an ergonomic, query-oriented API for inspecting the parsed document.",
      "text": "Web IDL (std::idl::web) This module provides a Web IDL parser plus an ergonomic, query-oriented API for inspecting the parsed document. The long-term goal is to support bidirectional binding generation: Web IDL \u2192 Silk: generate Silk APIs for DOM / JavaScript environments (for example when targeting WASM and calling out to JavaScript host APIs). Silk \u2192 JS bindings: generate JavaScript glue for Silk-defined interfaces (when embedding Silk/WASM in JS runtimes). This first slice focuses on a stable, testable parsing substrate that can be grown as silk bindgen work lands. Design Goals Lossless enough for bindgen: preserve source spans for identifiers and raw values so downstream tools can generate bindings and diagnostics. Ergonomic queries: parse once, then ask the document for interfaces, members, argument lists, and types via IDs and ranges (no recursion required for common workflows). Compact storage: avoid heavyweight allocation patterns; store parsed data in compact slot vectors (std::vector::Vector(i64)). High-Level API std::idl::web::parse(source: string) -> Result(Document, ParseError) std::idl::web::parseowned(source: std::strings::String) -> Result(Document, ParseError) Document owns the (copied or moved) source text and stores all parsed spans as offsets into that owned source. Parse Errors ParseError reports: code: int (stable kind code), and kind() -> ParseErrorKind / message() -> string, offset: i64 (byte offset), line: i64 / column: i64 (1-based), requested: i64 (non-zero only for OutOfMemory). The Document API exposes: definition iteration (defcount, defkind, defname, defmembers, \u2026) member inspection (memberkind, membername, membertype, \u2026) type inspection (typekind, typename, typechildren, \u2026) extended attributes (extattrname, extattrvalue, \u2026) All names and raw values are represented as SpanIds that can be rendered to string views via Document.spantext(spanid). Current Grammar Coverage (Initial) Designed as a lenient parser that can preserve and skip unknown constructs: Extended attributes: [Attr, Attr=Value, Attr(Args)] (value captured as a raw span) Top-level definitions: interface, partial interface, interface mixin dictionary, partial dictionary enum typedef callback (function form) and callback interface includes statements (A includes B;) unknown definitions are preserved as DefKind::Unknown Members (within interfaces/dictionaries/namespaces): attributes, operations, constructors, constants dictionary fields (required + default values captured as raw spans) unknown members are preserved as MemberKind::Unknown Types: identifier types (including common multi-token builtins like unsigned long) generic types (Foo<Bar, Baz>) union types ((A or B or C)?) nullable types via ? The grammar coverage will expand as the bindgen pipeline becomes concrete. Notes For Bindgen The parser intentionally preserves: definition/member/argument extended attributes, raw spans for constant/default values, enough structural information (member kinds, argument lists, type AST) to map Web platform APIs to a generated Silk surface and to synthesize JS host glue."
    },
    {
      "id": "std/wasm",
      "title": "WebAssembly Runtime (`std::wasm`)",
      "section": "std",
      "summary": "`std::wasm` is the standard library surface for **executing WebAssembly (WASM) modules** from Silk.",
      "text": "WebAssembly Runtime (std::wasm) std::wasm is the standard library surface for executing WebAssembly (WASM) modules from Silk. This module is about running wasm. It is not the Silk compiler\u2019s wasm output Goals Provide a portable API for: loading/validating wasm bytes, instantiating modules (including imports), calling exported functions, interacting with exported linear memory. Keep the module swappable, like the rest of std::: embedders may provide an alternate implementation (for example a wasm engine binding) while preserving the same public API. Record a clear path to a full native runtime and JIT in later phases (no dependency on external language toolchains). High-Level API The public Silk surface is centered around: Engine \u2014 a runtime context and configuration (currently minimal). Module \u2014 a validated module (owned bytes + parsed metadata). Instance \u2014 an instantiated module (module + runtime state). Func \u2014 an exported function handle for calling. Imports \u2014 host-provided imports used during instantiation. linear memory access via Instance.memorybytes() (returns None when the module has no memory; otherwise Some(ByteSlice), possibly length 0). Val / ValType \u2014 a small tagged value representation for wasm values (currently used for results). Host Imports (MVP) Module.instantiatewithimports(imports: Imports) uses Imports to resolve wasm imports (functions, globals, memory, table). Imported Functions Imported functions are dispatched through a single host callback: Imports.funccall: HostCall HostCall uses a scalar-only calling convention so it can be stored as a first-class value and passed around in Silk: type fn HostCall = fn (importindex: i64, argsptr: u64, argslen: i64, memptr: u64, memlen: i64, outbitsptr: u64) -> int; Semantics: importindex is 0-based in the order declared by the wasm module. (argsptr, argslen) describes a u64 slice of raw argument bits (i32 uses the low 32 bits; f32 also uses the low 32 bits). (memptr, memlen) describes the instance linear memory as a raw byte view (or (0, 0) when the module has no memory). When the imported function returns i32, i64, f32, or f64, the host writes the raw result bits to outbitsptr (at offset 0, as a u64). i32/f32 use the low 32 bits. i64/f64 use the full 64 bits. The return value is 0 on success; non-zero values are treated as WASMError.code (with offset = -1). Named Imported Functions For embedders that want named host functions (instead of a single index-based dispatcher), std::wasm also provides a helper that links imported functions by (modulename, importname) using std::map: export struct ImportFuncName { modulename: string, name: string } export fn hashimportfuncname (k: ImportFuncName) -> u64; export fn eqimportfuncname (a: ImportFuncName, b: ImportFuncName) -> bool; Module.instantiatewithnamedfuncimports(imports: Imports, funcimports: &std::map::HashMap(ImportFuncName, HostCall)) Semantics: Every imported function in the module must have a corresponding entry in funcimports, otherwise instantiation fails with LinkError. Extra entries in funcimports are ignored. The linked callbacks are stored in a per-instance dispatch table so the map itself does not need to outlive instantiation. Example: import std::map; import std::wasm; type ImportMap = std::map::HashMap(std::wasm::ImportFuncName, std::wasm::HostCall); fn main () -> int { let r = ImportMap.init(8, std::wasm::hashimportfuncname, std::wasm::eqimportfuncname); if r.iserr() { return 1; } let mut m: ImportMap = match (r) { Ok(v) => v, Err() => ImportMap.empty(std::wasm::hashimportfuncname, std::wasm::eqimportfuncname), }; // Link the wasm import (import \"env\" \"add1\" ...) to a host callback. let = (mut m).put(std::wasm::ImportFuncName{ modulename: \"env\", name: \"add1\" }, hostcall); let instr = (mut module).instantiatewithnamedfuncimports(imports, &m); (mut m).drop(); // ... return 0; } Imported Globals Imported globals are provided as raw bits: Imports.globalbits: Slice(u64) Semantics: The slice length must equal the number of imported globals in the module. Globals are ordered by the wasm module\u2019s import order (0-based). For imported i32 globals, only the low 32 bits are used. For imported i64 globals, the full 64 bits are used. For imported f32 globals, only the low 32 bits are used (raw IEEE bits). For imported f64 globals, the full 64 bits are used (raw IEEE bits). Imported Memory/Table Imports can configure the initial sizes of imported memory/table: Imports.memorypages: i64 (for imported memory) Imports.tablesize: i64 (for imported table) Semantics: 1 means \u201cuse the module minimum\u201d. Any other value must satisfy the module\u2019s declared limits. Error Model std::wasm uses a single typed error: WASMError { code, offset, requested, trap } Where: code is a stable kind code. offset is a byte offset into the wasm input when known (otherwise -1). requested is used for allocation failures (otherwise 0). trap is a stable trap-kind code when code == Trap (otherwise 0). WASMError.kind() and WASMError.message() provide a semantic view over the stable integer codes. Supported Features (MVP) The implementation is a pure Silk interpreter intended to be: self-contained (no external dependencies), correct for the WebAssembly 1.0 MVP semantics it supports, explicit about unsupported extensions (returns Unsupported). Targets Only wasm32 modules are supported. The module must be a valid wasm binary module (magic + version 1). Sections Supported: custom sections are ignored, core sections: type, import, function, table, memory, global, export, start, element, code, data. Notes / current constraints (MVP): At most one table and one memory are supported (MVP constraint). start is executed automatically during Module.instantiate after instantiation initialization. the start function must have signature [] -> [] (no parameters, no results). datacount and all non-MVP extensions are rejected as Unsupported. Values and Function Calls Supported ValType: I32, I64, F32, F64. Supported function signatures: any number of i32/i64/f32/f64 parameters and 0\u20131 i32/i64/f32/f64 results. Calls pass arguments as raw bits (std::arrays::Slice(u64)): for i32/f32 parameters, only the low 32 bits are used, for i64/f64 parameters, the full 64 bits are used. Calls return 0\u20131 results as Val?. Instructions The interpreter supports a practical wasm32 subset sufficient for \u201creal\u201d wasm code (including f32/f64): control/parametric/variable: unreachable, nop, block, loop, if, else, end, br, brif, brtable, return, call, callindirect, drop, select (with block results for i32/i64/f32/f64) memory: all MVP loads/stores (including sign/zero-ext forms), memory.size, memory.grow numerics: i32/i64/f32/f64 operators and conversions (including float\u2194int conversions and bit reinterpret ops). Float\u2192int truncation traps on NaN and out-of-range inputs (WASMTrapKind::InvalidConversionToInteger). Unsupported opcodes/extensions are rejected as Unsupported with an offset pointing at the opcode. Ownership Rules A Module owns the wasm bytes and parsed metadata. An Instance owns its own runtime state and takes ownership of the module\u2019s owned allocations during instantiation. Module.instantiate(mut self: &Module) consumes the module by moving its owned allocations into the returned Instance. after a successful call, the original Module is left in an empty, inert state. if instantiation fails (including start traps), no instance is produced and the original Module remains intact. Func is a lightweight view into an Instance, and memory is accessed by calling Instance.memorybytes() when present. Example import std::wasm; import std::arrays; import std::buffer; using Engine = std::wasm::Engine; using EngineResult = std::wasm::EngineResult; using Module = std::wasm::Module; using ModuleResult = std::wasm::ModuleResult; using Instance = std::wasm::Instance; using InstanceResult = std::wasm::InstanceResult; using Func = std::wasm::Func; using Val = std::wasm::Val; using CallResult = std::wasm::CallResult; using ByteSlice = std::arrays::ByteSlice; using BufferU8 = std::buffer::BufferU8; using U64Slice = std::arrays::Slice(u64); fn main () -> int { let r: EngineResult = Engine.initdefault(); if r.iserr() { return 1; } let engine: Engine = match (r) { Ok(v) => v, Err() => Engine{ maxstack: 0, maxcalldepth: 0, maxmemorypages: 0 }, }; // Minimal wasm module: // (module // (func (export \"answer\") (result i32) // i32.const 7)) // Note: u8[N] arrays use the scalar-slot memory model (not packed bytes). // Build a packed ByteSlice via BufferU8 when supplying raw wasm bytes. let wasmbytes: u8[39] = [ 0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 7, 10, 1, 6, 97, 110, 115, 119, 101, 114, 0, 0, 10, 6, 1, 4, 0, 65, 7, 11 ]; let bufr = BufferU8.init(39); if bufr.iserr() { return 2; } let mut buf: BufferU8 = match (bufr) { Ok(v) => v, Err() => BufferU8.empty(), }; var i: i64 = 0; while i < 39 { let pusherr = (mut buf).push(wasmbytes[i]); if pusherr != None { (mut buf).drop(); return 2; } i = i + 1; } let bytes: ByteSlice = buf.asbytes(); let mr: ModuleResult = engine.compile(bytes); (mut buf).drop(); if mr.iserr() { return 2; } let mut m: Module = match (mr) { Ok(v) => v, Err() => Module.empty(), }; let instr: InstanceResult = (mut m).instantiate(); if instr.iserr() { return 3; } let mut inst: Instance = match (instr) { Ok(v) => v, Err() => Instance.empty(), }; let fopt: Func? = inst.exportfunc(\"answer\"); if fopt == None { return 4; } let f: Func = fopt ?? Func{ index: 0 }; let args: U64Slice = { ptr: 0, len: 0 }; let callr: CallResult = (mut inst).call(f, args); if callr.iserr() { return 5; } let outopt: Val? = match (callr) { Ok(v) => v, Err() => None, }; if outopt == None { return 6; } let out: Val = outopt ?? Val.i32(0); let gotopt: i32? = out.asi32(); if gotopt == None { return 7; } if (gotopt ?? 0) != 7 { return 8; } return 0; } Future Work A stable, ergonomic host import resolver API (beyond the MVP Imports list). WASI bindings and host library shims. Post-MVP proposals: bulk memory, reference types, SIMD (v128), threads, multi-value. A native runtime/JIT implementation for performance."
    },
    {
      "id": "usage/cli-examples",
      "title": "CLI usage examples",
      "section": "usage",
      "summary": "This page is a grab bag of practical workflows for the `silk` toolchain. It focuses on *how people actually use the CLI*: quick feedback (`check`), tests that integrate with CI (`test`), and explicit build outputs (`build`).",
      "text": "CLI usage examples This page is a grab bag of practical workflows for the silk toolchain. It focuses on how people actually use the CLI: quick feedback (check), tests that integrate with CI (test), and explicit build outputs (build). For the conceptual model, read: CLI and toolchain. For flag-by-flag reference, use the manpages (sidebar \u2192 man). Minimal loop: check \u2192 test \u2192 build Create hello.slk: import std::io::println; fn main () -> int { println(\"hello {s}\", \"world\"); return 0; } Then: silk check hello.slk silk test hello.slk silk build hello.slk -o build/hello This loop is intentionally boring: each command has one job, and it scales from a single file to large packages. Explicit module sets (multiple files) Passing multiple files defines the module set explicitly: silk check src/main.slk src/util.slk silk test src/main.slk src/util.slk silk build src/main.slk src/util.slk -o build/app If you\u2019re just starting a project, this is a great way to keep things simple before introducing manifests and named build targets. Package builds (silk.toml) For larger projects, you typically describe the module set in silk.toml and ask the CLI to load it: silk check --package . silk test --package . silk build --package . Why this model is valuable: \u201cwhat gets compiled\u201d is explicit and reproducible tooling can reason about packages without executing code named targets let you build multiple artifacts from one codebase Build kinds: executable, object, static, shared silk build makes the output kind explicit: Executable (default) silk build src/main.slk -o build/app Object file silk build src/lib.slk --kind object -o build/lib.o Static library silk build src/lib.slk --kind static -o build/libfoo.a Shared library silk build src/lib.slk --kind shared -o build/libfoo.so Emitting C headers for exports When building libraries for C consumers, emit a header for exported symbols: silk build src/lib.slk --kind static -o build/libmylib.a --c-header build/mylib.h This is a practical bridge between \u201cSilk as a language\u201d and \u201cSilk as a component inside another system\u201d. Target selection Cross compilation and alternate backends are selected explicitly: silk build src/main.slk --target x8664-linux-gnu -o build/app silk build src/main.slk --arch wasm32 --kind executable -o build/app.wasm Explicit targets keep builds readable: you can tell from the command line what you\u2019re producing. Standard library selection (--std-root, --nostd, --std-lib) When a module imports std::..., the CLI resolves the standard library from its configured stdlib root. Common customizations: Point at an alternate stdlib root (for custom std distributions or runtimes) silk check --std-root ./path/to/std src/main.slk silk build --std-root ./path/to/std src/main.slk -o build/app Disable std auto-loading (useful for sandboxed embedding flows) silk check --nostd src/main.slk On hosted targets where stdlib archives are used, --std-lib selects the archive to link. Reference: Custom stdlib root Docs and manpages from source Silk can extract documentation from doc comments: silk doc src/main.slk -o build/api.md And render a man-style view of a symbol/module/concept: silk man std::io Embedding workflows (C) Two common embedding shapes: 1. Build a library for a C program to link against (object/static/shared + optional C header). 2. Embed the compiler itself (libsilk) inside another program. When you\u2019re in the \u201ccall a C compiler\u201d world, silk cc is a convenience wrapper: silk cc -std=c99 -Wall -Wextra myprogram.c -o build/myprogram Reference: libsilk (sidebar \u2192 man \u2192 libsilk (7))."
    },
    {
      "id": "usage/editor-coc-nvim",
      "title": "coc.nvim Integration for Silk",
      "section": "usage",
      "summary": "This document describes the coc.nvim extension shipped in this repository under `coc/`.",
      "text": "coc.nvim Integration for Silk This document describes the coc.nvim extension shipped in this repository under coc/. Location and Layout coc/ contains the full coc.nvim extension. coc/src/index.ts wires silk-lsp into coc.nvim. coc/src/snippets.json provides a small set of Silk snippets. Requirements Neovim with coc.nvim (engine version ^0.0.80). silk-lsp on your PATH or a configured absolute path. filetype=silk for .slk and .silk buffers (including build.silk; use the Vim plugin under vim/ or your own filetype setup). Install (local, from this repo) 1. Build the language server: cd /path/to/silk/compiler zig build 2. Build the extension: cd /path/to/silk/compiler/coc npm install npm run build 3. Symlink into Coc\u2019s extensions directory: mkdir -p ~/.config/coc/extensions/nodemodules ln -s /path/to/silk/compiler/coc ~/.config/coc/extensions/nodemodules/coc-silk 4. Restart Neovim. Configuration Add settings to your coc-settings.json: { \"silk.enabled\": true, \"silk.startUpMessage\": true, \"silk.path\": \"silk-lsp\", \"silk.args\": [], \"silk.env\": {}, \"silk.stdRoot\": \"\", \"silk.noStd\": false, \"silk.filetypes\": [\"silk\"], \"silk.rootPatterns\": [ \"build.silk\", \"silk.toml\", \"build.zig\", \"build.zig.zon\", \".git\" ], \"silk.outputChannel\": \"Silk Language Server\" } silk.stdRoot maps to silk-lsp --std-root <path> and silk.noStd maps to silk-lsp --nostd. You can also use silk.args or silk.env.SILKSTDROOT for custom setups. Commands Use :CocCommand for server lifecycle management: silk.start \u2014 start the language server. silk.stop \u2014 stop the language server. silk.restart \u2014 restart the language server. Features The extension exposes the capabilities currently implemented by silk-lsp: diagnostics from the Silk lexer, parser, and type checker, hover with approximate type hints for identifiers and struct fields, heuristic go-to-definition across the module set (functions, lets, structs, struct fields, and impl methods), including local let bindings and parameters, keyword/identifier completion with symbol-aware details and struct member suggestions, struct-literal field suggestions in Type { ... } expressions, signature help while typing function and method calls, top-level document symbols for fn, let, struct, enum, error, interface, ext, and impl declarations. Reference: LSP protocol and server. Notes and Troubleshooting If diagnostics are missing, check that :set filetype? reports silk. If silk-lsp cannot be found, set silk.path to the full path of your silk-lsp binary. Use :CocList outputs and open the Silk Language Server channel for logs."
    },
    {
      "id": "usage/getting-started",
      "title": "Getting Started (Repo Workflow)",
      "section": "usage",
      "summary": "This document is a practical starting point for working with the Silk compiler repository: building the `silk` CLI, running a minimal program, and finding the right documentation for deeper language and ABI details.",
      "text": "Getting Started (Repo Workflow) This document is a practical starting point for working with the Silk compiler repository: building the silk CLI, running a minimal program, and finding the right documentation for deeper language and ABI details. Build silk This repository is built with Zig. From the repo root: make build If you want to fetch/build the pinned vendored crypto/TLS dependencies (libsodium + mbedTLS) for linux/x8664, run: make deps This produces: zig-out/bin/silk (the compiler CLI) zig-out/lib/libsilk.a (the C99 static library) zig-out/lib/libsilkstd.a (a stdlib archive for supported targets) You can also run the Zig build directly: zig build Run a Minimal Program Create a file hello.slk: fn main () -> int { return 0; } Then: ./zig-out/bin/silk check hello.slk ./zig-out/bin/silk build hello.slk -o hello ./hello For more CLI examples (including stdlib use, wasm outputs, and library/object Supported behavior vs Full Design The language docs describe both: the full language design, and the current implemented subset. For \u201csupported behavior\u201d: unsupported features. Run Tests From the repo root: make test This runs: Zig unit tests (zig build test) Where To Go Next"
    },
    {
      "id": "usage/github-linguist",
      "title": "GitHub Linguist Support",
      "section": "usage",
      "summary": "This repository includes a `.gitattributes` file that tags `*.slk` files as Silk sources for GitHub Linguist.",
      "text": "GitHub Linguist Support This repository includes a .gitattributes file that tags .slk files as Silk sources for GitHub Linguist. What This Does Ensures .slk files are classified as Silk in GitHub\u2019s language breakdown. Helps GitHub apply the correct syntax highlighting when a TextMate grammar is available. Reuse in Other Repositories If you maintain downstream Silk projects, copy the .gitattributes entry: .slk linguist-language=Silk .slk linguist-detectable=true Adjust or extend the entries if you use additional Silk-related file extensions."
    },
    {
      "id": "usage/howto-run-wasi-node",
      "title": "How-To: Run `wasm32-wasi` Output in Node.js",
      "section": "usage",
      "summary": "This guide shows how to:",
      "text": "How-To: Run wasm32-wasi Output in Node.js This guide shows how to: compile a Silk program to wasm32-wasi, and run it under Node\u2019s built-in WASI runtime (node:wasi). The wasm32-wasi backend emits a start () -> void entrypoint that calls Silk fn main () -> int and then calls wasisnapshotpreview1.procexit(exitcode). 1) Build a WASI Module Create main.slk: import std::io; fn main () -> int { std::io::println(\"hello from silk wasm wasi\"); return 7; } Build: silk build main.slk --target wasm32-wasi -o out.wasm 2) Run it with node:wasi Create run.js: const fs = require('node:fs'); const { WASI } = require('node:wasi'); async function main() { const wasmPath = process.argv[2]; const wasi = new WASI({ version: 'preview1', args: [wasmPath], env: {}, preopens: {} }); const bytes = fs.readFileSync(wasmPath); const { instance } = await WebAssembly.instantiate(bytes, wasi.getImportObject()); try { wasi.start(instance); } catch (err) { // Some Node versions throw on procexit; the exit code is still available. } const exitSym = Object.getOwnPropertySymbols(wasi).find((s) => s.toString() === 'Symbol(kExitCode)'); const code = (exitSym && typeof wasi[exitSym] === 'number') ? wasi[exitSym] : (process.exitCode ?? 0); process.exit(code); } main().catch((err) => { console.error(err); process.exit(1); }); Run: node --no-warnings run.js out.wasm echo $? Expected output: stdout contains hello from silk wasm wasi exit code is 7 Troubleshooting If you see missing-import errors mentioning wasisnapshotpreview1, confirm you built with --target wasm32-wasi (not wasm32-unknown-unknown). If your program relies on OS-specific APIs (filesystem, processes): WASI is a constrained environment. Prefer stdlib APIs that are designed for WASI, or build for a hosted target. For deeper backend details and entrypoint behavior, see: WASM backend."
    },
    {
      "id": "usage/howto-custom-stdlib-root",
      "title": "How-To: Use a Custom Stdlib Root (and Runtime)",
      "section": "usage",
      "summary": "The `std::...` modules are loaded from a *stdlib root* (a directory containing a `std/` tree). Because `std::runtime` is part of that source tree, selecting a different stdlib root is also how you select a different runtime implementation",
      "text": "How-To: Use a Custom Stdlib Root (and Runtime) The std::... modules are loaded from a stdlib root (a directory containing a std/ tree). Because std::runtime is part of that source tree, selecting a different stdlib root is also how you select a different runtime implementation underneath std::fs, std::io, std::task, and std::sync. Reference: std::runtime (see the sidebar under \u201cStandard library\u201d). Use a Custom Std Root (CLI) Point the compiler at an alternate stdlib root: silk build --std-root /path/to/my-stdlib-root myprogram.slk -o myprogram You can also set an environment variable: export SILKSTDROOT=/path/to/my-stdlib-root silk build myprogram.slk -o myprogram Notes: nostd disables auto-loading of import std::...; modules, but it does not prevent from \"std/...\" file imports from resolving relative to the selected std root. See: CLI and toolchain. Provide a Prebuilt Std Archive On hosted targets where std archives are supported, you can also provide a prebuilt std archive: silk build --std-root /path/to/my-stdlib-root --std-lib /path/to/libsilkstd.a myprogram.slk -o myprogram Or via environment variable: export SILKSTDLIB=/path/to/libsilkstd.a If no suitable archive is provided, the compiler may fall back to compiling reachable std sources as part of the build on supported targets. Implementing a Custom Runtime To reuse the shipped high-level std::... modules while changing the OS integration, provide compatible std::runtime::... modules in your stdlib root. Example (hosted POSIX baseline): std/runtime/fs.slk delegates to std/runtime/posix/fs.slk, std/runtime/posix/fs.slk implements primitives using ext (e.g. open, read, close). For a new environment (for example Windows), the intent is to provide std/runtime/windows/fs.slk and have std/runtime/fs.slk delegate to it in that stdlib distribution. Keep the stable contract at the std::runtime::... signature level, not at the ext spelling level. Higher-level ergonomics belong in std::... modules."
    },
    {
      "id": "usage/editor-textmate",
      "title": "TextMate Grammar (tmLanguage)",
      "section": "usage",
      "summary": "1. Copy `textmate/silk.tmLanguage.json` to: - `~/Library/Application Support/TextMate/Bundles/Silk.tmbundle/Syntaxes/silk.tmLanguage.json` 2. Restart TextMate. 3. Open an `.slk` (or `.silk`) file and confirm it is recognized as `Silk`.",
      "text": "TextMate Grammar (tmLanguage) Scope and File Extension Scope: source.silk File extensions: .slk and .silk (including build scripts like build.silk) TextMate (macOS) 1. Copy textmate/silk.tmLanguage.json to: ~/Library/Application Support/TextMate/Bundles/Silk.tmbundle/Syntaxes/silk.tmLanguage.json 2. Restart TextMate. 3. Open an .slk (or .silk) file and confirm it is recognized as Silk. VS Code"
    },
    {
      "id": "usage/tutorials/01-first-program",
      "title": "Tutorial 1: your first program",
      "section": "usage",
      "summary": "This tutorial gets you from \u201ca file\u201d to \u201ca runnable program\u201d with the smallest useful workflow:",
      "text": "Tutorial 1: your first program This tutorial gets you from \u201ca file\u201d to \u201ca runnable program\u201d with the smallest useful workflow: silk check to validate code quickly silk build to produce an executable (optionally) silk test to run language-level tests 1) Create a minimal program Create hello.slk: import std::io::println; fn main () -> int { println(\"hello from silk\"); return 0; } 2) Check it silk check hello.slk check is meant to be cheap: it answers \u201cdoes this module set parse and type-check?\u201d 3) Build and run silk build hello.slk -o build/hello ./build/hello On hosted platforms, main returns a conventional process exit code (0 means success). 4) Add a tiny test (optional) Add this to the same file: import std::test::expectequal; fn add (a: int, b: int) -> int { return a + b; } test \"add returns the sum\" { expectequal(3, add(1, 2)); } Run: silk test hello.slk Next More workflows: CLI examples Tutorial 2: Structs and impl"
    },
    {
      "id": "usage/tutorials/02-structs-and-impls",
      "title": "Tutorial 2: structs and `impl`",
      "section": "usage",
      "summary": "This tutorial covers:",
      "text": "Tutorial 2: structs and impl This tutorial covers: defining a struct (data layout) attaching behavior with impl blocks calling methods with explicit receivers (self: &Self, mut self: &Self) Reference: Structs, impls, layout (see the sidebar under \u201cLanguage\u201d). 1) Define a struct struct Packet { sequence: u32, size: u16, isurgent: u8, } Structs define shape: fields and layout. Behavior lives in impl blocks. 2) Add behavior with an impl block impl Packet { public fn markurgent (mut self: &Self) -> void { self.isurgent = 1; } public fn islarge (self: &Self) -> bool { return self.size > 1024; } } Two important ideas: Methods are functions with an explicit receiver parameter (self). mut self: &Self means the method needs to mutate the value. 3) Use it (a complete program) Create packet.slk: import std::io::println; struct Packet { sequence: u32, size: u16, isurgent: u8, } impl Packet { public fn markurgent (mut self: &Self) -> void { self.isurgent = 1; } public fn islarge (self: &Self) -> bool { return self.size > 1024; } } fn main () -> int { let mut p = Packet{ sequence: 1, size: 2048, isurgent: 0 }; if p.islarge() { (mut p).markurgent(); } println(\"seq={d} urgent={d}\", p.sequence as int, p.isurgent as int); return 0; } Then: silk check packet.slk silk build packet.slk -o build/packet ./build/packet Optional: constructor overloads and new Silk supports a conventional pattern for heap allocation: new Type(...) selects a constructor overload in an impl block. impl Packet { fn constructor (mut self: &Self, seq: u32, size: u16) -> void { self.sequence = seq; self.size = size; self.isurgent = 0; } } This keeps construction explicit (you can read the initializer logic) without inventing a second \u201cclass system\u201d. Next Tutorial 3: Arrays and slices"
    },
    {
      "id": "usage/tutorials/03-arrays-and-slices",
      "title": "Tutorial 3: Arrays and Slices",
      "section": "usage",
      "summary": "This tutorial covers:",
      "text": "Tutorial 3: Arrays and Slices This tutorial covers: fixed arrays T[N], slices T[], array literals [a, b, c] and empty literals [] with expected types, indexing (xs[i]) and indexed assignment (xs[i] = v, xs[i] += v). For the precise rules, see: Aggregate literals (arrays and structs) (sidebar \u2192 language), Types (sidebar \u2192 language). 1) Fixed arrays (T[N]) fn main () -> int { let mut xs: int[3] = [1, 2, 3]; xs[1] = 9; xs[1] += 1; if xs[1] != 10 { return 1; } return 0; } Notes: Array lengths are part of the type: int[3] is distinct from int[4]. Indexing is explicit (xs[i]). Keep indices in range; out-of-bounds behavior is not something you want to depend on. 2) Slices (T[]) Slices are a \u201cview\u201d type: T[] represents a sequence of T values without baking a fixed length into the type. fn main () -> int { let mut s: int[] = [10, 20, 30]; s[2] = 5; if s[2] != 5 { return 1; } return 0; } 3) Empty literals (with expected types) Empty array literals require an expected type: struct HasSlice { xs: int[], } fn main () -> int { let emptyfixed: int[0] = []; let emptyslice: int[] = []; let hs = HasSlice{ xs: [] }; return 0; } This rule keeps [] unambiguous: the compiler needs to know what element type you meant."
    },
    {
      "id": "usage/tutorials/04-filesystem",
      "title": "Tutorial 4: filesystem basics (`std::fs`)",
      "section": "usage",
      "summary": "This tutorial demonstrates a very common \u201csystems script\u201d pattern:",
      "text": "Tutorial 4: filesystem basics (std::fs) This tutorial demonstrates a very common \u201csystems script\u201d pattern: 1. create a directory 2. write a file 3. read it back 4. clean up Reference: std::fs (sidebar \u2192 standard library). Program: write and read back a small file Create fsroundtrip.slk: import std::fs; import std::io::println; fn main () -> int { // 493 == 0o755 on POSIX. if std::fs::mkdirall(\"tmp\", 493) != None { println(\"mkdir failed\"); return 1; } let path: string = \"tmp/tutorialfsroundtrip.txt\"; std::fs::unlink(path); // ignore errors; we just want the file gone // 420 == 0o644 on POSIX. match (std::fs::writefilestring(path, \"hello\\\\n\", 420)) { Ok() => {}, Err() => { println(\"write failed\"); std::fs::unlink(path); return 2; }, } match (std::fs::readfilestring(path)) { Ok(s) => { println(\"read: {s}\", s.asstring()); std::fs::unlink(path); return 0; }, Err() => { println(\"read failed\"); std::fs::unlink(path); return 3; }, } } Build and run: silk check fsroundtrip.slk silk build fsroundtrip.slk -o build/fsroundtrip ./build/fsroundtrip What to take away std::fs uses explicit return shapes (Result(...) or optional errors) so failure handling stays visible. Whole-file helpers (readfilestring, writefilestring) are the easiest way to get real work done early. For deeper control (streaming I/O, seeking, file handles), std::fs::File exposes a lower-level handle API. Next Tutorial 5: Concurrency basics"
    },
    {
      "id": "usage/tutorials/05-concurrency",
      "title": "Tutorial 5: concurrency basics (`async`, `task`, `yield`, `await`)",
      "section": "usage",
      "summary": "Silk\u2019s concurrency model is built from two orthogonal modifiers:",
      "text": "Tutorial 5: concurrency basics (async, task, yield, await) Silk\u2019s concurrency model is built from two orthogonal modifiers: async \u2014 \u201cthis function can be awaited\u201d (concurrency / pausable execution) task \u2014 \u201cthis function can run as a task\u201d (parallel work / worker execution) Calling a concurrency-marked function produces a handle: calling a task fn ... -> T produces a Task(T) calling an async fn ... -> T produces a Promise(T) You then use: yield to receive values from tasks (and to send values from inside a task) await to unwrap promises Reference: Concurrency. 1) A minimal task + receiver Create concurrencybasic.slk: task fn add (a: int, b: int) -> int { return a + b; } async fn main () -> int { let h = add(1, 2); // h: Task(int) // task { ... } establishes a task context so yield is available. task { let v: int = yield h; if v != 3 { return 1; } return 0; } } Build and run: silk check concurrencybasic.slk silk build concurrencybasic.slk -o build/concurrencybasic ./build/concurrencybasic What to notice: Calling add(1, 2) does not immediately give you an int; it gives you a handle. yield h receives the task\u2019s produced value. The task/async split keeps \u201cwhat can block\u201d explicit in the code. 2) A minimal promise + await Promises are the async counterpart: async fn answer () -> int { return 42; } async fn main () -> int { let p = answer(); // p: Promise(int) let v: int = await p; // unwrap the promise if v != 42 { return 1; } return 0; } Why this model is valuable Silk\u2019s concurrency keywords are intentionally explicit because they communicate \u201cshape\u201d: If a function is async, callers know they\u2019re getting a promise-like handle. If a function is task, callers know they\u2019re spawning work that must be joined/drained. yield/await make synchronization points visible in code review (no hidden \u201cmaybe blocks here\u201d). Next Reference: std::task and std::sync (sidebar \u2192 standard library)"
    },
    {
      "id": "usage/editor-ctags",
      "title": "Universal Ctags Support",
      "section": "usage",
      "summary": "This repository ships a Universal Ctags configuration for Silk at the repo root in `.ctags`.",
      "text": "Universal Ctags Support This repository ships a Universal Ctags configuration for Silk at the repo root in .ctags. What It Tags The bundled rules recognize: fn declarations (including export fn, export default fn when named, and async/task-modified functions), let and var bindings (including export let, export var, and let mut), ext declarations (including export ext), struct, enum, error, interface, and impl declarations, package declarations. These tags are regex-based and intentionally conservative; they do not perform semantic resolution or scope analysis. Usage (Project-Local) From the repository root: ctags -R Universal Ctags will read .ctags automatically and tag .slk files as Silk. If your ctags binary is not Universal Ctags, install it first; Exuberant/etags do not support the same configuration format. Usage (Global) To use the Silk rules across multiple projects: 1. Copy .ctags to ~/.ctags.d/silk.ctags. 2. Run ctags -R in any Silk project. If you already maintain a global ctags configuration, merge the Silk rules into it instead."
    },
    {
      "id": "usage/editor-vim",
      "title": "Vim Integration for Silk",
      "section": "usage",
      "summary": "This document describes the built-in Vim support for the Silk language shipped with this repository.",
      "text": "Vim Integration for Silk This document describes the built-in Vim support for the Silk language shipped with this repository. The goal of the Vim plugin is to provide a lightweight, spec-aligned editing experience that: recognizes Silk source files by extension, respects this repository\u2019s indentation and comment style guidelines. Files and Layout The Vim plugin lives under the top-level vim/ directory: vim/plugin/silk.vim \u2013 plugin entrypoint (sources the ftdetect script even if :filetype on is not enabled). vim/ftdetect/silk.vim \u2013 filetype detection for Silk source files. vim/syntax/silk.vim \u2013 core syntax highlighting rules for Silk. vim/ftplugin/silk.vim \u2013 filetype-specific editor defaults for Silk buffers. vim/indent/silk.vim \u2013 indentation rules for Silk buffers. These files follow Vim\u2019s standard runtime layout and can be copied into a user\u2019s ~/.vim (or Neovim) configuration or used directly from this repository via the runtimepath. Filetype Detection The plugin defines filetype=silk for .slk and .silk buffers (including build.silk). Syntax Highlighting The vim/syntax/silk.vim file is derived from: the current token and keyword tables in src/token.zig. It currently highlights: lexer keywords (as currently implemented by the keyword table in src/token.zig): package, module, import, from, export, public, private, default, const, let, var, mut, fn, test, theory, struct, enum, type, error, interface, impl, as, raw, extends, if, else, loop, while, for, in, match, return, panic, break, continue, assert, await, yield, pure, async, task, region, with, new, sizeof, ext, None/none/null, Some, true/false; testing and assertion keywords: test, assert; builtin types and type-like names: bool, integer and float types (u8, i8, \u2026, u64, i64, int, f32, f64), char, string, void, Instant, Duration, Task, Promise, map, Option, Buffer, and other core names drawn from the spec; literal forms: boolean literals (true, false), None/Some, numeric literals (decimal integers and floats) and duration literals with unit suffixes (e.g. 10ns, 250us, 5ms, 2s, 5min, 1h, 7d), character and string literals; compiler/runtime intrinsics: identifiers matching silk (internal ABI surface); special method names: constructor and drop (both have language-defined meaning in Silk); well-known package prefixes such as std::, so that standard library imports and qualified names stand out from ordinary identifiers; Formal Silk annotations: #const, #require, #assure, #assert, #invariant, #variant, #monovariant, #theory (including whitespace forms like # require) are treated as preprocessor-style constructs; comments: both // line comments and / ... / block comments (excluding doc-comment forms), consistent with the current lexer behavior in src/lexer.zig. Editor Defaults The vim/ftplugin/silk.vim file configures: indentation defaults: by default, Silk buffers inherit your Vim tab settings, if Vim is using its built-in defaults (tabstop=8, shiftwidth=8, softtabstop=0, noexpandtab), Silk buffers will use the repository\u2019s preferred indentation (2 spaces with expandtab), override via g:silkindentstyle ('auto', 'inherit', 'repo'), a line comment style of // via commentstring=// %s, C-style block comment metadata via 'comments' / 'formatoptions' so that doc-style comments like: / This is a comment / are indented and continued automatically when you press <CR> on a comment line (mirroring typical C-style comment editing behavior in Vim). The vim/indent/silk.vim file provides a simple, block-oriented indent expression that: indents by &shiftwidth across Silk buffers, indents lines that follow opening {, (, or [ characters, outdents lines that begin with closing }, ), or ]. These settings mirror the mandatory style documented in AGENTS.md for code indentation and align the editor experience with the language\u2019s comment syntax. Additional Silk-specific editor behaviors (such as formatting commands or motion/textobject helpers) can be layered on in future iterations once the language and CLI stabilize further. Snippets (Tab Expansion) The Vim plugin includes a tiny built-in snippet expander (no external snippet plugin required). In Silk buffers, pressing <Tab> will expand a small set of common constructs only when the trigger word is the only non-whitespace text on the line. Supported triggers include: fn \u2192 function skeleton export fn \u2192 exported function skeleton async fn / task fn / async task fn \u2192 concurrency-flavored function skeletons let / export let \u2192 binding skeletons import / package \u2192 statement skeletons import from \u2192 file import skeleton (import { ... } from \"file.slk\";) ext / export ext \u2192 external declaration skeletons while / for / if / ife \u2192 block skeletons (ife includes an else) match \u2192 match skeleton with Some/None cases struct / enum \u2192 type skeletons interface / impl \u2192 declaration skeletons / \u2192 doc comment block skeleton Installation Examples Option A: Install This Repo as a Vim Plugin (Recommended) If you install the repository root as a Vim plugin (common with plugin managers), plugin/silk.vim will automatically add vim/ to 'runtimepath', so Vim can discover the Silk runtime files without extra configuration. Option B: Install Only the vim/ Subdirectory If you want to distribute or install the vim/ directory as a standalone Vim plugin, keep the vim/ directory structure intact (it is a valid plugin root), including vim/plugin/silk.vim. Option C: Add vim/ to runtimepath Manually You can use the plugin directly from this repository by adding vim/ to Vim\u2019s runtimepath, for example: set runtimepath^=/path/to/silk/compiler/vim If you prefer to copy the files into your own configuration: copy vim/ftdetect/silk.vim into ~/.vim/ftdetect/, copy vim/syntax/silk.vim into ~/.vim/syntax/, copy vim/ftplugin/silk.vim into ~/.vim/ftplugin/, copy vim/indent/silk.vim into ~/.vim/indent/, copy vim/autoload/silk/snippets.vim into ~/.vim/autoload/silk/snippets.vim (if you want the built-in snippets), copy vim/plugin/silk.vim into ~/.vim/plugin/ (only needed if you want .slk filetype detection without enabling :filetype on). For Neovim, use the equivalent ~/.config/nvim/ directories or a plugin manager that can add this repository as a plugin source. LSP Integration (Silk Language Server) For a richer editing experience (on top of syntax highlighting), you can pair the Vim/Neovim plugin with the silk-lsp language server: silk-lsp implements the Language Server Protocol over stdin/stdout. It currently supports: full-document text synchronization, diagnostics driven by the parser and type checker, hover with approximate type hints for identifiers and struct fields, heuristic go-to-definition across the module set (functions, lets, structs, struct fields, and impl methods), including local let bindings and parameters, keyword/identifier completion with symbol-aware details and struct member suggestions, struct-literal field suggestions in Type { ... } expressions, signature help while typing function and method calls, top-level document symbols for fn, let, struct, enum, error, interface, ext, and impl. It does not yet provide semantic tokens, code actions, or full scope-aware navigation for match-expression binders or references; these will be added later as the compiler and LSP spec evolve. Example: Neovim Built-in LSP With Neovim\u2019s built-in LSP client (and nvim-lspconfig or a custom setup), a minimal configuration might look like: In your Neovim config (e.g., init.lua) local lspconfig = require('lspconfig') lspconfig.silkls = { cmd = { 'silk-lsp' }, filetypes = { 'silk' }, rootdir = lspconfig.util.rootpattern('.git', '.'), } To override the stdlib root for the language server, add --std-root <path> to the cmd list (or set SILKSTDROOT). Use --nostd to disable stdlib integration entirely. This assumes: silk-lsp is on your PATH (for example, after running zig build install or equivalent), the Vim filetype detection is in place so that .slk buffers have filetype=silk. Example: Generic LSP Client Configuration For other editors or LSP frontends, the configuration is conceptually similar: command: [\"silk-lsp\"] transport: stdio filetypes / selectors: Silk source files (typically .slk) capabilities: no need to advertise advanced features; the server\u2019s initialize response drives what is supported."
    },
    {
      "id": "compiler/cli-silk",
      "title": "`silk` CLI",
      "section": "compiler",
      "summary": "This document describes the command-line interface of the `silk` compiler from the downstream user\u2019s perspective.",
      "text": "silk CLI This document describes the command-line interface of the silk compiler from the downstream user\u2019s perspective. Binary Name: silk. Alias entrypoints: slc \u2014 behaves like silk build ... (convenience wrapper), slcc \u2014 behaves like silk cc ... (convenience wrapper). Core Responsibilities At maturity, the silk CLI should: Compile Silk source files into: executables, static libraries (.a), shared libraries (.so / .dylib / .dll as appropriate). Provide options to: select target triple and optimization level, choose build mode (debug / release), control linkage to the default std:: implementation or an alternative, enable/disable or tune Formal Silk verification checks, configure external and ABI-related behaviors where appropriate (e.g. visibility of libsilk.a symbols, header emission). Emit clear diagnostics with stable error codes and machine\u2011readable output when requested. The initial implementation is intentionally smaller and focuses on: global options: help / -h \u2014 print global usage and exit, help \u2014 print global usage and exit, help <command> \u2014 print command-specific usage and exit, version \u2014 print the embedding ABI version and exit, silk repl \u2014 start an interactive \u201ccompile-and-run\u201d REPL: currently supported only on linux/x8664 (native ELF backend), intended as a node-like default when silk is launched with no arguments and stdin is a TTY, stateful by replay: each successful line is appended to a session program. When you enter runtime lines (statements/expressions), the session is re-executed from the start (so side effects may repeat). Import and declaration lines are validated by compilation only (not executed), supports: .help \u2014 show help, .clear \u2014 reset session state, .cls \u2014 clear the screen, .undo \u2014 undo the last successful line, .exit \u2014 exit the REPL, history is loaded/saved to: $SILKREPLHISTORY when set, otherwise $SILKWORKDIR/replhistory (default: .silk/replhistory under the nearest package root or current directory), silk check [--nostd] [--std-root <path>] [--z3-lib <path>] [--debug] [--package <dir manifest>] <file> [<file> ...] \u2014 parse and type-check one or more Silk source files as a unit, exiting with: code 0 on success, silk test [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--filter <pattern>] [--package <dir manifest>] <file> [<file> ...] \u2014 compile and run language-level test declarations found in the module set, emitting TAP output: uses TAP version 13 formatting (TAP version 13, 1..N, ok/not ok lines), in the current implementation, each test runs in its own process so a failing assert (panic/abort) does not stop the whole suite, the supported code generation subset matches silk build for the active target (initially linux/x8664). filter <pattern> runs only tests whose display name contains <pattern> (substring match). when <file> ... inputs are omitted and --package is also omitted, but ./silk.toml exists, silk test behaves as if --package . was provided. when --package is provided: input files must be omitted (the compiler loads the package module set from the manifest), the manifest file is silk.toml (when a directory is provided, it is discovered in that directory), silk doc \u2014 generate documentation from Silkdoc comments (/ ... / and /// ...) attached to declarations: Markdown mode: silk doc [--all] <file> [<file> ...] [-o <output.md>] by default, includes exported fn/let/ext declarations and exported impl methods, plus all struct and interface declarations in the input modules, all includes non-exported functions, bindings, and methods, when -o / --out is provided, writes the Markdown output to that path; otherwise writes to stdout. Manpage mode: silk doc --man [--package <dir manifest>] [--std-root <path>] <query> [-o <output.man>] renders a single roff man(7) page to stdout (or to -o / --out when provided), the page kind is derived from the documentation tags (@cli \u2192 section 1, @misc \u2192 section 7, otherwise section 3 for API pages), when <query> is not std::..., the module set is loaded from --package when provided; otherwise the compiler searches the current working directory and its parents for silk.toml and uses the nearest match, intended as a non-interactive complement to silk man <query>. silk man <query> \u2014 render and view a temporary manpage for a symbol/module/concept derived from source documentation: std::... queries are resolved from the configured stdlib root (see \u201cstandard library import resolution\u201d below), other queries are resolved from --package when provided; otherwise the compiler searches the current working directory and its parents for silk.toml and uses the nearest match, when no manifest is found, the compiler may also resolve the query from the package search path (SILKPACKAGEPATH). diagnostics (initial): emits a single primary error diagnostic on error, includes a stable error code for known error kinds, includes a file/line/column location and caret snippet when available, when stderr is a TTY, diagnostics are decorated with ANSI colors unless disabled via NOCOLOR or TERM=dumb, standard library import resolution (first slice): when a module contains import std::...;, the CLI automatically loads the referenced std::... package modules from a configured stdlib root, so downstream users do not need to pass std source files explicitly on the command line, when --nostd (or -nostd) is provided, this auto-loading is disabled and import std::...; must be satisfied by explicitly passing source files (or the build fails), note: --nostd only affects import std::...; auto-loading; it does not disable std-root file imports (from \"std/<path>\"), which still resolve relative to the selected stdlib root, the stdlib root is selected via: std-root <path> (or --std <path> / -std <path> when <path> does not end in .a) when provided, otherwise SILKSTDROOT (environment variable) when set, otherwise a std/ directory in the current working directory (development default), otherwise ../share/silk/std relative to the silk executable (installed default), otherwise walk upward from the silk executable\u2019s directory to find a std/ directory (developer build fallback). package-to-path mapping is deterministic: std::foo::bar resolves to the file <stdroot>/foo/bar.slk. JS-style file imports may also target stdlib sources directly via from \"std/<path>\" (or from \"std/<path>.slk\"): these specifiers are resolved relative to the selected stdlib root and treated as file imports, when the .slk extension is omitted, it is appended during std-root resolution, they always load and compile the referenced .slk source module (they do not rely on the prebuilt stdlib archive). package search path import resolution (non-std::): when a module imports a bare package specifier (for example import api from \"myapi\";), the CLI may load that package from a search path configured by SILKPACKAGEPATH, SILKPACKAGEPATH is PATH-like: a list of directories separated by : (POSIX), package-to-path mapping is deterministic: myapi::core resolves to the candidate directory <root>/myapi/core and the manifest <candidate>/silk.toml, qualified symbol imports resolve the longest package prefix that exists (for example myapi::core::Thing loads myapi::core if present, otherwise myapi), the same search path is used when loading manifest dependencies that omit a path standard library archive linking (linux/x8664, current archive layout): make stdlib builds a target-specific static archive (libsilkstd.a) containing one ELF object per std module (development default: zig-out/lib/libsilkstd.a), for supported silk build --kind executable builds, the compiler can treat auto-loaded std::... modules as external during code generation and resolve their exported functions from the archive when available (while still type-checking the std sources as part of the module set), by default this archive-linking path is only used for -O0 builds (when O is omitted, this is usually the case only when --debug is enabled), for -O1+ builds, silk build prefers compiling std sources into the executable so unreachable std code can be pruned, std-lib / --std <path>.a forces archive linking regardless of -O, only std modules auto-loaded via import std::...; participate in this external/archive path; std modules imported by file path (including from \"std/<path>\") are compiled into the build like ordinary file imports, archive discovery (in order): std-lib <path> (or --std <path>.a / -std <path>.a) when provided, otherwise SILKSTDLIB when set, otherwise zig-out/lib/libsilkstd.a when using the in-repo std/ root, otherwise ../lib/libsilkstd.a relative to the silk executable, otherwise common installed-layout heuristics derived from the selected stdlib root, walk up from the current working directory to find libsilkstd.a or lib/libsilkstd.a, when no suitable archive is found (or on unsupported targets), the compiler falls back to compiling the reachable std sources into the build, nostd disables stdlib auto-loading and avoids linking the default std archive (but users may still explicitly provide their own std::... inputs as ordinary source files), user-provided package std::...; modules continue to override the default std implementation for the same package names. silk build [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--package <dir manifest>] [--build-script] [--package-target <name> ...] <input> [<input> ...] -o <path> [--kind executable object static shared] [--arch <arch>] [--target <triple>] [--c-header <path>] [--needed <soname> ...] [--runpath <path> ...] [--soname <soname>] (or --out <path>) \u2014 for now: inputs are classified by extension: .slk \u2014 Silk source files (compiled as the module set), .o \u2014 ELF relocatable objects linked into --kind executable shared outputs (and included in --kind static archives), .a \u2014 static archives; their .o members are treated like object inputs, .so \u2014 shared libraries treated as dynamic dependencies (equivalent to --needed <soname> using the library\u2019s basename), .c \u2014 C sources compiled to objects via the host C compiler (see silk cc / SILKCC) and then treated like .o inputs, note: linking .o/.a/.c inputs is currently supported only for linux/x8664 outputs, when multiple input files are provided, runs module-set front-end checks (package/import resolver + multi-module type checking that accounts for imported exported constants and imported export fn calls), declaration-only exported function prototypes (export fn name(...) -> T;) are accepted as module exports for type-checking, but do not emit code; calls lower as link-time symbol references that must be satisfied by other Silk sources in the module set and/or non-.slk link inputs (.o/.a/.c), when a single input file is provided, runs the existing single-module front-end checks, when no input files are provided and --package / --pkg is omitted, but ./silk.toml exists, the compiler behaves as if --package . was provided (package builds from the current directory by default), when --package is provided: .slk input files must be omitted (the module set is loaded from the manifest), but non-.slk link inputs (.c, .o, .a, .so) may still be provided, build-script runs <packageroot>/build.silk and uses its stdout as package-target <name> selects one or more manifest [[target]] entries by name (repeatable; --pkg-target is accepted as an alias), when omitted, the compiler builds every manifest [[target]] entry by default, when building multiple targets (the default when --package-target is omitted, or when it is repeated), per-output flags are rejected: o/--out, --kind, --arch, --target, --c-header, --needed, --runpath, --soname, o/--out is optional only when building a single target (defaults to the target\u2019s output or a computed default under build/), package dependencies are loaded from the manifest\u2019s [dependencies] table, when -o/--out or --c-header includes parent directories that do not exist yet, the compiler creates them (like mkdir -p), multi-file builds are supported for --kind executable and for --kind object, --kind static, and --kind shared: when multiple packages are present in a module set for a non-executable output, only exports from the root package (the package of the first input module) are emitted as globally-visible symbols; other packages are compiled as dependencies and their export declarations are treated as internal for that output, for --kind executable: when the module set defines a valid Silk entrypoint, enforces the executable entrypoint rule (exactly one main of either fn main() -> int, async fn main() -> int, or fn main(argc: int, argv: u64) -> int), script-style entrypoints: when the first .slk input contains top-level statements (after the normal package/module header and import block) and does not define an explicit main, silk build treats those statements as a script body and synthesizes an implicit fn main() -> int that executes them and then returns 0, when the module set defines no valid Silk main, requires an object/archive-provided main(argc: int, argv: u64) -> int symbol (for example from a .c/.o/.a input) and emits an entry stub that forwards argc/argv to it, note: for now, --std-lib / --std <path>.a is rejected when linking additional .c/.o/.a inputs into an executable (std sources are compiled into the build instead), for linux/x8664 native executables, when the argc/argv form is used, the entry stub passes: argc: the process argument count, and argv: a raw pointer to the argv pointer list (a C-style char, where argv[0] is at byte offset 0, argv[1] at 8, etc.), other targets and backends may continue to require the parameterless fn main() -> int form until they implement argument passing, for --kind object, --kind static, and --kind shared, main is optional; the current backend emits supported export fn functions and supported exported constants (export let/export const; scalar exports require an explicit type annotation, and string exports may omit : string when the initializer is a string literal), plus a valid executable main when present, as globally-visible symbols, it is valid for a non-executable output to contain no globally-visible symbols (for example, type-only or interface-only modules); in that case the build still succeeds and produces an \u201cempty\u201d object/archive/shared library, debug (or -g) enables a debug build mode for the supported linux/x8664 back-end subset: failed assert prints a panic header + optional message + stack trace to stderr (via glibc backtracesymbolsfd) before aborting, and dynamically-linked executables export internal function symbols in .dynsym (similar to -rdynamic) so stack traces can be symbolized without external tooling, compiled code can query build metadata at runtime via std::runtime::build::{isdebug,kind,mode,version}(), noheap disables heap allocation for the current compiler/runtime subset: heap-backed new (outside a with region) is rejected with E2027, ext bindings to libc heap primitives (malloc/calloc/realloc/free/etc) are rejected with E2027 in non-stdlib modules, std::runtime::mem::{alloc,realloc,free} traps when called without an active with region (no implicit heap fallback), any use of async, task, await, yield, or capturing closures is rejected with E2027, region-backed new inside with is still permitted, noheap is currently incompatible with --debug (debug panic traces require malloc/free), by default, builds an executable (--kind executable), when --kind object, --kind static, or --kind shared is provided: on linux/x8664, attempts to emit an ELF64 relocatable object, static library, or shared library (.so) for the same supported IR subset, and otherwise exits non-zero with E4001 (unsupported construct) or E4002 (backend failure) diagnostics that explain the exact limitation, attempts to emit an executable using: for --target linux-x8664 (the default; also accepts common x8664--linux- triples such as x8664-linux-gnu), an IR\u2192ELF backend on linux/x8664 for a growing scalar subset, and a constant\u2011expression backend (with a tiny ELF64 stub) for purely constant main bodies, for --target wasm32-unknown-unknown: an IR\u2192WASM backend for the current supported subset (multi-module builds, control flow, string/data segments, and ext imports), exports memory plus main when present (embedder entry), or emits an export-only module (no main) that exports supported export fn declarations from the root package, note: Silk int currently lowers to wasm i64, so wasm exports using int surface as i64, for --target wasm32-wasi: an IR\u2192WASM backend that emits memory plus start () -> void, imports wasisnapshotpreview1.procexit, and calls Silk fn main () -> int (the main(argc, argv) entrypoint form is not supported yet for WASI), also supports export-only modules for embedding (export-only modules do not include start), for both wasm targets, a smaller constant-only wasm backend remains as a fallback for programs that fit the constant subset, the constant subset (available on linux-x8664 and the initial wasm32 targets) consists of: a single fn main() -> int whose body is: zero or more let statements with constant integer initializers, followed by exactly one return of a constant integer expression, or the same, with a final if whose condition is a compile\u2011time boolean literal (true / false) and whose branches each satisfy the \u201cconstant lets + return constant expression\u201d rule, and on linux/x8664, a richer IR\u2011based backend is used first; for this backend, the currently supported (documented and tested) subset includes: fn main() -> int and helper functions that: take scalar parameters (defaulting to int when unannotated) drawn from int, bool, char, f32, f64, Instant, Duration, and the fixed-width integer types (u8/i8 \u2026 u64/i64); helper functions return a scalar from the same set (while main remains -> int), or void (omitted result type or explicit -> void) when used only as standalone statements (return; and implicit fallthrough returns are supported for void helpers), helpers may also accept and return string values at ABI boundaries (represented as { ptr: u64, len: i64 } / SilkString; results return via rax/rdx), use integer arithmetic (+, -, , /, %, including unary -x), bitwise operators (&, , ^, ~, <<, >>), integer comparisons (==, !=, <, <=, >, >=), and floating-point arithmetic/comparisons (+, -, , /, ==, !=, <, <=, >, >=, including unary -x) over f32/f64, use char literals (UTF-8 or escaped) and == / != comparisons over char values (lowered as u32 scalars in IR), use bool as a distinct surface type, with booleans represented as integer values at the IR level, use if / else and while with conditions drawn from: boolean literals, comparisons over integer and floating-point expressions, and == / != over boolean expressions, calls to bool-returning helpers of this subset, logical operators !, &&, and composed over those expressions (&& / are short\u2011circuiting), and boolean locals (let flag: bool = <bool expr>; if flag { ... }), in addition to conditions, boolean value positions (for example let flag: bool = a && b; and return a b; in bool-returning helpers) support the same boolean expression subset and preserve short-circuit evaluation, use break; and continue; inside while loops, allow call expressions as standalone statements (discarding the returned value), allow assignment and compound assignment to let mut locals by name (x = expr;, x += y;); in the current implementation the left-hand side must be an identifier, = is supported for all currently supported value types (including string, the supported struct subset, and optionals of those), and compound assignments are supported only for numeric scalar locals, integer-like scalars (bool and integers) use up to 6 general-purpose registers (rdi, rsi, rdx, rcx, r8, r9), f32/f64 use up to 8 XMM registers (xmm0..xmm7), remaining scalar arguments are spilled to the stack in order, the caller maintains 16-byte stack alignment before call (padding by one 8-byte slot when needed), and results return in registers for 0\u20132 scalar results (integer-like in rax/rdx, floats in xmm0/xmm1), and 3+ scalar results return indirectly via a hidden sret pointer passed in rdi (caller-allocated return buffer), on linux/x8664, the same backend also supports a limited string subset: within function bodies, the compiler supports a small string expression subset: string literals, let bindings of string, return of a string value, direct calls to string-returning helpers, and ==/!=/</<=/>/>= comparisons over string values (producing bool); other string operations (concatenation, indexing, etc.) are not implemented yet, string literals are embedded as rodata byte blobs and .text\u2192rodata fixups are emitted/handled appropriately for each output kind (ELF relocations for object/static outputs; direct RIP-relative displacement patching for shared libraries and executables once the final .text/rodata layout is known), for non-executable outputs, exported string constants (export let/export const with a string literal initializer; : string is optional) are emitted as SilkString data symbols for downstream C consumers, and exported functions of this subset may accept and return string values using the same { ptr: u64, len: i64 } ABI. on linux/x8664, the current backend also supports a limited struct subset: struct declarations with 0+ fields of supported value types: scalar primitives (int/fixed-width ints, bool, char, f32, f64, Instant, Duration), string (lowered as { ptr: u64, len: i64 }), nested (non-opaque) structs, and optionals (T?) of supported payload types, struct literals (Type{ field: expr, ... }) and field access (value.field) for those structs; in Silk, struct literals may omit fields and omitted fields are zero-initialized, ==/!= comparisons over values of those structs (deep/slot-wise equality, including embedded strings, nested structs, and optionals) producing bool, passing and returning such structs by value in helper calls by lowering them to their scalar slots in order (\u201cslot flattening\u201d) and using the same System V AMD64 calling convention as scalar arguments/results, at ABI boundaries for exported/FFI functions, structs must be ABI-safe: after slot flattening, all slots must be i64/u64/f64 (for example string fields are ABI-safe, but bool, char, and f32 fields are not). on linux/x8664, the current backend also supports a limited optional subset: optionals of scalar payload types (T? where T is bool, char, f32, f64, int, Instant, Duration, or a fixed-width integer), optionals of string payload type (string?), and optionals of the supported struct subset (Type? where Type is a supported 0+ field struct), nested optionals (T??) for these payload types, constructing optionals via None and Some(<expr>) for those payload types, == / != comparisons over those optionals (tag + payload equality; nested optionals compare recursively); None / Some(...) can be used directly in equality expressions when the other operand provides the optional type context (for example opt == None and opt == Some(x)), accessing fields of optional structs via optional field access (opt?.field), producing an optional result of the field type (FieldType?), matching on optionals via match <scrutinee> { None => <expr>, Some(<name >) => <expr>, } (exactly one None arm and one Some(...) arm; arm bodies are expressions in the current implementation), unwrapping optionals via ?? with short-circuit evaluation of the fallback expression (including unwrapping T?? to T?), and passing/returning optionals between helpers at ABI boundaries as (bool tag, payload0, payload1, ...), where the payload slots follow the lowering of the underlying non-optional type (for example string? is (bool, u64 ptr, i64 len)). on linux/x8664, the current backend also supports a limited external call subset: top-level ext declarations of external functions (ext name = fn (T, ...) -> R;) may be called like normal functions from Silk code, these calls are supported for all output kinds: kind object and --kind static emit relocations against undefined external symbols for downstream linkers, and kind shared emits dynamic imports and calls through the shared object\u2019s GOT (symbols must be available at runtime), kind executable emits a dynamically-linked ELF64 executable and calls through the executable\u2019s GOT (symbols must be available at runtime), top-level ext declarations of external scalar variables (ext name = T;) may be read like normal values from Silk code: kind object and --kind static emit relocations against undefined external data symbols, and kind shared emits dynamic imports and loads through the shared object\u2019s GOT (symbols must be available at runtime), kind executable emits a dynamically-linked ELF64 executable and loads through the executable\u2019s GOT (symbols must be available at runtime), writing to ext variables is not supported, for executables and shared libraries, silk build supports declaring dynamic loader dependencies via --needed <soname> (repeatable), which are emitted as DTNEEDED entries, runtime search paths for those dependencies can be provided via --runpath <path> (repeatable), which is emitted as a single DTRUNPATH entry (joined with ':'), and for shared library outputs, the library soname can be set via --soname <soname> (emitted as DTSONAME), on linux/x8664 with the glibc dynamic loader (ld-linux), when an executable or shared library imports any external symbols, silk automatically adds libc.so.6 as a DTNEEDED dependency (so hosted std:: modules do not require --needed libc.so.6), on the same baseline, when libsodium-backed symbols are imported (for example via import std::crypto;), silk automatically adds libsodium.so.23 as a DTNEEDED dependency, on the same baseline, when bundled runtime support symbols are imported (for example via import std::regex;, import std::unicode;, or import std::number;), silk statically links the bundled runtime support archive into the output (libsilkrt.a, or libsilkrtnoheap.a when building with --noheap); the produced executable/shared library does not depend on libsilkrt.so at runtime, additional non-libc, non-libsodium dependencies still must be declared via --needed <soname> (or otherwise be available in the process global scope at load time, for example via LDPRELOAD), bundled runtime archive discovery: the compiler locates libsilkrt.a / libsilkrtnoheap.a via (in order): SILKRTLIBDIR (environment variable; a directory containing the runtime archives), zig-out/lib in the current working directory (development default), ../lib relative to the silk executable (installed default). fn main() itself may be: a single function with structured control flow as above, or a small program that calls one or more helpers (with the same scalar subset), all lowered into IR and compiled together into a single executable, when multiple input files are provided, this executable build path operates on the entire module set and supports: same-package helper calls across modules (functions in one module calling functions defined in another module of the same package), and imported exported calls (export fn) across packages for the current scalar subset (both foo() and pkg::foo() call forms are accepted initially after import pkg;), examples that are known to be supported and tested include: straight\u2011line integer programs such as fn main() -> int { return 1 + 2 3; }, programs with local and top\u2011level integer let bindings used in the final return, programs that branch on comparison conditions at runtime, for example: fn main () -> int { if 1 < 2 { return 10; } else { return 20; } } small loops expressed in terms of while and break; / continue;, helper\u2011call programs such as: fn helper (x, y) -> int { if x < y { let one: int = 1; return x + one; } else { let two: int = 2; return y + two; } } fn main () -> int { return helper(1, 3); } helpers that take many integer parameters (exercising both register and stack\u2011passed arguments) and are called from main, programs that use boolean locals and conditions, for example: fn main () -> int { let x: int = 1; let y: int = 2; let flag: bool = x < y; if flag { return 3; } else { return 4; } } and small helper programs with boolean locals and if / else, such as: fn helper (x) -> int { let flag: bool = x < 0; if flag { return 1; } else { return 2; } } fn main () -> int { return helper(1); } for programs that type\u2011check but fall outside both the constant subset and the current IR\u2011based backend subset, silk build exits non\u2011zero with E4001 diagnostics that point at the rejected construct (or E4002 when the backend fails unexpectedly). High-Level Command Model (Initial Implementation) The initial CLI implementation supports a small, well-defined subset of the eventual UX. Top-level commands: silk help [<command>]: Prints global usage when <command> is omitted. Prints command-specific usage when <command> is provided. Subcommands also accept --help / -h to print command-specific usage. For check / test / build / doc, -- ends option parsing (all remaining args are treated as file paths, even if they begin with -). silk check [--nostd] [--std-root <path>] [--z3-lib <path>] [--debug] [--package <dir manifest>] <file> [<file> ...]: Reads one or more input files, runs lexing, parsing, package/import resolution, and type checking. Prints a success message on stdout for valid programs. Prints a human-readable error on stderr and exits non-zero for invalid programs. silk test [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--filter <pattern>] [--package <dir manifest>] <file> [<file> ...]: Compiles and runs each test, emitting TAP version 13 output. In the current implementation, each test runs in its own process so a failing assert (panic/abort) does not stop the whole suite. Optimization: O <0-3> selects the optimization level (default: -O2; when --debug is set and -O is omitted, defaults to -O0). In the current implementation, -O1+ prunes unused extern symbols before code generation (typically reducing output size and stdlib linkage). For IR-backed native executable builds, -O1+ also prunes unreachable functions from the executable entrypoint (function-level dead-code elimination). When --filter <pattern> is provided, only tests whose display name contains <pattern> are executed. When <file> ... inputs are omitted and --package is also omitted, but ./silk.toml exists, silk test behaves as if --package . was provided. silk build [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--package <dir manifest>] [--build-script] [--package-target <name> ...] <file> [<file> ...] -o <path> [--kind executable object static shared] [--arch <arch>] [--target <triple>] [--c-header <path>] [--needed <soname> ...] [--runpath <path> ...] [--soname <soname>] (or --out <path>): Reads one or more input files, runs the same front-end pipeline as check. Optimization: O <0-3> selects the optimization level (default: -O2; when --debug is set and -O is omitted, defaults to -O0). In the current implementation, -O1+ prunes unused extern symbols before code generation. For --kind executable builds, -O1+ also prunes unreachable functions from the executable entrypoint (function-level dead-code elimination), typically reducing output size. When --package is provided: input files must be omitted, build-script runs <packageroot>/build.silk and uses its stdout as package-target <name> selects one or more manifest [[target]] entries by name (repeatable; --pkg-target is accepted as an alias), when omitted, the compiler builds every manifest [[target]] entry by default, when building multiple targets (the default when --package-target is omitted, or when it is repeated), per-output flags are rejected: o/--out, --kind, --arch, --target, --c-header, --needed, --runpath, --soname, when building a single target, -o/--out is optional (defaults to that target\u2019s output or a computed default under build/). Target selection: arch <arch> and --target <triple> are mutually exclusive; omit both to use the default target. Entrypoint rules: for --kind executable (the default), there must be exactly one main, using either fn main() -> int, async fn main() -> int, or fn main(argc: int, argv: u64) -> int, for --kind object, --kind static, and --kind shared, main is not required; at least one supported export fn, supported export let constant, or a valid executable main must be present so the output contains one or more globally-visible symbols. Multi-file builds are supported for --kind executable and for --kind object/--kind static/--kind shared: for non-executable outputs, when multiple packages are present in a module set, only exports from the root package (the package of the first input module) are emitted as globally-visible symbols; other packages are compiled as dependencies and their export declarations are treated as internal for that output. Output selection: default: build an executable (--kind executable), kind object: build an ELF64 relocatable object (.o) on linux/x8664, kind static: build a static library (.a) on linux/x8664, kind shared: build a shared library (.so) on linux/x8664. Dynamic dependencies: needed <soname> adds a DTNEEDED entry for executable and shared outputs; it may be repeated, runpath <path> (or --rpath <path>) adds a runpath element for executable and shared outputs; it may be repeated (joined with ':' into DTRUNPATH), soname <soname> sets the shared library soname recorded as DTSONAME for shared outputs (an empty string clears it), for object and static library outputs, --needed, --runpath, and --soname are ignored. on linux/x8664 with the glibc dynamic loader (ld-linux), silk automatically adds: libc.so.6 as a DTNEEDED dependency when external symbols are present (so hosted std:: modules do not require --needed libc.so.6), and libpthread.so.0 when pthread symbols are imported, and libsodium.so.23 when libsodium-backed symbols are imported (for example via import std::crypto;). when bundled runtime support symbols are imported (for example via import std::regex;), silk statically links libsilkrt.a (or libsilkrtnoheap.a when building with --noheap) into the output; no runtime DTNEEDED entry is emitted for libsilkrt. needed entries starting with libsilkrt are rejected; the bundled runtime support layer is always linked from the static archives. Debug builds: debug (or -g) enables runtime stack traces for failed assert statements on linux/x8664 by printing a stack trace to stderr before aborting, and preserves internal function symbols in .dynsym for better symbolization. when Formal Silk verification fails, --debug also emits Z3 debugging output and writes an SMT-LIB2 reproduction script under .silk/z3/ (or $SILKWORKDIR/z3). Heap control: noheap disables heap allocation for the: heap-backed new (outside a with region) is rejected with E2027, ext bindings to libc heap primitives (malloc/calloc/realloc/free/etc) are rejected with E2027 in non-stdlib modules, std::runtime::mem::{alloc,realloc,free} traps when called without an active with region (no implicit heap fallback), any use of async, task, await, yield, or capturing closures is rejected with E2027, region-backed new inside with is still permitted. noheap is currently incompatible with --debug (debug panic traces require malloc/free). For the supported subset, emits the selected artifact at <path>. C99 header emission (for downstream consumers of exported symbols): c-header <path> writes a generated C header at <path> that declares the root package\u2019s exported symbols (export fn prototypes and export let extern declarations) for consumption from C/C++, this option is only meaningful for non-executable outputs (--kind object static shared) and is rejected for --kind executable, to keep the C ABI surface obvious and stable, --c-header requires the root package (the package of the first input module) to be the global package (i.e. omit package ...; in the exported library\u2019s sources), string values use SilkString { ptr, len } (from silk.h), optionals and 3+ slot structs are lowered at call boundaries as multiple scalar parameters (so C prototypes for such parameters use flattened arguments rather than by-value C struct parameters). For programs outside the supported subset that nonetheless type-check, exits non-zero with a clear E4001 / E4002 diagnostic (instead of a generic \u201ccode generation is not implemented yet\u201d message). Formal Silk verification: when Formal Silk syntax is present (for example #require, #assure, #assert, #invariant, #variant, #monovariant, #const), check / test / build require proofs and fail the build when verification fails, when --debug is set, failing proof obligations also emit Z3 debugging output and write an SMT-LIB2 reproduction script under .silk/z3/ (or $SILKWORKDIR/z3), z3-lib <path> overrides the Z3 dynamic library used by the verifier (it also honors SILKZ3LIB). silk doc: Markdown mode: silk doc [--all] <file> [<file> ...] [-o <output.md>] Generates Markdown documentation from Silkdoc comments (/ ... / and /// ...) attached to declarations. By default, includes exported fn/let/ext declarations and exported impl methods, plus all struct and interface declarations in the input modules. all includes non-exported functions, bindings, and methods. When -o / --out is provided, writes the Markdown output to that path; otherwise writes to stdout. Manpage mode: silk doc --man [--package <dir manifest>] [--std-root <path>] <query> [-o <output.man>] Renders a roff man(7) page derived from source docs (@cli/@misc/API docs) and writes it to stdout (or to -o / --out). silk cc <cc args...>: Runs a host C compiler to build C99 (or C++) programs that embed or link against libsilk.a. Selects the compiler executable via SILKCC (when set), otherwise falls back to cc. Automatically adds the include and library search paths adjacent to the installed silk binary (for example ../include and ../lib), plus -lsilk. On linux/x8664, also adds -lstdc++ -lpthread -lm (vendored Z3 is built as C++). Passes through additional arguments verbatim to the underlying compiler (files, flags, -o, -I, -L, etc.). Wrapper usage can be displayed via silk help cc (since silk cc --help is passed through to the underlying compiler). Future commands (not yet implemented, but documented for roadmap clarity): silk fmt <path> \u2014 format Silk source files. silk abi header \u2014 emit silk.h and ABI descriptions for embedders. Documentation & Manpages"
    },
    {
      "id": "compiler/build-scripts",
      "title": "Build Scripts (`build.silk`)",
      "section": "compiler",
      "summary": "This document specifies Silk\u2019s *build script* concept: a package-local Silk program named `build.silk` that can generate a package build plan at build time.",
      "text": "Build Scripts (build.silk) This document specifies Silk\u2019s build script concept: a package-local Silk program named build.silk that can generate a package build plan at build time. Build scripts are intentionally outside the core language semantics (they are a tooling/build feature). The language-level package / import / export Overview A build script is an optional file: build.silk (in the package root directory) When enabled, silk compiles and runs the build script and treats its stdout as a TOML v1.0 package manifest in the same format as silk.toml This allows packages to compute targets, outputs, and dependency paths dynamically (for example from environment variables, host information, or local filesystem probes) while keeping the compiler\u2019s build execution model centered on a concrete manifest. Invocation (CLI) Build scripts are executed only when explicitly requested. silk build --package <dir manifest> --build-script Rules: The build script path is <packageroot>/build.silk, where <packageroot> is the directory containing the package. If build.silk does not exist, silk build --build-script fails. The build script is executed as a hosted native program on the build host. In the current implementation, this is supported only on linux/x8664. The build script\u2019s stdout is parsed as a manifest and used for the remainder of the build in place of reading <packageroot>/silk.toml. The build script may write logs to stderr; they are forwarded by the driver. Script Contract The build script MUST exit with status code 0 on success. The build script MUST print a valid TOML v1.0 manifest to stdout. The build script SHOULD avoid printing non-manifest text to stdout (use stderr for logs). The build script output is subject to the same size cap as manifests: The build script is invoked with one positional argument: argv[1] \u2014 the absolute package root directory. Security Model Build scripts are arbitrary code execution. For this reason: build scripts are not run implicitly by silk build in the current implementation; they require --build-script, downstream tooling (package managers, CI, editor integrations) MUST treat build scripts as untrusted inputs unless they are pinned and reviewed. Example build.silk (prints a manifest that builds src/main.slk as an executable): import std::io; fn main (argc: int, argv: u64) -> int { = argc; = argv; std::io::print([package] name = \"hello\" [[target]] name = \"hello\" kind = \"executable\" entry = \"src/main.slk\" ); return 0; }"
    },
    {
      "id": "compiler/abi-libsilk",
      "title": "C99 ABI and `libsilk.a`",
      "section": "compiler",
      "summary": "This document defines the C99 ABI and the interface of the `libsilk.a` static library.",
      "text": "C99 ABI and libsilk.a This document defines the C99 ABI and the interface of the libsilk.a static library. Goals Provide a stable C ABI for embedders. Keep the ABI small, explicit, and well-documented. Library & Headers Static library: libsilk.a. Primary header: include/silk.h. Linking on linux/x8664 (vendored Z3) On linux/x8664, libsilk.a vendors Z3 (via vendor/lib/x64-linux/libz3.a) to support Formal Silk verification. The vendored Z3 static library is built as C++, so downstream embedders linking against libsilk.a MUST also link the system C++ runtime and any required system libraries: cc -std=c99 -Wall -Wextra \\ I/path/to/include yourapp.c \\ L/path/to/lib -lsilk \\ lstdc++ -lpthread -lm The silk cc wrapper adds these flags automatically when linking on linux/x8664. The header must define: Core bridged types (e.g. SilkString, and any other structs or enums used by the ABI). Opaque handle types (SilkCompiler, SilkModule, SilkError) and their lifetime rules. Entry points for: initializing and shutting down compiler/runtime state, configuring compilation (target triple, stdlib name, optimization level), adding source buffers, compiling Silk source to executables, libraries, or object files, interacting with diagnostics and error reporting. Initial C Header Shape (include/silk.h) The initial C header provided in this repository defines: SilkString mirroring the internal Silk string layout: Note: SilkString is also the C ABI shape for Silk regexp values (bytecode-backed { ptr, len }), but the bytes are opaque and not required to be null-terminated. typedef struct SilkString { char ptr; int64t len; } SilkString; SilkBytes for owned binary buffers returned by in-memory build APIs: typedef struct SilkBytes { uint8t ptr; int64t len; } SilkBytes; 128-bit scalar primitives (i128 / u128 / f128) used by generated C headers for exported Silk interfaces: typedef struct SilkU128 { uint64t lo; uint64t hi; } SilkU128; typedef struct SilkI128 { uint64t lo; int64t hi; } SilkI128; typedef struct SilkF128 { uint64t lo; uint64t hi; } SilkF128; Notes: SilkF128 stores the IEEE\u2011754 binary128 bit pattern. It is not C long double. These types are passed and returned as two integer-like 8-byte slots in the current linux/x8664 backend subset. Opaque handles: typedef struct SilkCompiler SilkCompiler; typedef struct SilkModule SilkModule; typedef struct SilkError SilkError; An output-kind enum: typedef enum SilkOutputKind { SILKOUTPUTEXECUTABLE = 0, SILKOUTPUTSTATICLIBRARY = 1, SILKOUTPUTSHAREDLIBRARY = 2, SILKOUTPUTOBJECT = 3, } SilkOutputKind; ABI version query: void silkabigetversion(int outmajor, int outminor, int outpatch); Compiler lifecycle: SilkCompiler silkcompilercreate(void); void silkcompilerdestroy(SilkCompiler compiler); Configuration: bool silkcompilersetstdlib(SilkCompiler compiler, SilkString stdlibname); bool silkcompilersetstdroot(SilkCompiler compiler, SilkString stdroot); bool silkcompilersetnostd(SilkCompiler compiler, bool nostd); bool silkcompilersetdebug(SilkCompiler compiler, bool debug); bool silkcompilersetnoheap(SilkCompiler compiler, bool noheap); bool silkcompilersettarget(SilkCompiler compiler, SilkString targettriple); bool silkcompilersetz3lib(SilkCompiler compiler, SilkString path); bool silkcompilersetstdarchive(SilkCompiler compiler, SilkString path); bool silkcompileraddneededlibrary(SilkCompiler compiler, SilkString soname); bool silkcompileraddrunpath(SilkCompiler compiler, SilkString path); bool silkcompilersetsoname(SilkCompiler compiler, SilkString soname); bool silkcompilersetoptimizationlevel(SilkCompiler compiler, int level); bool silkcompilersetcheader(SilkCompiler compiler, SilkString path); silkcompilersetstdroot configures the filesystem stdlib root directory used to auto-load std::... packages when modules contain import std::...;. The stdroot string is copied. When set, it overrides SILKSTDROOT and the working-directory/default search behavior described below. silkcompilersetnostd disables this stdlib auto-loading behavior when set to true. When nostd is enabled, import std::...; declarations must be satisfied by explicitly adding the corresponding std sources as modules (for example via silkcompileraddsourcebuffer); the compiler will not consult SILKSTDROOT or the filesystem std root search paths. silkcompilersetdebug enables the same debug build mode as the CLI (silk --debug): debug-mode lowering for supported native outputs, and additional Z3 debug output plus .smt2 reproduction scripts on failing Formal Silk obligations (written under .silk/z3/ or $SILKWORKDIR/z3). silkcompilersetnoheap enables the same no-heap mode as the CLI (silk --noheap): heap-backed allocation is disabled for the supported subset. --noheap is currently incompatible with --debug; the ABI rejects configurations that enable both. silkcompilersetoptimizationlevel selects the optimization level (0-3), matching the CLI -O flag. The default is level 0 unless overridden. In the current implementation, level 1+ enables lowering-time pruning of unused extern symbols before code generation. For IR-backed native executable builds, it also prunes unreachable functions from the executable entrypoint (function-level dead-code elimination), typically reducing output size and over-linking when using the prebuilt libsilkstd.a archive to satisfy auto-loaded import std::...; modules. silkcompilersettarget selects the code generation target. The targettriple string is copied. The initial implementation recognizes: linux-x8664 (default), and common x8664--linux- triples such as x8664-linux-gnu and x8664-unknown-linux-gnu, wasm32-unknown-unknown, wasm32-wasi (and other wasm32 triples containing wasi). For wasm32 targets, only SILKOUTPUTEXECUTABLE is supported. The output bytes are a final WebAssembly module (.wasm) produced by the IR-backed wasm backend (src/backendwasmir.zig), with a smaller constant-only fallback for programs that fit the constant subset. The wasm backend is still early-stage, but it is no longer limited to single-module constant programs: Multi-module builds (packages + file imports) are supported. ext foo = fn (...) -> ...; declarations become imported functions under env.foo for wasm32-unknown-unknown, analogous to extern symbols in C. String and other constant data are emitted into wasm data segments. Entrypoint conventions: wasm32-unknown-unknown: when a valid executable main exists, it is exported as main for embedder use, when no main exists, an export-only module is emitted that exports each supported export fn from the root package. wasm32-wasi: requires fn main () -> int (the main(argc, argv) form is not supported yet for WASI), emits an exported start () -> void wrapper that calls main and then imports/calls WASI procexit, export-only modules are supported for embedding (export-only modules do not include start). silkcompileraddneededlibrary records a dynamic loader dependency for executable and shared library outputs (emitted as DTNEEDED). The soname string is copied; the function may be called multiple times (duplicates are ignored). For static library and object outputs, the value is ignored. DTNEEDED entries starting with libsilkrt are rejected: bundled runtime helpers are linked statically from libsilkrt.a / libsilkrtnoheap.a and must not become runtime loader dependencies. On linux/x8664 with the glibc dynamic loader (ld-linux), when an executable or shared library imports any external symbols, the compiler automatically adds libc.so.6 as a DTNEEDED dependency (so embedders do not need to manually add libc when using hosted std:: modules like std::io and std::fs). Additional non-libc dependencies must still be declared via silkcompileraddneededlibrary. silkcompileraddrunpath records a dynamic loader search path element for executable and shared library outputs (emitted as DTRUNPATH). The path string is copied; the function may be called multiple times (duplicates are ignored) and the final DTRUNPATH string is formed by joining all entries with ':'. silkcompilersetsoname configures the shared library soname recorded as DTSONAME for shared library outputs. The soname string is copied; passing an empty string clears the configured soname (no DTSONAME entry). For executable, static library, and object outputs, the value is ignored. silkcompilersetz3lib configures a Z3 dynamic library override for Formal Silk verification (equivalent to the CLI --z3-lib <path>). Passing an empty string clears the override and returns to the normal Z3 selection rules (including honoring SILKZ3LIB). silkcompilersetstdarchive configures a stdlib archive override (equivalent to the CLI --std-lib <path>). Passing an empty string clears the override and returns to the normal stdlib archive selection rules (including honoring SILKSTDLIB). silkcompilersetcheader configures C header generation for non-executable outputs (equivalent to the CLI --c-header <path>). The header is written when silkcompilerbuild succeeds for SILKOUTPUTOBJECT, SILKOUTPUTSTATICLIBRARY, or SILKOUTPUTSHAREDLIBRARY. C header generation is not supported for silkcompilerbuildtobytes. Source management: SilkModule silkcompileraddsourcebuffer(SilkCompiler compiler, SilkString name, SilkString contents); Building artifacts: bool silkcompilerbuild(SilkCompiler compiler, SilkOutputKind kind, SilkString outputpath); For embedders that need filesystem-free compilation (for example sandboxed hosts or WASM-like environments), the ABI also provides an in-memory build API that returns an owned byte buffer: bool silkcompilerbuildtobytes(SilkCompiler compiler, SilkOutputKind kind, SilkBytes outbytes); void silkbytesfree(SilkBytes bytes); The returned bytes are target-specific: for example an ELF64 binary on linux-x8664, or a .wasm module on wasm32 targets. Ownership rules: On success, silkcompilerbuildtobytes fills outbytes with a pointer and length describing the produced artifact, and returns true. The returned outbytes->ptr is owned by libsilk.a and must be freed by calling silkbytesfree(&bytes). Callers must not free the pointer with free() (or any other allocator). silkbytesfree is a no-op when passed NULL or when bytes->ptr is NULL; it always clears the struct to { NULL, 0 }. Note: the compiler may still consult the filesystem to auto-load std::... modules unless silkcompilersetnostd(compiler, true) has been set. At the current stage of implementation: silkcompilerbuild always performs full front\u2011end validation for all modules added via silkcompileraddsourcebuffer: it lexes and parses each module into an internal representation, it then type\u2011checks the set of modules as a unit, taking into account package/import relationships and exported constants, according to the if Formal Silk syntax is present (for example #require, #assure, #assert, #invariant, #variant, #monovariant, #const), it also runs the Z3-backed verifier and fails the build if verification fails (E3001..E3008), the verifier is currently skipped for stdlib modules (std::...), on linux/x8664, Z3 is linked from the vendored static archive vendor/lib/x64-linux/libz3.a, the verifier honors SILKZ3LIB (environment variable) to override the Z3 dynamic library at runtime, it fails fast on the first front\u2011end error. when packages/imports are present: import declarations must refer to packages that exist in the current module set (otherwise a resolver error is reported, such as \"unknown imported package\"), exported let bindings with explicit type annotations in an imported package are treated as ordinary, unqualified names in the importing modules for type\u2011checking purposes (for example, import util; and export let answer: int = 42; in util allows let x: int = answer; in app), imported exported functions (export fn) are callable across packages for the current scalar subset (both unqualified foo() and qualified pkg::foo() call forms are accepted initially), and functions in the same package share a call namespace across modules in the same module set, duplicate exported names within a single package are reported as a resolver error (\"duplicate exported symbol\"). standard library import resolution (first slice): when a module contains import std::...;, the compiler will attempt to auto-load the referenced std::... package modules from a configured stdlib root so embedders do not need to provide std sources explicitly in the common case, the stdlib root is selected via: silkcompilersetstdroot when set, otherwise SILKSTDROOT (environment variable) when set, otherwise a std/ directory in the current working directory (development default), otherwise ../share/silk/std relative to the current executable (installed default). package-to-path mapping is deterministic: std::foo::bar resolves to the file <stdroot>/foo/bar.slk, if the embedder explicitly provides a std::... module via silkcompileraddsourcebuffer, that module is treated as authoritative for its package (auto-loading does not replace already-provided packages). standard library archive linking (linux/x8664, current archive layout): the toolchain can build a target-specific stdlib static archive (libsilkstd.a) containing one ELF object per std module (for example via make stdlib), for supported executable builds, the compiler treats auto-loaded std::... modules as external during code generation and resolves their exported functions from the archive when available (while still type-checking the std sources as part of the module set), archive discovery (in order): SILKSTDLIB when set, otherwise zig-out/lib/libsilkstd.a when using the in-repo std/ root, otherwise ../lib/libsilkstd.a relative to the current executable, otherwise common installed-layout heuristics derived from the selected stdlib root, walk up from the current working directory to find libsilkstd.a or lib/libsilkstd.a, when no suitable archive is found (or on unsupported targets), the compiler falls back to compiling the reachable std sources into the build as part of module-set code generation. When a front\u2011end error occurs (e.g. parse error, type mismatch, invalid control\u2011flow such as break/continue/return in the wrong context, or other semantic violations), the call returns false and silkcompilerlasterror/silkerrorformat provide a human\u2011readable description (such as \"unexpected token while parsing module\", \"type mismatch\", \"invalid break statement\", \"invalid return statement\", \"missing return statement\", etc.). For executable outputs (kind == SILKOUTPUTEXECUTABLE), the compiler also enforces an entrypoint precondition on the front\u2011end: there MUST be exactly one top\u2011level function fn main() -> int { ... } with no parameters and a declared result type of int, otherwise silkcompilerbuild fails with an error message such as \"no valid main function for executable output\" or \"multiple main functions for executable output\". When all modules pass front\u2011end validation (including the executable entrypoint requirement, where applicable), code generation behavior depends on kind: for non-executable outputs (SILKOUTPUTOBJECT, SILKOUTPUTSTATICLIBRARY, SILKOUTPUTSHAREDLIBRARY): main is optional, but when more than one valid executable main exists in the module set, silkcompilerbuild fails with \"multiple main functions for non-executable output\", when multiple packages are present in the module set, only exports from the root package (the package of the first module added to the compiler via silkcompileraddsourcebuffer) are emitted as globally-visible symbols for that output; other packages are compiled as dependencies and their export declarations are treated as internal for that output. within the current linux/x8664 IR subset, string and regexp values are supported at ABI boundaries in a C-friendly SilkString { ptr, len } layout: string/regexp parameters lower to two integer-like scalars in order (u64 pointer, then i64 byte length) and consume the normal integer argument locations (registers then stack), string/regexp results return as two integer-like scalars in rax/rdx, within function bodies, the compiler supports a small string/regexp expression subset: string: string literals, let bindings of string, return of a string value, direct calls to string-returning helpers, and ==/!=/</<=/>/>= comparisons over string values (producing bool), regexp: regex literals (/pattern/flags), let bindings of regexp, return of a regexp value, and direct calls between helpers that accept/return regexp, other string operations (concatenation, indexing, etc.) are not implemented yet; higher-level regex matching lives in std::regex and is routed through ext calls. within the current linux/x8664 IR subset, i128/u128/f128 values are supported at ABI boundaries using the stable C99 { lo, hi } struct shapes: parameters lower to two integer-like scalars (u64 lo, then u64/i64 hi) and consume integer argument locations, results return as two integer-like scalars in rax/rdx, f128 values are transported as raw IEEE binary128 bits in the two lanes (not via SSE registers). within the current linux/x8664 IR subset, a limited struct subset is supported at ABI boundaries: within function bodies and internal helper calls, struct declarations with 0+ fields of supported value types are supported (scalar primitives, string, nested structs, and supported optionals), at ABI boundaries for exported/FFI functions, only ABI-safe structs are currently supported: after slot-flattening, all scalar slots must be i64/u64/f64 (until packed ABI mapping for smaller fields is implemented), at the C ABI surface, exported function parameters support 1+ slot ABI-safe structs by lowering the struct to its scalar slots in order; downstream C callers should declare separate parameters for 3+ slot structs (by-value C struct parameters are ABI-compatible only for the 1\u20132 slot cases), while exported function returns support 1+ slot ABI-safe structs (3+ slot returns use the native backend\u2019s sret return path and are ABI-compatible with returning an equivalent C struct by value), in all cases, the compiler lowers a struct value into N scalar slots in field order and assigns argument/result locations according to System V AMD64 integer/SSE classification for those slots. within the current linux/x8664 IR subset, optionals (T?) are supported at ABI boundaries for the supported payload subset (scalar payloads, string?, and optionals of ABI-safe structs): an optional lowers to a Bool tag followed by the payload scalar slots: (tag, payload0, payload1, ...) with tag=0 for None and tag=1 for Some(...), nested optionals (T??) lower by treating the payload slots as the full inner optional representation (for example int?? lowers as (tag0, tag1, i64 payload)), optional parameters are passed as these scalar slots in order (so downstream C callers should declare separate parameters, treating tag as an integer-like 0/1 value), optional results return as the same scalar slots (1\u20132 slots in registers; 3+ slots via a hidden sret pointer as described above). for object outputs (SILKOUTPUTOBJECT): on linux/x8664, the compiler can emit an ELF64 relocatable object (ETREL) for the supported IR subset, emitting supported functions (scalar-returning, void-returning, and a limited string subset) and supported exported constants (export let/export const; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit : string when the initializer is a string literal), and marking export fn declarations, supported exported constants, and a valid executable main (when present) as global symbols, when the module set contains no supported globally-visible symbols (no supported export fn, no supported export let constants, and no valid executable main), silkcompilerbuild still succeeds and writes a valid relocatable object with no globally-visible symbols, for programs outside that subset (or on unsupported targets), silkcompilerbuild returns false with an E4001 / E4002 formatted diagnostic (via silkcompilerlasterror / silkerrorformat) and does not write an output file. for static library outputs (SILKOUTPUTSTATICLIBRARY): on linux/x8664, the compiler can emit a static library archive (.a) containing an object file for the supported IR subset, emitting supported functions (scalar-returning, void-returning, and a limited string subset) and supported exported constants (export let/export const; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit : string when the initializer is a string literal), and marking export fn declarations, supported exported constants, and a valid executable main (when present) as global symbols, when the module set contains no supported globally-visible symbols (no supported export fn, no supported export let constants, and no valid executable main), silkcompilerbuild still succeeds and writes a valid archive containing an object file with no globally-visible symbols, for programs outside that subset (or on unsupported targets), silkcompilerbuild returns false with an E4001 / E4002 formatted diagnostic (via silkcompilerlasterror / silkerrorformat) and does not write an output file. for shared library outputs (SILKOUTPUTSHAREDLIBRARY): on linux/x8664, the compiler can emit an ELF64 shared library (ETDYN, typically with a .so filename) for the supported IR subset, emitting supported functions (scalar-returning, void-returning, and a limited string subset) and supported exported constants (export let/export const; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit : string when the initializer is a string literal), and marking export fn declarations, supported exported constants, and a valid executable main (when present) as dynamic global symbols, when the module set contains no supported globally-visible symbols (no supported export fn, no supported export let constants, and no valid executable main), silkcompilerbuild still succeeds and writes a valid shared library with an empty export set, for programs outside that subset (or on unsupported targets), silkcompilerbuild returns false with an E4001 / E4002 formatted diagnostic (via silkcompilerlasterror / silkerrorformat) and does not write an output file. for executable outputs (SILKOUTPUTEXECUTABLE): the implementation supports a minimal constant\u2011expression backend: the program must satisfy the entrypoint rule above, the body of main must be one of the following shapes: zero or more let statements whose initializers are constant integer expressions, followed by exactly one return statement that returns a constant integer expression built only from: integer literals, the arithmetic operators +, -, , /, and %, and references to immutable let bindings (top\u2011level or local to main, or imported exported scalar constants from imported packages) whose initializers are themselves constant integer expressions in this same sense (no side\u2011effecting operations); imported exported constants must be declared as export let or export const with the shape export <binding> name: <scalar> = <literal>; (explicit scalar type and literal initializer), on linux/x8664, direct calls to simple helper functions of the form fn helper (x, y) -> int { [let ...;] return <expr>; } where: parameters may be annotated as scalar types (defaulting to int when unannotated), arguments at each call site are drawn from the same scalar expression subset as <expr> (including bool, char, Instant, Duration, fixed-width integers, and f32/f64 on linux/x8664), with optionals (T?) supported for scalar payloads, string?, and optionals of the POD struct subset via None / Some(...) and ?? coalescing, and in module-set builds, helper calls may target: functions defined in the same package (across multiple modules), and imported exported functions (export fn) from any packages imported by the module that contains main (both foo() and pkg::foo() call forms are accepted initially for imported exports), the helper body either: consists only of scalar let bindings and a final return, or ends in a simple if / else of the form: if <cond> { [let ...;] return <expr>; } else { [let ...;] return <expr>; } where <cond> is a boolean expression built from comparisons over scalar expressions and boolean literals, and both branches end in return; such calls are lowered to IR Call instructions and compiled to native code together with main, using the System V AMD64 scalar calling convention on linux/x8664 (integer-like scalars in rdi..r9, f32/f64 in xmm0..xmm7, with additional arguments spilled to the stack); helpers may have more than six integer parameters, and this path is exercised a final if statement whose condition is a boolean expression: for the purely constant subset, the condition is a compile\u2011time boolean literal (true or false) and each branch body itself satisfies the same \u201cconstant lets + return constant integer expression\u201d rule, and on linux/x8664, a slightly richer branching main shape is also supported in which the body is exactly: fn main () -> int { if <cond> { [let ...;] return <expr>; } else { [let ...;] return <expr>; } } where <cond> is built from integer comparisons (==, !=, <, <=, >, >=) over integer expressions from the same constant subset; this shape is lowered to IR using BrCond and compiled to native code by the IR\u2192ELF backend so that the condition is evaluated at runtime, or one or more trivial constant while loops that appear before the final return, each of which has: a condition that is a compile\u2011time boolean literal (true or false), for while false { ... }, a body that is ignored by the constant backend, and for while true { ... }, a body consisting of zero or more constant let statements followed by a break;, with no other control\u2011flow; loop invariants (#invariant) and variants (#variant) may be present but are treated as metadata and do not affect constant evaluation, examples of supported forms include: fn main() -> int { return 0; } fn main() -> int { return 1; } fn main() -> int { return 1 + 2 3; } let answer: int = 21 2; fn main() -> int { return answer; } // Two-module imported constant example (module-set builds only): // // util.slk package util; export let answer: int = 42; // // app.slk package app; import util; fn main () -> int { return answer; } // Two-module imported function example (module-set builds only): // // util.slk package util; export fn add (x: int, y: int) -> int { return x + y; } // // app.slk package app; import util; fn main () -> int { return add(40, 2); } fn main () -> int { let a: int = 21; let b: int = a 2; return b; } fn main () -> int { if true { return 0; } else { return 1; } } fn main () -> int { while true { break; } return 0; } when these conditions hold and outputpath names a valid path, silkcompilerbuild: evaluates the constant integer expression in the body of main, emits a tiny native executable image directly using a Silk\u2011owned backend (no C stub, no external C compiler), currently this backend writes a minimal ELF64 executable for linux/x8664 whose entrypoint immediately performs a sysexit(value) system call, returns true on success with no last error recorded. when the program is front\u2011end valid but outside this subset (e.g. main contains non\u2011constant expressions, references to non\u2011constant values, or calls that fall outside the simple helper\u2011call subset described above), or when the backend cannot produce an executable for the current platform or output path, the call returns false and records either an E4001 / E4002 diagnostic (for unsupported constructs or backend failures) or a descriptive string for I/O/argument errors as the last error. Error reporting: SilkError silkcompilerlasterror(SilkCompiler compiler); sizet silkerrorformat(const SilkError error, char buffer, sizet bufferlen); silkerrorformat returns a human-readable diagnostic message. When the compiler can associate the error with a source span, the formatted message includes the module name/path plus line/column and a caret snippet. Ownership, lifetime, and thread-safety guarantees for these APIs must be clearly documented and kept in sync with the implementation. ABI rules: All exposed functions must be C99-compatible. Data layouts must be stable and match the Silk side. Ownership and lifetime of any pointers passed across the boundary must be explicitly documented. In addition, the embedding ABI must clearly distinguish: functions that consume Silk\u2011owned values (e.g. SilkString whose storage is owned by the runtime) versus functions that take ownership of data supplied by the embedder (and are responsible for freeing it via documented APIs). See Also libsilk (7) \u2014 C99 ABI manpage for embedders. silk.h \u2014 public C header shipped with the library."
    },
    {
      "id": "compiler/architecture",
      "title": "Compiler Architecture",
      "section": "compiler",
      "summary": "This document describes the intended architecture of the Silk compiler implemented in Zig.",
      "text": "Compiler Architecture This document describes the intended architecture of the Silk compiler implemented in Zig. Current hard implementation limits (file size caps, current maxima, etc.) High-Level Structure The compiler is implemented in Zig and organized into three major layers: Front-end: Middle-end: Optimizations that respect the language\u2019s safety guarantees. Back-end: Code generation for executables, static libraries, and shared libraries using an Silk-owned backend (IR + codegen), not by \u201ctranspiling to C\u201d. Emission of object files and archives that can be linked into executables and libraries. C99 ABI mappings for interop with libsilk.a. In terms of concrete targets and file formats, the back-end MUST eventually support: ELF for Unix-like systems: initial implementation is linux/x8664 only (already prototyped for constant-expression main), linux/aarch64 (ARM64) is a required future target, position-independent code and shared objects (.so) for dynamic libraries. Mach-O for macOS: both Intel (x8664) and Apple Silicon (arm64) MUST be supported, dynamic libraries (.dylib) for loading Silk packages at runtime. PE/COFF for Windows: initially x8664, with other architectures considered later as needed, DLLs for dynamic loading. The current ELF-only constant-expression backend is a temporary first slice targeting linux/x8664; Mach-O, PE/COFF, and additional architectures (notably ARM64 on Linux and macOS), as well as full object-file, archive (.a), and shared-library emission, are explicit future requirements and MUST be planned and implemented as the back-end matures. An initial IR-driven, native backend is being prototyped alongside the existing constant-expression emitter: the front-end (parser + checker) produces ast.Module values, a lowering pass in src/lowerir.zig translates a constrained subset of fn main() -> int programs into ir.Function graphs, using integer arithmetic, comparisons, and simple control flow (Br / BrCond), a target-independent IR interpreter in src/ireval.zig provides reference semantics for these IR functions, the existing ELF64 emitter in src/backendconst.zig still constructs the final executable image by writing a minimal ELF64 file for linux/x8664 whose entrypoint performs a sysexit(value) system call, a dedicated IR\u2192ELF backend module (src/backendirelf.zig) will gradually assume responsibility for emitting native code directly from ir.Function graphs, starting with a single-function, integer-returning subset and expanding as more language features are lowered to IR. Packages, Modules, Imports, and Exports Silk programs are organized into packages and modules: A module is a single source file and the natural unit of parsing and type checking. A package is a collection of modules that share a namespace and build configuration (e.g. the main package, std::, and third-party packages). Packages may: export symbols (types, functions, constants) that are visible to importers, import symbols from other packages via explicit imports. The compiler MUST: represent packages and their dependency graph explicitly in the middle-end, implement an import resolver that: maps import paths to source modules/packages, enforces acyclic and well-formed package graphs, implement symbol visibility rules: distinguish exported vs internal symbols within a package, ensure only exported symbols are visible across package boundaries. Front-end work (parser, checker, resolver) and back-end work (linkage, symbol emission) MUST be designed so that: importing and exporting package symbols is a first-class, well-specified feature, building advanced programs that span multiple modules and packages (including std:: and user packages) is supported by both the CLI (silk) and the C ABI (libsilk.a). The concrete surface syntax for packages, imports, and exports is specified in incrementally in the front-end. Resolver and back-end integration will follow that spec. Executable Entrypoint (Initial Rule) For executable builds driven via the C ABI (SILKOUTPUTEXECUTABLE) and, eventually, the silk CLI, the compiler enforces a simple, explicit entrypoint: there MUST be exactly one top-level function with the signature: fn main() -> int { ... } this function: takes no parameters, returns int, serves as the process entrypoint when an executable is produced. At the current implementation stage, this requirement is enforced by the front-end (via silkcompilerbuild) and a minimal back-end that currently supports only constant integer main functions. This is a temporary measure; the long-term back-end is a true Silk code generator, not a C transpiler. Module Layout (Draft) This is a draft module layout for the Zig implementation. Exact file names may change, but the layering should be preserved. src/ (compiler implementation): src/driver.zig \u2014 CLI entry points and high-level orchestration. src/lexer.zig \u2014 tokenization and trivia handling. src/parser.zig \u2014 AST construction. src/ast.zig \u2014 AST node definitions. src/types.zig \u2014 type system representation and operations. src/checker.zig \u2014 type checking and semantic analysis. src/formalsilk.zig \u2014 Formal Silk VC generation and verification (Z3-backed). src/z3api.zig \u2014 Z3 C API shim (static-by-default, optional dynamic override). src/ir.zig \u2014 core intermediate representation. src/codegen.zig \u2014 target-independent code generation logic. src/abi.zig \u2014 C99 ABI and FFI glue for libsilk.a. src/stdintegration.zig \u2014 integration with the std:: package and stdlib selection. src/cli/ (optional breakdown): src/cli/options.zig \u2014 option parsing. src/cli/commands.zig \u2014 build, check, abi subcommands. Test code is expected to live alongside these modules (via Zig test blocks) and/or under dedicated test drivers. Test Layout (Draft) Testing is incremental and must be developed alongside the implementation: Zig unit tests: Each core module (lexer.zig, parser.zig, checker.zig, etc.) contains Zig test blocks that exercise its behavior. C99 tests: link against libsilk.a, use the C ABI (silk.h) to drive compilation/execution, validate FFI and ABI behavior. The build system (Zig build file and any supporting scripts) must be wired so that: running the Zig test suite exercises all relevant test blocks, running the C test suite builds and runs the C harnesses, both suites can be invoked easily during development and CI."
    },
    {
      "id": "compiler/diagnostics",
      "title": "Compiler Diagnostics",
      "section": "compiler",
      "summary": "This document specifies the *human-readable* diagnostic format emitted by the Silk toolchain, including:",
      "text": "Compiler Diagnostics This document specifies the human-readable diagnostic format emitted by the Silk toolchain, including: the silk CLI (silk check, silk build), the embedding ABI (libsilk.a via silkcompilerlasterror / silkerrorformat), and tooling that reuses the front-end (for example silk-lsp). The goal is to provide diagnostics that are: precise (file + line + column + source span), stable (consistent wording and stable error codes for known error kinds), consumable by humans (caret snippets, notes/help where appropriate), easy to test (deterministic formatting; the canonical text contains no ANSI escapes). Terminology Source span: a byte range in the UTF\u20118 source buffer (offset, length). Displayed line and column numbers are 1-based. Columns are measured in UTF\u20118 bytes (matching the lexer\u2019s current Token.column behavior). Primary label: the main span where the error is reported (single span in the initial implementation). Note / Help: supplemental lines that explain context or suggest a fix. Text Format (CLI and ABI) The standard human-readable diagnostic format is: error[E<code>]: <message> <path>:<line>:<column> <line> <source line text> <caret underline> = note: <note text> (optional, repeatable) = help: <help text> (optional, repeatable) Rules: The error[...] line always appears for known error kinds; <code> is stable for that error kind. For diagnostics with no usable location, the --> ... and snippet block may be omitted. The snippet block uses the 1-based line number and includes the full line text as it appears in the source. The caret underline is placed under the primary span: for a zero-length span, print a single ^, otherwise print ^ repeated for the span length, clipped to the line end if needed. The canonical text format contains no ANSI color escapes. Manifest and Config Errors The CLI uses the same caret diagnostic format for errors in tooling/config inputs, including the package manifest silk.toml and build-script-generated manifests. These diagnostics may not yet have stable error codes. Example (missing = in silk.toml): error: invalid TOML in package manifest silk.toml:2:6 2 name \"app\" ^ expected = ANSI Color (CLI) The silk CLI may decorate the canonical diagnostic format with ANSI SGR escape codes when writing to a terminal. The visible text (after stripping ANSI escapes) must still match the canonical format. Color is enabled only when: stderr is a TTY that supports ANSI escapes, NOCOLOR is not set, TERM is not dumb. Color is never used for the embedding ABI (silkerrorformat / silkcompilerlasterror), and is not used when stderr is not a TTY (for example when piping diagnostics to a file). Suggestions and Help Text Diagnostics may include one or more = help: lines that suggest concrete fixes. These are heuristic and may be omitted when the compiler cannot compute a safe suggestion. Examples of help/suggestion content the compiler may emit: for unknown imports, a \"did you mean ...?\" suggestion based on nearby names, for file imports, a note about the resolved import path, reminders about enabling or configuring the standard library (--nostd, std-root, SILKSTDROOT) when importing std::..., guidance to include additional modules in the build/module set when an import refers to a package or file that is not present. Error Codes (Initial Set) The compiler assigns a stable code to each currently supported error kind. Parsing E0001 \u2014 unexpected token / invalid top-level ordering. Import and Package Resolution E1001 \u2014 unknown imported package. E1002 \u2014 cyclic package imports. E1003 \u2014 unknown imported file. E1004 \u2014 cyclic file imports. E1005 \u2014 duplicate exported symbol within a package. E1006 \u2014 file imports require a module file path. Type Checking E2001 \u2014 type mismatch. E2002 \u2014 unsupported construct in Silk (the diagnostic detail may identify the rejected statement/expression form). E2003 \u2014 unknown imported name. E2004 \u2014 duplicate imported name. E2005 \u2014 invalid assignment. E2006 \u2014 invalid borrow. E2007 \u2014 invalid break. E2008 \u2014 invalid continue. E2009 \u2014 invalid return. E2010 \u2014 missing return. E2011 \u2014 opaque struct used by value. E2012 \u2014 cannot instantiate opaque struct. E2013 \u2014 cannot access fields on opaque struct. E2014 \u2014 formal Silk declaration used in runtime expression. E2015 \u2014 let requires an initializer. E2016 \u2014 unsupported generic form in Silk (for example const parameters / const type arguments). E2017 \u2014 builtin map(K, V) type form was removed (use std::map::{HashMap, TreeMap} instead). E2018 \u2014 namespace import is not callable. E2019 \u2014 duplicate default export in a module. E2020 \u2014 invalid panic statement. E2021 \u2014 unknown error type. E2022 \u2014 error not declared in function signature. E2023 \u2014 error-producing call must be handled with match. E2024 \u2014 match scrutinee is not an error-producing call. E2025 \u2014 match is missing an arm. E2026 \u2014 typed error-handling match arm must end with a terminal statement. E2027 \u2014 heap allocation is disabled (--noheap) and heap-backed allocation is rejected (new outside with, libc allocator ext, concurrency keywords, capturing closures). E2028 \u2014 unknown name. E2029 \u2014 ambiguous implicit coercion. E2030 \u2014 await requires an async function. E2031 \u2014 async { ... } / task { ... } requires an async function. E2032 \u2014 ambiguous constructor call. E2033 \u2014 await requires a Promise operand. E2034 \u2014 cannot copy a Task/Promise handle. E2035 \u2014 Task/Promise handle used after await/yield . E2036 \u2014 cannot consume an outer Task/Promise handle inside a loop. E2037 \u2014 task fn uses a non-task-safe type at a task boundary. E2038 \u2014 ? requires an error contract (-> T ErrorType...). E2039 \u2014 ? requires a fallible call operand. E2040 \u2014 propagated error is not declared in the function signature. E2041 \u2014 const initializer is not compile-time evaluable. E2042 \u2014 pure fn may not have a typed-error contract ( in return type). E2043 \u2014 pure fn may not contain panic statements. E2044 \u2014 pure fn may not have mut parameters. E2045 \u2014 pure fn may not declare mutable locals (var or let mut). E2046 \u2014 pure fn may not perform mutation via assignment. E2047 \u2014 pure fn may not allocate (new). E2048 \u2014 pure fn may not call impure functions. E2049 \u2014 pure fn may not be combined with task or async. E2050 \u2014 theories are not callable as runtime functions (use #theory Name(...);). E2051 \u2014 module does not satisfy the declared interface (missing exported function). E2052 \u2014 module does not satisfy the declared interface (signature mismatch). E2053 \u2014 unknown re-export name. E2054 \u2014 duplicate exported name. E2055 \u2014 prototype implementation is missing required import of its prototype module. E2056 \u2014 function expression may not have &T parameters. E2057 \u2014 duplicate type alias name. E2058 \u2014 type alias cycle. E2059 \u2014 type alias kind mismatch. E2060 \u2014 unknown extends base. E2061 \u2014 invalid extends base. E2062 \u2014 cyclic extends chain. E2063 \u2014 derived struct redeclares an inherited field name. E2064 \u2014 derived interface redeclares an inherited method name. E2065 \u2014 opaque structs may not use extends. E2066 \u2014 prototype and implementation signatures do not match. E2067 \u2014 capturing closure is not allowed in pure code. E2068 \u2014 capturing closure capture type is not supported in Silk. E2069 \u2014 capturing closure may not capture a mutable binding in Silk. E2070 \u2014 yield requires a task context. E2071 \u2014 yield in value position requires a Task operand. E2072 \u2014 yield requires a Task operand. E2073 \u2014 yield as a statement requires an enclosing task function. E2074 \u2014 await requires a Promise-array operand. E2075 \u2014 duplicate type name. E2076 \u2014 generic type arguments must be fully specified at the use site (missing a required, non-default type argument). E2077 \u2014 invalid region declaration. E2078 \u2014 with requires a region binding. E2079 \u2014 invalid with ... from region slice. E2080 \u2014 reserved (previously: indexing a slice cast from u64 required an explicit length). E2081 \u2014 slice-length cast suffix requires a u64 pointer operand. E2082 \u2014 const fn may not be task or async. E2083 \u2014 const fn may not have a typed-error contract ( in return type). E2084 \u2014 const fn parameter types must be compile-time value types. E2085 \u2014 const fn result type must be a compile-time value type. E2086 \u2014 const fn may not allocate (new). E2087 \u2014 const fn may not call a non-const fn. E2088 \u2014 const fn may not contain panic statements. E2089 \u2014 unsupported construct in a const fn body (outside the current const-eval subset). E2090 \u2014 const fn may be called only from compile-time contexts. E2091 \u2014 generic function call type arguments could not be inferred at the call site. E2092 \u2014 use of moved value. E2093 \u2014 move requires a local binding name. E2094 \u2014 slice borrow escapes its lexical scope. E2095 \u2014 reference borrow escapes its lexical scope. E2096 \u2014 unknown using target. E2097 \u2014 using alias conflicts with an existing name. E2098 \u2014 using target is ambiguous. E2099 \u2014 using cannot import constructor In Silk. E2100 \u2014 using may not import methods that require mutable Self borrows in Silk. E2101 \u2014 using method reuse requires compatible struct layouts. E2102 \u2014 cannot move value while it is borrowed. E2103 \u2014 invalid regexp flags (unknown or duplicate). E2104 \u2014 invalid regexp literal (pattern compile failed). E2105 \u2014 method is private to its impl block (not visible from the call site). E2106 \u2014 interface-required methods may not be declared private. E2107 \u2014 destructuring requires a non-opaque struct value. E2108 \u2014 cannot destructure opaque struct. E2109 \u2014 destructuring pattern does not match the struct type (wrong arity, unknown field, or duplicate binder/field). E2110 \u2014 array destructuring requires an array/slice value. E2111 \u2014 array destructuring pattern does not match the array type (wrong arity for fixed arrays, or duplicate binder). E2112 \u2014 enum destructuring requires an enum value. E2113 \u2014 enum destructuring pattern does not match the enum type (unknown variant or wrong arity). E2114 \u2014 reserved (previously: u128 not supported in the subset). E2115 \u2014 reserved (previously: f128 not supported in the subset). Formal Silk Verification E3001 \u2014 loop invariant may not hold. E3002 \u2014 loop variant may be negative. E3003 \u2014 loop variant may not decrease. E3004 \u2014 postcondition may not hold. E3005 \u2014 Formal Silk verification failed to initialize or encountered an unsupported construct. E3006 \u2014 assertion may not hold (#assert and theory assertions). E3007 \u2014 call precondition may not hold. E3008 \u2014 loop monovariant may not be monotonic. Notes: When silk build --debug or silk test --debug is used, failed Formal Silk checks emit additional Z3 debug output and write an SMT-LIB2 reproduction script under .silk/z3/ in the current working directory (or $SILKWORKDIR/z3). Code Generation / Backend Lowering E4001 \u2014 unsupported construct in Silk. E4002 \u2014 code generation failed in the backend (unexpected backend error). Notes: This error is reported when a program successfully parses and type-checks, but IR lowering or native code generation cannot yet handle a construct. The diagnostic detail names the rejected construct kind (statement / expression / function) and its surface form tag when available. Tooling Integration Notes silk-lsp should map the compiler\u2019s primary source span to the LSP diagnostic range directly. When the compiler grows multi-span diagnostics (labels and secondary spans), the LSP implementation must be updated to surface them."
    },
    {
      "id": "compiler/limits",
      "title": "Compiler Limits",
      "section": "compiler",
      "summary": "This document enumerates the current hard limits in the Silk compiler and its tooling. These limits are **implementation guardrails** (primarily to keep memory usage bounded when compiling untrusted inputs); they are not intended to",
      "text": "Compiler Limits This document enumerates the current hard limits in the Silk compiler and its tooling. These limits are implementation guardrails (primarily to keep memory usage bounded when compiling untrusted inputs); they are not intended to be permanent language constraints unless explicitly called out in the language Where a language feature has an implementation cap that affects user code, the cap is also documented in the relevant language document (for example Source and Manifest Size Limits Silk source file max size (per file): 64 MiB Applies to: the silk CLI (src/driver.zig), the Zig wrapper API that loads sources from disk (src/silk.zig), the C ABI entrypoints that load sources from disk (src/abi.zig), the LSP server file loader (src/lspmain.zig). Rationale: avoid unbounded allocations while still allowing large modules. Package manifest max size: 1 MiB Applies to reading silk.toml (src/packagemanifest.zig). Front-End (Type Checker) Structural Limits The current checker uses fixed-capacity buffers for a number of intermediate tables. Module-/package-scoped tables are heap-backed to avoid stack overflows when compiling large module sets, while some per-function scratch state is still stack-backed. When these limits are exceeded, the current implementation typically reports E2002 (\u201cunsupported expression in Silk\u201d) because the checker uses CheckError.UnsupportedExpression as a shared \u201cnot supported yet\u201d / \u201chit an internal cap\u201d path. This will be refined into dedicated \u201climit exceeded\u201d diagnostics as the compiler matures. Current caps (src/checker.zig): Top-level bindings per module: 16384 Local bindings per function: 1024 Function-like bindings tracked in a module set (functions, externs, imported callables, etc.): 16384 Struct declarations tracked in a module set: 16384 Enum declarations tracked in a module set: 16384 Interface declarations tracked in a module set: 16384 Type aliases tracked in a module set: 16384 Methods tracked in a module set (impl methods, coercions, etc.): 16384 Fixed array type length cap (T[N]): 4096 Varargs Pack Capacity Varargs are implemented using an internal, fixed-size \u201cpack struct\u201d lowered as a flattened scalar-slot struct value. Varargs pack capacity (N): 128 Lowering / IR Limits Current caps (src/lowerir.zig): Lowering binding environment size (per function): 1024 This is the maximum number of simultaneously in-scope bindings that the IR lowerer can track in the current implementation. Type-alias resolution depth: 256 This bounds recursive/chain alias resolution during lowering to avoid runaway recursion in pathological cases. Varargs pack capacity (N): 128 Const Evaluator Limits The current const-evaluator used for the fn main() -> int constant program path builds a small environment of constant top-level let bindings that main may reference. Const-eval environment bindings: 4096 (src/backendconst.zig) If a module exceeds this, additional candidate bindings are ignored for the purposes of const-evaluating main in that path."
    },
    {
      "id": "compiler/ir-overview",
      "title": "Intermediate Representation (IR) \u2013 Overview",
      "section": "compiler",
      "summary": "This document introduces the initial intermediate representation (IR) used by the Silk compiler. The IR is intentionally small and focused for now so that we can start supporting more advanced programs while keeping the design",
      "text": "Intermediate Representation (IR) \u2013 Overview This document introduces the initial intermediate representation (IR) used by the Silk compiler. The IR is intentionally small and focused for now so that we can start supporting more advanced programs while keeping the design tractable. The goals of the IR are: provide a target-independent representation of Silk programs, be simple enough to interpret or lower to multiple back-ends, make control flow and data flow explicit so optimizations are possible. This document will evolve as the IR grows; it is not yet a complete spec. High-Level Shape The IR is structured in three main layers: IrProgram represents a collection of functions within a compilation unit, owns an array of IrFunction values, identifies a designated entry function by index. IrFunction represents a single function, owns a sequence of basic blocks, has a designated entry block. IrBlock represents a basic block: a straight-line sequence of instructions, terminated by a control-flow instruction (e.g. Return or branch). IrInstr represents a single instruction: scalar constants (integers and floats represented as raw bits), integer and floating-point arithmetic and comparisons, explicit control flow (branches and returns), direct calls between functions in the same program, calls to external functions declared in the program, (later) memory operations, aggregates, etc. Values are referenced by small integer IDs (ValueId). IR is not yet in full SSA form, but the representation is compatible with an SSA-style design. Typed Values Although the earliest experiments treated all values as untyped 64-bit integers, the IR now carries an explicit scalar type for each value so that front-end lowering, the interpreter, and native back-ends can agree on how values are represented and passed. For now, the scalar type universe focuses on booleans, fixed-width integers, and IEEE-754 floating-point values: Bool logical true / false values. Encoded as integers in the IR (0 = false, 1 = true) so that existing arithmetic and comparison machinery can be reused. I8 / U8, I16 / U16, I32 / U32, I64 / U64 fixed-width integer types with explicit signedness and width. the current lowering and ELF backend primarily exercise I64 (corresponding to the language\u2019s int on linux/x8664) plus Bool for conditions and boolean locals. F32 / F64 IEEE-754 single- and double-precision floats. Represented in the IR as raw IEEE bits stored in the same 8-byte slot as integer scalars: F64 uses all 64 bits, F32 uses the low 32 bits (the high 32 bits are canonicalized to 0). Each ValueId is associated with exactly one scalar type; instructions know both the type of their operands and the type of the value they produce. This typed representation is used by: the lowering passes in src/lowerir.zig to ensure that arithmetic, comparisons, and boolean expressions are mapped to the correct instruction shapes, the IR interpreter in src/ireval.zig to maintain a consistent runtime encoding (everything is stored in 8-byte slots, with Bool encoded as 0/1 and floats stored as raw IEEE bits), and the ELF backend in src/backendirelf.zig to choose the appropriate register/stack conventions and any sign/zero-extension rules when additional integer widths are introduced. In the current implementation, this type information is carried on each IrFunction as: a function signature (paramtypes and resulttypes), and a valuetypes table that maps each ValueId slot to a scalar type. Future revisions of this document will extend the IR beyond the current scalar set to cover pointer-like types, address computations, and aggregates (structs/tuples) along with their layout rules. The design above is intentionally minimal but is the foundation on which full language type coverage will be added. Multi-Scalar Boundaries (Current Extension) Most IR functions return exactly one scalar value, but the IR can represent small aggregate-like results at function boundaries by returning multiple scalars in a fixed order. Concretely: IrFunction.resulttypes is a slice of scalar result types (not a single scalar type). Return returns a slice of ValueIds whose length and element types must match resulttypes. Call has dests as a slice of ValueIds whose length and element types must match the callee\u2019s resulttypes. The first multi-scalar boundary use case is string at ABI boundaries, represented as two scalars in order: ptr: u64 (address of UTF-8 bytes) len: i64 (byte length, excluding any trailing \\\\0) Within the current back-end subset, this allows exported functions to accept and return string values in a C-friendly SilkString layout without adding a dedicated \u201cstring pointer\u201d ABI. Minimal Instruction Set (Initial) The initial IR supports only what is needed to model small scalar-returning programs, with scalar values drawn from Bool, the fixed-width integer types, and F32/F64. In the current compiler, the surface char type is lowered into this IR as a U32 scalar holding the Unicode code point value. Multi-Scalar Values at ABI Boundaries (Initial) While IR values are scalar, the compiler also supports a small set of multi-scalar values at function ABI boundaries (parameters and results) by lowering a single surface-language value into multiple scalar slots: string is lowered as { ptr: u64, len: i64 } and returns via rax/rdx on a struct value is lowered as 1+ scalar slots in source field order. Each field may contribute one or more slots (for example, string contributes (u64 ptr, i64 len)), and nested structs are lowered by concatenating their slots. Calls assign each scalar slot to INTEGER/SSE argument slots as if passing independent scalars: integer-like slots consume GP argument slots, f32/f64 slots consume XMM argument slots, and 1\u20132 slot results use rax/rdx for integer-like slots and xmm0/xmm1 for float slots (mixed aggregates use both). For results with 3+ scalar slots, the native backend returns indirectly via a hidden sret pointer passed in rdi, storing each slot into the caller-provided buffer and returning that pointer in rax. For optionals (T?) in Silk, an optional value is lowered at IR boundaries as a Bool tag followed by the payload scalars: (Bool tag, payload0, payload1, ...) where tag=0 represents None and tag=1 represents Some(...). The payload scalar slots follow the lowering of the underlying non-optional type: scalar payloads lower as (Bool tag, payload), string? lowers as (Bool tag, u64 ptr, i64 len), and struct? lowers as (Bool tag, slot0, slot1, ...) for the current POD struct subset. Nested optionals (T??) are lowered in this subset by treating the payload slots as the full inner optional representation. For example, int?? lowers as (Bool tag0, Bool tag1, i64 payload). This keeps the IR scalar-only while allowing the surface language to express optionals; it maps cleanly to the System V AMD64 ABI as independent scalar arguments/results, with 3+ scalar results returning via a hidden sret pointer as described above. Semantically, most integer-producing instructions are defined in terms of the destination ScalarType: after executing the operation in a larger machine register, results are canonicalized (masked/truncated and sign-extended for signed integers) to the destination type. ConstInt create a constant scalar value; the raw payload is canonicalized to the destination ScalarType. For floats, the payload is the raw IEEE bit pattern (F32 uses the low 32 bits). ConstDataAddr materialize the address of a read-only data symbol emitted alongside the IR program (for example, an embedded string-literal byte blob). dest must have scalar type U64. Back-ends typically lower this to RIP-relative addressing and either: emit relocations (for relocatable objects), or patch displacements directly once the final .text/rodata layout is known. LoadU8 load a single byte from memory at address base + offset, zero-extending the result into the destination scalar slot. dest must have scalar type U8, base must have scalar type U64, and offset must have scalar type I64. The current compiler uses this instruction for bytewise string equality and ordered comparisons in the linux/x8664 IR\u2192ELF backend subset; the IR interpreter currently treats it as unsupported. StackAddr produce the address of the stack slot backing an existing ValueId. dest must have scalar type U64. This is a backend-facing operation used by the current compiler to lower borrowed references (&T) without requiring contiguous aggregate storage; the IR interpreter currently treats it as unsupported. Load load an 8-byte scalar value from memory at address ptr into dest, canonicalizing the loaded raw bits according to the destination ScalarType. ptr must have scalar type U64. This is used by the current compiler for reading through borrowed references; the IR interpreter currently treats it as unsupported. Store store an 8-byte scalar value from src to memory at address ptr. ptr must have scalar type U64. This is used by the current compiler for mutating through borrowed references; the IR interpreter currently treats it as unsupported. Copy copy a scalar value from one ValueId to another (both IDs must have the same ScalarType); this is used by CFG-based boolean lowering to merge short-circuit && / paths into a single boolean value slot. AddInt, SubInt, MulInt, DivInt, ModInt integer arithmetic operations on previously defined values of a single integer ScalarType; for DivInt/ModInt, signedness is determined by the operand type (I vs U), and results are canonicalized to the destination type. BitAndInt, BitOrInt, BitXorInt bitwise AND/OR/XOR on previously defined integer values. ShlInt, ShrInt shift-left and shift-right on previously defined integer values; ShrInt uses arithmetic shift-right for signed integer types (I) and logical shift-right for unsigned integer types (U). CmpEqInt, CmpNeInt, CmpLtInt, CmpLeInt, CmpGtInt, CmpGeInt integer comparison operations on previously defined values, producing a result of type Bool that is encoded as 0 (false) or 1 (true) in the underlying integer storage; for ordered comparisons, signedness is determined by the operand type. AddFloat, SubFloat, MulFloat, DivFloat floating-point arithmetic over F32 or F64 values, producing a result of the same float type (stored as raw IEEE bits in the destination slot). CmpEqFloat, CmpNeFloat, CmpLtFloat, CmpLeFloat, CmpGtFloat, CmpGeFloat floating-point comparisons over F32 or F64 values, producing a Bool. These follow IEEE-754 semantics: ordered comparisons (<, <=, >, >=) are false when either operand is NaN, and NaN compares unequal to everything (including itself). Br, BrCond explicit intra-function control flow: Br performs an unconditional branch to another basic block by index, BrCond branches based on an integer condition value (0 = false, non-zero = true) to either a \"then\" or \"else\" target block. Return terminator that returns zero or more scalar values from the current function (matching the enclosing function\u2019s resulttypes). Additional instructions (memory operations and aggregates) will be added as we lower richer subsets of the language. The Call instruction represents direct calls between functions within the same IrProgram: Call calls another IR function within the same IrProgram, In Silk, calls are: direct (identified by function index, not by name or pointer), between functions that return one or more scalar results (most commonly a single integer-like scalar, Bool, or F32/F64, with limited multi-scalar boundary support as described above), parameterized over a sequence of scalar arguments whose types must match the callee\u2019s paramtypes, semantically, a call: evaluates each argument expression to a scalar value in the caller, transfers control to the callee\u2019s entry block with a fresh frame in which parameter value slots 0..N-1 are initialized from those arguments, on Return, writes the callee\u2019s returned scalars into the caller\u2019s destination ValueIds (in order) and continues execution in the caller. The IR also supports calls to external (linker-provided) functions via an explicit external-function table and call instruction: IrProgram.externfunctions a list of external functions referenced by the program, each with: a symbol name (as it should appear to the linker), a scalar paramtypes slice, and a scalar resulttypes slice. CallExtern calls an external function identified by index in externfunctions, argument and destination value IDs must match the referenced signature, on linux/x8664, the ELF back-end lowers this in different ways depending on the selected output kind: for relocatable object and static library outputs, emits a .rela.text relocation against an undefined function symbol so downstream linkers can resolve it, for shared library and dynamically-linked executable outputs, emits a dynamic import and routes the call through a GOT slot that is relocated by the platform dynamic loader. The IR also supports reading external (linker-provided) data symbols via an explicit extern-data table and load instruction: IrProgram.externdata a list of external data symbols referenced by the program, each with: a symbol name (as it should appear to the linker), and the scalar type of the value loaded from that symbol. LoadExtern loads the current value of an external data symbol identified by index in externdata into a destination ValueId, the destination\u2019s ScalarType must match the referenced extern-data entry\u2019s scalar type, on linux/x8664, the ELF back-end lowers this in different ways depending on the selected output kind: for relocatable object and static library outputs, emits a .rela.text relocation against an undefined object symbol so downstream linkers can resolve it, for shared library and dynamically-linked executable outputs, emits a dynamic import and routes the load through a GOT slot that is relocated by the platform dynamic loader. Relationship to Front-End and Back-End Short term : The IR is now part of the primary executable build path on linux/x8664: the front-end (parser + checker) produces an ast.Module, src/lowerir.zig lowers supported programs into ir.Function / ir.Program graphs, src/backendirelf.zig lowers those IR graphs directly to a minimal native ELF64 executable (no C stub, no external compiler). A constant-expression fallback remains in place for programs that type-check but are not yet handled by IR code generation: src/backendirconst.zig attempts IR lowering + interpretation for constant-style fn main() -> int programs using src/ireval.zig, if that fails, callers fall back to the legacy AST-based constant evaluator in src/backendconst.zig, src/backendconst.zig emits the tiny ELF64 stub executable for this constant-only path. Medium term: The front-end will gain a richer lowering pass that translates general (non-constant) Silk functions into IrFunction graphs, including: boolean values and comparisons, structured control flow for if/else and loops expressed as multiple basic blocks connected by Br/BrCond. The existing IR interpreter will remain the reference semantics for IR programs and will be extended to cover any new instruction kinds. Back-ends for ELF/Mach-O/PE will lower from IR to target-specific machine code or object files. The current constant-expression ELF64 emitter is a minimal slice of this design, not a separate \u201cnon-IR\u201d path. The IR is designed so that importing and exporting package symbols can be modeled cleanly at the function and module level. Symbol visibility and one of the layers that will carry that information down to the back-end. Lowering Structured Control Flow Structured control flow in the surface language (if / else and while) is lowered into explicit basic blocks and branches in IR. The design is: Conditions are lowered using a dedicated helper that produces an integer value interpreted as a boolean (0 = false, non\u2011zero = true). if / else statements become: an entry block that evaluates the condition and terminates in BrCond(cond, thenblock, elseblock), a then block containing the lowered then\u2011branch statements, an else block (when present) containing the lowered else\u2011branch statements, an optional join block that receives control when both branches fall through (that is, when neither branch unconditionally returns, breaks, or continues). while loops become: a loop header block that evaluates the condition and terminates in BrCond(cond, bodyblock, exitblock), a body block that contains the lowered loop body and typically ends in a Br back to the header or a Br to the exit (for break), an exit block that receives control when the loop condition is false. Current implementation status: A narrow, constant\u2011oriented lowering in src/lowerir.zig is wired into the compiler: lowerMainFunction lowers constant\u2011style fn main() -> int functions into a single\u2011block ir.Function using integer literals, arithmetic, and a restricted control\u2011flow surface (constant while and terminating if with compile\u2011time boolean conditions). lowerBranchingMainFunction lowers a specific branching fn main() -> int shape into a three\u2011block IR graph: an entry block that evaluates a non\u2011constant boolean condition (using integer comparisons and boolean literals), followed by BrCond, a then block that contains let bindings and a Return, an else block that contains let bindings and a Return. More general lowering of if/else and while throughout function bodies will follow this block\u2011structured design: nested control flow is expressed by nesting these patterns, join blocks are introduced where multiple paths must converge before execution can continue, the IR remains free of implicit control flow; all transfers are represented explicitly with Br / BrCond / Return. Multi-Function Programs and Calls Multi-function programs are represented at the IR level using IrProgram and the Call instruction: IrProgram groups a set of IrFunction values and identifies an entry function index that serves as the starting point when interpreting or executing the program. Functions within an IrProgram may call each other using Call: the initial design targets simple scalar-returning helpers of the form fn helper(x: int, y: u8, flag: bool, ...) -> u8 and fn main() -> int, calls are direct: the instruction encodes the callee\u2019s function index, and recursion is allowed at the IR level (subject to front-end limits), each IrFunction records a paramcount indicating how many parameters it expects; parameters are modeled as value IDs 0..N-1 that are initialized at function entry. The IR interpreter models calls using an explicit call stack: each activation has its own value storage for the callee\u2019s ValueId space, Return instructions pop the current frame and resume the caller, writing the callee\u2019s returned scalars into the caller\u2019s destination ValueIds (in order). Native back-ends (starting with the existing ELF64 emitter) lower Call / Return to a concrete calling convention: for linux/x8664, the current implementation follows a simplified subset of the System V AMD64 ABI for scalar parameters: integer-like scalars (Bool and integers) use the first six general-purpose registers (rdi, rsi, rdx, rcx, r8, r9), floats (F32/F64) use up to 8 XMM registers (xmm0..xmm7), any additional scalar arguments are spilled to the caller's stack in 8-byte slots in source order, the caller maintains 16-byte stack alignment before call (padding by one 8-byte slot below the stack arguments when an odd number of stack-passed arguments are present), and results follow the same ABI-style shape as the IR signature: void (0 results) returns no value in registers, 1 scalar result returns in rax (integer-like) or xmm0 (float), 2 scalar results return in up to two registers per class (integer-like in rax/rdx, floats in xmm0/xmm1, assigned in order by class), 3+ scalar results return indirectly via a hidden sret pointer passed in rdi (shifting integer-like argument registers by one); the caller allocates a return buffer and the callee stores returned 8-byte scalar slots sequentially into it, returning the same pointer in rax, additional types and full ABI parity will be introduced as the language and ABI docs are extended. These multi-function and call semantics are designed here so that IR, interpreter, and back-ends can evolve in lockstep; the current codebase still operates primarily on single-function programs, with calls introduced incrementally in tests and then in the compiler\u2019s lowering pipeline."
    },
    {
      "id": "compiler/package-manifests",
      "title": "Package Manifests (`silk.toml`)",
      "section": "compiler",
      "summary": "This document specifies Silk\u2019s package manifest format and how the `silk` compiler consumes it.",
      "text": "Package Manifests (silk.toml) This document specifies Silk\u2019s package manifest format and how the silk compiler consumes it. Manifests are a build/package concept (they are not part of the core language syntax). The language-level package / import / export semantics remain Manifest Discovery A package root directory MAY contain a manifest file with one of these names: silk.toml Rules: When a manifest directory is provided (CLI via --package <dir>), the compiler looks for silk.toml in that directory. When a manifest path is explicitly provided (CLI via --package <path>), the compiler reads exactly that file (and it MUST be named silk.toml). Manifests are encoded as TOML v1.0. Diagnostics When a manifest is malformed (invalid TOML syntax or an invalid manifest shape), the compiler reports a diagnostic with file, line, and column information and a caret snippet pointing at the offending token when possible. Build Scripts (build.silk) A package root directory MAY also contain a build script: build.silk When a build script is enabled via the CLI, the compiler compiles and runs the script and treats its stdout as a TOML manifest in this format (used in place of reading silk.toml for the root package). Package Metadata ([package]) Minimal manifest shape: [package] name = \"myapp\" version = \"0.1.0\" package.name (required) The package name used for package imports (e.g. import ui from \"ui\";) and as the default package name for modules that omit an explicit package ...; declaration. In the current implementation, name MUST be a valid Silk package path: one or more identifiers separated by :: each identifier matches [A-Za-z][A-Za-z0-9] Examples: ui myapp myapp::core package.version (optional) Free-form version string (commonly MAJOR.MINOR.PATCH). In the current implementation, when building from a package manifest, the compiler surfaces this value to runtime code via std::runtime::build::version() (otherwise it defaults to \"0.0.0\"). Additional optional metadata fields MAY be present under [package] (for example description, license, authors, repository), but the current compiler only uses name and version. Source Layout ([sources]: include / exclude) Packages may specify which .slk files belong to the package with glob patterns: [sources] include = [\"src//.slk\"] exclude = [\"src/experimental/\"] Rules: Patterns are evaluated against forward-slash (/) relative paths rooted at the manifest directory. Supported glob syntax : matches any characters within a single path segment. matches zero or more path segments. If include is omitted, the default is to include all /.slk under the manifest directory. exclude patterns always remove files, even if they match an include. When building a target, the target\u2019s entry file MUST be included after applying include/exclude (or the build fails). Dependencies ([dependencies]) Dependencies are a table mapping dependency import names to dependency specs: [dependencies] ui = { path = \"../libs/silk-ui\", sha256 = \"sha256:0123456789abcdef...\" } Fields: The dependency key (ui above) is the package import name used in source (import ui from \"ui\";). In the current implementation, this MUST match the dependency\u2019s own manifest package.name. path (optional): local filesystem path to the dependency package root, resolved relative to the importing manifest directory when not absolute. When path is omitted, the dependency is resolved from the package search path (see \u201cDependency discovery via SILKPACKAGEPATH\u201d below). sha256 (required): integrity hash string. Dependency sha256 verification: The sha256 value must be of the form sha256:<64 hex digits> (case-insensitive). The compiler verifies it by hashing the dependency package\u2019s contents using a deterministic scheme: The hash input starts with the ASCII prefix silk-package-sha256-v1\\0. Then the exact bytes of the dependency\u2019s silk.toml, followed by \\0. Then, in sorted (lexicographic) order by relative path: the file\u2019s relative path bytes, then \\0, the file\u2019s bytes, then \\0. Only files included by that dependency manifest\u2019s [sources] include/exclude rules are hashed. Limitations: Only local-path dependencies are supported (no remote fetch). Dependency discovery via SILKPACKAGEPATH When a dependency entry omits path, the compiler resolves it by searching a PATH-like list of package roots provided by SILKPACKAGEPATH. Rules: SILKPACKAGEPATH is a list of directories separated by : (POSIX). For a dependency named myapi::core, each root directory contributes a candidate package root: <root>/myapi/core (where :: maps to /) and the manifest is <candidate>/silk.toml. The compiler searches roots in order and uses the first candidate that exists. The discovered manifest MUST declare package.name exactly matching the dependency key, and the dependency is still subject to the sha256 verification rules above. Example: [dependencies] myapi = { sha256 = \"sha256:0123456789abcdef...\" } Build Targets ([[target]]) A package may declare one or more build targets. Each target produces one artifact (an executable, an object, a static library, a shared library, or a wasm module). Example: [[target]] name = \"myapp\" kind = \"executable\" entry = \"src/main.slk\" output = \"build/myapp\" [[target]] name = \"mylib\" kind = \"static\" entry = \"src/lib.slk\" output = \"build/libmylib.a\" cheader = \"build/mylib.h\" Fields: name (required): unique target name within the package. kind (required): one of executable, object, static, shared. entry (required): path to the entry module, relative to the manifest directory. output (optional): output path relative to the manifest directory. If omitted, the compiler chooses a default under build/ based on name and kind: executable: build/<name> (or build/<name>.wasm for wasm targets), object: build/<name>.o, static: build/lib<name>.a, shared: build/lib<name>.so (current hosted baseline is linux/x8664). arch / target (optional): default codegen target for this artifact. arch is one of x8664, wasm32, wasm32-wasi (same as silk build --arch). target is a target triple string accepted by silk build --target (for example linux-x8664, wasm32-wasi). arch and target MUST NOT both be set for the same target. cheader (optional): emit a C header when building this target (only valid for kind = object static shared). Dynamic linkage fields (optional; passed through to the backend): needed = [\"libc.so.6\", \"...\"] (repeatable DTNEEDED entries), runpath = [\"$ORIGIN\", \"...\"] (joined with : for DTRUNPATH), soname = \"libfoo.so\" (for shared libraries). Note: needed entries starting with libsilkrt are rejected; bundled runtime helpers are linked statically by silk build when referenced. Default Target ([build]) When a package defines multiple [[target]] entries, silk build --package needs to know which one to build. [build] defaulttarget = \"myapp\" Rules: If build.defaulttarget is set, it MUST name an existing [[target]]. If build.defaulttarget is not set: if exactly one [[target]] exists, it is the default, otherwise, silk build --package requires an explicit target selection Interaction With package Declarations If a module contains an explicit package name; declaration, that name is authoritative. If a module omits package, the compiler assigns it to the manifest package.name (for files under that package root). This defaulting behavior exists to support small projects that do not want to repeat package ...; in every file. Reserved Fields The manifest reserves additional fields for future build integration: provenance / integrity metadata (repo, richer dependency sources), native build configuration (sources, link, compile), embedded targets / budgets."
    },
    {
      "id": "compiler/lsp-silk",
      "title": "Silk Language Server (LSP)",
      "section": "compiler",
      "summary": "This document specifies the initial Language Server Protocol (LSP) implementation for Silk.",
      "text": "Silk Language Server (LSP) This document specifies the initial Language Server Protocol (LSP) implementation for Silk. The goal of the language server is to provide editor and IDE integrations (diagnostics, and eventually features like completion and hover) while remaining a thin, spec-driven wrapper around the existing compiler front-end. Overview The Silk language server: is implemented in Zig and shipped as a separate executable (silk-lsp), speaks the Language Server Protocol over stdin/stdout using JSON-RPC 2.0 and Content-Length framing, reuses the existing lexer, parser, and type checker for semantics, does not change the language surface or ABI; it is a tooling layer on top of the existing compiler. Running the Server The silk-lsp binary is built and installed alongside the silk CLI: zig build install (or the project\u2019s preferred build wrapper) will install both silk and silk-lsp into the configured prefix. Editor and IDE integrations should launch silk-lsp as a stdio-based LSP server, without extra arguments, and then speak JSON-RPC 2.0 over its stdin/stdout. The server writes protocol messages to stdout and may emit diagnostic logs to stderr; LSP clients must not treat stderr as protocol traffic. Optional flags: std-root <path> overrides the stdlib root used for resolving import std::...;. nostd disables stdlib auto-loading entirely. Typical client configurations (e.g., Vim/Neovim LSP, VS Code, or other LSP frontends) should: set the command to [\"silk-lsp\"], enable standard LSP text document synchronization, refrain from sending requests beyond the capabilities advertised in initialize (hover, diagnostics, shutdown/exit). Transport and Protocol The language server: reads requests from standard input using the LSP message framing (Content-Length: <n>\\r\\n\\r\\n<json>), writes responses and server-initiated notifications to standard output using the same framing, implements JSON-RPC 2.0 semantics (jsonrpc: \"2.0\", id, method, params, result / error). The server does not depend on any external networking libraries; it uses Zig standard library I/O and JSON support. Position handling note: The lexer tracks byte offsets and byte-based columns. The LSP layer maps between byte columns and LSP utf-16 character positions. Clients should treat returned line/character values as LSP positions in UTF-16. If a request uses a character position beyond the end of a line, the server clamps it to the line end when locating tokens. Initialization The server supports the standard LSP initialization sequence: initialize (request): Advertised capabilities (initial version): positionEncoding: \"utf-16\" (the server currently operates in UTF-16 positions for maximum client compatibility). textDocumentSync: openClose: true, change: 1 (Full document sync), save: { includeText: false }. hoverProvider: true (minimal lexical hover on literals and identifiers as described below). definitionProvider: true (definition lookups backed by the module-set symbol index; see below). documentSymbolProvider: true (top-level fn/let/struct/enum/error/interface/ext/impl symbols as described below). completionProvider: a minimal completion provider that: does not support resolve, advertises trigger characters ., :, {, ,, \", ` `, and /, offers keyword, identifier, and symbol-aware suggestions as described below. signatureHelpProvider: trigger characters ( and ,, provides function and method signatures for the current call. No references/rename, semantic tokens, or other advanced features are claimed in the initial implementation. The server uses rootUri (or rootPath) to help locate a stdlib root when no explicit --std-root or SILKSTDROOT is set. initialized (notification): Accepted but does not currently trigger additional behavior. shutdown (request) and exit (notification) are honored as in the LSP spec. Requests received after shutdown (other than exit) are treated as invalid and answered with an error response. $\\/cancelRequest notifications are accepted and ignored; the initial server does not track per-request cancellation state. Any future capabilities (completion, hover, goto definition, etc.) must be documented here before being implemented. Hover (Initial Support) The server provides a minimal implementation of textDocument/hover: Hover requests are handled for the current contents of an open document (as tracked in the server\u2019s in-memory document table). The server computes hover information lexically, based on the token at the given position: integer literals are reported as \u201cint literal\u201d, floating-point literals as \u201cfloat literal\u201d, boolean literals (true/false) as \u201cbool literal\u201d, string and character literals as \u201cstring literal\u201d and \u201cchar literal\u201d, identifiers are reported as identifier 'name'. Hover now includes lightweight semantic hints: function identifiers show their fn name (...) -> result signature when available, let bindings show the declared (or literal-inferred) type when available, struct / enum / interface / error identifiers report struct Name / enum Name / interface Name / error Name, ext declarations report ext name: <type> when available, field and method accesses (value.field, value.method) report the field type or method signature when the receiver is a known struct, imported names are resolved across the module set (package imports and from \"...\" imports, including named imports and namespace/default imports). When the resolved declaration has a doc comment, hover renders it as Markdown: the first block is a silk code block containing the signature/header, followed by the rendered doc comment body. The hover range returned to the client corresponds to the token span (same token line/column/length used for diagnostics); when no suitable token is found at the requested position, the server returns null as the hover result. As the front-end grows richer (e.g. with symbol tables and more detailed type information), hover semantics may be extended to include resolved types and declaration summaries; such changes must be reflected here before being implemented. Go to Definition (Initial Support) The server provides an initial implementation of textDocument/definition: Definition requests are handled for the current contents of an open document. The server first consults the module-set symbol index (open docs + resolved imports + std modules) to resolve: exported or package-local fn, let, ext, struct, enum, interface, and error declarations, methods declared in impl blocks when invoked as value.method(...), qualified names such as std::pkg::name and namespace-qualified names like alias::name when alias is a namespace import. Local scopes are then consulted to resolve: function parameters, block-scoped let bindings, match-statement binders within the selected arm body. Member access (value.field / value.method) uses the heuristic receiver-type resolver: when a method is found, the definition points at the impl method declaration, when a struct field is found, the definition points at that field declaration, otherwise the definition falls back to the receiver struct declaration. Constructor calls (new Type(...)) resolve to the fn constructor declaration when the constructor overload set is unambiguous; otherwise the server falls back to the struct Type declaration. If symbol resolution fails, the server falls back to a lexical scan of the current file for the first matching let/fn/ext/struct/enum/interface/error declaration. Known limitations in this initial support: local block scopes and shadowing are only modeled for let-style bindings (not for match-expression binders), ambiguous names across multiple imports are not disambiguated; the first match wins, cross-file results are limited to declarations present in the current module set. Completion (Initial Support) The server provides a minimal implementation of textDocument/completion: Completion items are offered for: all language keywords defined in src/token.zig (via keywordTable()), all distinct identifiers lexed from the current document (names that are not recognized as keywords), symbol-aware suggestions from the current package and imported packages (functions, lets, ext, structs, enums, interfaces, errors), imported names from module-specifier imports (import { ... } from \"...\"; and import alias from \"...\";) when resolvable, import specifier path completion inside from \"...\" strings: file specifiers (\"./...\", \"../...\", and absolute paths) suggest .slk files and subdirectories, std-root file specifiers (\"std/...\") suggest stdlib paths (omitting the .slk extension), namespace completions after :: for known packages and namespace imports, member completions for struct fields and methods after . when the receiver type is known (including locals with type annotations or struct-literal/cast inference), struct-literal field suggestions in Type { ... } expressions when the cursor is in a field-name position (before the :). The current implementation: returns completion items with label, kind, and detail populated when symbol data is available, attaches a plaintext signature preview for functions and methods in completion documentation, filters results by the identifier prefix immediately preceding the cursor position, uses a heuristic symbol index built from the module set (open docs + imports + std modules). Scope precision is still limited: receiver type inference is heuristic (it is not a full typechecker), local scopes are only partially modeled for completion (not all binder forms and control-flow refinements are represented), cross-file results are limited to declarations present in the current module set (open docs + the import closure). As richer front-end support becomes available, completion may be extended to: filter suggestions by lexical/semantic scope, distinguish between functions, types, variables, and other symbol kinds, surface standard library symbols by consulting the resolver. Signature Help (Initial Support) The server provides a minimal implementation of textDocument/signatureHelp: Signature help is computed for the innermost call expression at the cursor. The server supports: direct calls to named functions (foo(...)), qualified calls (std::pkg::foo(...) and alias::foo(...) for namespace imports), method calls (value.method(...)) when the receiver resolves to a known struct type. constructor calls via heap allocation syntax (new Type(...)), which resolves to the constructor overload set defined in impl Type { ... }. calls via named imports and default-imported default exports (import { f as g } from \"...\"; g(...), import g from \"./mod.slk\"; g(...)) when resolvable. Active parameter selection is based on comma counting in the current call. Signature labels follow the Silk surface syntax (e.g. fn foo (a: int, b: int) -> int). When doc comments are available: SignatureInformation.documentation is populated with rendered Markdown from the doc comment, SignatureParameter.documentation is populated from @param entries when present. For constructor overload sets, the server returns multiple signatures and selects an active signature using argument-count heuristics. The implicit receiver parameter (mut self: &Type) is not shown in the signature parameters for new Type(...). Signature help is heuristic and will become richer as the front-end\u2019s symbol tables evolve. Some clients may request signature help even before ( is typed; the server will attempt to resolve the identifier under the cursor as a callee in that case. Document Symbols (Initial Support) The server provides a minimal implementation of textDocument/documentSymbol: Document symbols are derived lexically from the source text: top-level fn declarations are reported as function symbols, top-level let bindings are reported as variable symbols. top-level struct, enum, error, interface, ext, and impl declarations are also reported. Implementation details: symbols are inferred from fn name, let name, struct Name, enum Name, error Name, interface Name, ext name, and impl Name patterns in the token stream, the implementation tracks { ... } brace depth and only reports declarations at brace depth 0, the symbol range and selectionRange both correspond to the identifier token span, nested or block-local declarations are not yet surfaced. Symbol kinds: functions are reported using the LSP Function kind (numeric value 12), let bindings are reported using the Variable kind (numeric value 13), struct declarations use Struct (numeric value 23), enum declarations use Enum (numeric value 10), error declarations use Struct (numeric value 23), interface declarations use Interface (numeric value 11), ext declarations use Function (numeric value 12), impl declarations use Namespace (numeric value 3). Future extensions may: organize symbols hierarchically (for example nesting methods under an impl), add additional declaration kinds (imports and interface members). Text Document Lifetime and Diagnostics The server maintains an in-memory table of open documents, keyed by URI: textDocument/didOpen: stores the full text of the document, rebuilds a lightweight workspace cache (module set + symbol index + export table) used for hover/definition/completion/signature help, publishes diagnostics via textDocument/publishDiagnostics for the opened URI by parsing the opened document and type-checking it against the cached module set (imports + std modules). textDocument/didChange (full sync): replaces the stored text with the new full contents, parses the changed document and type-checks it against the cached module set (imports + std modules), publishes updated diagnostics for the changed URI. textDocument/didSave: rebuilds the module set from all open documents, resolves imports across the module set (packages + file imports) and loads standard library modules when configured, type-checks the module set, publishes diagnostics via textDocument/publishDiagnostics for any affected module URI (including imports). textDocument/didClose: removes the document entry, publishes an empty diagnostics list for the closed URI, rebuilds the workspace cache for the remaining open documents. For responsiveness, the server caches parsed modules (AST + lightweight module info) per open document revision and reuses them across hover/definition/completion/signatureHelp requests until the document changes. Standard Library Integration By default, the language server will load standard library packages referenced by import std::... when a stdlib root is available. The stdlib root is selected using the same rules as the compiler, with an additional workspace-root fallback: std-root <path> passed to silk-lsp (highest priority), SILKSTDROOT when set, ./std when present (development default), an executable-relative fallback (../share/silk/std) when installed, walk upward from the silk-lsp executable\u2019s directory to find std/ (developer build fallback), if none of the above are available and the LSP client provides rootUri/rootPath, walk upward from that workspace root to find a std/ directory. You can disable stdlib integration entirely with --nostd, which is useful for sandboxed editor setups or custom stdlib forks. Diagnostics Source and Limitations (Initial) Diagnostics are derived from the existing compiler front-end: For responsiveness while typing: didChange diagnostics are computed for the changed document by parsing it and type-checking it against the cached module set (imports + std modules). The cache is not rebuilt on every change. A full module-set parse + resolve + type-check (including imports) is performed on didSave, and diagnostics are published for all affected modules. The current front-end exposes errors as simple error codes (e.g. UnexpectedToken, TypeMismatch) without rich spans. The initial LSP implementation therefore follows these rules: Parse errors: reported at the location of the unexpected token using the token\u2019s line/column and length, message text describes the unexpected token and that parsing failed. Type-checking errors: reported at an approximate source location associated with the expression or statement that triggered the error (for example, the initializer expression for a mismatched let binding or the break / continue / return keyword), message text distinguishes between known error kinds (e.g. TypeMismatch, InvalidReturn) and carries the span reported by the type checker when available; if no span is available, diagnostics fall back to a coarse location. As the compiler evolves to carry richer diagnostic information (spans, notes, labels), this document and the LSP implementation must be updated so that: diagnostics map directly to the front-end\u2019s structured error data, positions and ranges reflect the exact source spans of the underlying errors. Non-Goals (Initial Version) The initial silk-lsp implementation explicitly does not provide: full semantic completions with scope-precise filtering and type inference (beyond the current heuristic symbol index), cross-file go-to-definition / references, semantic tokens or inlay hints, code actions or formatting. These features are intended as future extensions and must be: backed by the underlying compiler front-end and/or standard library, covered by tests (Zig and, where appropriate, C) before being advertised as supported capabilities. Relationship to Other Tooling The language server is part of the broader tooling story described in: The tmp/zls/` directory in this repository contains a vendored copy of the Zig Language Server (ZLS) for inspiration and experimentation only: it is not part of the supported Silk toolchain, it must not be treated as authoritative for Silk semantics,"
    },
    {
      "id": "compiler/stdlib-integration",
      "title": "Standard Library Integration",
      "section": "compiler",
      "summary": "This document describes how the `std::` package integrates with the compiler and the CLI.",
      "text": "Standard Library Integration This document describes how the std:: package integrates with the compiler and the CLI. Key requirements: std:: is a distinct package: linked by default by silk, replaceable with an alternative implementation via CLI or configuration. The default std:: assumes POSIX semantics for OS-facing components. Compiler responsibilities: Provide mechanisms for: linking the default stdlib, specifying an alternate stdlib, ensuring FFI and ABI remain stable regardless of the stdlib implementation."
    },
    {
      "id": "compiler/testing-strategy",
      "title": "Testing Strategy (Zig + C99 + Silk)",
      "section": "compiler",
      "summary": "This document defines how we validate the compiler, ABI, and standard library.",
      "text": "Testing Strategy (Zig + C99 + Silk) This document defines how we validate the compiler, ABI, and standard library. Goals Provide confidence in language features, FFI, and standard library behavior. Make testing incremental and continuous: every new feature or module must land with tests, not as a separate phase. Zig Tests For each compiler subsystem (lexer, parser, type checker, verifier, codegen), add Zig tests as the subsystem is implemented: Unit tests for lexer, parser, type checker, and verifier. Prefer placing tests close to the code they exercise (e.g. Zig test blocks in the same modules, plus higher-level integration suites where needed). C99 Tests For ABI and FFI boundaries, add C99 tests in lockstep with the implementation: Tests that link against libsilk.a and invoke compiled Silk code through the C ABI. Tests that exercise FFI boundaries (strings, structs, arrays, closures, error paths). Tests that validate ABI stability across builds (e.g. struct layouts, calling conventions). When building and running these tests: it is expected that the build system uses a C99 compiler (for example cc) only to compile the C test harnesses and embedder examples that link against libsilk.a, the Silk compiler itself MUST NOT generate C or invoke cc as part of its own code generation pipeline; using a C compiler here is strictly for exercising the public C ABI from C code, not for compiling Silk programs. Parity & Regression For critical features (especially FFI and ABI), maintain parallel test cases in Zig and C: Zig tests verify language semantics and internal representations. C tests verify ABI conformance and interop. When a bug is found: add a regression test in Zig and, where relevant, in C, Silk Tests In addition to Zig and C99 tests, we maintain Silk-written test programs: Location: They are regular Silk modules and are intended to be readable examples of language features. Categories: must parse and type-check successfully, are exercised from Zig tests via the compiler front-end and CLI helpers. are expected to fail type checking (many fixtures only assert \u201cfails\u201d, with targeted tests asserting specific error kinds such as TypeMismatch / InvalidBreak when stability matters), must parse and type-check successfully, are expected to fail Formal Silk verification with stable diagnostic codes (E3001..E3008), are used to validate verifier behavior independently of the type checker. are fixtures imported by other tests, are not executed directly by the harness as standalone \u201ctests\u201d. are multi-module package/import fixtures that require running silk check on an explicit module set, include both expected-success and expected-error scenarios (for example, duplicate exports across modules in the same package). Execution: Zig tests in src/tests.zig: for pass.slk, call driver.runCheck and require success, for fail.slk, parse and type-check and require that type checking fails (most fixtures only assert \u201cfails\u201d, with targeted tests asserting specific CheckError values), run verifyfail.slk fixtures through the Formal Silk verifier and assert stable diagnostic codes, run pkg.slk fixtures via explicit silk check module-set invocations (some are expected to fail), for a growing subset of pass.slk programs whose main fits the current constant-expression backend (e.g. passletlocals.slk, passtoplevellet.slk), invoke the silk CLI to build them to native executables and run those executables, asserting on their exit codes; this keeps Silk-written tests participating in both front-end and back-end validation as code generation matures. As the backend matures, additional Silk tests will be added that: build and run executables beyond the constant-expression subset, exercise libraries and FFI, validate behavior across targets (ELF/Mach-O/PE) and architectures."
    },
    {
      "id": "compiler/vendored-deps",
      "title": "Vendored Dependencies",
      "section": "compiler",
      "summary": "Silk aims to be buildable with minimal reliance on system-installed cryptography/TLS libraries. For the hosted POSIX baseline, Silk vendors:",
      "text": "Vendored Dependencies Silk aims to be buildable with minimal reliance on system-installed cryptography/TLS libraries. For the hosted POSIX baseline, Silk vendors: libsodium (jedisct1/libsodium) at tag 1.0.20-RELEASE mbedTLS (Mbed-TLS/mbedtls) at tag mbedtls-4.0.0 libssh2 (libssh2/libssh2) at tag libssh2-1.11.1 SQLite amalgamation at version 3510200 (downloaded from sqlite.org) ggml (ggml-org/ggml) at tag v0.9.5 These dependencies are fetched as shallow clones (--depth 1) and built as static libraries for linux/x8664. Note: the current deps workflow builds libssh2 with the OpenSSL backend, so building libssh2 requires system OpenSSL headers and libraries (libssl/libcrypto). Fetch + Build From the repo root: make deps Or directly: zig build deps This populates: vendor/deps/ \u2014 git checkouts of the pinned tags vendor/build/ \u2014 build directories (libsodium via autotools; mbedTLS via CMake) vendor/lib/x64-linux/ \u2014 built static archives: libsodium.a libmbedtls.a libmbedx509.a libmbedcrypto.a libssh2.a libsqlite3.a libggml.a libggml-base.a libggml-cpu.a libsilkggmlshims.a (ABI-safe Silk wrappers for by-value ggml APIs) These directories and generated .a files are ignored by git. Bundling Into libsilk.a When the vendored archives are present, the Zig build can bundle them into libsilk.a so C embedders do not have to link libsodium/mbedTLS separately. To require that the vendored archives are present (and fail the build if they are missing), pass: zig build -Drequire-vendored-crypto=true Notes Vendoring is currently wired up only for linux/x8664. Some std modules are currently wired to system shared libraries during the hosted linux/x8664 phase (for example std::tls and std::ssh2); the vendored static archives produced by zig build deps are used for embedding and future bundling into libsilk.a. mbedTLS uses git submodules (framework, tf-psa-crypto); zig build deps initializes them automatically. zig build deps configures mbedTLS with ENABLETESTING=OFF and ENABLEPROGRAMS=OFF (we only need the static libraries). The deps step requires git, cmake, perl, and a working C build toolchain (make + a C compiler). Building libssh2 currently requires system OpenSSL development files (headers + libraries) due to the OpenSSL backend configuration. mbedTLS/TF-PSA-Crypto generation requires python3 with jinja2 available; jsonschema is optional (validation is skipped when it is missing)."
    },
    {
      "id": "compiler/backend-wasm",
      "title": "WebAssembly Back-End (`wasm32` / `wasm64`)",
      "section": "compiler",
      "summary": "This document records the initial design and constraints for targeting WebAssembly from the Silk compiler back-end. It is intended to guide future implementation work and keep the compiler architecture spec-driven.",
      "text": "WebAssembly Back-End (wasm32 / wasm64) This document records the initial design and constraints for targeting WebAssembly from the Silk compiler back-end. It is intended to guide future implementation work and keep the compiler architecture spec-driven. Current Implementation (Phase 1, IR-backed wasm32) The repository now includes an initial wasm32 back-end capable of emitting a final .wasm module from the compiler\u2019s IR (CFG-based lowering for the current subset), plus a smaller constant-only fallback: Implementations: IR\u2192WASM backend: src/backendwasmir.zig (primary path), constant-only emitter: src/backendwasm.zig (fallback path). Supported targets: wasm32-unknown-unknown: emits a .wasm module exporting memory plus exported functions, when a valid main exists, exports main for embedder use. wasm32-wasi: emits a .wasm module exporting memory and start () -> void, imports wasisnapshotpreview1.procexit (exitcode: i32) -> void, start calls Silk main and then calls procexit with the wrapped exit code. Export-only modules (no main): emit a .wasm module exporting memory plus each supported export fn in the root package (suitable for JS/Node-style embedding). FFI mapping (WASM): ext foo = fn (...) -> ...; becomes an imported function env.foo, ext bar = T; becomes an imported global env.bar (scalar T). Current capabilities (prototype quality): supports multi-module builds (packages + file imports), emits static data into the wasm data section (string/byte blobs and other lowered constants), supports structured control flow (if/while/break/continue) for the current IR subset. does not yet support the concurrency runtime on wasm targets (no task / async lowering to a wasm-native scheduler); programs using concurrency constructs may fail code generation with a \u201cnot implemented yet\u201d error. The CLI exposes these targets via silk build --target ... and the shorthand Goals Support emitting WebAssembly modules for: wasm32 (32-bit linear-memory addressing), wasm64 (64-bit linear-memory addressing; future-facing). Support both: a hosted environment (wasm32-wasi), and an embedder-driven environment (wasm32-unknown-unknown, typically JS). Preserve Silk\u2019s \u201cnative compiler\u201d principle: this is Silk-owned codegen (no C transpilation). Non-Goals (for initial implementation) A full WASM toolchain replacement (linker, LTO, debug formats) on day one. A single \u201cportable\u201d stdlib archive usable across all WASM environments (WASI vs JS embedder differ in available imports and conventions). Universal ABI compatibility with arbitrary third-party wasm linkers before we have a stable Silk \u2194 WASM ABI specification. Output Model Module kinds The initial back-end should emit a final .wasm module (not a relocatable object) for the supported subset, analogous to the current linux/x8664 \u201cemit a final ELF image\u201d approach. Future work may add \u201cwasm object\u201d emission, but it requires relocation sections and a defined link model. Entry points We need two distinct entrypoint conventions: wasm32-wasi: emit a start function (no parameters, no results), start calls Silk fn main () -> int and then imports/calls WASI procexit(exitcode). wasm32-unknown-unknown: export an Silk main function for embedder use. Silk int is currently lowered as wasm i64, so main\u2019s return type is i64 unless a wrapper is introduced in the future. The CLI/ABI must document which convention is used for each target. Export-only modules (embedder mode) For embedder-driven environments (especially wasm32-unknown-unknown / JS), the toolchain also supports emitting a wasm module with no entry point (main / start) when the root package contains exported functions. In this mode, the compiler emits a .wasm module that exports each supported export fn declaration from the root package as a wasm export (with parameters and results lowered according to the current scalar ABI). Notes: For wasm32-wasi, export-only modules are intended for embedding; they do not include an start wrapper and are not directly runnable as WASI executables. Types, Layout, and Memory Integer and float types int maps to: i64 in wasm32/wasm64 backends (matching current compiler semantics). Fixed-width ints map to their obvious wasm integer types: u8/i8/u16/i16/u32/i32 lower to i32 values (with masking/sign rules applied in codegen), u64/i64 lower to i64 values. f32 and f64 map to wasm f32/f64. bool maps to i32 (0/1). Pointers and string Silk\u2019s current back-end assumes 64-bit pointers (u64). For WASM, pointer width depends on the target: wasm32: pointers are u32 byte offsets into linear memory. wasm64: pointers are u64 byte offsets into linear memory. string is currently represented as (ptr, len) and, at the C ABI boundary, as SilkString { ptr, len }. For WASM: In wasm32, the natural representation is (u32 ptr, i64 len) (or (u32,u32) if we later choose a fully-32-bit ABI for wasm-only code). In wasm64, (u64 ptr, i64 len) matches the existing layout. The chosen WASM ABI for strings must be documented and kept stable. Static data String literals and other constant data should be emitted into the wasm data section and referenced by linear-memory offsets. The compiler must define a deterministic data layout (alignment rules) so field access and pointer arithmetic remain correct. Calls, Imports, and FFI Internal calls For the initial subset, internal calls should be direct wasm calls using wasm\u2019s native calling convention (stack machine with typed locals), with the compiler responsible for lowering Silk IR values into the wasm value stack. ext declarations ext declarations should map to wasm imports: Each ext foo = fn (...) -> ...; becomes an imported function with a stable module/name convention (for example env.foo by default). Each ext bar = T; (external global) becomes an imported global when the environment supports it, or a function-based accessor in environments that do not. The module/name convention and supported import surface must be documented in WASI integration For wasm32-wasi, stdlib facilities like std::io and std::fs should eventually target WASI syscalls rather than libc symbols. This implies: The \u201chosted\u201d stdlib for WASI is a separate std distribution from the POSIX std/ currently used for linux/x8664. The stdlib archive must be target-specific (one archive per target ABI), and swapping stdlib roots should remain supported (--std / --nostd etc.). Tooling and Testing Strategy Add a small set of WASM end-to-end tests once codegen exists: compile a program to .wasm, run it with a runtime appropriate to the target (wasmtime for WASI, a JS harness for unknown-unknown), assert exit code or exported return value. Keep tests target-scoped and avoid requiring network access. Roadmap (Suggested Phases) 1. Minimal wasm32 module: emit a module that exports main returning i32 for fn main () -> int (constant subset first). 2. Data and strings: support string literals and string values backed by linear-memory data segments. 3. Control flow and helpers: lower the existing IR CFG into wasm blocks, loops, branches, and calls. 4. WASI start: add the start wrapper and procexit import for wasm32-wasi. 5. wasm64 exploration: validate pointer-width changes and ABI decisions."
    },
    {
      "id": "compiler/zig-api",
      "title": "Zig Embedding API (Programmatic Compilation)",
      "section": "compiler",
      "summary": "This document specifies the Zig-facing embedding API for using the Silk compiler programmatically from Zig code.",
      "text": "Zig Embedding API (Programmatic Compilation) This document specifies the Zig-facing embedding API for using the Silk compiler programmatically from Zig code. It complements (and is intentionally aligned with) the C99 embedding API Goals Allow Zig programs to compile Silk sources into: native executables, ELF relocatable objects (.o), static libraries (.a), shared libraries (.so), using the same implementation as the silk CLI and libsilk.a. Support filesystem-free embedding flows by building artifacts into owned in-memory byte buffers (and by allowing stdlib auto-loading to be disabled). Provide a Zig-friendly wrapper (slices, enums, error unions) over the existing embedding surface, while keeping the error semantics consistent. Keep the API small and stable: for feature gaps, return an error and surface details via the same \u201clast error\u201d mechanism as the C API. Relationship to the C ABI The Zig embedding API is a thin wrapper over the same implementation that backs libsilk.a. Practical implications: The supported language subset and backend constraints are the same as the CLI and C API for a given build of this repo. When an operation fails, the compiler records a human-readable last error. Zig callers can retrieve it via Compiler.lastErrorAlloc. The Zig API does not require @cImport; it reuses the Zig implementation directly. Public Module This repository exports a Zig module named silk from build.zig for downstream dependencies. Downstream build snippet (illustrative): const silk = b.dependency(\"silk\", .{ .target = target, .optimize = optimize }); exe.rootmodule.addImport(\"silk\", silk.module(\"silk\")); exe.rootmodule.linklibc = true; Notes: The compiler implementation uses libc for filesystem and process I/O in the current prototype; downstream artifacts that import the silk module should link libc. The module is source-based: depending on it compiles the compiler into your Zig program (this is intended for embedding). Compiler API The silk module exposes a Compiler type for constructing a compilation: const silk = @import(\"silk\"); var compiler = try silk.Compiler.init(); defer compiler.deinit(); try compiler.setStdRoot(\"./std\"); try compiler.addSourceBuffer(\"main.slk\", \"fn main () -> int { return 0; }\"); try compiler.build(.SILKOUTPUTEXECUTABLE, \"out/hello\"); For filesystem-free output, use buildToBytes: var exebytes = try compiler.buildToBytes(.SILKOUTPUTEXECUTABLE); defer exebytes.deinit(); Configuration The wrapper mirrors the existing embedding knobs: stdlib selection: setStdRoot(path) to select the root for import std::...; resolution, setStdlib(name) to select the stdlib package name (default std). stdlib auto-loading can be disabled (for sandboxed/WASM-like embedding) via: setNoStd(true). target selection: setTargetTriple(triple) (currently only a narrow subset of targets is implemented by the backend). optimization level: setOptimizationLevel(0..3). dynamic linking metadata for outputs that support it: addNeededLibrary(soname), addRunpath(path), setSoname(soname). Error handling Most operations return error.Failed on error, with details available via: lastErrorAlloc(allocator) -> ?[]u8 (returns an owned UTF-8 message slice). The last error is overwritten by subsequent operations, matching the C API. Stability and scope The Zig embedding API is intended to remain stable in lockstep with the C ABI this document, and add/adjust Zig tests that exercise the affected surface."
    },
    {
      "id": "man/libsilk.7",
      "title": "`libsilk` (7) \u2014 C99 ABI for the Silk Compiler",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for a man 7 page describing the C99 embedding ABI exposed by `libsilk.a`. The roff-formatted manpage should be generated from this content.",
      "text": "libsilk (7) \u2014 C99 ABI for the Silk Compiler NOTE: This is the Markdown source for a man 7 page describing the C99 embedding ABI exposed by libsilk.a. The roff-formatted manpage should be generated from this content. Name libsilk \u2014 C99-compatible embedding ABI for the Silk compiler. Synopsis include \"silk.h\" / Core types / typedef struct SilkString SilkString; typedef struct SilkBytes SilkBytes; typedef struct SilkCompiler SilkCompiler; typedef struct SilkModule SilkModule; typedef struct SilkError SilkError; typedef enum SilkOutputKind SilkOutputKind; / Version / void silkabigetversion(int outmajor, int outminor, int outpatch); / Lifecycle / SilkCompiler silkcompilercreate(void); void silkcompilerdestroy(SilkCompiler compiler); / Configuration / bool silkcompilersetstdlib(SilkCompiler compiler, SilkString stdlibname); bool silkcompilersetstdroot(SilkCompiler compiler, SilkString stdroot); bool silkcompilersetnostd(SilkCompiler compiler, bool nostd); bool silkcompilersetdebug(SilkCompiler compiler, bool debug); bool silkcompilersetnoheap(SilkCompiler compiler, bool noheap); bool silkcompilersettarget(SilkCompiler compiler, SilkString targettriple); bool silkcompilersetz3lib(SilkCompiler compiler, SilkString path); bool silkcompilersetstdarchive(SilkCompiler compiler, SilkString path); bool silkcompileraddneededlibrary(SilkCompiler compiler, SilkString soname); bool silkcompileraddrunpath(SilkCompiler compiler, SilkString path); bool silkcompilersetsoname(SilkCompiler compiler, SilkString soname); bool silkcompilersetoptimizationlevel(SilkCompiler compiler, int level); bool silkcompilersetcheader(SilkCompiler compiler, SilkString path); / Sources / SilkModule silkcompileraddsourcebuffer(SilkCompiler compiler, SilkString name, SilkString contents); / Build / bool silkcompilerbuild(SilkCompiler compiler, SilkOutputKind kind, SilkString outputpath); bool silkcompilerbuildtobytes(SilkCompiler compiler, SilkOutputKind kind, SilkBytes outbytes); void silkbytesfree(SilkBytes bytes); / Errors / SilkError silkcompilerlasterror(SilkCompiler compiler); sizet silkerrorformat(const SilkError error, char buffer, sizet bufferlen); Link with (on linux/x8664, libsilk.a vendors Z3 which is built as C++): cc -std=c99 -Wall -Wextra \\ I/path/to/include \\ yourapp.c \\ L/path/to/lib -lsilk \\ lstdc++ -lpthread -lm Description libsilk.a exposes a stable C99 ABI for embedding the Silk compiler inside C (or C++) applications. The ABI is designed to be: simple and explicit, versioned independently of the compiler implementation, usable from plain C99 without extensions. Embedders are expected to: include the public header silk.h, link against libsilk.a, drive compilation by creating a SilkCompiler handle, adding source buffers, and invoking silkcompilerbuild, inspect error details via silkcompilerlasterror and silkerrorformat. Types SilkString typedef struct SilkString { char ptr; int64t len; } SilkString; Represents a UTF\u20118 string as a pointer plus a length. ptr may be NULL when len == 0. Unless explicitly documented otherwise for a given API: functions taking SilkString do not take ownership of ptr, the caller is responsible for the lifetime of the underlying storage. SilkBytes typedef struct SilkBytes { uint8t ptr; int64t len; } SilkBytes; Represents an owned byte buffer as a pointer plus a length. ptr may be NULL when len == 0. Buffers returned by silkcompilerbuildtobytes must be freed with silkbytesfree. Opaque handles typedef struct SilkCompiler SilkCompiler; typedef struct SilkModule SilkModule; typedef struct SilkError SilkError; SilkCompiler represents a compiler instance and owns configuration, modules, and internal error state. SilkModule is an opaque handle returned when a source buffer is registered; its layout is not exposed. SilkError represents a diagnostic object owned by a SilkCompiler. Callers must never allocate, free, or dereference these types directly. They are managed exclusively through the ABI functions. SilkOutputKind typedef enum SilkOutputKind { SILKOUTPUTEXECUTABLE = 0, SILKOUTPUTSTATICLIBRARY = 1, SILKOUTPUTSHAREDLIBRARY = 2, SILKOUTPUTOBJECT = 3, } SilkOutputKind; Selects the kind of build artifact requested by silkcompilerbuild. At the current stage of implementation, all kinds perform full front\u2011end validation; code generation is implemented only for a small, constant\u2011expression subset of executable builds on linux/x8664 (see Build behavior). Versioning The header defines: define SILKABIVERSIONMAJOR 0 define SILKABIVERSIONMINOR 2 define SILKABIVERSIONPATCH 0 and the function: void silkabigetversion(int outmajor, int outminor, int outpatch); Callers should: compare the runtime version returned by silkabigetversion with the compile\u2011time macros, reject or warn on mismatches as appropriate for their integration. The ABI is versioned so that future incompatible changes can be detected at runtime. Lifecycle silkcompilercreate / silkcompilerdestroy SilkCompiler silkcompilercreate(void); void silkcompilerdestroy(SilkCompiler compiler); silkcompilercreate: returns a new compiler handle on success, returns NULL on allocation error. silkcompilerdestroy: may be called with NULL (it is a no\u2011op), must be called exactly once for each non\u2011NULL handle from silkcompilercreate, releases all modules and errors owned by the compiler. A single SilkCompiler instance is not currently specified as thread-safe; callers should either confine it to one thread or synchronize access. Configuration Standard library selection bool silkcompilersetstdlib(SilkCompiler compiler, SilkString stdlibname); Sets the name of the standard library package (for example \"std\"). The function: copies the name internally, returns true on success, returns false on error and records an error in the compiler. Standard library root bool silkcompilersetstdroot(SilkCompiler compiler, SilkString stdroot); Sets the filesystem stdlib root directory used to resolve import std::...; declarations. This overrides SILKSTDROOT (environment variable) and the std/ working-directory default. The function: validates that the directory exists, copies the path internally, returns true on success, returns false on error and records an error in the compiler. Disable stdlib auto-loading (nostd) bool silkcompilersetnostd(SilkCompiler compiler, bool nostd); When nostd is true, the compiler disables filesystem-based stdlib auto-loading for import std::...;. In this mode, any std::... packages must be provided explicitly by adding the corresponding sources as modules (for example via silkcompileraddsourcebuffer). Debug build mode (debug) bool silkcompilersetdebug(SilkCompiler compiler, bool debug); Enables the same debug build mode as the CLI (silk --debug / -g) for the supported subset: debug-mode lowering for supported native outputs (e.g. stack traces on failed assert for linux/x8664), additional Z3 debug output and .smt2 dump emission on failing Formal Silk debug is currently incompatible with --noheap. No-heap build mode (noheap) bool silkcompilersetnoheap(SilkCompiler compiler, bool noheap); Enables the same no-heap build mode as the CLI (silk --noheap), disabling heap-backed allocation for the supported subset. noheap is currently incompatible with --debug. Target triple bool silkcompilersettarget(SilkCompiler compiler, SilkString targettriple); Sets the code generation target triple (for example \"x8664-linux-gnu\"). The triple is copied; errors are recorded in the compiler\u2019s last\u2011error state. Supported targets (initial implementation): linux-x8664 (default), plus common x8664--linux- triples such as x8664-linux-gnu and x8664-unknown-linux-gnu, wasm32-unknown-unknown (IR-backed wasm32 mode; emits a final .wasm module exporting memory and exported functions, including main when present; ext declarations become imports under env.<name>; also supports export-only modules with no main for JS/Node-style embedding), wasm32-wasi (IR-backed wasm32 WASI mode; emits memory and start () -> void, imports wasisnapshotpreview1.procexit, and calls Silk fn main () -> int; also supports export-only modules for embedding, which do not include start). Note: for wasm32 targets, only SILKOUTPUTEXECUTABLE is supported. wasm32-wasi currently supports only fn main () -> int (no argv). Z3 dynamic library override (z3lib) bool silkcompilersetz3lib(SilkCompiler compiler, SilkString path); Configures a Z3 dynamic library override for Formal Silk verification (equivalent to silk --z3-lib <path>). Passing an empty string clears the override and returns to normal Z3 resolution (including honoring SILKZ3LIB). Stdlib archive override (stdarchive) bool silkcompilersetstdarchive(SilkCompiler compiler, SilkString path); Configures a stdlib archive override for native builds (equivalent to silk --std-lib <path>). Passing an empty string clears the override and returns to normal stdlib archive resolution (including honoring SILKSTDLIB). Dynamic linker metadata These configuration functions affect dynamic metadata emitted for executable and shared library outputs on platforms/backends that support dynamic linking (the current implementation: linux/x8664). silkcompileraddneededlibrary bool silkcompileraddneededlibrary(SilkCompiler compiler, SilkString soname); Adds a dynamic loader dependency for executable and shared outputs by emitting a DTNEEDED entry. The soname string is copied; the function may be called multiple times (duplicates are ignored). Ignored for static library and object outputs. On linux/x8664 with the glibc dynamic loader (ld-linux), when an executable or shared library imports any external symbols, the compiler automatically adds libc.so.6 as a DTNEEDED dependency (so hosted std:: modules like std::io and std::fs do not require manually adding libc). Additional non-libc dependencies still require explicit DTNEEDED entries via this API. DTNEEDED entries starting with libsilkrt are rejected: bundled runtime helpers are linked statically from libsilkrt.a / libsilkrtnoheap.a and must not become runtime loader dependencies. silkcompileraddrunpath bool silkcompileraddrunpath(SilkCompiler compiler, SilkString path); Adds a runtime search path element for executable and shared outputs by emitting a DTRUNPATH entry. The path string is copied; the function may be called multiple times (duplicates are ignored) and the final DTRUNPATH string is formed by joining entries with :. Ignored for static library and object outputs. silkcompilersetsoname bool silkcompilersetsoname(SilkCompiler compiler, SilkString soname); Sets the shared library soname recorded as DTSONAME for shared outputs. The soname string is copied; passing an empty string clears the configured soname (no DTSONAME entry). Ignored for executable, static library, and object outputs. Optimization level bool silkcompilersetoptimizationlevel(SilkCompiler compiler, int level); level must be in the range [0, 3]: 0 \u2014 no optimization (fastest compile), 1 \u2014 light optimization, 2 \u2014 balanced optimization, 3 \u2014 aggressive optimization. The default optimization level is 0 unless overridden. In the current implementation, level >= 1 enables lowering-time pruning of unused extern symbols before code generation. This typically reduces output size and over-linking when using the prebuilt stdlib archive (libsilkstd.a) to satisfy auto-loaded import std::...; modules. Returns: true on success, false and records an error (e.g. \"invalid optimization level (expected 0-3)\") when the value is invalid. C header generation (cheader) bool silkcompilersetcheader(SilkCompiler compiler, SilkString path); Configures C header generation for non-executable outputs (equivalent to the CLI --c-header <path>). Passing an empty string clears the configured header output path. The header is written when silkcompilerbuild succeeds for: SILKOUTPUTOBJECT, SILKOUTPUTSTATICLIBRARY, SILKOUTPUTSHAREDLIBRARY. C header generation is not supported for silkcompilerbuildtobytes. Source buffers silkcompileraddsourcebuffer SilkModule silkcompileraddsourcebuffer(SilkCompiler compiler, SilkString name, SilkString contents); Registers a source buffer with the compiler: name is a logical module name used in diagnostics (e.g. \"main.slk\" or \"<memory>\"), contents is the UTF\u20118 Silk source. On success: returns a non\u2011NULL SilkModule , copies both name and contents into memory owned by the compiler. On error: returns NULL, records an error describing the cause. The returned SilkModule must not be freed by the caller and remains valid until the compiler is destroyed. Build behavior silkcompilerbuild bool silkcompilerbuild(SilkCompiler compiler, SilkOutputKind kind, SilkString outputpath); Performs a build for all modules added to the compiler: lexes and parses each module, type\u2011checks statements and expressions according to the language spec, enforces additional front\u2011end constraints (see below), stops on the first error. outputpath: is the requested output location for the artifact, for executable outputs (SILKOUTPUTEXECUTABLE) in the supported subset (see below), it is used as the path of the native executable that is produced, for other output kinds, it is used as the output file path in supported backend subsets; for unsupported programs/targets, no output is written. Return value: On any front\u2011end error, returns false and records a descriptive error string. Examples include: \"unexpected token while parsing module\", \"type mismatch\", \"invalid break statement\", \"invalid continue statement\", \"invalid return statement\". On success of front\u2011end validation: for non\u2011executable outputs (SILKOUTPUTSTATICLIBRARY, SILKOUTPUTSHAREDLIBRARY, SILKOUTPUTOBJECT): on supported targets/backends (currently linux/x8664), the compiler attempts code generation for the documented backend subset and returns true after writing the requested artifact on success, for front\u2011end valid programs outside that subset (or on unsupported targets), the call returns false and records either an E4001 / E4002 formatted diagnostic (unsupported construct / backend failure) or a more direct descriptive error string (for example invalid arguments), and does not write output. for executable outputs (SILKOUTPUTEXECUTABLE): if the program satisfies the executable entrypoint rule (below) and main returns a constant integer expression in the supported subset: the body of main must be one of the following: zero or more let statements with constant integer initializers followed by exactly one return of a constant expression built from integer literals, +, -, , /, %, and references to immutable let bindings whose initializers are themselves constant integer expressions, or a final if statement whose condition is a compile\u2011time boolean literal (true or false) and whose branches each satisfy the same \u201cconstant lets + return constant expression\u201d rule, or one or more trivial constant while loops that appear before the final return, each of which has: a condition that is a compile\u2011time boolean literal (true or false), for while false { ... }, a body that is ignored by the constant backend, and for while true { ... }, a body consisting of zero or more constant let statements followed by a break;, with no other control flow; loop invariants (#invariant), variants (#variant), and monovariants (#monovariant) may be present but are treated as metadata and do not affect constant evaluation, then silkcompilerbuild: evaluates the constant integer expression determined by main, emits a tiny native executable image directly using an Silk\u2011owned backend (no C stub, no external C compiler): currently this backend writes a minimal ELF64 executable for linux/x8664 whose entrypoint immediately calls sysexit(value), returns true on success and leaves the last error unset, if the program is front\u2011end valid but outside this subset (for example, main contains non\u2011constant expressions, references to non\u2011constant values, function calls, or unsupported control flow), or if the backend cannot produce an executable for the current platform or output path, the call returns false and typically records either \"code generation is not implemented yet\" or \"failed to build executable output\" as the last error. Executable entrypoint rule For executable builds (kind == SILKOUTPUTEXECUTABLE), the ABI currently enforces a simple entrypoint rule: there MUST be exactly one top\u2011level function with the signature: fn main() -> int { ... } name: main, zero parameters, result type: int. If this condition is not met: silkcompilerbuild returns false, records an error message such as: \"no valid main function for executable output\", or \"multiple main functions for executable output\". This rule is enforced before code generation exists so that embedders and tests can rely on a stable definition of an \u201cexecutable module\u201d. For other SilkOutputKind values (static/shared libraries, object files), no main entrypoint is required by the current front\u2011end. silkcompilerbuildtobytes bool silkcompilerbuildtobytes(SilkCompiler compiler, SilkOutputKind kind, SilkBytes outbytes); Builds the requested artifact as an owned in-memory byte buffer instead of writing to a filesystem path. Behavior and supported subsets match silkcompilerbuild for the same kind (front\u2011end validation is always performed; code generation exists only for documented target/backend subsets). On success: returns true, fills outbytes with (ptr, len) describing the produced artifact, leaves the last error unset. On error: returns false, records an error message retrievable via silkcompilerlasterror, and sets outbytes to { NULL, 0 }. The returned buffer must be freed with: void silkbytesfree(SilkBytes bytes); When bytes->ptr is NULL, silkbytesfree is a no-op. After freeing, it clears the struct to { NULL, 0 }. Error handling silkcompilerlasterror SilkError silkcompilerlasterror(SilkCompiler compiler); Returns a pointer to the last error object produced by operations on compiler, or NULL if no error is recorded. Ownership and lifetime: the pointer is owned by the compiler, it remains valid until: the compiler is destroyed, or a subsequent operation overwrites the last\u2011error state. callers must not attempt to free it. silkerrorformat sizet silkerrorformat(const SilkError error, char buffer, sizet bufferlen); Formats a human\u2011readable error message into the caller\u2011provided buffer. Behavior: writes up to bufferlen - 1 bytes of UTF\u20118 into buffer, always NUL\u2011terminates if bufferlen > 0, returns the number of bytes that would be required to format the full message, excluding the terminating NUL. If the return value is greater than or equal to bufferlen, the message was truncated. Callers can use a two\u2011step pattern: 1. Call with buffer = NULL, bufferlen = 0 to discover the required size. 2. Allocate a buffer of that size plus one and call again to retrieve the full message. Build and link integration Typical integration in a C99 project: 1. Install or vendor: include/silk.h, libsilk.a. 2. Include the header from your C source: #include \"silk.h\" 3. Link against the static library: cc -std=c99 -Wall -Wextra \\ I/path/to/include \\ yourapp.c \\ L/path/to/lib -lsilk \\ lstdc++ -lpthread -lm 4. Create and drive a compiler instance: SilkCompiler compiler = silkcompilercreate(); if (!compiler) { / handle allocation error / } silkcompilersetstdlib(compiler, makestring(\"std\")); silkcompilersettarget(compiler, makestring(\"x8664-linux-gnu\")); silkcompilersetoptimizationlevel(compiler, 2); silkcompileraddsourcebuffer( compiler, makestring(\"main.slk\"), makestring(\"fn main() -> int { return 0; }\")); if (!silkcompilerbuild(compiler, SILKOUTPUTEXECUTABLE, makestring(\"out.exe\"))) { SilkError err = silkcompilerlasterror(compiler); char buf[256]; sizet n = silkerrorformat(err, buf, sizeof buf); / handle error message in buf / } silkcompilerdestroy(compiler); At this stage, successful builds are limited to the backends implemented by the compiler: On linux/x8664, the compiler can emit native ELF64 executables, objects, static libraries, and shared libraries for the current IR subset documented limited string/struct/optional support, and a limited FFI subset). On wasm32-unknown-unknown and wasm32-wasi, executable builds emit .wasm modules for the current IR-backed wasm32 subset documented in modules, and ext imports under env.<name>). On other targets, no code generation backend is available yet. For well\u2011typed programs outside these subsets, silkcompilerbuild fails with E4001 / E4002 diagnostics (or a more specific build error) until the back\u2011end is extended. When Formal Silk verification syntax is present (for example #require, assure, #assert, #invariant, #variant, #monovariant, #const), libsilk runs the Z3-backed Formal Silk verifier and fails the build if verification conditions cannot be proven. The verifier is currently skipped for std::... modules until it covers the full std surface. Environment SILKSTDROOT \u2014 path to the stdlib root directory used to resolve import std::...; declarations when the embedder has not called silkcompilersetstdroot. SILKSTDLIB \u2014 path to a target-specific stdlib static archive (libsilkstd.a). When present, supported executable builds treat auto-loaded std::... modules as external and resolve their exported functions from this archive. SILKZ3LIB \u2014 path to a dynamic Z3 library used by the Formal Silk verifier. When set, it overrides the default vendored Z3 linkage for verification. See Also silk (1) \u2014 Silk language compiler CLI. silkabigetversion (3), silkcompiler (3), silkerror (3), silkbytes (3) silk (7) silk.h \u2014 C99 ABI header in the source tree."
    },
    {
      "id": "man/silk-build.1",
      "title": "`silk-build` (1) \u2014 Build Silk Artifacts",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `silk build`. The roff-formatted manpage should be generated from this content.",
      "text": "silk-build (1) \u2014 Build Silk Artifacts NOTE: This is the Markdown source for the eventual man 1 page for silk build. The roff-formatted manpage should be generated from this content. Name silk-build \u2014 build an executable, object, static library, or shared library from Silk sources and link inputs (or a silk.toml package). Synopsis silk build [options] <input> [<input> ...] -o <output> silk build [options] --package <dir manifest> [--build-script] [--package-target <name> ...] silk build [options] (when ./silk.toml exists, behaves as if --package . was provided) Description silk build compiles a module set and emits an output artifact. You can build: explicit inputs (<input> ...), or a package module set from a manifest (silk.toml) using --package / --pkg. When explicit input files are used (no --package), the silk CLI may load additional packages into the module set by resolving bare-specifier package imports (for example import util from \"util\";) from the package search path (SILKPACKAGEPATH). Input kinds (by extension): .slk \u2014 Silk source file (part of the module set being compiled). .o \u2014 ELF relocatable object file linked into --kind executable shared outputs (and included in --kind static archives). .a \u2014 static archive; its .o members are linked like object inputs (or included in a combined --kind static output). .so \u2014 shared library; treated as a dynamic dependency (equivalent to --needed <soname> using the library\u2019s basename). .c \u2014 C source file; compiled to an object via the host C compiler (see silk-cc (1) / SILKCC) and then treated like a .o input. Package builds: when --package is provided, .slk inputs must be omitted, but non-.slk link inputs (.c, .o, .a, .so) may still be provided. Notes: .o/.a/.c link inputs are currently supported only for linux/x8664 outputs. .so inputs only affect executable/shared outputs (static archives cannot record dynamic dependencies). script-style entrypoints: when building an executable, if the first .slk input contains top-level statements (after the normal package/module header and import block) and does not define an explicit main, silk build synthesizes an implicit fn main() -> int that executes those statements and then returns 0. for --kind executable, --std-lib / --std <path>.a is currently rejected when linking additional .c/.o/.a inputs (std sources are compiled into the build instead). Options help, -h \u2014 show command help and exit. nostd, -nostd \u2014 disable stdlib auto-loading for import std::...;. std-root <path> \u2014 override the stdlib root directory used to resolve import std::...;. std-lib <path> \u2014 select a stdlib archive path for linking hosted builds. std <path> \u2014 alias of --std-root when <path> does not end in .a. std <path>.a \u2014 alias of --std-lib. z3-lib <path> \u2014 override the Z3 dynamic library used for Formal Silk verification (also honors SILKZ3LIB). debug, -g \u2014 enable debug build mode (also enables extra Formal Silk debug output when verification fails). O <0-3> \u2014 set optimization level (default: -O2; when --debug is set and -O is omitted, defaults to -O0). -O1+ prunes unused extern symbols before code generation and prunes unreachable functions in executable builds (typically reducing output size). Output selection: o <path>, --out <path> \u2014 output path. If parent directories do not exist, silk creates them. kind executable object static shared \u2014 output kind. Target selection: arch <arch> \u2014 shorthand target selector (mutually exclusive with --target). target <triple> \u2014 target triple (mutually exclusive with --arch). Linker metadata (executable/shared only): needed <soname> \u2014 add a DTNEEDED entry (repeatable). runpath <path> \u2014 add a DTRUNPATH entry (repeatable). rpath <path> \u2014 alias of --runpath. soname <soname> \u2014 set DTSONAME (shared only). C header emission: c-header <path> \u2014 write a C header declaring exported symbols (valid only for --kind object static shared). Package builds: package <dir manifest>, --pkg <dir manifest> \u2014 load the module set from a silk.toml manifest instead of explicit input files. build-script \u2014 compile and run <packageroot>/build.silk and use its stdout as the manifest. package-target <name> \u2014 select one or more manifest [[target]] entries by name (repeatable; --pkg-target is accepted as an alias). when omitted, silk build --package ... builds every manifest [[target]] entry by default. when building multiple targets, per-output flags are rejected (-o/--out, --kind, --arch, --target, --c-header, --needed, --runpath, --soname). Argument parsing: \u2014 end of options; treat following args as file paths (even if they begin with -). Examples Build an executable from a single file. silk build src/main.slk -o build/app Build an object file (and emit a C header for exported symbols). silk build src/lib.slk --kind object -o build/lib.o --c-header build/lib.h Link an extra C object into a Silk executable. cc -std=c99 -c -o build/extra.o src/extra.c silk build src/main.slk build/extra.o -o build/app Build the current directory as a package (when ./silk.toml exists). silk build Build a specific target from a manifest. silk build --package . --package-target app Environment SILKPACKAGEPATH \u2014 PATH-like list of package root directories used to resolve bare-specifier package imports (entries separated by : on POSIX). SILKCC \u2014 host C compiler used by silk cc (also used when compiling .c inputs passed to silk build). Exit status 0 on success. non-zero on error. See Also silk (1), silk-check (1), silk-test (1)"
    },
    {
      "id": "man/silk-cc.1",
      "title": "`silk-cc` (1) \u2014 C Compiler Wrapper for `libsilk`",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `silk cc`. The roff-formatted manpage should be generated from this content.",
      "text": "silk-cc (1) \u2014 C Compiler Wrapper for libsilk NOTE: This is the Markdown source for the eventual man 1 page for silk cc. The roff-formatted manpage should be generated from this content. Name silk-cc \u2014 run a host C compiler with default include and link flags for libsilk.a. Synopsis silk cc <cc args...> Description silk cc is a convenience wrapper for building C/C++ programs that embed or link against libsilk.a. It selects the underlying compiler via SILKCC (default: cc) and: adds -I <install>/include automatically, unless you pass -c/-E/-S/-M/-MM, also adds -L <install>/lib -lsilk, on linux/x8664, also adds -lstdc++ -lpthread -lm (vendored Z3 is built as C++). Environment SILKCC \u2014 host C compiler executable (default: cc). Examples Build an embedder (assumes silk is installed). silk cc -std=c99 -Wall -Wextra yourapp.c -o yourapp Exit status the exit status of the underlying compiler. See Also silk (1) libsilk (7) include/silk.h"
    },
    {
      "id": "man/silk-check.1",
      "title": "`silk-check` (1) \u2014 Parse and Type-Check",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `silk check`. The roff-formatted manpage should be generated from this content.",
      "text": "silk-check (1) \u2014 Parse and Type-Check NOTE: This is the Markdown source for the eventual man 1 page for silk check. The roff-formatted manpage should be generated from this content. Name silk-check \u2014 parse and type-check a Silk module set. Synopsis silk check [options] <file> [<file> ...] silk check [options] --package <dir manifest> Description silk check parses and type-checks a module set and reports any diagnostics. It does not emit an output artifact. To check a package manifest (silk.toml), pass --package / --pkg and omit explicit input files. When explicit input files are used (no --package), the silk CLI may load additional packages into the module set by resolving bare-specifier package imports (for example import util from \"util\";) from the package search path (SILKPACKAGEPATH). Options help, -h \u2014 show command help and exit. nostd, -nostd \u2014 disable stdlib auto-loading for import std::...;. std-root <path> \u2014 override the stdlib root directory used to resolve import std::...;. std <path> \u2014 alias of --std-root when <path> does not end in .a. std-lib <path> \u2014 accepted for consistency; ignored by check. std <path>.a \u2014 accepted for consistency; ignored by check. z3-lib <path> \u2014 override the Z3 dynamic library used for Formal Silk verification (also honors SILKZ3LIB). debug, -g \u2014 emit Z3 debug output and write .smt2 dumps for failing Formal Silk obligations. package <dir manifest>, --pkg <dir manifest> \u2014 load the module set from a silk.toml manifest instead of explicit input files. \u2014 end of options; treat following args as file paths (even if they begin with -). Examples Check a single-file program. silk check main.slk Check a module set. silk check src/main.slk src/util.slk Check the current directory as a package (explicit). silk check --package . Environment SILKPACKAGEPATH \u2014 PATH-like list of package root directories used to resolve bare-specifier package imports (entries separated by : on POSIX). Exit status 0 on success. non-zero on error. See Also silk (1), silk-build (1)"
    },
    {
      "id": "man/silk-doc.1",
      "title": "`silk-doc` (1) \u2014 Generate Documentation (Markdown or Manpages)",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `silk doc`. The roff-formatted manpage should be generated from this content.",
      "text": "silk-doc (1) \u2014 Generate Documentation (Markdown or Manpages) NOTE: This is the Markdown source for the eventual man 1 page for silk doc. The roff-formatted manpage should be generated from this content. Name silk-doc \u2014 generate documentation from doc comments in Silk sources. Synopsis silk doc [options] <file> [<file> ...] silk doc --man [options] <query> Description silk doc reads Silk sources and renders documentation from Silkdoc comments (/ ... / and /// ...) attached to declarations. It supports two modes: Markdown mode (default): emits Markdown documentation for one or more input files. Manpage mode (--man): renders a single roff man(7) page derived from doc comments and displays or writes it. In Markdown mode, by default silk doc includes exported values and types, plus all struct and interface declarations. Use --all to include non-exported declarations. In manpage mode, the rendered manpage section is derived from doc tags: @cli \u2192 section 1 @misc \u2192 section 7 otherwise API docs \u2192 section 3 Options help, -h \u2014 show command help and exit. o <path>, --out <path> \u2014 write output to <path> (default: stdout). Markdown mode: all \u2014 include non-exported functions, bindings, and methods. \u2014 end of options; treat following args as file paths (even if they begin with -). Manpage mode: man \u2014 render a roff manpage instead of Markdown. package <dir manifest>, --pkg <dir manifest> \u2014 load a module set from a package manifest (silk.toml) rooted at the provided directory (or from the provided manifest path). std-root <path> \u2014 override the stdlib root directory used for resolving std::... queries. Examples Generate docs for a module set. silk doc src/main.slk src/util.slk -o api.md Include non-exported declarations. silk doc --all src/main.slk -o api.md Render a roff manpage for a stdlib module. silk doc --man std::flag -o stdflag.3 Exit status 0 on success. non-zero on error. See Also silk (1) silk-man (1)"
    },
    {
      "id": "man/silk-lsp.1",
      "title": "`silk-lsp` (1) \u2014 Language Server Protocol (LSP) Server",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `silk-lsp`. The roff-formatted manpage should be generated from this content.",
      "text": "silk-lsp (1) \u2014 Language Server Protocol (LSP) Server NOTE: This is the Markdown source for the eventual man 1 page for silk-lsp. The roff-formatted manpage should be generated from this content. Name silk-lsp \u2014 Language Server Protocol server for Silk. Synopsis silk-lsp [--nostd] [--std-root <path>] Description silk-lsp speaks the Language Server Protocol over stdin/stdout for editor integrations. Options nostd \u2014 disable stdlib integration. std-root <path> \u2014 override the stdlib root used for stdlib integration (also respects SILKSTDROOT). Environment SILKSTDROOT \u2014 default stdlib root (used when --std-root is not provided). See Also silk (1)"
    },
    {
      "id": "man/silk-man.1",
      "title": "`silk-man` (1) \u2014 View Manpages Derived from Source Docs",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `silk man`. The roff-formatted manpage should be generated from this content.",
      "text": "silk-man (1) \u2014 View Manpages Derived from Source Docs NOTE: This is the Markdown source for the eventual man 1 page for silk man. The roff-formatted manpage should be generated from this content. Name silk-man \u2014 render and view a temporary manpage for a symbol, module, package, or conceptual topic. Synopsis silk man [options] <query> Description silk man is an interactive documentation viewer. It parses Silk source files and renders a temporary manpage derived from doc comments, then displays it using the user\u2019s pager. silk man recognizes: conceptual pages defined by doc blocks tagged with @misc <label> (intended for man section 7), CLI pages defined by doc blocks tagged with @cli (intended for man section 1), API pages derived from declaration docs (intended for man section 3). Options help, -h \u2014 show command help and exit. package <dir manifest>, --pkg <dir manifest> \u2014 load a module set from a package manifest (silk.toml) rooted at the provided directory (or from the provided manifest path). when omitted, and the query is not std::..., silk man searches the current working directory and its parent directories for silk.toml and uses the nearest match. when no manifest is discoverable, silk man may also resolve the query from the package search path (SILKPACKAGEPATH). std-root <path> \u2014 override the stdlib root directory used for resolving std::... queries. Environment MANPAGER / PAGER \u2014 controls the pager used to display the rendered output (when man -l is unavailable). SILKPACKAGEPATH \u2014 PATH-like list of package root directories used to resolve non-std:: queries when no package manifest is selected or discoverable. Examples View docs for a stdlib module. silk man std::flag View docs for a stdlib symbol. silk man std::sqlite::Database View a conceptual page labeled via @misc. silk man std::result::design Exit status 0 on success. non-zero on error (unknown query, parse errors, or pager failures). See Also silk (1), silk-doc (1)"
    },
    {
      "id": "man/silk-test.1",
      "title": "`silk-test` (1) \u2014 Run Language-Level Tests",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `silk test`. The roff-formatted manpage should be generated from this content.",
      "text": "silk-test (1) \u2014 Run Language-Level Tests NOTE: This is the Markdown source for the eventual man 1 page for silk test. The roff-formatted manpage should be generated from this content. Name silk-test \u2014 discover and run language-level test declarations. Synopsis silk test [options] <file> [<file> ...] silk test [options] --package <dir manifest> silk test [options] (when ./silk.toml exists, behaves as if --package . was provided) Description silk test discovers test declarations in the loaded module set and runs them, emitting TAP version 13 output. When explicit input files are used (no --package), the silk CLI may load additional packages into the module set by resolving bare-specifier package imports (for example import util from \"util\";) from the package search path (SILKPACKAGEPATH). Options help, -h \u2014 show command help and exit. nostd, -nostd \u2014 disable stdlib auto-loading for import std::...;. std-root <path> \u2014 override the stdlib root directory used to resolve import std::...;. std-lib <path> \u2014 select a stdlib archive path for linking hosted builds. std <path> \u2014 alias of --std-root when <path> does not end in .a. std <path>.a \u2014 alias of --std-lib. z3-lib <path> \u2014 override the Z3 dynamic library used for Formal Silk verification (also honors SILKZ3LIB). debug, -g \u2014 enable debug build mode (also enables extra Formal Silk debug output when verification fails). O <0-3> \u2014 set optimization level (default: -O2; when --debug is set and -O is omitted, defaults to -O0). -O1+ prunes unused extern symbols before code generation and prunes unreachable functions in executable builds (typically reducing output size). noheap \u2014 reject heap allocation in the supported subset. filter <pattern> \u2014 run only tests whose display name contains <pattern> (substring match). package <dir manifest>, --pkg <dir manifest> \u2014 load the module set from a silk.toml manifest instead of explicit input files. When <file> ... inputs are omitted and --package / --pkg is also omitted, but ./silk.toml exists, silk test behaves as if --package . was provided. \u2014 end of options; treat following args as file paths (even if they begin with -). Examples Run tests in an explicit module set. silk test src/main.slk src/util.slk Run package tests from the current directory manifest (implicit --package .). silk test Run package tests from the current directory manifest. silk test --package . Run only tests whose name contains \"url\". silk test --package . --filter url Environment SILKPACKAGEPATH \u2014 PATH-like list of package root directories used to resolve bare-specifier package imports (entries separated by : on POSIX). Exit status 0 when all tests pass. non-zero when any test fails or the module set is invalid. See Also silk (1), silk-build (1)"
    },
    {
      "id": "man/silk_abi_get_version.3",
      "title": "`silk_abi_get_version` (3) \u2014 Query the `libsilk` ABI Version",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 3 page for `silk_abi_get_version`. The roff-formatted manpage should be generated from this content.",
      "text": "silkabigetversion (3) \u2014 Query the libsilk ABI Version NOTE: This is the Markdown source for the eventual man 3 page for silkabigetversion. The roff-formatted manpage should be generated from this content. Name silkabigetversion \u2014 query the runtime embedding ABI version of libsilk.a. Synopsis include \"silk.h\" void silkabigetversion(int outmajor, int outminor, int outpatch); Description silkabigetversion reports the semantic version of the libsilk embedding ABI as MAJOR.MINOR.PATCH. Embedders should compare the runtime version returned by this function with the compile-time ABI version macros in include/silk.h: define SILKABIVERSIONMAJOR ... define SILKABIVERSIONMINOR ... define SILKABIVERSIONPATCH ... Parameters outmajor, outminor, outpatch \u2014 output pointers written on success. The current implementation tolerates NULL pointers and skips writing those components. Return value None. See Also libsilk (7)"
    },
    {
      "id": "man/silk_bytes.3",
      "title": "`silk_bytes` (3) \u2014 Manage Owned Build Output Buffers",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 3 page for `SilkBytes` output buffers. The roff-formatted manpage should be generated from this content.",
      "text": "silkbytes (3) \u2014 Manage Owned Build Output Buffers NOTE: This is the Markdown source for the eventual man 3 page for SilkBytes output buffers. The roff-formatted manpage should be generated from this content. Name silkbytes \u2014 manage owned SilkBytes buffers returned by libsilk build APIs. Synopsis include \"silk.h\" typedef struct SilkBytes { uint8t ptr; int64t len; } SilkBytes; bool silkcompilerbuildtobytes(SilkCompiler compiler, SilkOutputKind kind, SilkBytes outbytes); void silkbytesfree(SilkBytes bytes); Description silkcompilerbuildtobytes returns an owned artifact buffer in SilkBytes (for example for sandboxed or filesystem-free embedding scenarios). The buffer memory is owned by libsilk.a and must be released with silkbytesfree. silkbytesfree silkbytesfree frees a buffer returned by silkcompilerbuildtobytes. It is safe to call this with NULL. It is safe to call this with a SilkBytes whose ptr is NULL. After freeing, the buffer contents must not be accessed. See Also silkcompiler (3) libsilk (7)"
    },
    {
      "id": "man/silk_compiler.3",
      "title": "`silk_compiler` (3) \u2014 Embed the Silk Compiler",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 3 page for the `SilkCompiler` embedding API. The roff-formatted manpage should be generated from this content.",
      "text": "silkcompiler (3) \u2014 Embed the Silk Compiler NOTE: This is the Markdown source for the eventual man 3 page for the SilkCompiler embedding API. The roff-formatted manpage should be generated from this content. Name silkcompiler \u2014 C99 embedding API for compiling Silk sources via libsilk.a. Synopsis include \"silk.h\" typedef struct SilkCompiler SilkCompiler; typedef struct SilkModule SilkModule; typedef enum SilkOutputKind SilkOutputKind; SilkCompiler silkcompilercreate(void); void silkcompilerdestroy(SilkCompiler compiler); bool silkcompilersetstdlib(SilkCompiler compiler, SilkString stdlibname); bool silkcompilersetstdroot(SilkCompiler compiler, SilkString stdroot); bool silkcompilersetnostd(SilkCompiler compiler, bool nostd); bool silkcompilersettarget(SilkCompiler compiler, SilkString targettriple); bool silkcompileraddneededlibrary(SilkCompiler compiler, SilkString soname); bool silkcompileraddrunpath(SilkCompiler compiler, SilkString path); bool silkcompilersetsoname(SilkCompiler compiler, SilkString soname); bool silkcompilersetoptimizationlevel(SilkCompiler compiler, int level); SilkModule silkcompileraddsourcebuffer(SilkCompiler compiler, SilkString name, SilkString contents); bool silkcompilerbuild(SilkCompiler compiler, SilkOutputKind kind, SilkString outputpath); bool silkcompilerbuildtobytes(SilkCompiler compiler, SilkOutputKind kind, SilkBytes outbytes); Description The SilkCompiler API embeds the Silk compiler in C or C++ programs. Typical workflow: 1. Create a compiler: silkcompilercreate. 2. Optionally configure it (stdlib selection, target triple, etc). 3. Add one or more source buffers with silkcompileraddsourcebuffer. 4. Build an artifact with silkcompilerbuild (filesystem) or silkcompilerbuildtobytes (in-memory). 5. On error, retrieve diagnostics via silkcompilerlasterror and silkerrorformat (see silkerror (3)). 6. Destroy the compiler with silkcompilerdestroy. Configuration All configuration functions return true on success and false on failure. On failure, the compiler records an error retrievable via silkcompilerlasterror. Stdlib configuration: silkcompilersetstdlib selects the stdlib package name (for example \"std\"). silkcompilersetstdroot selects the filesystem root used to resolve import std::...;. silkcompilersetnostd(true) disables filesystem-based stdlib auto-loading. Target and linkage: silkcompilersettarget selects the code generation target triple. silkcompileraddneededlibrary / silkcompileraddrunpath / silkcompilersetsoname configure dynamic linker metadata for ELF outputs (when applicable). Optimization: silkcompilersetoptimizationlevel accepts an integer level in the range documented by include/silk.h. The default is level 0 unless overridden. In the current implementation, level 1+ enables lowering-time pruning of unused extern symbols before code generation (typically reducing output size and over-linking when using the prebuilt libsilkstd.a archive for auto-loaded import std::...; modules). Sources silkcompileraddsourcebuffer registers a module as an in-memory UTF-8 source buffer. The returned SilkModule is owned by the compiler; embedders must not free it. The name parameter is used for diagnostics and does not need to correspond to an on-disk file path. Building silkcompilerbuild writes an artifact to outputpath. Unlike the CLI, this ABI call does not create parent directories; the output directory must exist. silkcompilerbuildtobytes returns an in-memory artifact via SilkBytes. On success, the caller must free the buffer with silkbytesfree (see silkbytes (3)). Thread safety The SilkCompiler object is not currently specified as thread-safe. Confine it to one thread or synchronize access. See Also silkerror (3), silkbytes (3), silkabigetversion (3) libsilk (7)"
    },
    {
      "id": "man/silk_error.3",
      "title": "`silk_error` (3) \u2014 Retrieve and Format Compiler Errors",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 3 page for `SilkError` formatting and retrieval. The roff-formatted manpage should be generated from this content.",
      "text": "silkerror (3) \u2014 Retrieve and Format Compiler Errors NOTE: This is the Markdown source for the eventual man 3 page for SilkError formatting and retrieval. The roff-formatted manpage should be generated from this content. Name silkerror \u2014 retrieve the last compiler error and format it as text. Synopsis include \"silk.h\" typedef struct SilkCompiler SilkCompiler; typedef struct SilkError SilkError; SilkError silkcompilerlasterror(SilkCompiler compiler); sizet silkerrorformat(const SilkError error, char buffer, sizet bufferlen); Description When a SilkCompiler API call fails, it records a last-error object. Embedders can access it with silkcompilerlasterror and format it with silkerrorformat. Lifetime The SilkError returned by silkcompilerlasterror is owned by the compiler and remains valid until: the compiler is destroyed, or a subsequent operation overwrites the compiler\u2019s last-error state. Embedders must not free or dereference the SilkError object directly. Formatting silkerrorformat writes a UTF-8 diagnostic message into a caller-provided buffer. If bufferlen > 0, the message is always NUL-terminated. The return value is the number of bytes required to format the full message, excluding the terminating NUL. If the return value is >= bufferlen, the message was truncated. See Also silkcompiler (3) libsilk (7)"
    },
    {
      "id": "man/silk.1",
      "title": "`silk` (1) \u2014 Silk Language Compiler",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `silk`. The roff-formatted manpage should be generated from this content.",
      "text": "silk (1) \u2014 Silk Language Compiler NOTE: This is the Markdown source for the eventual man 1 page for silk. The roff-formatted manpage should be generated from this content. Name silk \u2014 compile Silk source code and packages. Synopsis silk [--help -h] [--version] silk <command> [options] [args...] silk help [<command>] silk repl silk check [--nostd] [--std-root <path>] [--z3-lib <path>] [--debug] [--package <dir manifest>] <file> [<file> ...] silk test [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--filter <pattern>] [--package <dir manifest>] <file> [<file> ...] silk build [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--package <dir manifest>] [--build-script] [--package-target <name> ...] <input> [<input> ...] -o <path> [--kind executable object static shared] [--arch <arch>] [--target <triple>] [--c-header <path>] [--needed <soname> ...] [--runpath <path> ...] [--soname <soname>] silk doc [--all] <file> [<file> ...] [-o <path>] silk doc --man [--package <dir manifest>] [--std-root <path>] <query> [-o <path>] silk man <query> silk cc <cc args...> Description silk is the command-line compiler for the Silk language. It reads Silk source files, performs parsing and type checking, and (in the initial implementation) can build simple executable programs for a small, documented subset of the language. As the compiler matures, silk will grow to support full code generation for executables, static libraries, and shared libraries. Convenience entrypoints: slc \u2014 behaves like silk build .... slcc \u2014 behaves like silk cc .... When invoked with no command and stdin is a TTY, silk enters the interactive REPL (equivalent to running silk repl). Diagnostics On error, silk prints a human-readable diagnostic to stderr and exits with a non-zero status. Diagnostics include a stable error code for known error kinds and, when available, a file/line/column location plus a caret snippet highlighting the primary span. When stderr is a TTY, silk may decorate diagnostics with ANSI colors. Set NOCOLOR (or use TERM=dumb) to disable color output. Options For the initial implementation, the supported options are: Global options: help / -h \u2014 show global usage and exit. help \u2014 show global usage and exit. help <command> \u2014 show command-specific usage and exit. version \u2014 show the embedding ABI version (queried via silkabigetversion) and exit. REPL command: silk repl starts an interactive \u201ccompile-and-run\u201d REPL. Currently supported only on linux/x8664 (native ELF backend). Stateful by replay: each successful line is appended to a session program. When you enter runtime lines (statements/expressions), the session is re-executed from the start (so side effects may repeat). Import and declaration lines are validated by compilation only (not executed). Built-in commands: .help \u2014 show help .clear \u2014 reset session state .cls \u2014 clear the screen .undo \u2014 undo the last successful line .exit \u2014 exit the REPL History is loaded/saved to: $SILKREPLHISTORY when set, otherwise $SILKWORKDIR/replhistory (default: .silk/replhistory). Check command: silk check [--nostd] [--std-root <path>] [--z3-lib <path>] [--debug] [--package <dir manifest>] <file> [<file> ...]: help, -h \u2014 show check usage and exit. nostd, -nostd \u2014 disable stdlib auto-loading; import std::...; must be satisfied by explicitly passing source files. std-root <path> (or --std <path> / -std <path> when <path> does not end in .a) \u2014 override the stdlib root directory used to resolve import std::...; and std-root file imports (from \"std/<path>\" / from \"std/<path>.slk\"). std-lib <path> (or --std <path>.a / -std <path>.a) \u2014 select a stdlib archive path for linking auto-loaded std::... modules during builds (ignored by check). z3-lib <path> \u2014 override the Z3 dynamic library used for Formal Silk verification (also honors SILKZ3LIB). debug, -g \u2014 when Formal Silk verification fails, emit Z3 debugging output and write an SMT-LIB2 reproduction script under .silk/z3/ (or $SILKWORKDIR/z3). package <dir manifest> (or --pkg) \u2014 load the module set from a package manifest (silk.toml) instead of explicit input files. When --package is provided, <file> ... inputs must be omitted. \u2014 end of options; treat remaining args as file paths (even if they begin with -). Test command: silk test [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--filter <pattern>] [--package <dir manifest>] <file> [<file> ...]: help, -h \u2014 show test usage and exit. compiles and runs each test, emitting TAP version 13 output, in the current implementation, each test runs in its own process so a failing assert (panic/abort) does not stop the whole suite. O <0-3> \u2014 set optimization level (default: -O2; when --debug is set and -O is omitted, defaults to -O0). -O1+ prunes unused extern symbols before code generation and prunes unreachable functions in executable builds (typically reducing output size). filter <pattern> \u2014 run only tests whose display name contains <pattern> (substring match). package <dir manifest> (or --pkg) \u2014 load the module set from a package manifest (silk.toml) instead of explicit input files. When --package is provided: <file> ... inputs must be omitted. When <file> ... inputs are omitted and --package / --pkg is also omitted, but ./silk.toml exists, silk test behaves as if --package . was provided. z3-lib <path> \u2014 override the Z3 dynamic library used for Formal Silk verification (also honors SILKZ3LIB). \u2014 end of options; treat remaining args as file paths (even if they begin with -). Build command: silk build [--nostd] [--std-root <path>] [--std-lib <path>] [--z3-lib <path>] [--debug] [-O <0-3>] [--noheap] [--package <dir manifest>] [--build-script] [--package-target <name> ...] <input> [<input> ...] -o <path> [--kind executable object static shared] [--arch <arch>] [--target <triple>] [--c-header <path>] [--needed <soname> ...] [--runpath <path> ...] [--soname <soname>]: help, -h \u2014 show build usage and exit. o <path>, --out <path> \u2014 write the generated output to <path>. if the parent directories of <path> do not exist, the compiler creates them (like mkdir -p). package <dir manifest> (or --pkg) \u2014 load the module set from a package manifest (silk.toml) instead of explicit input files. When --package is provided: <file> ... inputs must be omitted. When <file> ... inputs are omitted and --package / --pkg is also omitted, but ./silk.toml exists, silk build behaves as if --package . was provided. package-target <name> \u2014 select one or more manifest [[target]] entries by name (repeatable; --pkg-target is accepted as an alias). when omitted, silk build --package ... builds every manifest [[target]] entry by default. when building multiple targets, per-output flags are rejected (-o/--out, --kind, --arch, --target, --c-header, --needed, --runpath, --soname). \u2014 end of options; treat remaining args as file paths (even if they begin with -). debug, -g \u2014 enable debug build mode (supported subset, linux/x8664): failed assert prints a panic header + optional message + stack trace to stderr (via glibc backtracesymbolsfd) before aborting, and dynamically-linked executables preserve internal function symbols in .dynsym (similar to -rdynamic) for stack trace symbolization. when Formal Silk verification fails, --debug also emits Z3 debugging output and writes an SMT-LIB2 reproduction script under .silk/z3/ (or $SILKWORKDIR/z3). compiled code can query this mode at runtime via std::runtime::build::isdebug(). O <0-3> \u2014 set optimization level (default: -O2; when --debug is set and -O is omitted, defaults to -O0). -O1+ prunes unused extern symbols before code generation and prunes unreachable functions in executable builds (typically reducing output size). noheap \u2014 disable heap allocation for the: heap-backed new (outside a with region) is rejected with E2027, ext bindings to libc heap primitives (malloc/calloc/realloc/free/etc) are rejected with E2027 in non-stdlib modules, std::runtime::mem::{alloc,realloc,free} traps when called without an active with region (no implicit heap fallback), any use of async, task, await, yield, or capturing closures is rejected with E2027, region-backed new inside with is still permitted, noheap is currently incompatible with --debug (debug panic traces require malloc/free). z3-lib <path> \u2014 override the Z3 dynamic library used for Formal Silk verification (also honors SILKZ3LIB). kind <kind> \u2014 select the output kind: executable (default) object (ELF64 relocatable object on linux/x8664) static (static library archive on linux/x8664) shared (shared library on linux/x8664) arch <arch> \u2014 shorthand for selecting a known target: x8664 / amd64 \u2192 linux-x8664, wasm32 \u2192 wasm32-unknown-unknown, wasm32-wasi \u2192 wasm32-wasi, for convenience, --arch also accepts full target triples recognized by --target. target <triple> \u2014 select the compilation target (initial implementation): linux-x8664 (default; emits ELF64 binaries as described below), common x8664--linux- triples such as x8664-linux-gnu are accepted as aliases for linux-x8664, wasm32-unknown-unknown (IR-backed wasm32 mode; emits a .wasm module exporting memory and exported functions, including main when present; ext declarations become imports under env.<name>; also supports export-only modules with no main for JS/Node-style embedding), wasm32-wasi (IR-backed wasm32 WASI mode; emits memory and start () -> void, imports wasisnapshotpreview1.procexit, and calls Silk fn main () -> int; also supports export-only modules for embedding, which do not include start), unknown or unsupported triples currently cause silk build to fail with a \u201ctarget not implemented\u201d error. Note: wasm targets are only supported for --kind executable in the current implementation. arch and --target are mutually exclusive; passing both is an error. c-header <path> \u2014 emit a generated C header declaring the root package\u2019s exported symbols (C ABI consumption): writes prototypes for export fn and extern const declarations for supported export let constants, if the parent directories of <path> do not exist, the compiler creates them (like mkdir -p), only supported for --kind object static shared (rejected for --kind executable), requires the root package (the first input module\u2019s package) to be the global package (omit package ...; in exported library sources). needed <soname> \u2014 add a dynamic loader dependency (emitted as DTNEEDED) for executable and shared outputs; may be repeated. runpath <path>, --rpath <path> \u2014 add a runtime search path element (emitted as DTRUNPATH) for executable and shared outputs; may be repeated (joined with ':'). soname <soname> \u2014 set the shared library soname recorded as DTSONAME for shared outputs (an empty string clears it). nostd, -nostd \u2014 disable stdlib auto-loading; import std::...; must be satisfied by explicitly passing source files. std-root <path> (or --std <path> / -std <path> when <path> does not end in .a) \u2014 override the stdlib root directory used to resolve import std::...;. std-lib <path> (or --std <path>.a / -std <path>.a) \u2014 select a stdlib archive path for linking auto-loaded std::... modules during executable builds. The build currently: runs front-end checks, when multiple input files are provided, performs module-set validation (package/import resolution + multi-module type checking that accounts for imported exported constants and imported export fn calls for the current scalar subset), resolves std::... imports by loading stdlib source files from a configured stdlib root (see Environment below), for --kind executable (the default): when the module set defines a valid Silk entrypoint, enforces the executable entrypoint rule (exactly one main of either fn main() -> int, async fn main() -> int, or fn main(argc: int, argv: u64) -> int), script-style entrypoints: when the first .slk input contains top-level statements (after the normal package/module header and import block) and does not define an explicit main, silk build synthesizes an implicit fn main() -> int that executes those statements and then returns 0, when the module set defines no valid Silk main, requires an object/archive-provided main(argc: int, argv: u64) -> int symbol (for example from a .c/.o/.a input) and emits an entry stub that forwards argc/argv to it, note: for now, --std-lib / --std <path>.a is rejected when linking additional .c/.o/.a inputs into an executable (std sources are compiled into the build instead), on linux/x8664 native executables, when the argc/argv form is used, argv is a raw pointer to the argv pointer list (a C-style char, where argv[0] is at byte offset 0, argv[1] at 8, etc.), for --kind object, --kind static, and --kind shared, main is optional; the current backend emits supported export fn functions and supported exported constants (export let with an explicit type annotation and a literal initializer; currently scalar types and string), plus a valid executable main when present, as global symbols, it is valid for a non-executable output to contain no globally-visible symbols (for example, type-only or interface-only modules); in that case the build still succeeds and produces an \u201cempty\u201d object/archive/shared library, declaration-only exported function prototypes (export fn name(...) -> T;) are accepted as module exports for type-checking, but do not emit code; calls lower as link-time symbol references that must be satisfied by other Silk sources in the module set and/or .c/.o/.a inputs, on linux/x8664, the current backend also supports a limited string subset (SilkString { ptr, len } ABI, string literals + let/return + calls to string-returning helpers + ==/!=/</<=/>/>= comparisons; exported string constants are supported for non-executable outputs), on linux/x8664, the current backend also supports a limited FFI call subset: top-level ext declarations of external functions (ext name = fn (T, ...) -> R;) may be called like normal functions from Silk code, supported for: kind object and --kind static (relocations are emitted against undefined external symbols for downstream linkers), and kind shared (dynamic imports emitted and calls go through the shared object\u2019s GOT; symbols must be available at runtime), kind executable (a dynamically-linked ELF64 executable is emitted and calls go through the executable\u2019s GOT; symbols must be available at runtime), top-level ext declarations of external scalar variables (ext name = T;) may be read like normal values from Silk code: kind object and --kind static (relocations are emitted against undefined external data symbols), and kind shared (dynamic imports emitted and loads go through the shared object\u2019s GOT; symbols must be available at runtime), kind executable (a dynamically-linked ELF64 executable is emitted and loads go through the executable\u2019s GOT; symbols must be available at runtime), writing to ext variables is not supported, for executables and shared libraries, dynamic dependencies can be declared via --needed <soname> (emitted as DTNEEDED) and runtime search paths can be declared via --runpath <path> (emitted as DTRUNPATH); for shared outputs, the library soname can be set via --soname <soname> (emitted as DTSONAME). on linux/x8664 with the glibc dynamic loader (ld-linux), silk automatically adds: libc.so.6 when external symbols are present, libpthread.so.0 when pthread symbols are imported, libsodium.so.23 when libsodium-backed symbols are imported (for example via import std::crypto;), when bundled runtime helpers are imported (for example via import std::{regex,unicode,number};), silk statically links the bundled runtime archive (libsilkrt.a, or libsilkrtnoheap.a when --noheap) into the output, and does not emit a runtime DTNEEDED dependency on libsilkrt, needed entries starting with libsilkrt are rejected; the bundled runtime support layer is always linked from the static archives, additional dependencies must be declared via --needed (or be available in the process global scope at load time, for example via LDPRELOAD), multi-file builds are supported for --kind executable and for --kind object, --kind static, and --kind shared: when multiple packages are present in a module set for a non-executable output, only exports from the root package (the package of the first input module) are emitted as globally-visible symbols; other packages are compiled as dependencies and their export declarations are treated as internal for that output, attempts to emit a native executable using: a constant-expression backend for a small, fully constant subset of main bodies on platforms that support the minimal ELF64 stub, and when --kind object, --kind static, or --kind shared is selected, the build attempts the IR\u2192ELF backend on linux/x8664 for the same subset and emits E4001 / E4002 diagnostics for programs outside that subset, the constant subset consists of: a single fn main() -> int with: zero or more let statements with constant integer initializers followed by exactly one return of a constant integer expression (literals, +, -, , /, %, and references to constant let bindings), or the same, with a final if whose condition is a compile-time boolean literal (true / false) and whose branches each satisfy the \u201cconstant lets + return constant expression\u201d rule, and optionally, one or more trivial constant while loops before the final return, with constant boolean conditions and bodies of constant let bindings followed by break;, with verification directives treated as metadata, on linux/x8664, the IR\u2192ELF backend supports a broader subset in which: fn main() -> int and helper functions: use only scalar parameters (defaulting to int when unannotated) drawn from int, bool, char, f32, f64, Instant, Duration, and the fixed-width integer types (u8/i8 \u2026 u64/i64); helper functions return a scalar from the same set (while main remains -> int), or void (omitted result type or explicit -> void) when used only as standalone statements (return; and implicit fallthrough returns are supported for void helpers), helpers may also accept and return string values at ABI boundaries (represented as { ptr: u64, len: i64 } / SilkString; results return via rax/rdx), use integer arithmetic (including unary -x), bitwise operators (including unary ~x), and comparisons, plus floating-point arithmetic/comparisons over f32/f64 (including unary -x), use char literals (UTF-8 or escaped) and == / != comparisons over char values, use bool as a surface type (lowered to integer 0/1 in IR), use structured control flow (if / else, while, break;, continue;) with conditions built from boolean literals, comparisons, calls to bool-returning helpers, logical operators ! / && / (with && / short-circuiting), and boolean locals, use boolean expressions in let initializers and bool return statements, including short-circuit && / (for example let flag: bool = a && b;), allow call expressions as standalone statements (discarding the returned value), allow assignment and compound assignment to let mut locals by name (x = expr;, x += y;); = is supported for all currently supported value types (including string, the supported struct subset, and optionals of those), and compound assignments are supported only for numeric scalar locals, for a limited subset of structs (slot-flattened structs with 0+ fields of supported value types), supports struct declarations, struct literals (Type{ field: expr, ... }, including partial initialization), field access (value.field, including nested access), == / != comparisons (deep/slot-wise), and passing/returning such structs by value using the System V AMD64 convention (one ABI \u201ceightbyte\u201d per slot). For non-executable outputs, exported functions accept only ABI-safe structs whose flattened scalar slots are restricted to i64/u64/f64; downstream C callers should declare separate parameters for 3+ slot structs, and, for helpers, use direct calls between functions that fit this subset, following the System V AMD64 scalar calling convention (rdi..r9 for integer-like args, xmm0..xmm7 for f32/f64, stack spill for remaining args, and rax/xmm0 results), and main may either be a single structured function or call such helpers; the compiler lowers these programs into an IR program and compiles them to a single ELF64 executable, when multiple input files are provided, helper calls may target: functions defined in the same package across modules, and imported exported functions (export fn) from any packages imported by the module that contains main (both foo() and pkg::foo() call forms are accepted initially), examples known to be supported and tested include: straight-line integer programs such as fn main() -> int { return 1 + 2 3; }, programs with local and top-level integer let bindings in the final return, programs that branch on comparison conditions evaluated at runtime, small loops using while with break; / continue;, helper-call programs equivalent to: fn helper (x, y) -> int { if x < y { let one: int = 1; return x + one; } else { let two: int = 2; return y + two; } } fn main () -> int { return helper(1, 3); } helpers with many integer parameters (exercising both register and stack-passed arguments), and programs that use boolean locals in conditions, such as: fn main () -> int { let x: int = 1; let y: int = 2; let flag: bool = x < y; if flag { return 3; } else { return 4; } } for programs that type-check but are outside both the constant subset and the current IR-based subset, silk build exits non-zero with E4001 / E4002 diagnostics describing the backend limitation. Doc command: Markdown mode: silk doc [--all] <file> [<file> ...] [-o <path>]: Generates Markdown documentation from Silkdoc comments (/ ... / and /// ...) attached to declarations. By default, includes exported fn/let/ext declarations and exported impl methods, plus all struct and interface declarations in the input modules. help, -h \u2014 show doc usage and exit. all includes non-exported functions, bindings, and methods. o <path>, --out <path> writes the Markdown output to <path>; when omitted, output is written to stdout. \u2014 end of options; treat remaining args as file paths (even if they begin with -). Manpage mode: silk doc --man [--package <dir manifest>] [--std-root <path>] <query> [-o <path>]: Renders a single roff man(7) page to stdout (or to -o / --out when provided). The manpage kind is derived from documentation tags (@cli \u2192 section 1, @misc \u2192 section 7, otherwise section 3 for API pages). C compiler wrapper: silk cc <cc args...>: runs a host C compiler to build programs that embed or link against libsilk.a, selects the compiler executable via SILKCC (when set), otherwise falls back to cc, automatically adds include and library search paths adjacent to the installed silk binary (for example ../include and ../lib), plus -lsilk, on linux/x8664, also adds -lstdc++ -lpthread -lm (vendored Z3 is built as C++), passes through additional arguments verbatim to the underlying compiler (files, flags, -o, -I, -L, etc.); use silk help cc for wrapper usage. Environment SILKSTDROOT \u2014 path to the stdlib root directory used to resolve import std::...; declarations when --std/--std-root is not provided. When neither is set (and --nostd is not set), silk searches for: a std/ directory in the current working directory (development default), otherwise ../share/silk/std relative to the silk executable (installed default). SILKWORKDIR \u2014 base directory for compiler-generated scratch/debug artifacts (defaults to .silk). For example, Formal Silk Z3 dumps are written under $SILKWORKDIR/z3 and silk man may write temporary roff output under $SILKWORKDIR/man. SILKSTDLIB \u2014 path to a target-specific stdlib static archive (libsilkstd.a). When present, supported executable builds treat auto-loaded std::... modules as external and resolve their exported functions from this archive. SILKPACKAGEPATH \u2014 PATH-like list of package root directories used to resolve bare-specifier package imports (non-std::) in file-list workflows (when --package is not used). Entries are separated by : (POSIX). A package like myapi::core maps to the candidate manifest <root>/myapi/core/silk.toml (where :: maps to /). When SILKPACKAGEPATH is not set, silk also checks ./packages when it exists (development convenience). SILKZ3LIB \u2014 path to a dynamic Z3 library used by the Formal Silk verifier. When --z3-lib is not provided, the verifier will use this value when set. SILKCC \u2014 the host C compiler executable used by silk cc (defaults to cc when unset). See Also silk-build (1), silk-check (1), silk-test (1), silk-doc (1), silk-man (1), silk-cc (1), silk-lsp (1) silk (7) libsilk (7)"
    },
    {
      "id": "man/silk.7",
      "title": "`silk` (7) \u2014 Silk Toolchain Overview",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 7 page for Silk. The roff-formatted manpage should be generated from this content.",
      "text": "silk (7) \u2014 Silk Toolchain Overview NOTE: This is the Markdown source for the eventual man 7 page for Silk. The roff-formatted manpage should be generated from this content. Name silk \u2014 overview of the Silk language toolchain, documentation, and conventions. Description Silk is a native compiler toolchain with: a CLI entrypoint (silk (1)), an embedding API (libsilk (7) and the silk functions documented in section 3), Current Backend Subset The compiler currently supports full parsing and type checking, but code generation is implemented only for a subset of the language. When a program type-checks but uses a construct outside this subset, builds fail with E4001 diagnostics that point at the rejected construct and name its kind. The supported subset is documented in: silk (1) (see the build command and its notes), Source Layout Silk source files use the .slk extension. The default stdlib implementation is a directory tree rooted at std/ and is imported via import std::...;. Standard Library The std:: package namespace is the primary stdlib surface. The compiler can auto-load std::... modules from a configured stdlib root, and hosted builds may link a prebuilt stdlib archive. See: Formal Silk Formal Silk verification is an optional part of the toolchain. The verifier uses Z3 and can be configured via CLI flags or environment variables. See: See Also silk (1) silk-build (1), silk-check (1), silk-test (1), silk-doc (1), silk-man (1), silk-cc (1) silkcompiler (3), silkerror (3), silkbytes (3), silkabigetversion (3) libsilk (7)"
    },
    {
      "id": "man/slc.1",
      "title": "`slc` (1) \u2014 Alias of `silk build`",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `slc`. The roff-formatted manpage should be generated from this content.",
      "text": "slc (1) \u2014 Alias of silk build NOTE: This is the Markdown source for the eventual man 1 page for slc. The roff-formatted manpage should be generated from this content. Name slc \u2014 convenience entrypoint for silk build. Synopsis slc [options] <file> [<file> ...] -o <output> slc [options] --package <dir manifest> [--build-script] [--package-target <name> ...] Description slc is an argv0-based alias of silk build. It behaves the same as running: silk build <args...> See silk-build (1) for full documentation of options, arguments, and behavior. See Also silk (1), silk-build (1)"
    },
    {
      "id": "man/slcc.1",
      "title": "`slcc` (1) \u2014 Alias of `silk cc`",
      "section": "man",
      "summary": "> NOTE: This is the Markdown source for the eventual man 1 page for `slcc`. The roff-formatted manpage should be generated from this content.",
      "text": "slcc (1) \u2014 Alias of silk cc NOTE: This is the Markdown source for the eventual man 1 page for slcc. The roff-formatted manpage should be generated from this content. Name slcc \u2014 convenience entrypoint for silk cc. Synopsis slcc <cc args...> Description slcc is an argv0-based alias of silk cc. It behaves the same as running: silk cc <cc args...> See silk-cc (1) for details, including the default -I/-L/-lsilk flags. See Also silk (1), silk-cc (1)"
    },
    {
      "id": "spec/2026",
      "title": "Silk Specification (2026)",
      "section": "spec",
      "summary": "This is the single-file edition of the Silk language specification for 2026.",
      "text": "Silk Specification (2026) This is the single-file edition of the Silk language specification for 2026. Language Cheat Sheet This document summarizes the key syntax and concepts from the Silk language in a condensed form. It is meant as a quick reference; detailed semantics live in the other this specification files. Types (Surface Forms) Booleans: bool \u2014 true, false. Integers: u8, i8, u16, i16, u32, i32, u64, i64, int. Floats: f32, f64. Char: char. String: string. Time: Instant, Duration. Optional: T? (sugar for Option(T)). References: &T. Arrays / slices: T[], T[N]. Maps / dictionaries: std::map::{HashMap, TreeMap} (standard library). Function types: fn(params) -> R (discipline modifiers apply to function declarations; function types are unmodified in Silk). Function expressions (non-capturing, inferred pure): expression body: fn (x: int, y: int) -> x + y block body: fn (x: int, y: int) -> int { return x + y; } capturing closures are supported as a subset; see Types. Structs / enums / interfaces: struct Name { ... }, struct Name extends Base { ... } enum Name { ... } interface Name { ... }, interface Name extends Base { ... } Literals Integers: 0, 42, with base/suffixes as per the spec. Floats: 3.14, 1.0e-9. Booleans: true, false. Chars: 'A', escape sequences. Strings: single-line: \"hello\", multi-line: multi-line quoted forms. Durations: numeric + unit, e.g. 10ms, 2s, 5min. Aggregates: arrays: [1, 2, 3], structs: Point { x: 1, y: 2 }. Operators Arithmetic: +, -, , /, %. Bitwise: &, , ^, ~, <<, >>. Comparison: ==, !=, <, <=, >, >=. Logical: !, &&, . Assignment: =, +=, -=, =, /=. Increment/decrement: ++, -- (statement-like void). Optional / nullability: optional chaining: ?., coalescing: ??. Member/scope: ., ::. Ranges: .., ..=, .... Other punctuation: ,, ;, :, ->, =>. Operator precedence and associativity follow the rules in Operators. Flow Control if cond { ... } else { ... } (statement form) let v = if cond { a } else { b }; (if expression) loop { ... } (infinite loop; exits via break/return). while (cond) { ... } for pattern in iterable { ... } (ranges, builtin arrays/slices). for (init; cond; step) { ... } (C-style loop header). async loop { ... } / task loop { ... } (loop forms in async context). match value { ... } \u2014 pattern matching. return expr; assert expr; or assert(expr, \"message\"); break; continue; Blocks: { stmt }. Expression statements: expr; (where allowed). See the relevant chapters of this specification for details. Executable entrypoint (initial rule): A minimal executable module defines exactly one top-level function: fn main() -> int { return 0; } This main function takes no parameters and returns int. The front-end enforces this shape for executable builds before code generation. Optionals & Mutability Declare optionals: let x: T? = None; or let x: Option(T) = None;. Create values: None, Some(value). Use: user.profile?.email \u2014 optional chaining. email ?? \"default@example.com\" \u2014 coalescing. Mutability: Parameters and references are immutable by default. Grant mutation via mut: in function definition: fn reset(mut r: &Runner) { ... }, at call site (syntax per spec). Structs, Impl Blocks, Interfaces Structs: struct Packet { seq: u32, size: u16, flag: u8 } pure data, well-defined layout. Impl blocks: impl Packet { fn sizebits(self: &Packet) -> u32 { ... } } Interfaces: interface Element { fn onclick(event: &Event) -> void; } impl Button as Element { fn onclick(self: &Button, event: &Event) -> void { ... } } See Structs, Impl Blocks, and Memory Layout and Interfaces for details. Regions & Buffers Regions (fixed-size allocation context): declare: const region arena: u8[1024]; use: with arena { let p: &Packet = new Packet{ ... }; } anonymous: with 1024 { let p: &Packet = new Packet{ ... }; } Buffers: intrinsic Buffer(T) with (ptr, capacity), unsafe primitive underpinning higher-level collections. Allocation: new uses the active region inside with (see Regions). Concurrency Function modifiers: fn \u2014 normal. async fn \u2014 await-able; calling yields Promise(T). task fn \u2014 runs in parallel on a worker thread; calling yields Task(T). async task fn \u2014 async + task; calling yields Promise(Task(T)). Structured block: async fn getdashboarddata() -> Dashboard { // Note: the scheduler-backed async { ... } semantics are still design work, // but the compiler implements Task(T)/Promise(T) handles, yield, and await. let mut user: User; let mut orders: Order[]; async { let userpromise = fetchuserprofile(123); let orderspromise = fetchrecentorders(123); user = await userpromise; orders = await orderspromise; } return Dashboard(user, orders); } To receive task values, use yield inside a task context (task { ... } or task fn): task fn worker () -> int { return 42; } async fn main () -> int { let h = worker(); task { let value: int = yield h; return value; } } See Concurrency for deeper semantics. Formal Silk #const \u2014 formal Silk declarations used inside specifications (not available at runtime). #require \u2014 preconditions. #assure \u2014 postconditions. #assert \u2014 block-local proof obligations. #invariant \u2014 invariants. #variant \u2014 termination measures. #monovariant \u2014 monotonic measures. theory / #theory \u2014 reusable proof obligations. require / #assure appear before functions; #invariant / #variant / #monovariant appear before loops; #const and #assert appear inside blocks. See Formal Silk. External Declarations & ABI (Quick View) Declare external bindings: ext foo = fn (string) -> void; ext bar = u32; Strings: Silk string is internally { ptr, len }, C side uses SilkString { char ptr; int64t len; } for embedding, ext calls to typical C APIs may pass const char derived from string where appropriate. See External Declarations (ext) and C99 ABI and libsilk.a` for full details. Silk Syntax Tour (Soup to Nuts) This document is an example-driven tour of Silk\u2019s surface syntax, from a single-file \u201chello world\u201d through modules/packages, declarations, statements, expressions, and the Formal Silk verification directives. This guide complements (not replaces): Formal Grammar Spec (the exact grammar the parser accepts), the concept documents under this specification (semantics and checker rules), the implementation status (what works end-to-end today), and Compiler Diagnostics (error codes for unsupported forms). 0. Minimal Executable Module The smallest executable is a module with a main function: fn main () -> int { return 0; } Notes: Most statements end with ;. Blocks are { stmt }. The entrypoint for an executable build is main returning int (see silk CLI for the CLI rules and supported targets). 1. Lexical Basics Whitespace and comments Whitespace (spaces, tabs, newlines) is generally allowed between tokens. Comments: // Line comment / Block comment (non-nesting) / Doc comments (tooling-only; see Silkdoc (Documentation Comments)): /// Line doc comment / Block doc comment @example silk fn main -> int { return 0; } / fn main () -> int { return 0; } Identifiers and qualified names Names are often qualified with ::: package myapp::core; import std::strings; fn main () -> int { let s: string = std::strings::trim(\" hi \"); return 0; } Formal Silk directive tokens (#...) Formal Silk directives like #require and #invariant are not comments. They are real tokens and are parsed as part of the language (see Formal Silk). require x >= 0; assure result == x + 1; fn inc (x: int) -> int { return x + 1; } 2. Source File Structure: package/module, import, then declarations Top-level ordering is enforced (see Packages, Imports, and Exports): 1. Optional package ...; or module ...; 2. Zero or more import ...; declarations as a contiguous block 3. All other top-level declarations (fn, let, struct, enum, impl, \u2026) package // app/main.slk package app; fn main () -> int { return 0; } module (compile-time-only module values) // crypto/sha256.slk module crypto::sha256; Modules can declare interface conformance (design surface is implemented): // drivers/uart.slk module drivers::uart as Device; 3. Imports and Exports See Packages, Imports, and Exports for the full import/export model. Package imports package app; import std::strings; fn main () -> int { let s: string = trim(\" hi \"); // may be visible unqualified in the let t: string = std::strings::trim(\" hi \"); return 0; } File imports (from \"...\") Named import: // main.slk import { answer as theanswer } from \"./util.slk\"; fn main () -> int { return theanswer; } Default import (binds a default export if present, otherwise a namespace): // module.slk export default fn () -> int { return 3; } // main.slk import foo from \"./module.slk\"; fn main () -> int { return foo(); } Named exports and re-exports Export a declaration directly: // util.slk export let answer: int = 42; export fn add1 (x: int) -> int { return x + 1; } Re-export an in-scope name: // api.slk import { answer } from \"./util.slk\"; export { answer as theanswer }; 4. Top-Level Declarations (Overview + Examples) This section shows the core top-level declaration forms: bindings: const, let, var functions: fn (plus pure/async/task) type aliases: type types: struct, enum, interface, impl, error external declarations: ext tests: test Formal Silk: theory (and #... directives) 4.1 Bindings: const, let, let mut, var Example (requires initializers; see E2015): fn main () -> int { const answer: int = 42; let x: int = answer; let mut y: int = 0; var z: int = 1; // var is an alias for let mut y = y + 1; z += 2; return x + y + z; } Notes: const initializers must be compile-time evaluable in Silk (see E2041). Only let mut/var bindings are assignable lvalues (see Mutability and Operators). Destructuring let bindings are supported for struct values: struct User { id: u64, name: string } let (id, name) = User{ id: 123, name: \"alice\" }; struct Record { id: u64, data: string } let { data as d, id as i } = Record{ id: 456, data: \"other\" }; Array destructuring is also supported: let records: Record[] = [{ id: 123, data: \"a\" }, { id: 456, data: \"b\" }]; let [a, b] = records; 4.2 Functions: fn (plus pure, async, task) Basic function declaration: fn add (x: int, y: int) -> int { return x + y; } pure fn (restricted subset; see Function Disciplines (pure, task, async)): pure fn inc (x: int) -> int { return x + 1; } async fn / task fn / async task fn (handles; see Concurrency): task fn worker () -> int { return 7; } async fn main () -> int { task { let t = worker(); // Task(int) let value: int = yield t; return value; } } Parameters: mut, defaults, and varargs Mutable reference parameters require mut both in the signature and at the call site (see Mutability): struct Pair { a: int, b: int } fn bumpa (mut p: &Pair) -> void { p.a += 1; } fn main () -> int { let mut p: Pair = Pair{ a: 1, b: 2 }; bumpa(mut p); return p.a; } Default arguments (restricts default expressions to a constant/literal subset): fn add2 (x: int, y: int = 2) -> int { return x + y; } Varargs (final parameter prefixed by ...; see Varargs (Variable Arguments)): fn log (fmt: string, ...args: std::fmt::Arg) -> void { std::io::println(fmt, args); } Generic function parameter split (;) (Design, parsed but rejected) Generic functions use ; to separate compile-time parameters from value parameters: // Design (currently rejected with E2016). fn getfirst(T, N: int; xs: &T[N]) -> T { return xs[0]; } 4.3 Function expressions (lambdas) Example (non-capturing expression body): fn main () -> int { let add = fn (x: int, y: int) -> x + y; return add(1, 2); } Example (block body with explicit return type): fn main () -> int { let add = fn (x: int, y: int) -> int { return x + y; }; return add(1, 2); } Capturing closures are supported as a restricted subset; see Types and Memory Model (Stack, Heap, and Moves). 4.4 Type aliases: type Basic alias: type I = int; Optional kind tags (validated by the checker; see Types): type struct UserId = int; type fn IntAdder = fn(int, int) -> int; type pure fn PureIntAdder = fn(int, int) -> int; 4.5 Structs: struct and impl Struct declarations (fields use name: Type, optional default with =): struct Point { x: int = 0, y: int = 0, } Struct literals: fn main () -> int { let p1: Point = Point{ x: 1, y: 2 }; let x = p1.x; // Shorthand field init (x means x: x): let y: int = 3; let p2: Point = Point{ x, y }; return x + p2.y; } Inferred struct literals require an expected struct type context: fn main () -> int { let p: Point = { x: 1, y: 2 }; return p.x + p.y; } Heap allocation (new) produces a &Struct reference in Silk: struct Boxed { value: int } fn main () -> int { let b: &Boxed = new Boxed{ value: 7 }; return b.value; } Attach methods with impl (see Structs, Impl Blocks, and Memory Layout): impl Point { public fn sum (self: &Point) -> int { return self.x + self.y; } } fn main () -> int { let p: Point = Point{ x: 1, y: 2 }; return p.sum(); } Single inheritance (current surface is implemented; see Structs, Impl Blocks, and Memory Layout): // Design shape (field/layout rules and limits are documented). struct Base { x: int = 0 } struct Derived extends Base { y: int = 0 } 4.6 Enums: enum + match expression enum Color { Red, Rgb(u8, u8, u8), } fn toint (c: Color) -> int { return match c { Color::Red => 0, Color::Rgb(r, g, b) => (r as int) + (g as int) + (b as int), }; } See enum Types and match Expression. 4.7 Interfaces and impl ... as ... interface Counter { fn inc() -> void; fn get() -> int; } struct Cell { value: int = 0 } impl Cell as Counter { fn inc (mut self: &Cell) -> void { self.value += 1; } fn get (self: &Cell) -> int { return self.value; } } See Interfaces. 4.8 Typed errors: error, panic, T ErrorType..., match statement, ? Error type declaration: error OutOfBounds { index: int, len: int } Error-producing signatures use : fn getat (xs: &u8[], index: int) -> u8 OutOfBounds { if index < 0 index >= std::length(xs) { panic OutOfBounds { index: index, len: std::length(xs) }; } return xs[index]; } Handling typed errors uses the match statement form: fn main () -> int { match (getat([1, 2, 3], 10)) { value => { return value as int; }, err: OutOfBounds => { std::abort(); } } } Propagating errors from calls uses postfix ?: // Example when main declares a compatible error set. fn main () -> int OutOfBounds { let x: u8 = getat([1, 2, 3], 0)?; return x as int; } See Typed Errors (error, panic, and T ErrorType...). 4.9 External declarations: ext External function binding (symbol name optional; see External Declarations (ext)): export ext puts = fn(string) -> int; export ext cabort \"abort\" = fn() -> void; export ext errno \"errno\" = int; Note: C variadics (printf-style ...) via ext are not implemented yet; see Varargs (Variable Arguments) and External Declarations (ext). See also: C99 ABI and libsilk.a (C ABI) and include/silk.h. 4.10 Tests: test test \"addition works\" { if (1 + 2) != 3 { std::abort(); } } See Testing and run with silk test. 4.11 Formal Silk theories: theory Top-level theory (exportable/importable): export theory nonzero (x: int) { #require x != 0; } Apply a theory inside a function: import { nonzero } from \"./theories.slk\"; fn main () -> int { let x: int = 1; #theory nonzero(x); return 0; } Inline (block-local) theories use the same #theory token and are disambiguated from theory use by { ... } (inline declaration) vs ; (use): fn main (x: int, y: int) -> int { #theory localsumnonzero (x: int, y: int) { #const z = x + y; #assure z != 0; } #theory localsumnonzero(x, y); return 0; } See Formal Silk. 5. Types (Surface Forms) See Types for full details and implementation limits. Primitive types bool, i8/u8, i16/u16, i32/u32, i64/u64, int, f32/f64, char, string, void, Instant, Duration Optional types fn main () -> int { let a: int? = None; let b: int? = Some(7); let c: int = b ?? 0; return c; } Nested optionals use ?? in type position (T?? means \u201coptional of optional\u201d): fn main () -> int { let x: int?? = Some(Some(1)); let y: int? = x ?? None; return (y ?? 0); } Optional match expressions are the explicit form of optional consumption: fn main () -> int { let x: int? = Some(7); let y: int = match x { None => 0, Some(v) => v, }; return y; } References fn sum (p: &Point) -> int { return p.x + p.y; } Arrays and slices fn main () -> int { let xs: int[] = [1, 2, 3]; return xs[0]; } Fixed-length arrays use T[N]: fn main () -> int { let xs: int[3] = [1, 2, 3]; return xs[2]; } Function types type IntBinOp = fn(int, int) -> int; fn main () -> int { let add: IntBinOp = fn (x: int, y: int) -> x + y; return add(1, 2); } Applied types and generics Generic parameter lists on struct/interface/impl are implemented: struct Box(T) { value: T } fn main () -> int { let b: Box(int) = { value: 1 }; return b.value; } See Generics (Monomorphized) for limits (notably E2016 for const parameters/arguments and generic functions). 6. Statements (Inside Blocks) The statement grammar is summarized in Formal Grammar Spec and detailed in the relevant chapters of this specification. if / else fn main () -> int { let x: int = 1; if x == 0 { return 0; } else { return 1; } } loop, while, for fn main () -> int { let mut i: int = 0; while i < 3 { i += 1; } return i; } for over a range form (special-cased surface; see for Loop): fn main () -> int { let mut sum: int = 0; for i in 0 .. 5 { sum += i; } return sum; } C-style for header: fn main () -> int { let mut sum: int = 0; for (let mut i: int = 0; i < 5; i += 1) { sum += i; } return sum; } break, continue, return fn main () -> int { let mut i: int = 0; loop { i += 1; if i < 3 { continue; } break; } return i; } assert and panic fn main () -> int { assert 1 + 2 == 3; assert(2 + 2 == 4, \"math is broken\"); return 0; } panic is used for typed errors (see Typed Errors (error, panic, and T ErrorType...)): panic OutOfBounds { index: 1, len: 0 }; match statement (typed errors) See Typed Errors (error, panic, and T ErrorType...) for the Terminal Arm Rule and the supported pattern forms. async { ... } and task { ... } Structured blocks (implemented as lexical blocks in Silk; see Concurrency): async fn main () -> int { async { // async region } task { // task region } return 0; } Concurrency operators: await, await , yield, yield await unwraps Promise(T) values inside async fn: async fn add2 (x: int) -> int { return x + 2; } async fn main () -> int { let p = add2(1); // Promise(int) let v: int = await p; return v; } await awaits a collection of promises and yields a collected T[]: async fn add1 (x: int) -> int { return x + 1; } async fn main () -> int { let values: int[] = await [add1(1), add1(2), add1(3)]; return values[0] + values[1] + values[2]; } yield / yield interact with Task(T) values (used inside task regions in the): task fn producer (n: int) -> int { var i: int = 0; while i < n { yield i; i += 1; } return n; } async fn main () -> int { task { let t = producer(2); // Task(int) let values: int[] = yield t; return values[0] + values[1] + values[2]; } } 7. Expressions (Precedence + Demonstrations) Silk expressions follow a conventional precedence hierarchy. For the exact productions, see Formal Grammar Spec. Literals and other primary expressions See the the relevant chapters of this specification concept documents for precise rules. fn main () -> int { // Booleans. let b: bool = true; // Integers and floats. let i: int = 42; let u: u8 = 0xFF; let f: f64 = 3.14; // Characters and strings. let ch: char = 'A'; let s1: string = \"hello\"; let s2: string = raw \\n no escapes; // Durations. let d: Duration = 10ms; // Optionals. let opt: int? = Some(i); let x: int = opt ?? 0; // Arrays. let xs: int[] = [1, 2, 3]; assert b; assert x == 42; assert xs[0] == 1; assert u == 0xFF; assert s1 == \"hello\"; assert s2 == raw \\n no escapes; assert ch == 'A'; assert (f as int) == 3; assert (d as int) == (d as int); // d exists to demonstrate duration literal syntax. See Duration Literals. return 0; } Postfix forms: calls, fields, indexing, casts, ?, ++/-- struct Point { x: int, y: int } fn main () -> int { let xs: int[] = [10, 20, 30]; let a: int = xs[0]; let b: int = (a + 1) as int; let c: int = Point{ x: 1, y: 2 }.x; return b + c; } as and as raw as performs explicit numeric/shape casts and as raw performs raw bit casts for scalar types (see Operators). fn main () -> int { let bits: u64 = (1.0 as f32) as raw u64; let f: f32 = bits as raw f32; return f as int; } Unary forms: !, ~, -, new, await, yield, mut, ++/-- fn main () -> int { let mut x: int = 0; ++x; x++; if !(x == 2) { return 1; } return 0; } mut <expr> is permitted only where a mutable borrow is required (most commonly, in call arguments and method receivers): struct Pair { a: int, b: int } fn bump (mut p: &Pair) -> void { p.a += 1; } fn main () -> int { let mut p: Pair = Pair{ a: 0, b: 0 }; bump(mut p); return p.a; } Arithmetic, bitwise, comparisons, and boolean operators fn main () -> int { let a: int = 1 + 2 3; let b: int = (a << 1) 1; if (b >= 0) && (b != 0) { return b; } return 0; } Optional operators: ?. and ?? struct User { email: string } fn main () -> int { let user: User? = Some(User{ email: \"a@b.c\" }); let email: string = user?.email ?? \"unknown\"; if email == \"a@b.c\" { return 0; } return 1; } Typed error propagation: postfix ? on calls fn main () -> int OutOfBounds { let x: u8 = getat([1, 2, 3], 0)?; return x as int; } 8. Formal Silk (Verification) Syntax Formal Silk is Silk\u2019s compile-time verification surface (Z3-backed). It uses directive tokens that attach to functions and loops: function contracts: #require, #assure, #theory loop contracts: #invariant, #variant, #monovariant formal Silk declarations: #const block-local proof obligations: #assert reusable proof bundles: theory / #theory See Formal Silk for the exact verifier model and current restrictions. Contracts on functions require x >= 0; assure result == x + 1; fn inc (x: int) -> int { return x + 1; } Loop invariants, variants, and monovariants fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; #monovariant i; while i < limit { i += 1; } return 0; } Theories (theory / #theory) export theory addcommutes (x: int, y: int) { #assure (x + y) == (y + x); } theory addcommutes(x, y); fn add (x: int, y: int) -> int { return x + y; } 9. Next References If you want more detail on a specific construct, jump to: Syntax: Formal Grammar Spec Types: Types, Generics (Monomorphized) Operators: Operators Flow control: Flow Control Overview and the relevant chapters of this specification Modules/imports/exports: Packages, Imports, and Exports Optionals: Optional Typed errors: Typed Errors (error, panic, and T ErrorType...) Concurrency: Concurrency Formal verification: Formal Silk Formal Grammar Spec This document contains the formal grammar and lexical specification for Silk as used by the compiler implementation. Lexical Structure (Overview) The lexer operates over: Whitespace and comments (trivia): spaces, tabs, newlines; line comments starting with // and continuing to the end of the line; doc line comments start with /// and follow the same lexical rules; block comments starting with / and ending with the next / (non\u2011nesting); doc block comments start with / and also end at the next /. Both doc-comment forms are still trivia for the parser (they do not affect the syntax tree), but tooling may preserve and parse their text for documentation generation as specified in Silkdoc (Documentation Comments). Identifiers: sequences of Unicode letters, digits, and , with language-specific rules for leading characters. Keywords: packages and imports: package, module, import, file imports: from, control flow: if, else, loop, while, for, in, match, return, panic, break, continue, assert, await, yield, declarations and mutability: export, public, private, default, const, let, var, mut, fn, test, theory, type, types and declarations: struct, enum, error, interface, impl, as, raw, extends, pure, task, async, memory and regions: move, region, with, new, other operators: sizeof, alignof, offsetof, typename, optionals and literals: None/none, Some, true, false, null, verification and external declarations: ext, and Formal Silk directives #const, #require, #assure, #assert, #invariant, #variant, #monovariant, #theory, other keywords as listed in the spec. Keywords are lexed as distinct tokens, but in name positions (for example qualified-name segments like std::test, function/method names, and member access like value.test) the parser accepts keywords anywhere an identifier is expected. The #require / #assure / #assert / #invariant / #variant / #monovariant / #const / #theory forms are not comments; they are first-class lexical tokens that participate in the normal expression grammar and are handled by the verifier. A directive token begins with # followed by optional horizontal whitespace and the directive name (so #require and # require are equivalent spellings). When these sequences appear inside a // line comment or anywhere inside a / ... / block comment, the surrounding comment is treated as trivia and the directive spellings are ignored by the lexer. Literals: numeric, duration, boolean, character, string, regexp, aggregate (see literals-.md). String literals have two surface forms: \"...\" (escape sequences), ... (raw/no-escape). Regular expression literals have a JavaScript-style surface form: /pattern/flags (see Regular Expression Literals). Disambiguation is context-sensitive (like JavaScript): the parser only recognizes a regex literal in expression-start positions where a Primary expression may begin; otherwise / is parsed as the division operator. Because // starts a line comment, an empty regex literal // is not a valid token sequence; use /(?:)/ for an explicit empty pattern. Operators and delimiters: as listed in Operators (assignment, arithmetic, logical, bitwise, ranges, ?., ??, ::, ->, =>, etc.). The lexer must implement longest-token rules for ambiguous prefixes (e.g. ... vs ..= vs ..). Lexical Grammar for Whitespace and Comments For the purposes of the grammar, whitespace and comments are treated as trivia that may appear between any two tokens and are ignored by the parser: Trivia ::= (Whitespace LineComment BlockComment)+ Whitespace ::= ' ' '\\t' '\\r' '\\n' LineComment ::= '//' LineCommentChar Newline? LineCommentChar ::= any character except '\\n' Newline ::= '\\n' BlockComment ::= '/' BlockCommentChar '/' BlockCommentChar ::= any character except the end of input Block comments are not nesting: a / sequence inside an existing BlockComment has no special meaning and is treated as part of the comment text until the first following /. Doc-style comments such as / ... / are just syntactic sugar for BlockComment at the lexical level. High-Level Grammar Skeleton At a high level, the language can be structured as: Compilation unit: Module ::= (PackageDecl ModuleDecl)? ImportDecl TopLevelDecl Top-level declarations: TopLevelDecl ::= PackageDecl ModuleDecl ImportDecl InlineModuleDecl UsingDecl ReExportDecl DefaultExportDecl ExportableDecl TestDecl ExportableDecl ::= FnDecl LetDecl TypeDecl StructDecl EnumDecl InterfaceDecl ImplDecl ExtDecl ... Packages and imports: The surface syntax for packages, imports, and exports is specified in detail in Packages, Imports, and Exports. The grammar in this file mirrors the currently implemented subset: PackageDecl ::= 'package' PackagePath ';' ModuleDecl ::= 'module' PackagePath ModuleAsOpt ';' InlineModuleDecl ::= ExportModifier 'module' NameToken '{' InlineModuleItem '}' InlineModuleItem ::= InlineModuleDecl UsingDecl ExportableDecl NameToken ::= Identifier Keyword PackagePath ::= NameToken ('::' NameToken) ModuleAsOpt ::= ('as' QualifiedName TypeArgListOpt) \u03b5 ImportDecl ::= 'import' ImportSpec ';' ImportSpec ::= ImportPath FileImportSpec FileDefaultImportSpec ImportPath ::= ('::')? NameToken ('::' NameToken) ImportFrom ::= StringLiteral PackagePath FileImportSpec ::= '{' ImportBindingListOpt '}' 'from' ImportFrom FileDefaultImportSpec ::= NameToken 'from' ImportFrom ImportBindingListOpt ::= ImportBindingList \u03b5 ImportBindingList ::= ImportBinding (',' ImportBinding) ','? ImportBinding ::= NameToken ('as' NameToken)? ReExportDecl ::= 'export' '{' ReExportBindingListOpt '}' ';' ReExportBindingListOpt ::= ReExportBindingList \u03b5 ReExportBindingList ::= ReExportBinding (',' ReExportBinding) ','? ReExportBinding ::= NameToken ('as' NameToken)? DefaultExportDecl ::= 'export' 'default' NameToken ';' UsingDecl ::= 'using' Identifier '=' QualifiedName ';' 'using' QualifiedName UsingAsOpt ';' UsingAsOpt ::= ('as' Identifier) \u03b5 ExportModifier ::= 'export'? FnExportModifier ::= ('export' ('default')?)? For top-level declarations that can be exported, the ExportModifier appears before the declaration keyword (currently fn, let, ext, type, struct, enum, theory, error, and interface): FnDecl ::= FnSpecs FnExportModifier FnModifierOpt 'fn' FnGenericParamListOpt FnNameOpt FnSignature Block FnModifierOpt ::= FnModifier FnModifier ::= 'const' 'pure' 'task' 'async' FnGenericParamListOpt ::= GenericParamList \u03b5 FnNameOpt ::= NameToken \u03b5 FnSpecs ::= (FnPrecondition FnPostcondition FnContractTheory) FnPrecondition ::= '#require' Expr ';' FnPostcondition ::= '#assure' Expr ';' FnContractTheory ::= '#theory' Identifier '(' ArgListOpt ')' ';' Formal Silk theories may be declared either at top level (exportable) or inline inside blocks (non-exportable): TheoryDecl ::= TheorySpecs ExportModifier 'theory' Identifier '(' TheoryParamsOpt ')' '{' TheoryBodyItem '}' TheorySpecs ::= (TheoryPrecondition TheoryPostcondition) TheoryPrecondition ::= '#require' Expr ';' TheoryPostcondition ::= '#assure' Expr ';' TheoryParamsOpt ::= TheoryParams \u03b5 TheoryParams ::= TheoryParam (',' TheoryParam) ','? TheoryParam ::= Identifier ':' Type TheoryBodyItem ::= SpecConstStmt SpecTheoryStmt TheoryRequires TheoryInvariant TheoryEnsures TheoryVariant TheoryRequires ::= '#require' Expr ';' TheoryInvariant ::= '#invariant' Expr ';' TheoryEnsures ::= '#assure' Expr ';' TheoryVariant ::= '#variant' Expr ';' FnSignature ::= '(' FnParamsOpt ')' ResultTypeOpt FnParamsOpt ::= FnParams \u03b5 FnParams ::= GenericParamSectionOpt ';' ParamListOpt ParamList GenericParamSectionOpt ::= GenericParamSection \u03b5 GenericParamSection ::= GenericParam (',' GenericParam) ','? ParamListOpt ::= ParamList \u03b5 ParamList ::= Param (',' Param) Param ::= VarArgsOpt MutOpt Identifier TypeAnnotationOpt DefaultArgOpt VarArgsOpt ::= '...' \u03b5 DefaultArgOpt ::= ('=' Expr) \u03b5 ResultTypeOpt ::= ('->' TypeNoPipe TypedErrorTypesOpt)? TypedErrorTypesOpt ::= (' ' TypeNoPipe)+ \u03b5 Notes: When a top-level ; appears inside the function parameter list, it splits compile-time parameters (type/const parameters) from run-time value parameters. The compile-time side uses GenericParam syntax (T and N: int) and does not permit mut. FnNameOpt is currently permitted only for default-exported functions (export default fn (...) { ... }). For non-default functions, the fn identifier is required. Default export statements (export default Name;) always name an existing symbol; they do not permit anonymous exports. The run-time side uses ordinary Param syntax (mut x: T or x: T, with the type annotation optional in Silk). If there is no ;, the entire list is treated as run-time parameters. Default arguments are supported in function parameter lists: any parameter may provide a default expression (x: int = 1), defaulted parameters must be trailing (once a parameter has a default, all subsequent parameters must also have defaults) because call syntax is positional-only in the current language subset, and in the current implementation, default expressions are restricted to a constant/literal expression subset (no name references), so they can be inlined at call sites during lowering. a parameter declared as T? with a default has two effective behaviors in the current implementation subset: if the default expression has type T, the parameter has effective type T (the argument may be omitted at call sites, but the callee sees a non\u2011optional value), if the default expression is None/Null, the parameter remains T? (the argument may be omitted, and callers may still pass optional values explicitly). Varargs parameters are supported: a varargs parameter is declared by prefixing the final parameter with ... (for example fn f(x: int, ...rest: int) { ... }), only one varargs parameter is permitted per function and it must be final, In Silk, varargs parameters: must have an explicit type annotation, may not be mut, and may not have a default expression. The from string literal is a module specifier (either \"...\" or ... ): strings starting with ./, ../, or an absolute path are treated as file specifiers and resolve to a module by file path, strings starting with std/ are treated as std-root file specifiers and resolve to a module by file path under the configured stdlib root, other strings are treated as package specifiers and resolve to a package by name (see Packages, Imports, and Exports). BindingDecl ::= ('const' 'let' MutOpt 'var') Identifier TypeAnnotationOpt InitializerOpt ';' LetDecl ::= ExportModifier BindingDecl TypeAnnotationOpt ::= (':' Type)? InitializerOpt ::= ('=' Expr)? Type aliases are supported: TypeDecl ::= ExportModifier 'type' TypeDeclKindOpt Identifier '=' Type ';' TypeDeclKindOpt ::= TypeDeclKind \u03b5 TypeDeclKind ::= 'struct' 'enum' 'error' 'interface' 'fn' 'pure' 'fn' test declarations are supported as Zig-inspired top-level test blocks: TestDecl ::= 'test' StringLiteral? Block FFI declarations are also part of the language grammar: ExtDecl ::= ExportModifier 'ext' NameToken ExtExternNameOpt '=' Type ';' ExtExternNameOpt ::= StringLiteral \u03b5 When ExtExternNameOpt is present, it sets the linked external symbol name. This allows Silk code to bind a local name that differs from the C/FFI symbol name (for example to avoid name collisions in wrapper modules). The current compiler implementation supports external declarations (ext) whose type is either: a FunctionType (external functions, callable from Silk), or a supported scalar type (external variables, readable as values in Silk). the compiler requires an initializer for runtime bindings (let/var) and for compile-time constant bindings (const). Uninitialized declarations like let x: int; / const x: int; are parsed but rejected by the checker (see Compiler Diagnostics, E2015). Additionally, const initializers must be compile-time evaluable; otherwise the compiler reports an error (see Compiler Diagnostics, E2041). In practice, prefer: let x: int = 0; for a zero value, or let x: T? = None; for an \u201cempty\u201d optional. Struct declarations are also accepted by the current parser: StructDecl ::= ExportModifier 'struct' Identifier GenericParamListOpt StructExtendsOpt ';' ExportModifier 'struct' Identifier GenericParamListOpt StructExtendsOpt '{' StructFieldListOpt '}' StructExtendsOpt ::= ('extends' QualifiedName) \u03b5 GenericParamListOpt ::= GenericParamList \u03b5 GenericParamList ::= '(' GenericParamListInnerOpt ')' GenericParamListInnerOpt ::= GenericParamListInner \u03b5 GenericParamListInner ::= GenericParam (',' GenericParam) ','? GenericParam ::= Identifier (':' Type)? ('=' Type)? StructFieldListOpt ::= StructFieldList \u03b5 StructFieldList ::= StructField (',' StructField) ','? StructField ::= Identifier ':' Type StructFieldDefaultOpt StructFieldDefaultOpt ::= ('=' Expr) \u03b5 Enum declarations are part of the core language design. They are specified in enum Types. EnumDecl ::= ExportModifier 'enum' Identifier GenericParamListOpt '{' EnumVariantListOpt '}' EnumVariantListOpt ::= EnumVariantList \u03b5 EnumVariantList ::= EnumVariant (',' EnumVariant) ','? EnumVariant ::= Identifier EnumVariantPayloadOpt EnumVariantPayloadOpt ::= ('(' TypeListOpt ')') \u03b5 Interface and impl declarations are part of the language design and are parsed by the front-end as the syntax is implemented: InterfaceDecl ::= ExportModifier 'interface' Identifier GenericParamListOpt InterfaceExtendsOpt '{' InterfaceItem '}' InterfaceExtendsOpt ::= ('extends' QualifiedName) \u03b5 InterfaceMethodDecl ::= 'fn' NameToken FnSignature ';' InterfaceItem ::= InterfaceMethodDecl UsingDecl ImplDecl ::= 'impl' QualifiedName GenericParamListOpt ImplAsOpt '{' ImplMemberDecl '}' ImplAsOpt ::= ('as' QualifiedName TypeArgListOpt) \u03b5 ImplMemberDecl ::= FnDecl UsingDecl (within an impl block, export is reserved for static members with no self receiver; instance method visibility uses public/private) Note: const-parameter-style generics (N: int parameters and integer literal type arguments like Foo(u8, 1024)) remain tracked work; the front-end parses these surface forms but the current implementation focuses on type parameters and monomorphization for type arguments. Exception: the nominal optional form Option(T) is recognized as sugar for T? and is accepted in Silk. Types: Type ::= UnionType UnionType ::= TypeNoPipe (' ' TypeNoPipe) TypeNoPipe ::= BaseType TypeSuffix TypeSuffix ::= TypeSuffixElem TypeSuffix \u03b5 TypeSuffixElem ::= OptionalTypeSuffix ArrayTypeSuffix OptionalTypeSuffix ::= '?' '??' ArrayTypeSuffix ::= '[' ']' '[' ArrayLen ']' ArrayLen ::= IntLiteral Identifier BaseType ::= ReferenceType FunctionType '(' Type ')' SimpleType ReferenceType ::= '&' BaseType FunctionType ::= 'fn' '(' TypeListOpt ')' ResultTypeOpt TypeListOpt ::= TypeList \u03b5 TypeList ::= Type (',' Type) SimpleType ::= PrimitiveType NamedType PrimitiveType ::= 'bool' 'i8' 'u8' 'i16' 'u16' 'i32' 'u32' 'i64' 'u64' 'int' 'f32' 'f64' 'char' 'string' 'void' 'Instant' 'Duration' NamedType ::= QualifiedName TypeArgListOpt TypeArgListOpt ::= ('(' TypeArgListInnerOpt ')') \u03b5 TypeArgListInnerOpt ::= TypeArgListInner \u03b5 TypeArgListInner ::= TypeArg (',' TypeArg) ','? TypeArg ::= Type IntLiteral This means that type annotations such as string? or int?? are parsed into nested optional types. For simple nominal optionals, the parser also recognizes Option(T) and desugars it to the same internal representation as T?. Borrowed reference types (&T) are now parsed in type annotations. Array/slice types (T[], T[N]) are parsed and type-checked in Silk (with element-type restrictions), and are part of the implemented expression grammar via array literals ([a, b, c]) and indexing (xs[i]). Function types (fn (T, ...) -> R) are parsed as part of the Type grammar, and function values are supported in the current lowering subset (including capturing closures as a restricted scalar-only subset; see Types and Memory Model (Stack, Heap, and Moves)). Statements: Stmt ::= LetStmt SpecConstStmt SpecAssertStmt SpecTheoryDeclStmt SpecTheoryStmt AsyncBlockStmt TaskBlockStmt ExprStmt IfStmt LoopStmt WhileStmt ForStmt MatchStmt ReturnStmt PanicStmt AssertStmt BreakStmt ContinueStmt LetStmt ::= ('const' 'let' MutOpt 'var') LetBinder TypeAnnotationOpt InitializerOpt ';' LetBinder ::= Identifier '' LetTupleBinder LetStructBinder LetArrayBinder LetTupleBinder ::= '(' LetTupleBinderItemsOpt ')' LetTupleBinderItemsOpt ::= LetTupleBinderItem (',' LetTupleBinderItem) ','? \u03b5 LetTupleBinderItem ::= Identifier '' LetStructBinder ::= '{' LetStructBinderItemsOpt '}' LetStructBinderItemsOpt ::= LetStructBinderItem (',' LetStructBinderItem) ','? \u03b5 LetStructBinderItem ::= Identifier ('as' (Identifier ''))? LetArrayBinder ::= '[' LetArrayBinderItemsOpt ']' LetArrayBinderItemsOpt ::= LetArrayBinderItem (',' LetArrayBinderItem) ','? \u03b5 LetArrayBinderItem ::= Identifier '' SpecConstStmt ::= '#const' Identifier '=' Expr ';' SpecAssertStmt ::= '#assert' Expr ';' SpecTheoryDeclStmt ::= '#theory' Identifier '(' TheoryParamsOpt ')' '{' TheoryBodyItem '}' SpecTheoryStmt ::= '#theory' Identifier '(' ArgListOpt ')' ';' AsyncBlockStmt ::= 'async' Block TaskBlockStmt ::= 'task' Block MutOpt ::= 'mut' \u03b5 ExprStmt ::= Expr ';' IfStmt ::= 'if' Expr Block ('else' (IfStmt Block))? LoopStmt ::= LoopPrefixOpt 'loop' Block LoopPrefixOpt ::= 'async' 'task' \u03b5 WhileStmt ::= WhileSpecs 'while' Expr Block WhileSpecs ::= (LoopInvariant LoopVariant LoopMonovariant) LoopInvariant ::= '#invariant' Expr ';' LoopVariant ::= '#variant' Expr ';' LoopMonovariant ::= '#monovariant' Expr ';' ForStmt ::= ForInStmt ForCStmt ForInStmt ::= 'for' ForBinder 'in' Expr (RangeOp Expr)? Block ForCStmt ::= 'for' '(' ForInit ';' Expr ';' Expr ')' Block ForInit ::= ('const' 'let' MutOpt 'var') Identifier TypeAnnotationOpt '=' Expr ForBinder ::= Identifier '' RangeOp ::= '..' '..=' BlockStmt ::= Block Block ::= '{' Stmt '}' ReturnStmt ::= 'return' ExprOpt ';' ExprOpt ::= Expr? PanicStmt ::= 'panic' QualifiedName StructLiteralSuffixOpt ';' AssertStmt ::= 'assert' Expr ';' 'assert' '(' Expr (',' Expr)? ')' ';' BreakStmt ::= 'break' ';' ContinueStmt ::= 'continue' ';' WithStmt ::= 'with' Identifier Block 'with' WithBytes Block 'with' WithBytes 'from' Identifier WithFromSliceOpt Block WithBytes ::= IntLiteral '(' IntLiteral ')' WithFromSliceOpt ::= '[' IntLiteral '..' IntLiteralOpt ']' \u03b5 IntLiteralOpt ::= IntLiteral \u03b5 MatchStmt ::= 'match' Expr '{' MatchStmtArmListOpt '}' MatchStmtArmListOpt ::= MatchStmtArmList \u03b5 MatchStmtArmList ::= MatchStmtArm (',' MatchStmtArm) ','? MatchStmtArm ::= MatchStmtPattern '=>' Block OptionalPattern ::= 'None' 'Some' '(' (Identifier '') ')' MatchStmtPattern ::= OptionalPattern '' Identifier (Identifier '') ':' QualifiedName StructLiteralSuffixOpt ::= StructLiteralSuffix \u03b5 Region declarations and with blocks are specified in Regions. match is implemented in two separate forms: match as an expression (arms are expressions; see MatchExpr below), match as a statement (arms are blocks), used for typed errors as specified in Typed Errors (error, panic, and T ErrorType...). In the current implementation, the match statement form is restricted to a call-expression scrutinee and the patterns listed above. Expressions: Expressions follow a conventional precedence hierarchy, as implemented in the implementation: Expr ::= Assign Assign ::= Coalesce (AssignOp Assign)? AssignOp ::= '=' '+=' '-=' '=' '/=' Coalesce ::= LogicalOr ('??' Coalesce)? LogicalOr ::= LogicalAnd (' ' LogicalAnd) LogicalAnd ::= BitOr ('&&' BitOr) BitOr ::= BitXor (' ' BitXor) BitXor ::= BitAnd ('^' BitAnd) BitAnd ::= Equality ('&' Equality) Equality ::= TypeTest (('==' '!=') TypeTest) TypeTest ::= Relational ('is' Type)? Relational ::= Shift (('<' '<=' '>' '>=') Shift) Shift ::= AddSub (('<<' '>>') AddSub) AddSub ::= MulDiv (('+' '-') MulDiv) MulDiv ::= Unary (('' '/' '%') Unary) Unary ::= ('!' '~' '-' 'mut' 'move' 'new' 'await' 'yield' 'sizeof' 'alignof' 'offsetof' 'typename' '&' '' '++' '--') Unary Postfix Postfix ::= Primary PostfixSuffix PostfixSuffix ::= CallSuffix FieldSuffix OptionalFieldSuffix StructLiteralSuffix IndexSuffix SliceSuffix CastSuffix TrySuffix IncDecSuffix CallSuffix ::= '(' CallArgsOpt ')' FieldSuffix ::= '.' NameToken OptionalFieldSuffix ::= '?.' NameToken StructLiteralSuffix ::= '{' StructInitListOpt '}' IndexSuffix ::= '[' Expr ']' SliceSuffix ::= '[' SliceBoundOpt '..' SliceBoundOpt ']' SliceBoundOpt ::= Expr \u03b5 CastSuffix ::= 'as' RawOpt Type CastSliceLenOpt CastSliceLenOpt ::= '(' Expr ')' \u03b5 RawOpt ::= 'raw' \u03b5 TrySuffix ::= '?' IncDecSuffix ::= '++' '--' StructInitListOpt ::= StructInitList \u03b5 StructInitList ::= StructInit (',' StructInit) ','? StructInit ::= NameToken (':' Expr)? CallArgsOpt ::= CallArgs \u03b5 CallArgs ::= GenericArgListOpt ';' ArgListOpt ArgList GenericArgListOpt ::= GenericArgList \u03b5 GenericArgList ::= GenericArg (',' GenericArg) ','? GenericArg ::= Type IntLiteral ArgListOpt ::= ArgList \u03b5 ArgList ::= Expr (',' Expr) Note: the parser treats mut <expr>, new <expr>, await <expr>, await <expr>, yield <expr>, yield <expr>, sizeof <expr>, alignof <expr>, offsetof(Type, fieldpath), typename <expr>, and prefix ++<expr> / --<expr> as unary expressions. Note: CastSliceLenOpt is permitted only when Type is a slice type (T[]) and RawOpt is \u03b5 (it is used by unsafe pointer\u2192slice casts like ptr as u8[](len)). The type checker currently permits mut <expr> only in call arguments (and method receivers) when the corresponding parameter is declared mut and is: a borrowed reference type (mut r: &T), or a slice type (mut s: T[]). The move <expr> unary form is used for explicit ownership transfer; in the it is restricted to move <name> where <name> is a local binding. The type checker currently permits new <expr> only when it can determine a concrete reference result type of the form &Struct. In the current implementation this happens either: from an expected &Struct type context (for example let x: &Packet = new Packet{ ... }; or as a call argument whose parameter type is &Struct) from the operand itself when it names the struct type (for example let x = new Packet{ ... }; or let x = new Packet(...);) new is supported only in function bodies (not in top-level let initializers). Primary ::= IntegerLiteral DurationLiteral FloatLiteral StringLiteral RegexpLiteral CharLiteral 'true' 'false' 'None' 'null' 'Some' '(' Expr ')' ArrayLiteral IfExpr MatchExpr FnExpr '(' Expr ')' InferredStructLiteral QualifiedName RegexpLiteral ::= '/' RegexpBody '/' RegexpFlagsOpt RegexpFlagsOpt ::= Identifier \u03b5 Notes: RegexpBody is scanned by the parser (not the lexer): it is the byte span between the opening and closing /, where the closing delimiter is the first unescaped / that is not inside a character class ([...]). ArrayLiteral ::= '[' ExprListOpt ']' ExprListOpt ::= ExprList \u03b5 ExprList ::= Expr (',' Expr) ','? QualifiedName ::= GlobalPrefixOpt NameToken ('::' NameToken) GlobalPrefixOpt ::= '::' \u03b5 InferredStructLiteral ::= '{' StructInitListOpt '}' FnExpr ::= 'fn' '(' LambdaParamListOpt ')' '->' LambdaBody LambdaParamListOpt ::= LambdaParamList \u03b5 LambdaParamList ::= LambdaParam (',' LambdaParam) ','? LambdaParam ::= Identifier ':' Type LambdaBody ::= Type Block Expr Disambiguation rule (current parser): fn (...) -> Type Block is treated as the block-body form only when the return type is followed immediately by { (starting the block). Otherwise, fn (...) -> Expr is treated as an expression-body function expression and its result type is inferred by the checker. Notes: InferredStructLiteral has the same token-level shape as StructLiteralSuffix (used for Type{ ... }), but appears as a Primary expression with no explicit type name. The type checker requires an expected struct type context to resolve the literal\u2019s target type. To avoid ambiguity with statement blocks, the parser only recognizes InferredStructLiteral when the { ... } contents look like a struct initializer list (or are {}): either the first token after { is } or it is an Identifier followed by : (explicit initializer) or followed by , / } (shorthand initializer). MatchExpr ::= 'match' Expr '{' MatchArmListOpt '}' MatchArmListOpt ::= MatchArmList \u03b5 MatchArmList ::= MatchArm (',' MatchArm) ','? MatchArm ::= MatchExprPattern '=>' Expr MatchExprPattern ::= OptionalPattern EnumVariantPattern ResultPattern IfExpr ::= 'if' Expr IfExprBlock 'else' (IfExpr IfExprBlock) IfExprBlock ::= '{' Expr '}' ResultPattern ::= ('Ok' 'Err') '(' (Identifier '') ')' EnumVariantPattern ::= EnumVariantName EnumVariantBinderListOpt EnumVariantName ::= ('::')? Identifier '::' Identifier ('::' Identifier) EnumVariantBinderListOpt ::= ('(' EnumVariantBinderListInnerOpt ')') \u03b5 EnumVariantBinderListInnerOpt ::= EnumVariantBinderList \u03b5 EnumVariantBinderList ::= EnumVariantBinder (',' EnumVariantBinder) ','? EnumVariantBinder ::= Identifier '' Declarations: Decl ::= ... ErrorDecl ErrorDecl ::= ExportModifier 'error' Identifier '{' StructFieldListOpt '}' This matches the current AST and checker: Primary constructs Literal or Name expressions (or a parenthesized Expr), unary expressions are represented as UnaryExpr with a token kind indicating the operator, binary expressions are represented as BinaryExpr with a token kind indicating the operator, identifiers and qualified names are stored as NameExpr with the full slice of source text (e.g. util::answer), simple function calls such as helper() or util::helper(1, 2) are parsed as call expressions using the Postfix/CallSuffix productions; the current implementation supports calls to named functions, but the type checker and back-end currently restrict which value types can appear at call boundaries; see silk CLI for the exact supported subset. Further expression forms (ranges, etc.) are described in other language concept documents and in Operators. The current parser now accepts ?. optional field access (opt?.field) and the initial match expression form as part of the implemented optional subset, but other expression forms will be added here as they are implemented. Role of This File This document serves as the reference for: lexer implementation (token categories and reserved words), parser implementation (production rules and precedence), pretty-printer or formatter behavior. As the parser and lexer are implemented, this file must be updated with: the exact grammar that the compiler accepts (including any temporary limitations), clarifications or corrections discovered during implementation (recorded here so this file remains canonical), notes about desugaring and how surface constructs map into the internal AST, clear indication of which productions are implemented today vs. planned future work, so that downstream users can see both the full language design and the currently supported subset. Types This document specifies the Silk type system used by the compiler front-end and type checker. Implementation status : Supported end-to-end: primitives, nominal struct types, optionals (T?), &Struct references (in function parameter types and as local values produced by new / calls that return &Struct), and array/slice types (T[N], T[]) over element types that lower to a fixed scalar-slot sequence In Silk (including array literals, indexing reads, and iterable for loops). Indexed assignment targets (xs[i] = v) are supported for these element types; compound index ops require numeric scalar element types in Silk. Parameterized nominal types (monomorphized): generic struct and interface declarations with type parameters, plus applied types in type positions (Name(u8), Name(string)) for those declarations. Reserved intrinsics: the compiler currently exposes reserved, stdlib bring-up intrinsics for working with the string ABI (silkstringptr, silkstringlen, and silkstringfromptrlen); these are not yet a stable user API and exist primarily to unblock std::fmt, std::io, and std::args while slice/iterator features are still evolving. Special-case: the nominal optional form Option(T) is accepted and desugared to T? in type annotations (it is not a general generics feature). Parsed but rejected by the current checker: const parameters and integer literal type arguments (Foo(N: int), Foo(u8, 1024)) (Compiler Diagnostics, E2016), and the removed builtin map type form (map(K, V)) (E2017; use std::map::{HashMap, TreeMap} instead). Typed errors (error, panic, and T ErrorType...) are specified in Typed Errors (error, panic, and T ErrorType...). The current compiler models typed error contracts as an effect on function return types and expressions. Separately, type unions (T1 T2 ...) are supported in type annotations as described in Type Unions (T1 T2 ...). In function declaration return types, union returns must be parenthesized (-> (A B)) because unparenthesized after -> is reserved for typed-error contracts. Quick Reference The core categories are: Booleans: bool Examples: true, false. Notes: logical values. Integers (fixed width): u8, i8, u16, i16, u32, i32, u64, i64 Examples: let n: i32 = 42;. Notes: signed/unsigned bit-widths. Integer (platform): int Examples: let n: int = 1;. Notes: implementation/default integer. Pointer-width integers: usize, size Examples: let n: usize = 1;, let n: size = -1;. Notes: unsigned/signed integer types whose width matches the target architecture pointer width (for example 64-bit on linux/x8664). Compatibility: isize is accepted as an alias for size. Floats: f32, f64 Examples: let x: f64 = 3.14;. Notes: IEEE\u2011754. Char: char Examples: 'A'. Notes: Unicode scalar. String: string Examples: \"hello\". Notes: immutable text; multi\u2011line strings supported. Regexp: regexp Examples: /hello/i. Notes: compiled regular expression bytecode; a non-owning { ptr, len } view analogous to string. Regex literals compile at compile time; runtime compilation and matching helpers live in std::regex (see std::regex). Region handle: Region Examples: fn f (r: Region) -> int { with r { ... } }. Notes: a first-class region allocation context handle; see Regions. Void / Unit: void Examples: fn foo () -> void {}. Notes: functions that return nothing. Time Types: Instant, Duration Examples: let i: Instant = std::now();. Notes: specialized i64-based types for time measurement. Optional: T? Examples: User?, i32?. Notes: None / none is the canonical empty value; null may also be used when an optional type is expected and coerces to None. Use match, ?., ??. None (value): Examples: None / none (represented as None in code samples). Notes: the distinguished empty value; typed as T?. The null literal is a distinct literal that can coerce to None when an optional type is expected (see Optional). Reference (borrow): &T Examples: &User. Notes: reference type; in Silk, &Struct may appear in parameter types and as local values when produced by new or by calls that return &Struct. Mutability follows the mut borrow contract and per-call aliasing rules described in Mutability. Arrays / Slices: T[], T[N] Examples: i32[], byte[32]. Notes: dynamic slice vs fixed length (compile\u2011time N). In the current compiler/backend subset, arrays/slices are supported only when the element type lowers to a fixed scalar slot sequence in the current scalar-slot memory model (for example primitive scalars, string, and supported regexp, supported non-opaque structs, and enums). See Structs, Impl Blocks, and Memory Layout for the current scalar-slot memory model. in Silk, fixed array lengths are limited to N <= 4096. Indexing xs[i] traps when i is out of bounds in Silk. Function Types: fn(params) -> R Examples: fn(i32) -> i32. Notes: function types are part of the type grammar and function-typed values are supported as function values (including capturing closures) in the compiler. Concurrency disciplines (task / async) are implemented on function declarations (see Concurrency); function types in type positions do not currently include discipline modifiers. Capturing Closures: Notes: capturing closures are supported as function values with an environment; see \u201cFunction Types and Closures\u201d below for restrictions. Structs (nominal): Surface: struct Name { ... } then Name(...). Examples: Point, Option(T). Notes: user\u2011defined records; may be parameterized. Enums (sum types): Surface: enum Name { ... }. Notes: nominal tagged unions as described in the spec. Type unions: Surface: T1 T2 ... (type annotations). Notes: a tagged \u201cone-of-these-types\u201d type for a small, explicitly defined subset; see Type Unions (T1 T2 ...). The compiler must represent these types faithfully in its internal type system and in the C99 ABI mappings, and it must follow the exact surface syntaxes indicated above when parsing and printing types. Type Aliases (type) Silk supports compile-time-only type aliases via type declarations. Syntax examples: type Int32 = i32; type struct Bar = Foo; type fn IntAdder = fn(int, int) -> int; type pure fn PureIntAdder = fn(int, int) -> int; export type struct PublicBar = Foo; Semantics : A type alias introduces a new name for an existing type; it does not introduce a distinct nominal type. The type checker MUST treat uses of the alias name as equivalent to the alias target type (the alias is transparent). Type aliases may be used anywhere a type is expected (parameter/result types, local annotations, struct fields, as casts, etc.). Cycles in type aliases are rejected (E2058). Kind tags: A type declaration may optionally specify a kind tag, for example type struct Name = Foo; or type pure fn Name = fn(...) -> ...;. When present, the compiler MUST validate that the resolved alias target matches the declared kind (E2059). Import/export: type aliases may be exported (export type ...;) and imported as type names via named file imports (see Packages, Imports, and Exports). Implicit Call-Argument Coercions In Silk, Silk supports a small, opt-in implicit coercion mechanism for function call arguments. This exists to keep the current standard library ergonomic while generics and richer overload systems are still evolving. There are two related mechanisms: 1. Coercion to a nominal struct value T (by-value parameters and varargs elements) via exported static ctor-like methods. 2. Coercion to a borrowed reference &T (read-only &T parameters) via a constructor method that initializes a compiler-generated stack temporary. 1) Coercion to T via exported static ctor-like methods Rule (informal): When a function call argument type does not match a parameter type, and the parameter is a nominal struct type T, the compiler may rewrite the argument to a call of an exported, static ctor-like method on T. This also applies to varargs elements (...args: T). Supported ctor-like method names (destination type opts in by defining these): T.int(value: int) -> T T.u64(value: u64) -> T T.f64(value: f64) -> T T.bool(value: bool) -> T T.char(value: char) -> T T.string(value: string) -> T T.regexp(value: regexp) -> T T.Region(value: Region) -> T Selection (source type \u2192 constructor): Signed integer primitives (i8/i16/i32/i64/int/size/isize/Instant/Duration) \u2192 int Unsigned integer primitives (u8/u16/u32/u64/usize) \u2192 u64 Float primitives (f32/f64) \u2192 f64 bool \u2192 bool char \u2192 char string \u2192 string regexp \u2192 regexp Region \u2192 Region Integer width: When the source argument is a fixed-width integer, the compiler inserts an implicit integer cast to match the ctor parameter type before calling the ctor. When the source argument is f32 and the selected ctor parameter type is f64, the compiler inserts an implicit float cast (f32 -> f64) before calling the ctor. Example: struct Counter { value: int, } impl Counter { public fn int (value: int) -> Counter { return Counter{ value: value }; } } fn takes (c: Counter) -> int { return c.value; } fn main () -> int { let x: i32 = 7; return takes(x); // coerces via Counter.int } Notes: Coercions are only attempted when the destination type provides the matching exported static ctor method. Today this primarily exists to support std::fmt::Arg and ergonomic std::io::print/println calls without requiring explicit Arg. wrappers everywhere. 2) Coercion to &T via constructor (stack temporary) Rule (informal): When a call argument does not match a parameter type, and the parameter is a read-only borrowed reference &T to a nominal struct type T, the compiler may create an implicit stack temporary tmp: T, initialize it by invoking tmp.constructor(...), and pass &tmp to the callee. This is intentionally a stack construction mechanism: it does not allocate on the heap, it is compatible with silk build --noheap, and the temporary\u2019s lifetime is the duration of the call (similar to how C++ binds temporaries to const& parameters). Eligibility requirements: The parameter must be &T (not mut &T). The destination type T must provide a visible constructor overload with: receiver mut self: &T, exactly one non-receiver parameter (value: U), return type void. The call argument type must match the selected overload\u2019s U parameter type. If multiple overloads are viable for a given argument, the coercion is ambiguous and rejected (the call must be written with an explicit construction). Example: struct User { name: string, } impl User { fn constructor (mut self: &Self, name: string) -> void { self.name = name; } } fn printuser (user: &User) -> void { std::io::println(\"user.name = {}\", user.name); } fn main () -> int { // Implicitly constructs a temporary User from a string for this call. printuser(\"alice\"); return 0; } Notes: This is an opt-in mechanism: types must provide the matching constructor. If the coercion is ambiguous (multiple viable conversion paths), the compiler rejects the call and requires an explicit construction. Because this coercion participates in ordinary call argument checking, it can make additional overloads applicable (for example a copy-constructor constructor(mut self: &Self, other: &Self) can accept a string argument by first constructing a temporary Self from string). Overload resolution prefers overloads that match without requiring such coercions. Explicit Casts (as) Silk supports explicit casts using the postfix as operator: let x: f64 = 3.14; let n: int = x as int; This operator is intended for explicit, potentially lossy primitive numeric conversions. in Silk it also supports explicit conversions via std::interfaces::Serialize(T) by lowering expr as T to expr.serialize() when the operand type provides a matching serialize method. For structured conversions, it also supports std::interfaces::Deserialize(S) by lowering expr as T to T.deserialize(expr) when the target type provides a matching static deserialize method. The supported conversions and semantics for the compiler are specified in Operators (\u201cCasts (as)\u201d). Notes: as is explicit. It does not introduce new implicit coercions. For call-argument ergonomics, see the separate opt-in coercion mechanism described above (\u201cImplicit Call-Argument Coercions\u201d). Nominal & Parameterized Types Nominal types are introduced by declarations (e.g. struct, enum, interface) and are equal only to themselves. Parameterized types are constructed by applying a type constructor to type arguments. The compiler must: Treat nominal types as distinct even if their field layout is identical. In the full language design, support parameterized types in all contexts where the spec permits them. in Silk, type-parameter generics are supported for nominal declarations (struct / interface) and for applied types in type positions (Name(u8)). Const parameters and integer-literal type arguments (Name(N: int), Name(u8, 1024)) remain tracked work and are rejected (E2016). The Option(T) optional sugar described above remains supported for the . Parameterized type syntax (initial surface form) The initial surface syntax for applying type arguments is: TypeApply ::= TypeName '(' TypeArgListOpt ')' TypeName ::= Identifier ('::' Identifier) TypeArgListOpt ::= TypeArgList \u03b5 TypeArgList ::= TypeArg (',' TypeArg) ','? TypeArg ::= Type IntLiteral Examples: Foo(int, 1024) Mutex(Account) Result(int, string) Notes: A TypeArg may be a type (e.g. int, &Foo, Option(string)) or a compile-time integer literal for const-parameter-style arguments. The full semantics (declaring generic parameters, constraint checking, and monomorphization) are still evolving; the key requirement is that the compiler preserves the argument structure in the AST/type system so later stages can enforce and lower it. Reference Types Reference types describe access to values rather than owning them (e.g. references, borrowed views, or other non-owning handles as specified in this document and related language docs). Key requirements: Distinguish owning vs. non-owning types in the type system. Preserve aliasing and lifetime constraints so that regions, buffers, and FFI safety rules can be enforced. Current implementation notes: &Struct is supported in function parameter types and as local values when produced by heap allocation (new) or by calls that return &Struct. Borrowed &Struct references may also be created from stack values: via the borrow operator &expr on borrowable lvalues, and via implicit borrow coercions in contexts that expect &T (for example let r: &Pair = pair;). These borrows are checked with conservative lexical lifetime rules (they may not escape the scope of the borrowed stack storage). Mutable reference parameters use the two-part mut contract and conservative per-call aliasing rules; see Mutability. Function Types and Closures (Implementation Status) the compiler: Parses function types in type positions (most notably for ext declarations). Implements function expressions (lambdas) in expression positions: expression body form: fn (x: int, y: int) -> x + y block body form: fn (x: int, y: int) -> int { return x + y; } Function expressions may not declare &T parameters in Silk. Function expressions are inferred as pure when they are non-capturing: they may call only pure functions, they may not mutate (let mut/var, assignment), they may not allocate (new), they may not use typed error contracts or panic. The checker also supports purity inference (\u201cauto-pure\u201d) for ordinary function declarations and impl methods. When inferred, these functions/methods are treated as pure for call checking and are callable from pure code. Capturing closures are implemented as a subset of function values: a function expression body may reference immutable locals/parameters from an enclosing scope; those values are captured by value into a heap environment, In Silk, only scalar captures are supported (int, fixed width ints, bool, char, f32, f64, Instant, Duration), capturing closures are not pure (they have an environment) and are rejected in pure code in Silk. Function values are supported end-to-end for this subset (non-capturing and capturing): they may be passed as arguments, returned from functions, stored in structs/arrays, and called indirectly. the runtime representation is a pair { funcptr, envptr } as specified in Memory Model (Stack, Heap, and Moves). Discipline modifiers for function declarations (pure / task / async) are implemented. Function types in type positions do not currently include discipline modifiers. Literals Overview This document provides a high-level overview of literals in Silk, with details split into dedicated documents for each category. For first-time readers, a good path is: 1. Types (primitive types like int, f64, bool, string), 2. this overview (what literal categories exist), 3. the specific literal docs below (syntax, semantics, and supported behavior). Returning readers typically want the \u201cImplementation Status\u201d section near the top of each literal concept doc, plus the \u201cRelevant Tests\u201d links for runnable examples. Literal Categories Silk includes the following literal categories: Numeric literals Duration literals Boolean literals Character literals String literals Regular expression literals Aggregate literals (arrays, structs) Each literal form has well-defined syntax and type inference rules that the compiler must implement. See: Numeric Literals Duration Literals Boolean Literals Character Literals String Literals Regular Expression Literals Aggregate Literals Numeric Literals Numeric literals produce integer (int, u8, i64, \u2026) and floating-point (f32, f64) values. In Silk, the sign is an operator: -1 is a unary - expression applied to the integer literal token 1, not a distinct \u201cnegative literal\u201d token. Quick Reference fn main () -> int { let a = 42; // int let b: u8 = 42; // u8 (typed by context) let x: f64 = 1.5; // f64 let y: f32 = 1.5; // f32 (typed by context) let d: Duration = 5ms; let t0: Instant = 0; return 0; } Surface Syntax (Current Lexer) In the current implementation, numeric literal tokens are recognized as: Integer literal: decimal digits ([0-9]+), binary prefix: 0b / 0B followed by binary digits ([01]+), octal prefix: 0o / 0O followed by octal digits ([0-7]+), hex prefix: 0x / 0X followed by hex digits ([0-9a-fA-F]+), legacy octal: 0[0-7]+ (for example 017). Float literal: digits, ., digits ([0-9]+ '.' [0-9]+) Notes: A float literal must have digits on both sides of the .: 1.0 is a float literal. 1. is not a float literal in the current lexer. .5 is not a float literal; write 0.5. Numeric literals must start with a digit in the current lexer. The - sign is not part of the literal token: 1 parses as unary - applied to the integer literal 1. 1.5 parses as unary - applied to the float literal 1.5. A numeric token immediately followed by a duration unit suffix (e.g. 1s, 500ms, 1.5s) is a single Duration literal token, not a number token followed by an identifier. A numeric literal token may not be immediately followed by an identifier start character or an ASCII digit (unless the identifier characters are part of a duration unit suffix). For example: 3in is a lexical error (write 3 in or 3 in as intended), 0b102 is a lexical error (invalid binary digit), 08 is a lexical error in Silk because multi-digit literals starting with 0 are legacy octal (use 0o10 for octal 8, or write 8 for decimal). Type Rules See Types for the primitive type names used below. Integer literals Without an expected type, an integer literal has type int. When a context provides an expected type that is: an integer type (u8, i64, int, \u2026), or a time type (Duration, Instant), then the integer literal adopts that expected type. Example: parameter context and \u201cadopt the expected type\u201d fn idu8 (x: u8) -> u8 { return x; } fn main () -> int { // 255 is contextually typed as u8 because idu8 expects u8. let v: u8 = idu8(255); if v != 255 { return 1; } return 0; } Example: time types share an i64-based representation in Silk (Duration & Instant), so integer literals can be used as Instant/Duration values via context: fn main () -> int { let t0: Instant = 0; let d: Duration = 1s; let t1: Instant = t0 + d; let diff: Duration = t1 - t0; if diff != d { return 1; } return 0; } Float literals Without an expected type, a float literal has type f64. When a context provides an expected float type (f32 or f64), the literal adopts that expected type. fn idf32 (x: f32) -> f32 { return x; } fn main () -> int { // 1.5 is contextually typed as f32 because idf32 expects f32. let v: f32 = idf32(1.5); if v != 1.5 { return 1; } return 0; } Common Pitfalls Trying to use suffixes: 42u8 / 1.5f32 are not supported. Use type annotations (let x: u8 = 42;) or casts (42 as u8). Using digit separators: 1000 is not supported yet. Using exponent notation: 1e6 is not supported yet. Writing incomplete floats: write 1.0 (not 1.) and 0.5 (not .5). Mixing integers and floats implicitly: use as casts (Operators) to convert explicitly when you need to combine integer and float values. Related Documents Duration Literals (duration literals like 5ms, 1.5s) Duration & Instant (time types and operators) Operators (unary -, arithmetic, and as casts) Types (primitive numeric type names) Relevant Tests Integer literal contextual typing (u8 parameters): the runnable fixtures Integer wrap behavior in arithmetic: the runnable fixtures the runnable fixtures Float literal contextual typing (f32 parameters): the runnable fixtures Float literal default type (f64): the runnable fixtures Float arithmetic and comparisons: the runnable fixtures the runnable fixtures Duration literals (numeric + unit suffix): the runnable fixtures Integer literal base prefixes and legacy octal: the runnable fixtures String Literals String literals represent string values: immutable, length-tracked sequences of bytes that are typically interpreted as UTF-8 text. Use strings for: filenames and paths, user-visible messages, structured formats (JSON, CSV, etc), and general \u201ctext\u201d data. If you need a single Unicode scalar value, use char literals (Character Literals). Semantics The value of a string literal is a sequence of bytes. By convention and by intent, string values represent UTF-8 text, but some escape forms (notably \\xNN) can construct byte sequences that are not valid UTF-8. Avoid this unless you are intentionally working with raw bytes. String literals are immutable. Unless otherwise specified for a particular FFI surface, string literals do not implicitly include a trailing \\0 byte; length is carried explicitly. Single-Line Strings Single-line string literals: Use standard quote-delimited syntax. Support escape sequences as described below. Raw Strings (Backtick) Raw string literals are delimited by backticks: ... They may include newlines directly. They do not process escape sequences: \\n is two bytes ('\\' and 'n'). They still normalize embedded \\r\\n / \\r in the source text to \\n. Escape Sequences Double-quoted string literals support the same escape spellings as character literals: \\\\ (backslash) \\\" (double quote) \\' (single quote) \\n (newline, U+000A) \\r (carriage return, U+000D) \\t (tab, U+0009) \\0 (NUL byte, U+0000) \\xNN (byte escape, two hex digits) \\u{...} (Unicode scalar value escape, 1\u20136 hex digits) When decoding \\u{...} escapes, the compiler must reject non-scalar Unicode values (for example surrogate code points). Multi-Line Strings Multi-line strings: Allow embedding newlines directly in the literal. Must be represented and encoded identically to string values produced at runtime. Line Ending Normalization When decoding string literals, the compiler must normalize: \\r\\n to \\n \\r to \\n This applies both to embedded newlines in multi-line literals and to escaped forms such as \\r. Note: a sequence of two escapes like \"\\r\\n\" is still two escapes. In the current implementation, \\r escapes become \\n, so \"\\r\\n\" produces two line feed bytes (\"\\n\\n\"). Examples Basic string literal fn main () -> int { let s: string = \"hello\"; if s == \"hello\" { return 0; } return 1; } Escapes and byte escapes fn main () -> int { // Quote and backslash escapes. if \"\\\"\" != \"\\x22\" { return 1; } if \"\\\\\" != \"\\u{005C}\" { return 2; } // Control escapes. if \"\\t\" != \"\\x09\" { return 3; } if \"\\n\" != \"\\x0A\" { return 4; } if \"\\r\" != \"\\n\" { return 5; } // \\r is normalized to \\n in the . // NUL bytes are permitted; strings are length-tracked (not NUL-terminated). if \"\\0\" != \"\\x00\" { return 6; } // Unicode escapes insert UTF-8 bytes for that scalar. if \"\u00e9\" != \"\\u{00E9}\" { return 7; } return 0; } Multi-line string literal (embedded newline) fn main () -> int { let multi: string = \"a b\"; // Equivalent to using a \\n escape. if multi != \"a\\nb\" { return 1; } return 0; } Raw multiline string literal (backticks) fn main () -> int { let multi: string = a b; if multi != \"a\\nb\" { return 1; } // Backslashes are literal bytes in raw strings. if a\\nb != \"a\\\\nb\" { return 2; } return 0; } Common Pitfalls Expecting NUL termination: \"hi\" does not include an implicit \\0. Use \\0 explicitly when you need it, and prefer APIs that are length-aware. Using \\xNN for non-ASCII characters: \\xNN inserts a raw byte, not a Unicode scalar. Use \\u{...} for text. Assuming multi-line indentation stripping: multi-line strings include all bytes between the quotes, including indentation spaces. Related Documents Types (primitive string and char) Character Literals (shared escape spellings) C99 ABI and libsilk.a (C ABI string representation) Relevant Tests Core string equality and ordering: the runnable fixtures the runnable fixtures Escape coverage: the runnable fixtures Raw/backtick coverage: the runnable fixtures The compiler must: Implement lexing and parsing for both \"...\" and ... . Normalize line endings and escapes according to the spec. Ensure compatibility with the FFI SilkString representation. Regular Expression Literals Regular expression literals represent regexp values: compiled regular expression bytecode that can be used by std::regex helpers. The regex literal syntax is modeled after JavaScript: /pattern/flags Syntax Delimiters and scanning Regex literals are scanned by the parser (not the lexer): the opening delimiter is a single /, the closing delimiter is the first unescaped / that is not inside a character class ([...]), after the closing delimiter, the parser consumes ASCII letters as flags. The parser does not interpret regex escapes: backslash sequences are preserved as bytes for the regex engine. Empty patterns and // Because // introduces a line comment, an empty regex literal // is not a valid token sequence. Use an explicit empty pattern, for example /(?:)/. Flags The supported flag set is intentionally small in Silk: g \u2014 global (recorded; does not change std::regex::matches semantics) i \u2014 ignore case m \u2014 multiline s \u2014 dotAll y \u2014 sticky d \u2014 indices (recorded; not surfaced by std::regex helpers) The type checker rejects: unknown flags, duplicate flags (for example /a/ii). Semantics A regex literal\u2019s value is a non-owning { ptr, len } view (regexp) into compiled bytecode embedded in read-only data. The bytecode format is owned by the runtime regex engine; regexp values are opaque and must be consumed via std::regex. In Silk, matching is defined over the raw bytes of the input string, and match indices are byte offsets. Examples Basic test import std::regex; fn main () -> int { if std::regex::matches(/hello/, \"hello world\") { return 0; } return 1; } Related Documents Types (regexp) Formal Grammar Spec (regexp literal grammar) std::regex (runtime regex API) Character Literals Character literals represent Unicode scalar values (code points) and have type char (Types). Use char for: single-character markers and delimiters (e.g. ',', ':'), working with code points when interfacing with parsing/lexing logic, representing control characters ('\\n', '\\t', '\\0'). If you need multiple characters, use string literals (String Literals). Surface Syntax Character literals are delimited by single quotes: let a: char = 'x'; Rules: The contents must represent exactly one Unicode scalar value. A character literal must not span multiple lines. The source file is interpreted as UTF-8. Escapes Inside a character literal, \\ introduces an escape sequence. Supported escapes in the current implementation: \\n \u2014 U+000A (line feed) \\r \u2014 U+000D (carriage return) \\t \u2014 U+0009 (tab) \\0 \u2014 U+0000 (NUL) \\\\ \u2014 backslash \\' \u2014 single quote \\\" \u2014 double quote \\xNN \u2014 a code point given as exactly two hex digits \\u{...} \u2014 a code point given as 1\u20136 hex digits Unicode rules: The decoded code point must be a Unicode scalar value: range 0x0000..=0x10FFFF, excluding the surrogate range 0xD800..=0xDFFF. For \\u{...}, values outside that range are rejected. Semantics Evaluating a character literal produces a char value whose numeric value is the decoded Unicode code point. In Silk, that code point is carried as a u32 scalar. This is an implementation detail; the language-level rule is \u201ca char is a Unicode scalar value\u201d. Examples ASCII and punctuation fn main () -> int { let comma: char = ','; if comma == ',' { return 0; } return 1; } Unicode: literal UTF-8 vs \\u{...} fn main () -> int { let a: char = '\u00e9'; let b: char = '\\u{00E9}'; if a == b { return 0; } return 1; } Escape sequences fn main () -> int { if '\\n' != '\\x0A' { return 1; } if '\\r' != '\\x0D' { return 2; } if '\\t' != '\\x09' { return 3; } if '\\0' != '\\x00' { return 4; } if '\\\\' != '\\u{005C}' { return 5; } if '\\'' != '\\x27' { return 6; } if '\\\"' != '\"' { return 7; } return 0; } Common Pitfalls Using double quotes: \"x\" is a string, not a char. Use 'x'. Writing more than one character: 'ab' is invalid; use \"ab\". Source encoding surprises: prefer \\u{...} for non-ASCII characters when you want the source spelling to be stable across editors/fonts. Confusing \\xNN between char and string: for char, \\xNN denotes a code point value, for string, \\xNN denotes a raw byte (String Literals). Related Documents Types (primitive char and string) String Literals (string literals and escape sequences) Operators (as casts for int-like types, including char) Relevant Tests Unicode char equality and \\u{...} escape: the runnable fixtures Returning and comparing char values: the runnable fixtures Escape coverage: the runnable fixtures Aggregate Literals Aggregate literals cover arrays and structs. Array Literals Array literals construct fixed-size array values from a list of elements. Surface Syntax An array literal is written using square brackets: let xs = [1, 2, 3]; let ys = [1, 2, 3,]; // trailing comma allowed Empty array literals are permitted only when an expected array type is available from context (so the compiler knows the element type and, for fixed-size arrays, the required length): let empty: i32[0] = []; let emptyslice: i32[] = []; Typing A non-empty array literal has type T[N] where N is the number of elements and T is inferred from the elements (or from an expected type when present). When an expected type is present and it is T[N], the literal must contain exactly N elements. When an expected type is present and it is T[], the literal\u2019s elements are type-checked against T and the resulting value has type T[]. In Silk, this slice form is lowered as a non-owning view over a compiler-generated backing array. The current implementation does not yet enforce lifetime rules for such slices; do not allow a slice derived from a stack-backed array literal to outlive the scope where it was created. Compiler requirements: Infer element type when possible, or require explicit annotation where ambiguity exists. Validate that all elements are convertible to the target element type. Enforce current-subset restrictions on which element types are supported for array lowering/codegen (see Types and Structs, Impl Blocks, and Memory Layout). Struct Literals Struct literals construct values of struct types by specifying field names and values. Surface Syntax A struct literal may be written in two forms: An explicit struct literal begins with a struct type name followed by a brace-enclosed field initializer list. A contextual (inferred) struct literal omits the type name and consists only of the brace-enclosed field initializer list. This form is only valid when an expected struct type is available from context (for example a function argument position or an explicit type annotation). An explicit struct literal looks like: struct Pair { a: int, b: int, } fn make () -> Pair { return Pair { a: 1, b: 2 }; } An inferred struct literal looks like: struct User { name: string, } fn printuser (user: User) -> void { std::println(\"user.name = {}\", user.name); } fn main () -> int { // Equivalent to: printuser(User{ name: \"user name\" }); printuser({ name: \"user name\" }); return 0; } Initializers are written as either: fieldname: <expr> (explicit initializer), or fieldname (shorthand initializer, equivalent to fieldname: fieldname). Initializers are separated by commas and an optional trailing comma is permitted. Example (shorthand): struct User { name: string, } fn main () -> int { let name: string = \"alice\"; let user = User{ name }; // equivalent to User{ name: name } if (user.name != \"alice\") { return 1; } return 0; } Field defaults (struct declarations) A struct field declaration may include a default value expression: struct Beep { value: string = \"boop\", } When a struct literal omits a field, the compiler uses the field default expression when present; otherwise it falls back to zero-initialization in the current backend subset. This means the empty literal form is useful when all fields have defaults: let b = Beep {}; Important notes: Inferred struct literals are a value construction mechanism. They do not imply heap allocation. The compiler will not infer &T from { ... }; use new for heap allocation explicitly. The parser only treats { ... } as an inferred struct literal when it contains a struct-style initializer list (or is {}); blocks ({ Stmt }) remain statement syntax (there is no general \u201cblock expression\u201d in the current subset). Compiler requirements: Enforce that field names are valid and that each field is initialized at most once. Define the behavior for omitted fields (in Silk, omitted fields are default-initialized). Respect struct lowering/layout rules from Structs, Impl Blocks, and Memory Layout. Details The current compiler implementation supports struct literals only for the limited struct subset described in Structs, Impl Blocks, and Memory Layout: structs with 0+ fields of supported value types (scalar primitives, string, nested structs, and supported optionals), literals may omit fields: omitted fields that have a field default (field: T = <expr>) use that default expression, otherwise, omitted fields are zero-initialized in the current backend subset, no duplicate field initializers are permitted, field order is not semantically significant. Boolean Literals Boolean literals are the two built-in logical values: true false They have type bool (Types). Examples Basic control flow fn main () -> int { let ready: bool = true; if ready { return 0; } else { return 1; } } Short-circuit evaluation fn returnsfalse () -> bool { return false; } fn main () -> int { // Because the left operand is true, the right operand is evaluated. let a: bool = true && returnsfalse(); if a { return 1; } // Because the left operand is false, the right operand is not evaluated. let b: bool = false && returnsfalse(); if b { return 2; } return 0; } Common Pitfalls Assuming \u201ctruthy\u201d values: bool is a distinct type. Use comparisons to produce a bool (for example x != 0) rather than writing if x { ... }. Forgetting short-circuiting: && and may skip evaluating the right operand; do not rely on side effects in the skipped operand. Related Documents Types (the bool type) Operators (!, &&, ) if / else (if statement semantics) while Loop (while statement semantics) Relevant Tests Boolean control flow: the runnable fixtures the runnable fixtures Short-circuit semantics: the runnable fixtures the runnable fixtures Unary !: the runnable fixtures Duration Literals The Duration and Instant types have specialized literal support. Syntax Duration literals are written as a decimal integer or decimal float immediately followed by a unit suffix: Examples: 10ns 250us 5ms 1s 1.5s 2min 1h The unit suffix is part of the literal token; the lexer must not split it into an integer token followed by an identifier. Units The current implementation recognizes the following suffixes: ns \u2014 nanoseconds us \u2014 microseconds ms \u2014 milliseconds s \u2014 seconds min \u2014 minutes h \u2014 hours d \u2014 days Semantics Duration literals evaluate to a Duration value represented as an i64 nanosecond count. For integer forms (e.g. 5ms), the value is scaled exactly. For floating-point forms (e.g. 1.5s), the value is scaled and then rounded toward zero to an integral nanosecond count. If the scaled value does not fit in i64, compilation fails. Compiler requirements: Implement lexing rules that distinguish unit suffixes from identifiers. Map duration literals to the Duration type with correct unit scaling. Ensure constant-evaluation behavior (rounding, overflow) matches the spec. Flow Control Overview Flow control describes how Silk programs sequence work, branch, loop, and exit. This concept spans several surface constructs and their static rules (typing, scoping, and diagnostics). Core Constructs if / else loop loops while loops for loops match expressions return break continue blocks and statement composition expression statements Each construct has defined syntax, typing, and evaluation semantics which the compiler must implement. Principles These rules help keep control flow explicit and statically checkable: Conditions are boolean: if and while require a bool condition (no integer \u201ctruthiness\u201d). Bodies are blocks: flow constructs use { ... } blocks as their bodies. Statements are terminated: most statement forms end with ; (for example let, return, break, continue, panic, assert, and expression statements). Quick Examples Branching: fn main () -> int { let x: int = 1; if x == 0 { return 0; } else { return 1; } } Looping: fn main () -> int { let mut i: int = 0; while i < 3 { i += 1; } return 0; } Matching: fn main () -> int { let x: int? = Some(7); let y: int = match x { None => 0, Some(v) => v, }; return y; } See the dedicated documents: if / else loop Loop while Loop for Loop match Expression return break continue Blocks and Statement Composition Expression Statements if / else The if / else construct provides branching based on a boolean condition. In Silk, if is a statement that selects which block of statements executes. The broader language design also includes expression-oriented forms; those are documented as planned where relevant. Surface Syntax Minimal form: if <condition> { ... } With an else: if <condition> { ... } else { ... } Notes: <condition> is an expression; parentheses are optional because the normal expression grammar already includes parenthesized expressions. Bodies are blocks. else may be followed by either: a block (else { ... }), or another if (else if ... { ... }) to form an \u201celse-if\u201d chain. Surface Syntax (Expression Form) Silk also supports if / else as an expression form that yields a value: let v: int = if cond { 123 } else { 456 }; Notes: if expressions require an else branch so the expression yields a value on all paths. The else if ... chain form is supported in expression position: let v: int = if a { 1 } else if b { 2 } else { 3 }; Current compiler subset restriction: the { ... } bodies of if expressions contain a single expression (not a full statement block). Semantics The condition expression is evaluated exactly once. If the condition is true, the if block executes and the else block (if present) does not execute. If the condition is false, the else block executes if present; otherwise the if statement does nothing. Blocks create scopes: Declarations inside the if body are not visible outside that body. Declarations inside the else body are not visible outside that body. Type Checking Rules The condition must have type bool. If it does not, the checker reports a type mismatch (Compiler Diagnostics, E2001). For if expressions: The then and else branches must produce compatible value types. The expression\u2019s result type is the shared branch type (or the expected type when the expression is type-directed). else if Chains The language supports chained conditions (\u201celse-if chains\u201d). The compiler parses else if as sugar for nesting an if inside the else block: fn main () -> int { let x: int = 1; if x == 0 { return 0; } else { if x == 1 { return 1; } else { return 2; } } } The equivalent direct surface form is: fn main () -> int { let x: int = 1; if x == 0 { return 0; } else if x == 1 { return 1; } else { return 2; } } Examples Minimal if / else fn main () -> int { if true { return 0; } else { return 1; } } Boolean expressions in conditions fn main () -> int { let x: int = 1; let y: int = 2; if x < y && y < 10 { return 3; } else { return 4; } } Control flow inside branches fn main () -> int { let x: int = 1; let y: int = 2; if x < y { while false { continue; } return 3; } else { return 4; } } while Loop The while loop repeatedly executes a block while a boolean condition holds. Surface Syntax Minimal form: while <condition> { // body } <condition> is an expression. Parentheses are optional because the condition is parsed using the normal expression grammar: while (x < y && y < 10) { ... } Loop Specifications (#invariant / #variant / #monovariant) The language supports attaching loop specifications immediately before a while. This is part of Formal Silk (see Formal Silk). When Formal Silk syntax is present, the compiler proves these obligations with Z3 at compile time. invariant <expr>; variant <expr>; monovariant <expr>; while <condition> { ... } Semantics Evaluation rules: The condition is evaluated before each iteration. If the condition evaluates to true, the body block executes. After the body completes normally, control returns to the condition. If the condition evaluates to false, the loop terminates and execution continues after the loop statement. Control-flow statements inside the body follow their own definitions: break exits the nearest enclosing loop (break). continue skips to the next iteration (continue). return exits the function (return). panic exits the function via the typed error system (Typed Errors (error, panic, and T ErrorType...)). Blocks create scopes. A let declared inside the body is not visible outside the loop\u2019s body block. Type Checking Rules The checker enforces: The loop condition must have type bool (otherwise E2001). Each #invariant expression must have type bool (otherwise E2001). If present, the #variant expression must have an integer type (int or a fixed-width integer; otherwise E2001). Each #monovariant expression must have an integer type (int or a fixed-width integer; otherwise E2001). invariant, #variant, and #monovariant expressions are compile-time-only (erased from runtime code). When Formal Silk verification is enabled by syntax, they are proved with Z3 during compilation. Examples Minimal loop with break fn main () -> int { while true { break; } return 0; } Loop with invariants and a variant fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; while i < limit { i = i + 1; } return 0; } break break exits the nearest enclosing loop. Surface Syntax break; Notes: break is a statement, terminated by a semicolon. break does not carry a value in the current language design; there is no break <expr> form. Semantics When executed, break;: terminates the innermost enclosing loop (loop, while, or for), and continues execution at the statement immediately following that loop. In nested loops, break only exits the nearest loop: fn main () -> int { while true { while true { break; // exits the inner loop only } break; // exits the outer loop } return 0; } break does not exit the current function. Use return for that. Type Checking Rules break is only permitted inside a loop body. A break outside a loop is a type-check error (Compiler Diagnostics, E2007). Common Pitfalls Forgetting the semicolon (break is a statement). Expecting break to return a value (not supported). Using break outside a loop (rejected, E2007). continue continue skips the remainder of the current loop iteration and jumps to the next iteration of the nearest enclosing loop. Surface Syntax continue; Notes: continue is a statement, terminated by a semicolon. Semantics When executed inside a loop body, continue;: stops executing the remainder of the current iteration\u2019s body, and transfers control to the loop\u2019s \u201cnext iteration\u201d point: for loop, this means jumping to the start of the loop body. for while, this means re-evaluating the loop condition. for for, this means advancing to the next iteration (and for C-style for loops, executing the loop step before re-checking the loop condition). Example: fn main () -> int { let mut i: int = 0; while i < 10 { i += 1; if i == 5 { continue; // skips the return below for i == 5 } // More work could happen here. } return 0; } In nested loops, continue applies to the nearest loop: fn main () -> int { while true { while true { continue; // continues the inner loop } } return 0; } Type Checking Rules continue is only permitted inside a loop body. A continue outside a loop is a type-check error (Compiler Diagnostics, E2008). Common Pitfalls Forgetting the semicolon (continue is a statement). Expecting continue to exit the loop (it does not; use break). Using continue outside a loop (rejected, E2008). return The return statement exits a function, optionally with a value. Surface Syntax Return a value: return <expr>; Return from a void function: return; Semantics When a return statement executes: the current function terminates immediately, and control transfers back to the caller, carrying a return value if the function\u2019s result type is non-void. No statements after a return in the same control-flow path are executed. Type Checking Rules The checker enforces: return is only valid inside a function body (otherwise E2009). In a function with non-void result type R, return must provide an expression whose type is R (otherwise E2009). In a void function, return; is permitted and return <expr>; is rejected (E2009). In a function with non-void result, falling off the end of the function body is a compile-time error (Compiler Diagnostics, E2010). Examples Returning from main fn main () -> int { return 0; } Early return fn main () -> int { let x: int = 1; if x == 0 { return 0; } return 1; } return; in a void function struct Counter { value: int, } impl Counter { fn inc (mut self: &Counter) -> void { self.value += 1; return; } } match Expression The match expression provides structured pattern matching. Key ideas: A match selects one of several branches based on a scrutinee expression. Patterns and guards are defined as per the language specification in this specification. match is an expression; all arms must be compatible in type. The compiler must: Enforce exhaustiveness rules (where specified). Type check each arm and compute a consistent result type. Surface Syntax The full language design includes rich pattern matching, guards, and matching over many scrutinee types. The current compiler implementation supports only a narrow, explicitly documented subset so we can validate end-to-end lowering and code generation. In the current implementation, match is accepted as an expression of the form: match <scrutinee> { <pattern> => <expr>, <pattern> => <expr>, } Notes: Arms are separated by commas; a trailing comma is permitted. Arm bodies are expressions (not blocks) in the current implementation. Optional Matching (T?) The currently implemented pattern subset is limited to optionals: The scrutinee expression must have optional type T? (Option(T)), where T is a payload type supported by the backend. Patterns are restricted to: None Some(<name>) Some() No guards (if ...) are implemented yet. Matches must be exhaustive for the optional scrutinee: there must be exactly one None arm and exactly one Some(...) arm (order is not significant). Example: fn main () -> int { let x: int? = Some(7); let y: int = match x { None => 5, Some(v) => v, }; return y; } Enum Matching (enum) The language design supports matching over user-defined enum types (enum Types). Defined initial subset: The scrutinee expression must have an enum type E (including an instantiated generic enum in module-set builds). Patterns are restricted to enum variants: unit variants: E::Cancelled or Cancelled tuple variants: E::Msg(x) / Msg(x) / E::Pair(a, b) / Pair(a, b) (binders may be identifiers or ) For instantiated generic enums, the qualifier E in patterns may be a type alias for the instantiation (for example type R = Result(int, string); then R::Ok(v) / R::Err(e)), or patterns may omit the qualifier and use the variant name directly. No guards (if ...) are implemented yet. Matches must be exhaustive for the enum scrutinee in the initial subset: there must be exactly one arm for each enum variant (order is not significant). Type Union Matching (T1 T2 ...) The language supports matching over type unions (Type Unions (T1 T2 ...)). Defined initial subset: The scrutinee expression must have a union type T1 ... Tn. Patterns are restricted to typed binders: name: Ti (binds the payload as Ti), or : Ti (matches and ignores the payload), where Ti is one of the union member types. No guards (if ...) are implemented yet. Matches must be exhaustive: there must be exactly one arm per union member type (order is not significant). Semantics (Initial Subset) The scrutinee expression is evaluated exactly once. The selected arm is chosen based on the scrutinee value; non-selected arms are not evaluated. For Some(v) => ..., the binder v is in scope only within that arm and has type T (the inner payload type of the scrutinee T?). The result type of a match expression is the common type of its arms; all arms must type-check to the same result type in the current implementation. match Statement (Typed Errors) The language design also includes a statement form of match used for typed errors (Typed Errors (error, panic, and T ErrorType...)). Surface form: match (expr) { pattern => { ... }, err: SomeError => { std::abort(); } } Key semantic rule (Terminal Arm Rule): If expr is an error-producing expression (its signature includes T ErrorType...), then any arm that matches an error type must end in a terminal statement. The compiler currently implements match as an expression for: the optional subset (T?), and exhaustive enum matches (no guards) for the current CFG IR backend subset. The statement form required for typed errors is implemented as part of the typed errors feature work and is described in Typed Errors (error, panic, and T ErrorType...). Note: the compiler also allows the match statement form to destructure recoverable Result-style values. This form does not trigger the Terminal Arm Rule because it is not a T ... typed-error expression. Result Matching (Ok(...) / Err(...)) The match expression also supports a small subset for recoverable \u201csuccess or error\u201d values. In the current implementation this includes: std::result::Result(T, E) (an enum with Ok(T) and Err(E) variants), and \u201cResult-like\u201d structs of the form { value: T?, err: E? }. For the struct form, the runtime invariant is: exactly one of value and err is Some(...). If this invariant is broken at runtime, execution traps. Patterns: Ok(name) / Ok() Err(name) / Err() Rules: Enum form: The scrutinee expression must have an enum type with variants Ok and Err. Ok(...) / Err(...) patterns are shorthand for R::Ok(...) / R::Err(...) where R is the scrutinee enum type, and may appear alongside other enum variant patterns. Exhaustiveness follows the enum rules: there must be exactly one arm per enum variant. Struct form: The scrutinee expression must have a nominal struct type that contains value: T? and err: E?. Matches must be exhaustive: for enum scrutinees, follow the enum rules (one arm per variant), for struct scrutinees, there must be exactly one Ok(...) arm and exactly one Err(...) arm. In Ok(v) => ..., the binder v has type T. In Err(e) => ..., the binder e has type E. Example: import std::result; import std::strings::String; fn main () -> int { let s: String = match String.fromstring(\"hello\") { Ok(v) => v, Err() => String.empty(), }; return s.len as int; } Relevant Tests Optional match expressions: the runnable fixtures Enum match expressions: the runnable fixtures the runnable fixtures the runnable fixtures the runnable fixtures the runnable fixtures Union match expressions: the runnable fixtures the runnable fixtures the runnable fixtures the runnable fixtures the runnable fixtures the runnable fixtures Result-like match expressions: the runnable fixtures the runnable fixtures the runnable fixtures Typed error-handling match statements: the runnable fixtures the runnable fixtures Structs, Impl Blocks, and Memory Layout Structs and impl blocks are separated: struct declarations define pure data layout. impl blocks attach behavior to types without changing their layout. struct Declarations Structs define a composite data type made of named fields: struct Packet { sequence: u32, size: u16, flag: u8, } Key rules: Structs contain only data members. Memory layout and padding are well-defined so that FFI and ABI rules can rely on them. Stack vs heap allocation is specified in Memory Model (Stack, Heap, and Moves). Generic structs Structs may declare type parameters: struct Data(T) { value: T, } Rules: A generic struct Name(T, ...) introduces a type constructor Name. Outside a generic context, uses of the type must be fully applied (for example Data(u8)), not bare Data. A declaration name may not be reused across different generic arities (for example struct Foo { ... } and struct Foo(T) { ... } cannot both exist in the same namespace). Field Default Initializers Struct fields may include an optional default initializer expression: struct Point { x: int = 0, y: int = 0, } When a struct literal omits a field, the compiler initializes the field from its default expression. In Silk, default field expressions use the same restriction as default function arguments: no name references, and no new. Example: struct Point { x: int = 0, y: int = 0, } fn main () -> int { let p = Point{ x: 5 }; return p.y; // defaults to 0 } Single Inheritance (extends) Silk supports single inheritance for struct declarations via extends. Surface syntax: struct Base { x: int, y: int = 0, } struct Derived extends Base { z: int, } Semantics: A derived struct inherits all fields of its base struct. The derived struct\u2019s field sequence is: 1) all base fields (in declaration order), then 2) all derived fields (in declaration order). Field access on the derived struct can refer to inherited base fields directly (d.x, d.y). Default field initializers are inherited: a Derived{ ... } literal may omit inherited fields that have defaults in the base struct. Type checking rules: extends is permitted only on non-opaque struct declarations. The base name must resolve to a struct type in the compiled module set. Cycles in extends chains are rejected. A derived struct may not declare a field whose name conflicts with an inherited field name. Notes: extends does not imply implicit subtyping in Silk: there is no implicit coercion from Derived to Base (or &Derived to &Base) yet. Opaque Structs (FFI Handles) Opaque structs are a special form of struct declaration intended for safely representing foreign pointers/handles from C APIs. Syntax: // Declares an opaque handle type. struct MyFFIHandle; An opaque struct has no fields and no Silk-defined layout. It exists only as a nominal handle type that can be passed around safely. Rules: Opaque structs cannot be instantiated (no struct literals). Opaque structs do not support field/member access (. / ?.). Opaque structs must not be used by value in type positions (locals, parameters, results). Only the reference form &MyFFIHandle is allowed. These rules increase safety at the language boundary: Eliminates type confusion: distinct handle types such as &DatabaseHandle and &FileHandle are not interchangeable. Prevents invalid operations in Silk: Silk code cannot read/write fields or assume a size/layout for the foreign type. Safety and Undefined Behavior (UB) Opaque handles do not carry lifetime information. You are responsible for calling the corresponding destruction/free function provided by the foreign library. Using an opaque handle after it has been destroyed is undefined behavior. The compiler does not currently enforce this at compile time. ABI and Lowering In Silk, an &Opaque value is lowered as a single pointer scalar (u64 on the current linux/x8664 target), rather than as a struct-of-pointers like &struct borrows. Memory Layout (Intended Contract) The long-term Silk design is for struct layout to match conventional C layout rules for the corresponding field types on the target: Sequential layout: fields appear in memory in the exact order they are declared in the struct definition. Alignment and padding: each field is placed at an offset that is a multiple of the field type\u2019s required alignment. The compiler inserts padding bytes where necessary. Final padding: the overall struct size is padded to a multiple of the struct\u2019s alignment (typically the maximum alignment of its fields), so arrays of the struct keep each element correctly aligned. Example (typical C layout on linux/x8664): struct Packet { sequence: u32, // 4 bytes size: u16, // 2 bytes flag: u8, // 1 byte } Conceptually, this layout would be: sequence at offset 0 (4 bytes) size at offset 4 (2 bytes) flag at offset 6 (1 byte) 1 byte of tail padding at offset 7 to make the total size a multiple of 4 Total size: 8 bytes (alignment 4). Memory Layout the compiler does not implement packed C-like struct layout yet. Instead, it uses a scalar slot model: A struct value is lowered into a sequence of scalar \u201cslots\u201d in source order, after recursively expanding certain composite field types: string contributes two slots: (u64 ptr, i64 len). nested non-opaque structs contribute their slot sequence. optionals contribute (bool tag, payload slots...), where payload slots follow the lowering of the underlying non-optional type. When a struct is stored in memory (stack locals and heap boxes), each slot is stored in a separate 8-byte cell. This means sub-64-bit fields (bool, i8/u8, i32/u32, f32, char, etc.) are not packed yet. Values are still typed as their declared scalar kinds (the checker and IR track widths/sign), but the physical in-memory representation is widened to one 8-byte slot per scalar. This design keeps lowering/codegen simple and lets the compiler support nested aggregates without committing to a final packed layout. The trade-off is that the in-memory representation is not ABI-compatible with a C struct unless the struct is restricted to ABI-safe 64-bit slots. Example : the Packet above is lowered as 3 scalar slots and occupies 24 bytes when stored in memory (3 \u00d7 8-byte cells), even though the intended C-like packed layout would be 8 bytes. ABI and Code Generation The Silk language design includes full support for user-defined structs, nested aggregates, and FFI-safe ABI mapping. The current compiler/backend implementation supports only a narrow, explicitly documented subset: Only \"plain\" structs with 0+ fields are supported by codegen. Empty structs (struct Empty {}) are currently represented as a single placeholder u64 slot in the scalar-slot model. Fields may be: scalar primitive types (bool, fixed-width integers, int, char, f32/f64, Instant, Duration), string (lowered as { ptr: u64, len: i64 }), nested (non-opaque) structs, and optionals (T?) of supported payload types. At ABI boundaries (exported functions and ext declarations), structs must be ABI-safe: after slot-flattening, all slots must be i64/u64/f64 (for example string fields are ABI-safe because they lower to (u64, i64), but bool, char, and f32 fields are not). Such structs are passed and returned by value by lowering them to their scalar slots in order and following the System V AMD64 ABI rules for those scalar slots: integer-like slots consume general-purpose argument slots (rdi, rsi, rdx, rcx, r8, r9, then the stack), f32/f64 slots consume XMM argument slots (xmm0..xmm7, then the stack), 1\u20132 slot results use rax/rdx for integer-like slots and xmm0/xmm1 for float slots, with mixed aggregates using both, 3+ slot results return indirectly via a hidden sret pointer passed in rdi (caller-allocated return buffer), with the callee storing each scalar slot sequentially and returning the pointer in rax. Note: at the C ABI surface, exported functions accept ABI-safe structs by flattening parameters to their scalar slots in order. For 1\u20132 slot structs this is ABI-compatible with passing an equivalent by-value C struct parameter, while for 3+ slot structs downstream C callers should declare separate scalar parameters for the slots. Struct returns with 3+ slots use sret and are ABI-compatible with returning an equivalent C struct by value. This subset is intentionally small so that we can validate the end-to-end type pipeline (parsing \u2192 checking \u2192 lowering \u2192 IR\u2192ELF codegen) while keeping ABI behavior consistent with C for the supported cases. impl Blocks impl blocks attach functions and methods to existing types without affecting memory layout. The intent is to provide \u201chigh-level\u201d APIs without baking behavior into struct layout. In the initial implementation, impl blocks are syntax and type-checking structure; code generation treats methods as ordinary functions that follow the same calling conventions as other Silk functions. Generic impl blocks If a type is declared with type parameters (struct or enum), its impl blocks must also declare those type parameters: struct Data(T) { value: T } // OK: impl Data(T) { fn get(self: &Self) -> T { return self.value; } } // Error: // impl Data { ... } This rule makes monomorphization explicit and ensures method receivers are not ambiguous when the type is specialized. Syntax impl List { // Ordinary static method (no receiver). fn init (cap: i64) -> List { ... } // Heap constructor used by new List(...) (special name, receiver + void). fn constructor (mut self: &Self, cap: i64) -> void { ... } // Instance method (receiver as first parameter). public fn len (self: &List) -> i64 { ... } // Mutating instance method (mutable receiver). public fn push (mut self: &List, value: u8) -> void { ... } } Rules: An impl block attaches methods to exactly one nominal type name (a struct or an enum). Multiple impl blocks may exist for the same type name; the compiler merges their methods (subject to duplicate-name rules). Methods inside an impl block are fn declarations (with bodies). The receiver, when present, is the first parameter and must be a borrowed reference to the impl type (self: &Type or mut self: &Type). Within an impl block, the special type name Self may be used anywhere a type name is accepted, and is treated as an alias for the impl type. For example, self: &Self is equivalent to self: &Type, and -> Self is equivalent to -> Type. Static methods omit the receiver parameter. Method visibility: Methods are private by default: a method declared without an explicit visibility modifier is callable only within the defining impl { ... } block. public fn marks a method as callable from outside the defining impl block. private fn is permitted to make intent explicit. export is reserved for static members (no self receiver) and is not permitted on instance methods; use public fn instead. When an impl block declares conformance to an interface (impl T as I), the interface\u2019s required methods are public by definition: the corresponding impl methods may omit public, but they may not be explicitly marked private. See Interfaces. The method named constructor is treated specially: it is only meaningful for struct types (it backs new Type(...)); enums do not support constructor methods in Silk, it is public by default, when explicitly marked private, it is callable only within the defining impl { ... } block, it may be declared multiple times in a single impl block (an overload set), its overload set includes constructor declarations across all merged impl blocks for the type, it is invoked by heap allocation (new Type(...)) and by certain call-argument coercions (see Types), new Type(args...) invokes the unique overload whose receiver is mut self: &Type, whose return type is void, and whose non-receiver parameter list matches args... after applying the normal call-argument type-checking rules, if multiple overloads are applicable, the compiler prefers overloads that do not rely on implicit call-argument coercions (notably the U -> &T constructor coercion for &T parameters); if multiple overloads remain tied, the call is rejected as ambiguous. Call syntax The surface call syntax uses field-access + call: Instance method call: value.method(arg0, arg1, ...) Static method call: Type.method(arg0, arg1, ...) Semantically, method calls behave like ordinary function calls where the receiver is passed as an explicit first argument. Static-method receiver sugar: If value.method(...) does not resolve to an instance method (a method whose first parameter is a receiver self: &Type / mut self: &Type), the compiler may resolve it as a call to a visible static method of the receiver type by inserting the receiver as the first argument: Type.method(value, ...). This supports fluent chaining for value-consuming helper APIs like std::result::Result.unwrapor: let r: R = / ... /; let x: int = r.unwrapor(0); // sugar for R.unwrapor(r, 0) Mutability rule: If the method receiver is self: &Type, the call site passes a read-only borrow of the receiver (for example value.method(...)). If the method receiver is mut self: &Type, the call site must pass a mutable borrow of the receiver. When the receiver is a name binding that is mutable (let mut value = ...) or a mutable reference binding (for example a mut self: &Type receiver), the compiler treats value.method(...) as a mutable receiver call (no (mut value) wrapper required). The explicit (mut value).method(...) form is permitted but is no longer required for name receivers. limitations: Mutable receiver calls must use a name receiver; mutable borrows from non-name receiver expressions (for example make().push(1)) are rejected. Non-mut receivers may be arbitrary expressions (including calls), so chaining like url.href().asstring() is permitted. Compiler requirements: Keep data layout and behavior separate in the IR. Preserve struct layout exactly for ABI and FFI. Enforce rules for opaque structs and UB as described in this document and the ABI spec. enum Types An enum defines a tagged union type: a value that is exactly one of several named variants, optionally carrying a payload. Use enums to model: finite state machines (connection state, parser state), protocol messages and events, and any API where \u201cexactly one of these cases\u201d is the core invariant. If your goal is \u201ca function can fail with one of several error shapes\u201d, prefer typed errors (Typed Errors (error, panic, and T ErrorType...)) over enums. Surface Syntax Enum declarations introduce a nominal type and its variants: enum RecvJob { Msg(Job), Cancelled, Timeout, } Rules: Variant names are identifiers and must be unique within the enum. Variant names may not be the reserved optional constructors Some / None. An enum must declare at least one variant. A variant is either: a unit variant (no payload): Cancelled, or a tuple variant with one or more payload element types: Msg(Job), Pair(int, int). A trailing comma after the last variant is permitted. Construction Unit variants Unit variants are constructed as values using Enum::Variant (or, in type-directed contexts, just Variant): enum E { A, B, } fn main () -> int { let x: E = E::A; let y: E = A; return 0; } Notes: E::A() and A() are invalid in Silk (unit variants are not callable). Tuple variants Tuple variants are constructed using Enum::Variant(<args...>) where the argument count and types match the variant\u2019s declared payload element types: enum E { Data(int), Pair(int, int), Empty, } fn main () -> int { let a: E = E::Data(7); let b: E = Data(7); let b: E = E::Pair(1, 2); let c: E = E::Empty; return 0; } Notes: E::Data by itself is not a value in Silk (tuple variants must be constructed with (...)). If a tuple-variant constructor argument has the wrong type, you get E2001. If the argument count does not match the variant definition, the compiler currently rejects the construct with E2002. Generic enums (instantiation via alias) When an enum is generic, callers typically alias an instantiation and then use that alias as the qualifier for constructors: enum Result(T, E) { Ok(T), Err(E), } type R = Result(int, int); fn main () -> int { let x: R = R::Ok(123); return match x { R::Ok(v) => v, R::Err() => 0, }; } Namespaced enums (packages) Across packages, enums and variants may be referenced with :: qualification. For example, if util defines enum Mode { Inc, Dec }, an importer can write: util::Mode as the type name, and util::Mode::Inc / util::Mode::Dec as the constructors and patterns. See Packages, Imports, and Exports for module-set rules and for how package imports seed qualified type names. Matching Enum values are typically consumed via match expressions. The match expression rules are defined in match Expression; this section focuses on the enum-specific subset. Patterns Enum patterns are variant patterns: Unit variant: E::A Tuple variant: E::Data(x), E::Pair(a, b) Tuple binder omission: E::Pair(, b) (underscore binder ignores that element) Shorthand: When the scrutinee type is the enum E, the qualifier may be omitted: Unit variant: A Tuple variant: Data(x), Pair(a, b) For instantiated generic enums, the qualifier E may be a type alias (for example type R = Result(int, string); then R::Ok(v) / R::Err(e)). Binders: introduce a name scoped to that arm only, and shadow outer bindings of the same name (because they create a new binding in the arm\u2019s environment). Exhaustiveness In Silk, enum matches must be exhaustive: There must be exactly one arm per enum variant. Each variant must appear exactly once. Wildcard arms ( => ...) are not supported for enum matches yet. If a match is not exhaustive, the compiler currently reports E2002 rather than a dedicated \u201cmissing match arm\u201d diagnostic. Example: unit enum match enum E { A, B, } fn main () -> int { let v: E = E::A; let x: int = match v { E::A => 10, E::B => 20, }; if x != 10 { return 1; } return 0; } Example: tuple enum match (payload binders) enum E { Pair(int, int), Empty, } fn main () -> int { let v: E = E::Pair(1, 2); let x: int = match v { E::Pair(a, ) => a, E::Empty => 0, }; if x != 1 { return 1; } return 0; } Example: struct payload enum match struct Job { id: int, } enum RecvJob { Msg(Job), Cancelled, } fn main () -> int { let j: Job = Job{ id: 5 }; let evt: RecvJob = RecvJob::Msg(j); let rc: int = match evt { RecvJob::Msg(job) => job.id, RecvJob::Cancelled => 0, }; if rc != 5 { return 1; } return 0; } Representation Enums are values. In the current IR-backed lowering, an enum value is lowered to scalar slots as: 1. a u64 tag (variant index in declaration order, starting at 0), and 2. a payload region that includes a distinct slot range for each variant\u2019s payload elements, in variant declaration order. Conceptually: (u64 tag, payload slots for variant 0, payload slots for variant 1, ...) Only the active variant\u2019s payload region is meaningful for a given value; other payload regions are unspecified. This representation is an implementation detail and is expected to evolve (for example, toward a tag + max-payload \u201cunion-style\u201d layout) as the compiler and ABI mature. Common Pitfalls Forgetting parentheses: E::Data(7) is valid, but E::Data is not a value In Silk (error E2002). Calling a unit variant: E::A is a value; E::A() is rejected (E2002). Wrong binder count: E::Pair(a) does not match Pair(int, int) (E2002). Non-exhaustive matches: you must list every variant (error E2002 in the ). Assuming enum equality is defined: use match to inspect the tag/payload; the backend does not define ==/!= over enums yet. Related Documents match Expression (match expression rules) Structs, Impl Blocks, and Memory Layout (struct payloads) Types (nominal types and type annotations) Packages, Imports, and Exports (namespaces and imports) Typed Errors (error, panic, and T ErrorType...) (typed errors, not enums) Relevant Tests Enum matches (end-to-end): the runnable fixtures the runnable fixtures the runnable fixtures the runnable fixtures the runnable fixtures Namespaced enum references (module-set build): the runnable fixtures (built with the runnable fixtures) Interfaces Interfaces allow types to declare that they implement a particular contract. They are the foundation for standard-library \u201cprotocols\u201d such as readers, writers, iterators, and allocators. Key components: The interface declaration. The struct that implements the interface. The impl ... as ... declaration that ties them together. A module ... as ... declaration for module-level conformance. Interface declarations An interface declares a set of required method signatures. Syntax: interface Element { fn onclick(event: &Event) -> void; } Rules: Interface members are method declarations introduced with fn. Interface methods have no body and end with ;. Parameter types in interface methods should be explicitly annotated (the compiler should not rely on type inference for interface contracts). Interface methods are part of a public contract: interfaces do not have private members, and interface method declarations do not accept visibility modifiers. Generic interfaces Interfaces may declare type parameters: interface Channel(T) { fn send(value: T) -> bool; fn recv() -> T?; } Rules: Generic parameter lists use the same syntax as structs ((T, ...)). Type parameters may provide default type arguments (T = Type). When defaults are present, use sites may omit trailing arguments that have defaults. The interface name is a type constructor and must be applied with the correct number of type arguments where a concrete interface type is required (for example in impl ... as ... declarations). Self in interface signatures Within an interface method signature, the special type name Self refers to the concrete implementing type when checking impl Type as Interface { ... } conformance. Interface inheritance (extends) Interfaces may use extends for single inheritance: interface BaseLogger { fn log(msg: string) -> void; } interface FancyLogger extends BaseLogger { fn warn(msg: string) -> void; } Semantics: An interface that extends another interface inherits all of the base interface\u2019s method signatures. A conformance declaration (impl T as I or module ... as I) must satisfy the full inherited interface surface. Rules: extends is permitted only on interface declarations. Only single inheritance is permitted (at most one extends base). Cycles in extends chains are rejected. A derived interface may not redeclare a method with the same name as an inherited base method. Implementations (impl ... as ...) An implementation block declares that a concrete type implements an interface and provides method bodies. Example: interface Element { fn onclick(event: &Event) -> void; } struct Button { handle: i64; } impl Button as Element { fn constructor(...) -> Button { ... } fn onclick(self: &Button, event: &Event) -> void { ... } } Applied interface types: interface Read(T) { fn read() -> T; } struct ByteSource { / ... / } impl ByteSource as Read(u8) { fn read(self: &ByteSource) -> u8 { / ... / } } Compiler requirements: Represent interface types and impl ... as ... relationships. Enforce that all required interface methods are implemented with compatible signatures. Treat required interface methods as public by definition: impl methods that satisfy an interface requirement may omit public, but they may not be explicitly marked private. Conformance rules (initial implementation): For an interface I { fn m(p0: T0, ...) -> R; }, the corresponding impl must provide a method m whose signature matches after accounting for the receiver: the impl method\u2019s first parameter is the receiver self: &Type (or mut self: &Type), and the remaining parameters and result type must match the interface method. Exception (static protocol, implemented subset): std::interfaces::Deserialize(S) is a static conversion protocol used by as casts. Its conformance does not use a receiver parameter: impl T as std::interfaces::Deserialize(S) provides fn deserialize(value: S) -> Self (no self parameter), calls use T.deserialize(value). Generic interface conformance rule: When the as clause names an applied generic interface type (for example Read(u8)), all type arguments must be fully known at the conformance site, unless the conformance itself is generic and binds those type parameters (for example impl Data(T) as DataInterface(T)). Module conformance (module ... as ...) A module declaration may declare conformance to an interface: interface Logger { fn log(msg: string) -> void; } module myapp::logger as Logger; export fn log (msg: string) -> void { // ... } Conformance rules: For an interface I { fn m(p0: T0, ...) -> R; }, the corresponding module must provide a function m whose signature matches exactly: there is no receiver parameter for module conformance, and the parameter and result types must match the interface method. In Silk, module conformance is checked against the module\u2019s exported functions (written as export fn ...), since those are the module members that are visible across module boundaries. Generic module conformance: A module may declare conformance to an applied generic interface type (for example module myapp::bytes as Read(u8);). All interface type arguments must be fully specified (modules do not bind their own type parameters). Dispatch model (status) objects / vtables) is part of the language design, but is not implemented yet. For the initial compiler/backend subset, interface use is limited to: declaring interfaces and impl blocks, and calling methods directly on concrete types (no interface-typed values at runtime). special-case compiler hooks for specific interfaces (currently std::interfaces::Drop for deterministic cleanup; see std::interfaces and Memory Model (Stack, Heap, and Moves)). Packages, Imports, and Exports This document specifies the initial surface syntax for packages, imports, and exports in Silk. The semantics are intentionally minimal for now and will be extended as the compiler\u2019s resolver and linker mature. Terminology Source file: a single .slk source file. Package: a named collection of source files that share a namespace (declared via package ...;). Module declaration: a module ...; header that declares a namespace and a compile-time-only module value, and may declare interface conformance via as. Module set: the set of source files the compiler is compiling together for a given command. Package imports can only resolve to packages that exist in this module set. Named import: import { A, B as C } from \"...\"; (introduces unqualified names). Default import: import X from \"...\"; (binds either a default export symbol or a namespace, depending on what is imported). Namespace import: a default import that binds a module or package namespace; you access its members as X::Name. Packages A Silk program is organized into packages and source files. Each source file may declare the package it belongs to using a package declaration at the top of the file: package myapp::core; Rules: Each module MAY declare at most one package declaration. When present, the package declaration MUST appear before all other top-level declarations in the module; it is the first declaration in the file. Package names are sequences of identifiers separated by ::. As a special case, the keyword task is permitted as a ::-qualified segment so std::task is a valid package name. std::strings std::task myapp::core example The standard library lives under the reserved std:: namespace, for example std::strings, std::memory, etc. If a source file omits a package declaration, it is treated as belonging to an implementation-defined default package (for example, the \u201cmain\u201d package for an executable). The exact rules for default packages will be specified as multi-module builds are implemented. In the current silk CLI implementation, when building a package via a package manifest (silk.toml), source files that omit package default to the manifest\u2019s package.name. See Package Manifests (silk.toml). Modules (module) module declares a named module namespace and a compile-time-only module value. Syntax: module myapp::core; module myapp::core as SomeInterface; Rules: A source file MAY declare at most one module declaration. A source file MAY declare at most one of: a package declaration, or a module declaration. When present, the module declaration MUST appear before all other top-level declarations in the source file; it is the first declaration in the file. Module names follow the same ::-qualified naming rules as packages. Modules are compile-time-only values: there is no runtime representation for a module value. If a module declares as <Interface>, the compiler MUST validate that the module satisfies the interface surface as specified in Interfaces. Inline modules (module Name { ... }) In addition to the source file header form (module ...;), Silk supports inline modules as a nested-namespace mechanism inside a file: package mypackage; export module innermodule { export fn hello () -> string { return \"hello world\"; } } Rules : Inline modules MUST appear at top level (not inside function blocks). The inline module name is a single identifier. The body is a brace-delimited list of top-level declarations; inline modules may be nested. package, header-form module ...;, and import declarations are not permitted inside an inline module body. Declarations inside an inline module are referenced from outside using :: qualification (innermodule::hello()). Within an inline module body, unqualified name lookup for inline-module declarations is not implemented yet in Silk; use explicit :: qualification. export module Name { ... } exports the namespace: exported declarations inside it become part of the containing package\u2019s export surface with their names prefixed by Name:: (for example innermodule::hello), nested export module declarations extend the prefix (for example outer::inner::name). Source File Header Ordering (Mandatory) In each source file, top-level declarations must appear in this order: 1. Optional package or module declaration (package ...; or module ...;). 2. Zero or more import declarations, as a contiguous block. 3. All other top-level declarations. This ordering is enforced by the parser/resolver and keeps dependency structure easy to understand and tooling-friendly. Imports Source files may refer to other packages or modules via import declarations: package myapp::core; import std::strings; fn main () -> int { return 0; } Rules: import declarations MUST appear at top level (not inside functions or blocks). All import declarations in a module, if any, MUST appear after the optional package declaration (if present) and before any other kind of top-level declaration. In other words, imports form a contiguous block at the beginning of the module immediately following the optional package. An import path is a sequence of identifiers separated by ::, matching the package naming rules above (including the std::task special case). As with expression/type qualified names, an import path MAY start with :: to explicitly name the global namespace (the unnamed package). import declarations identify dependencies and bring exported symbols from the imported package into scope in the importing module, subject to the visibility rules below. In the current implementation: importing a package makes its exported let bindings with explicit type annotations visible as ordinary, unqualified names in the importing module (for example, import util; followed by answer refers to util::answer when util exports let answer: int = 42;), imported exported let bindings are also reachable via qualified names of the form pkg::name (for example, util::answer after import util;); both unqualified (answer) and qualified (util::answer) forms are accepted for now, but the qualified form reflects the intended package-namespaced style, exported functions (export fn) are callable across packages for the compiler\u2019s current backend subset: within a package, top-level functions form a shared namespace across all modules in that package (so functions in one module may call functions defined in another module of the same package), when a module imports a package, that package\u2019s export fn declarations become callable from the importing module, both unqualified (foo()) and qualified (util::foo()) call forms are accepted initially for imported exports, matching the current constant-import behavior, though the qualified form reflects the intended package-namespaced style, this callable subset is limited to the compiler\u2019s current code generation subset (supported parameters/results, direct calls, and structured control flow supported by the IR\u2192ELF backend on linux/x8664), struct type names (struct declarations) from imported packages are visible in the importing module for the current supported struct subset: the qualified form pkg::Struct is always accepted when pkg is imported, the unqualified form Struct is accepted when it is unambiguous across the module\u2019s imports and does not conflict with a locally defined struct name, when multiple imported packages define the same struct name, the unqualified form is rejected as ambiguous and the qualified form must be used, enum type names (enum declarations) from imported packages are visible in the importing module for the current supported enum subset: the qualified form pkg::Enum is always accepted when pkg is imported, the unqualified form Enum is accepted when it is unambiguous across the module\u2019s imports and does not conflict with a locally defined type name, enum variants are referenced relative to the enum name (Enum::Variant or pkg::Enum::Variant), if an imported package does not exist, resolution fails before type-checking (see the resolver). a leading :: on a qualified name forces lookup in the global namespace (the unnamed package), bypassing any same-named declarations in the current package or imported packages. This is intended as an explicit escape hatch for shadowing (for example, calling ::malloc(...) when the current module also defines or exports malloc). The prefix is valid in both expression and type positions, including: values: ::malloc(...), types and struct literals: ::Foo and ::Foo{...}, enum variant paths/patterns: ::E::Variant. Qualified Symbol Imports In addition to importing whole packages, a module may import a single symbol by fully qualifying it: import std::io::println; import std::url::URL; import ::malloc; Semantics: If the import path matches a package name present in the module set, it is a package import (import std::io;). Otherwise, it is treated as a qualified symbol import: the compiler finds the longest package-name prefix of the path, the remaining suffix is the symbol name within that package (it may contain :: due to exported inline modules), the symbol is introduced into the importing module under its final path segment (for example, println for import std::io::println;). When the import path begins with ::, the symbol is resolved from the global namespace (the unnamed package) and is not subject to package export gating. import { Name } from \"...\"; remains the preferred form when you need to rename imports (as) or import from a file path. Global namespace (::name) rules : The global namespace is the package formed by modules that have no package ...; or header-form module ...; declaration (their package name is empty). ::Name resolves Name from that global namespace, if a matching declaration exists in the current module set. ::Outer::Inner::Name resolves Outer::Inner::Name from that same global namespace (for example, names nested under inline modules in a global module). Global names are only accessible via the explicit :: prefix; there is no implicit \u201cprelude import\u201d of global symbols. Future extensions may introduce aliasing (e.g. import std::strings as str;) and more fine-grained import forms. Such features will be documented here before they are implemented. Example: a two-module package program Two modules can share a package name and export symbols for other packages to use. // util.slk package util; export let answer: int = 41; export fn add1 (x: int) -> int { return x + 1; } // app.slk package app; import util; fn main () -> int { // In the current implementation, both unqualified and qualified access are // accepted after importing a package. Prefer the qualified form to make the // origin explicit. if util::add1(util::answer) != 42 { return 1; } return 0; } Package imports resolve against the module set In the current implementation, a package import can only resolve if the package exists in the current module set. This matters most when you use package specifiers (from \"nspkg\") or when you expect a package import to find a package that is not otherwise present. Tooling note (the silk CLI): The language semantics are still \u201cimports resolve against the module set\u201d. The CLI grows the module set by loading additional source files. In addition to auto-loading std::... packages from the stdlib root, the CLI MAY load non-std:: packages from a package search path when a bare package specifier is imported (e.g. import api from \"myapi\";). The package search path is configured via SILKPACKAGEPATH (PATH-like: roots separated by : on POSIX). A package name like myapi::core maps to the filesystem candidate <root>/myapi/core/silk.toml. The first matching manifest in search order is used. Qualified imports that include extra :: segments (e.g. myapi::core::Thing) are treated as qualified symbol imports: the CLI resolves the longest package prefix that exists (myapi::core, then myapi) and loads that package into the module set. Example: bringing a package into the module set via a file import, then importing the package namespace: // main.slk import { answer as ignored } from \"./supportpkgnspkg.slk\"; // declares package nspkg; import pkg from \"nspkg\"; // now resolves because nspkg exists in the module set fn main () -> int { return pkg::add1(pkg::answer); } If you omit the file import (or otherwise fail to include a module that declares package nspkg;), the package import fails with E1001 (\u201cunknown imported package\u201d). From the CLI, the usual fix is to ensure the missing package\u2019s module(s) are part of the command\u2019s module set (for example by passing their .slk files to silk check / silk build, or by adding a file import). See silk CLI and CLI Usage Examples. Import Specifier Imports (JS-style) In addition to import pkg::name; package imports, Silk supports JS-style import forms that use a string literal import specifier after from. An import specifier string is interpreted in one of three ways: File specifier: the string begins with ./ or ../, or is an absolute path. These imports resolve to a module by file path. Std-root file specifier: the string begins with std/. These imports resolve to a module by file path under the configured stdlib root (see the stdlib root selection rules in silk CLI and C99 ABI and libsilk.a). Package specifier: any other string. These imports resolve to a package by name (for example \"ui\" or \"std::strings\"). Note: in Silk, package specifiers are matched literally against package names present in the module set. In practice this means the specifier must be a valid Silk package path (identifiers separated by ::, with task permitted as a :: segment). This mirrors the common JS convention that relative file imports must start with ./ or ../. Silk additionally reserves the std/ prefix for stdlib source imports resolved via the configured stdlib root. Example (namespace-style imports): import ui from \"ui\"; // package namespace import helpers from \"./helpers.slk\"; // file module namespace (if no default export) fn main () -> void { let opts: &ui::WindowOptions = new ui::WindowOptions(); helpers::dosomething(); } Named imports Named imports import selected exported names directly into the importing module: import { StringBuilder, writeu8 as writeByte } from \"./runtime.slk\"; Notes: There is no combined import foo, { bar } from \"...\"; form in the current grammar. Use separate import declarations. For non-std/ file specifiers, include the .slk extension explicitly. (Only std/... specifiers get .slk appended automatically in the current implementation.) Rules: File imports MUST appear in the same import-declaration block as package imports: after the optional package declaration and before any other top-level declaration. The from keyword is part of the import syntax. The from specifier may be either: a string literal (from \"./file.slk\", from \"std/io\", from \"nspkg/sub\"), or a package path (from std::io;, from nspkg::sub;). If the specifier is a file specifier, it is resolved relative to the importing file\u2019s directory. ./ and ../ path segments are permitted. (Absolute paths are permitted for tooling, but downstream projects should prefer relative imports.) If the specifier is a std-root file specifier (\"std/<path>\" or \"std/<path>.slk\"), it is resolved relative to the configured stdlib root and then treated as a file import. If the .slk extension is omitted, it is appended during std-root resolution. If the specifier is a package specifier, it is interpreted as a package name (using the same ::-separated syntax as package declarations) and is resolved via the package graph. The imported module MAY declare a package or omit it. File specifiers refer to the target module by file path, not by package name. Exported names for named imports: Named imports can import: exported values: export fn, export let, and exported ext bindings, and type names: struct, enum, error, and interface declarations (treated as visible across module boundaries in the current implementation), exported type aliases: export type ...;, and exported Formal Silk theories: export theory declarations (importable so they can be applied via #theory Name(args);). impl blocks do not introduce importable names directly, but loading the imported module makes its methods available for method-call checking on the corresponding types. Name binding rules: Each entry in the { ... } list names one imported symbol. as can be used to rename an imported symbol (Name as Alias). For values (fn / let / ext), this introduces a value alias. For type names (struct / enum / error / interface) and exported type aliases (export type), this introduces a local type alias (transparent: it does not create a new type identity). For Formal Silk theories (export theory), this introduces a theory alias. Imported names are introduced into the importing module as unqualified names (matching the existing behavior for package imports). Importing an unknown name from a file is an error. Importing the same value name from multiple file imports without aliasing is an error. Importing a value name that is already visible in the module (for example via same-package scope or a package import) is treated as a no-op in the current implementation unless it conflicts with a local declaration in the importing module. Importing a type name that is already visible in the module is treated as a no-op in the current implementation. Default imports and namespace imports A module may declare a single default export and importing modules may bind that default export with a JS-style default import: // module.slk package module; export default fn () -> int { return 1 + 2; } // main.slk import foo from \"./module.slk\"; fn main () -> int { let value = foo(); if (value != 3) { return 1; } return 0; } Rules: Default exports are module-level and are consumed by default imports (import Name from \"<specifier>\";). A default export may be declared in either of two ways: a default-exported function declaration: export default fn ... (the function name is optional only in this form), or a default-export statement: export default Name; (names an in-scope symbol in the current module). Default exports may target any top-level symbol kind that can be referenced by name: functions (fn), top-level bindings (let / const / var), external bindings (ext), type aliases (type), nominal types (struct, enum, error, interface), Formal Silk theories (theory). Each module MAY declare at most one default export. A default export is distinct from named exports: export default fn add () -> int { ... } declares a default export whose internal name is add within the module, but it does not implicitly create a named export of add for other modules. To export it as a named export, write export fn add ... (or add an explicit named export form once one exists in the language). The function name after fn is optional only for default exports. When the name is omitted (export default fn () -> ...), the function is anonymous in the surface language and can only be referenced by importing it via a default file import. Default imports have two behaviors depending on whether a default export exists: If the imported module declares export default, the local name binds to that default-exported symbol. If the imported module does not declare a default export, the default import becomes a namespace import: the local name refers to the imported module\u2019s namespace and its exported names are accessed via foo::Name. In other words: if there is no explicit default export, the module\u2019s namespace is treated as the default export. When a default import binds a default export, it introduces a single unqualified name into the importing module: if the default export is callable (a fn or an ext function), it binds a callable value name (foo()), if the default export is a type (struct/enum/error/interface/type), it binds a type name usable in type positions (and as the head of struct literals), if the default export is a Formal Silk theory, it binds a theory name that may be applied via #theory foo(args...);, if the default export is a non-callable value (let/const/var or a non-function ext), it binds a value name. When a default import binds a namespace, it does not introduce any unqualified imported names; you must use foo::Name to access exported names. Using a namespace import name as a callable (e.g. foo()) is an error; add an explicit export default to the imported module or use a named import. Package namespace imports: For a package specifier (for example import ui from \"ui\";), the default import binds the package\u2019s default export when the package declares one. Otherwise, it binds a namespace and exported names are accessed via ui::Name. Exports Top-level declarations can be marked as exported using the export modifier: package myapp::core; export fn main () -> int { return 0; } export let answer: int = 42; Rules: export is not allowed inside blocks; it applies only to module-level declarations. Inside impl blocks, public controls method visibility and export is reserved for static members. The initial implementation supports export on: functions (export fn ...), let and const bindings (export let ..., export const ...). ext declarations (export ext name = ...;), Formal Silk theories (export theory Name(...) { ... }), type aliases (export type Name = ...;), struct declarations (export struct Name { ... }), enum declarations (export enum Name { ... }), error declarations (export error Name { ... }), interface declarations (export interface Name { ... }), static members inside impl blocks (impl T { export fn ... } with no self receiver). The export modifier marks a declaration as part of the package\u2019s externally visible surface. The exact visibility rules across packages (including how exports appear in the resolver and back-end symbol tables) will be specified and implemented alongside the package graph in Compiler Architecture. In the current implementation, most type names are treated as visible across module boundaries once the relevant module(s) are loaded into the module set. The export modifier is still recorded on type declarations so the package/export model can be tightened later without changing source. Re-export declarations (export { ... };) In addition to export fn ... and export let ..., Silk supports exporting an already in-scope name via a re-export declaration: import { myfunction } from \"./module.slk\"; export { myfunction }; This is the idiomatic way to build \u201cbarrel\u201d modules that forward selected exports from other modules. Rules : A re-export declaration must appear at top level and ends with ;. Each entry in the { ... } list names a local in-scope symbol. The entry may rename the exported name: export { localName as ExportedName };. Re-exported names are part of the module/package export surface, so other modules may import them via import { Name } from \"./barrel.slk\";. In the current implementation, export { ... } supports values and exported Formal Silk theories (theory declarations). It does not export type names. Common Pitfalls Forgetting semicolons: package and import declarations end with ; (parse error, E0001). Imports not at the top: imports must come immediately after the optional package declaration and before any other top-level declaration (E0001). Assuming package imports find code automatically: a package import can only resolve if the package exists in the module set (fix by adding the relevant .slk files to the build, or by file-importing them; missing packages are E1001). Calling a namespace import: if import foo from \"./mod.slk\"; binds a namespace (because there is no default export), then foo() is invalid; use foo::Name or add export default (E2018). Name collisions with named imports: when importing from multiple modules, use as to rename one binding (E2004). Relevant Tests Package import + unqualified/qualified access: the runnable fixtures the runnable fixtures (module-set package import; built with the runnable fixtures) Namespace imports (file and package): the runnable fixtures the runnable fixtures Named imports + aliasing: the runnable fixtures the runnable fixtures Re-exports (export { ... };): the runnable fixtures (built with the runnable fixtures and the runnable fixtures) the runnable fixtures (built with the runnable fixtures) Default exports: the runnable fixtures Importing types and using exported methods: the runnable fixtures Optional The Optional type provides a safe way to represent values that may or may not be present, instead of relying on sentinel values such as null. The nominal type constructor is Option(T). The shorthand T? is sugar for Option(T) and is the recommended form. Optional values are constructed using Some(...) and None (the compiler also accepts none as an alias of None). The null literal is distinct from None, but may coerce to None when an optional type is expected. Use match, ?. (optional chaining), and ?? (coalescing) to consume optionals. Declaring Optional Types You can declare variables or fields as optional using either: T? (idiomatic suffix form), Option(T) (nominal form). The language design treats these as equivalent. The type system (the implementation) models optional types, and the parser now accepts both: the suffix form T? in type annotations, and the nominal form Option(T) for simple cases (a single type argument), which is desugared into the same internal optional representation as T?. For example, the following is valid today and type-checks successfully (note that the current compiler requires let initializers; see Compiler Diagnostics, E2015): fn main () -> int { let a: string? = None; let b: Option(string) = None; return 0; } The current linux/x8664 IR\u2192ELF backend subset now supports a first slice of optional values for a subset of payload types: construct optionals via None and Some(value), access fields of optional structs via optional chaining (opt?.field, producing a FieldType? value), use nested optionals (T??) for a subset of payloads in the current backend (see below), compare supported optionals via == / != (tag + payload equality; nested optionals compare recursively), unwrap optionals via ?? (coalescing) with short-circuit evaluation of the fallback expression, explicitly branch on optionals via the match expression (see match Expression), and pass/return such optionals between helpers in the supported IR subset. Supported optional payloads in this backend subset include: scalars (bool, char, f32, f64, int, and fixed-width integers), string (lowered as { ptr: u64, len: i64 }), enums (tagged unions) in the current enum backend subset (lowered as (u64 tag, payload0, payload1, ...)), and the supported struct subset (0+ fields of supported value types, including nested structs and optionals; see Structs, Impl Blocks, and Memory Layout). In this subset, optionals are represented at IR boundaries as a Bool tag followed by the payload scalars: (Bool tag, payload0, payload1, ...) where tag=0 means None and tag=1 means Some(...). The payload scalar slots follow the same lowering rules as the underlying non-optional type (1 scalar for scalar payloads, 2 scalars for string, N scalars for the current struct subset, and N scalars for enums (including the enum\u2019s own u64 tag slot). Nested optionals (T??) are supported in this backend subset for the same payload subset (scalars, string, enums, and the supported struct subset). In this subset, T?? is represented as an outer optional whose payload is the full inner optional representation: for example int?? lowers as (Bool tag0, Bool tag1, i64 payload). Not yet implemented: optional chaining beyond the current optional-struct field access subset (for example chaining through optional fields, optional method calls, and optional indexing), match over non-optional scrutinee types (and richer pattern forms beyond None/Some(...)), and richer optional forms beyond the backend. Note: optional payload equality (== / !=) is still limited in the current backend subset; comparisons against None are supported broadly, but full payload equality for all optional payload kinds (notably optional-of-enum) is still evolving. For the current C ABI mapping of optionals in exported function signatures within the supported backend subset, see C99 ABI and libsilk.a and External Declarations (ext). Creating Optional Values An optional can be: None \u2014 the empty state. Some(value) \u2014 the value\u2011holding state. Examples from the spec: let age: u32? = None; let age: u32? = Some(30); struct User = { profile: None }; profile: Some({ email: \"some@example.com\", age: Some(30) }) The compiler infers the optional\u2019s element type from context when possible. In the current implementation, equality comparisons provide optional type context for None / Some(...) operands, so forms like opt == None and opt == Some(value) type-check when opt has type T?. None: The Empty State None represents the absence of a value. Spelling note: None may also be written as none (alias). The null literal is a distinct literal that can coerce to None in optional contexts. Key points: None can be assigned to any T?; its concrete T is inferred. In pattern matching and control flow, None corresponds to the empty branch. Some(value): The Value-Holding State Some(value) wraps a concrete value in an Option(T). Key points: The type of Some(value) is T? (or Option(T)). Nested optionals are allowed (e.g. a struct containing fields that are T?). Optional-Coalescing Operator ?? The ?? operator unwraps an optional by providing a fallback value if it is None. From the spec: It \u201ccoalesces\u201d the optional\u2019s value and the default into a single, non\u2011optional result. The expression opt ?? defaultvalue has type T when opt has type T?. When opt has type T??, the expression opt ?? defaultvalue has type T? (it unwraps one optional layer). It composes naturally with optional chaining. Example: let emailaddress: string = user2.profile?.email ?? \"no-email-provided@domain.com\"; Using Optional Values The spec provides several mechanisms for working with optionals: Optional chaining ?.: user.profile?.email yields string?. If any link in the chain is None, the result is None. Coalescing ??: Converts an optional into a non\u2011optional by supplying a default. Explicit checking via match: Pattern\u2011matching on Some(...) / None to handle both cases explicitly. Compiler Requirements The compiler must: Support T? and Option(T) as equivalent surface forms. Ensure that Some / None usage is type\u2011correct. Track optionality in the type system and enforce checks when unwrapping. Implement ?. and ?? with the short\u2011circuit semantics described above. Support match on Option(T) and integrate optionals with flow control and error reporting. Errors This document summarizes the Silk error-handling model at a level suitable for compiler implementation. It is based on the language design captured in this specification (optionals, verification, ext, ABI). For unrecoverable logic bugs and contract violations, Silk uses typed errors (error, panic, and T ErrorType...), specified in Typed Errors (error, panic, and T ErrorType...). Design Goals Error signaling is explicit and typed (no hidden global error state). Error paths are part of normal control flow, not out-of-band exceptions. The verifier can reason about both success and error paths symmetrically. The C99 ABI must be able to represent error outcomes in a stable, documented way. Recoverable Errors (Recommended Pattern) Silk distinguishes between: Recoverable errors (invalid user input, I/O failures, parse failures): model these as normal values, typically using std::result::Result(T, E) or an optional (T?). Typed errors (T ErrorType... + panic): reserved for unrecoverable contract violations and logic bugs that should not be silently ignored (see Typed Errors (error, panic, and T ErrorType...)). Example: Recovering from URL parse errors std::url exposes a recoverable parsing API (std::url::parse) that returns a tagged result (std::url::URLResult), so callers can report an error and keep going without aborting. A runnable example that wraps URLResult into std::result::Result and parses all command-line arguments is in: an example program Error Representation From the overall language design: Silk favors explicit types such as: optionals (T? / Option(T)) for \u201cmay be present / may be absent\u201d values. domain-specific error types (enums or structs) for richer error reporting. Functions that can fail should surface that in their type signatures: either by returning a value that encodes both success and error (e.g. an optional or a nominal error-aware type), or by returning an error-only type where success is absence of error. The naming and shapes of error-carrying types are defined by this language spec and by standard library APIs, but the compiler must: treat them as regular, first-class types, enforce that callers handle them appropriately (e.g. via pattern matching, explicit checks). Interaction with Control Flow Error-aware types integrate with control flow constructs: if / match can be used to branch on error vs. success cases. Pattern matching can destructure enum-based error types, exposing error codes or payloads. Optionals (T?) can be used where \u201cabsence\u201d is a common error shape; they compose with ?. and ?? to keep code concise while still explicit. The compiler must: ensure that branches that depend on error conditions are type-checked, support exhaustiveness checks when matching on error enums/types. Verification and Errors Formal Silk constructs (#require, #assure, #assert, #invariant, #variant, #monovariant) apply equally to: success paths (e.g. postconditions describing the returned value), error paths (e.g. guarantees about when and how certain errors can occur). The verifier should be able to: treat error-carrying types as ordinary values with invariants, prove that certain errors cannot happen given preconditions, or, conversely, require explicit handling of error cases when the proof cannot eliminate them. ABI and FFI Considerations On the C99 side: Error values exposed through libsilk.a should use well-defined C types (e.g. enums or structs) documented in C99 ABI and libsilk.a. For external functions declared via ext, any error behavior must be captured in the Silk-side function type and corresponding C signature (e.g. error-return codes, nullable pointers, or explicit error structs). The compiler must: preserve error-related information across the FFI boundary, avoid implicit, hidden error channels (such as untracked global error codes) in favor of explicit parameters or return values. Assertions (assert) assert is a debugging/safety construct intended to catch programmer mistakes. It is not part of Silk\u2019s typed error model and is not a replacement for returning optionals or Result(...). Syntax (initial): assert <Expr>; assert (<Expr>, <message>?); Rules: The condition expression must type-check as bool. The optional message, when present, must type-check as string. Runtime behavior : By default (release builds), if the condition evaluates to false, execution traps immediately (a panic-like abort). In the current linux/x8664 backend this is implemented as an invalid-instruction trap. In debug builds (silk build --debug / -g) on linux/x8664, a failed assertion prints a panic header, the optional message (when present), and a stack trace to stderr when available (via glibc backtracesymbolsfd) before aborting. Notes: Failed assertions are currently isolated by the silk test runner (each test runs in its own process). Future work may allow reporting failed assertions without process isolation (for example by lowering assert to a typed error in test contexts). See also: Testing. Typed Errors (error, panic, and T ErrorType...) Silk\u2019s typed error system exists to eliminate the \u201ctrust gap\u201d between a function\u2019s signature and its real behavior. There are no hidden exceptions and no implicit panic channel: if a function can terminate due to a logic bug / contract violation, it must say so in its signature, and the compiler must enforce it. This document specifies the surface syntax and checker rules for typed errors. The compiler supports error declarations, panic statements, error-aware return types (T ErrorType...), and the match statement form for handling typed errors (including the Terminal Arm Rule), plus the postfix ? propagation operator for error-producing calls. Overview An error represents an unrecoverable logic bug or contract violation. A function that can panic must declare that in its return type using : fn getat(xs: &u8[], index: int) -> u8 OutOfBounds; A typed error is triggered with panic, which terminates the current function and propagates the error to the caller. Typed errors are handled explicitly via match (statement form), and any arm that handles an error must end in a terminal statement. This model is intentionally closer to \u201ctyped, explicit non-local errors\u201d than to try/catch exceptions or an implicit panic mechanism. Recoverable errors are values (not typed errors) Typed errors are intentionally not the primary mechanism for routine runtime failures such as: invalid user input, parsing failures, I/O failures. Those should typically be modeled as ordinary values using std::result::Result or optionals (T?) so callers can handle them and continue normal execution. See: Errors (overview), std::result (recoverable Result(T, E)), std::url and an example program (recoverable URL parsing example). Declaring Error Types (error) Syntax: error OutOfBounds { index: int, len: int } Rules: error Name { ... } declares a nominal, struct-like type that represents an unrecoverable logic bug / contract violation. An error declaration has the same field rules as struct in the current compiler subset (scalar fields; see Structs, Impl Blocks, and Memory Layout). An error type may also be used as data (returned, stored, logged) when it is not part of a T ... error contract. The compiler treats error as a distinct nominal type category (separate from struct) but reuses the same field/layout rules in Silk. Error-Producing Function Signatures (T ErrorType...) A function declares that it may panic by adding one or more error types after its success type using . Examples: fn getat(xs: &u8[], index: int) -> u8 OutOfBounds { ... } fn parse() -> Packet? PacketTooLarge { ... } fn init() -> void InitFailure { ... } Note on disambiguation: In function declarations, an unparenthesized sequence after -> is always parsed as a typed-error contract. To return a union type from a function, parenthesize the union: fn f () -> (A B); fn g () -> (A B) SomeError; See Type Unions (T1 T2 ...) for union types. Rules: The leftmost type is the single success type. Each type on the right side of must name a declared error type. The list of error types in a signature is the complete contract: the implementation may not panic with any other error type. Implementation notes: The current compiler models typed errors as a distinct \u201cerror set\u201d attached to the function signature and to expressions that may panic. The success type is still a normal Silk type (including optionals). Triggering a Typed Error (panic) Syntax: panic OutOfBounds { index: index, len: std::length(xs) }; Rules: panic constructs a value of the named error type and immediately terminates the current function, propagating the error to the caller. A panic X { ... }; statement is only legal inside a function whose signature includes X (directly or indirectly via propagation). Implementation notes: panic is a statement (not an expression) in Silk. Propagating Typed Errors (?) The postfix ? operator propagates a typed error from an error-producing call expression to the caller without requiring an explicit match at every call site. Syntax: let value: T = errorcall(...)?; Semantics: If the call succeeds, call()? evaluates to the call\u2019s success value. If the call panics with a declared error type, call()? immediately returns from the current function, propagating the same error to the caller. Rules: ? is only legal inside a function that declares an error contract (-> SuccessType ErrorType...). The callee\u2019s error set must be a subset of the enclosing function\u2019s error set. Otherwise the call must be handled explicitly with a match statement that maps the error into the caller\u2019s contract. ? is only meaningful on an error-producing call expression (a call whose signature includes ErrorType...). Applying ? to an infallible call is a type-check error. Implementation notes: In the current compiler, call()? is lowered as \u201ccall + tag dispatch; on error return the appropriate error payload; on success yield the value\u201d, using the same encoding as the match statement lowering. Handling Typed Errors (match statement + Terminal Arm Rule) When the scrutinee expression of a match statement may panic (i.e. its signature includes ), the compiler activates a special rule for error arms. Match statement form match (createpacket(usersize)) { Some(packet) => { io::println(\"ok\"); }, None => { io::println(\"no packet\"); }, err: PacketTooLarge => { log::critical(\"invalid packet size requested\", err); std::abort(); } } Terminal Arm Rule If the scrutinee expression has an error contract (T ErrorType...), then for any arm that matches an error type, the arm\u2019s block must end with a terminal statement. Terminal statements are: panic <ErrorType> { ... }; (propagate or map to another error) std::abort(); std::halt(); std::reboot(); Implementation notes: std::abort() is lowered as a terminal action: in the native backend subset, this is routed through the platform abort() so the process terminates with SIGABRT, in non-debug builds on linux/x8664, the compiler disables core dumps (prctl(PRSETDUMPABLE, 0, 0, 0, 0)) before calling abort() to keep abort fast, on backends/targets where abort() is unavailable, it is lowered to the backend\u2019s Trap primitive. std::halt() and std::reboot() are currently lowered to Trap in the native backend subset. This rule is intentionally context-dependent: it is triggered by the error contract of the scrutinee expression, not by the fact that a type is declared with error. Error types as data (no Terminal Arm Rule) If a function returns an error type as a normal value (no in its signature), the special rule does not apply: fn inspectissues() -> PacketTooLarge; match (inspectissues()) { err: PacketTooLarge => { log::warn(\"non-critical issue\", err); // Allowed to complete normally because the scrutinee is not a T .... } } match statements over Result-like values (recoverable) The match statement form can also be used to destructure common recoverable result shapes such as std::result::Result(T, E). When the scrutinee expression is a call expression whose result type is either: std::result::Result(T, E) (an enum with Ok(T) and Err(E) variants), or a \u201cResult-like\u201d struct with fields: value: T? err: E? where E is an error type, then the checker accepts binder patterns of the form: name => { ... } / => { ... } for the success payload (binds name as T), err: E => { ... } for the error payload (binds err as E). The Terminal Arm Rule does not apply in this form because the scrutinee is not a T ErrorType... typed-error expression; the error is a normal returned value. Runtime invariant (struct form, current backend): exactly one of value and err must be Some(...). If the invariant is broken, execution traps. Implementation notes: The current compiler supports a match subset for optionals as an expression (match x { None => expr, Some(v) => expr }). The match expression also supports Ok(...) / Err(...) patterns for Result values (see match Expression). Typed error handling uses the statement form of match with block arms. Restrictions pure fn pure fn must not introduce or handle typed errors: pure fn may not have a in its return type. pure fn may not contain panic statements. The checker enforces these rules in Silk (see Compiler Diagnostics). ext boundary Typed errors must not cross the external boundary. External shims must translate typed errors into: explicit error return codes, nullable pointers / optionals, explicit error structs/enums, or a terminal action appropriate for the platform. (and rejects exported C ABI surfaces with ) in the current implementation. Related proposals Open/variadic error sets for higher-order adapters (E...). return <error> as shorthand for panic <error> (AP131). Mutability Mutability in Silk is \u201csafe by default\u201d: values are immutable unless explicitly marked mutable under clear rules using the mut keyword. All local bindings are immutable (read\u2011only) by default. const bindings are always immutable (there is no const mut). All function parameters are immutable (read\u2011only) by default. A value parameter may be declared mut to allow reassignment of the parameter binding inside the callee (this does not affect the caller). A borrowed reference parameter (&T) follows a two\u2011part mut borrow contract: the parameter is declared mut, and the call site uses mut <expr> to explicitly create a mutable borrow. A slice parameter (T[]) is a non-owning view; when the callee intends to mutate through a slice view, it also follows a two-part contract: the parameter is declared mut, and the call site uses mut <expr> to explicitly pass a mutable slice view. This two\u2011part system makes mutation explicit and intentional. Local Mutability (let mut) Local bindings introduced with const and let are immutable by default. To allow a local binding to be updated, it must be declared with let mut (or var, which is an alias for let mut): fn main () -> int { let mut x: int = 0; x = 1; x += 2; return x; } Key rules: Only let mut bindings may appear on the left-hand side of an assignment. The left-hand side must refer to an existing binding (an lvalue). The type checker enforces that the assigned value\u2019s type matches the binding\u2019s type. The Principle: Safe by Default Example from the spec: fn readrunner(r: &Runner) { // This is OK: io::print(\"Points: {}\", r.point); // This would be a compile-time error: // r.point = 5; } Key points: Borrowed references (&T) are read\u2011only unless explicitly declared mut. Attempts to mutate through a non\u2011mutable reference are compile\u2011time errors. Granting Permission to Mutate To make mutation possible through a borrowed reference, mut is used both: In the function definition, to declare that the function intends to mutate: fn resetrunner(mut r: &Runner) { r.point = 0; } At the call site, to explicitly pass a mutable argument, acknowledging that the callee is allowed to modify it (syntax defined in the language reference). The compiler uses this to: encode a clear contract that the function may modify its argument, ensure callers are consciously opting into mutation. Compiler Requirements The compiler must: Enforce immutability by default for parameters and references. Require mut at both the declaration and call site for mutable borrows. Surface clear diagnostics when mutation is attempted without proper mut markings. Integrate mutability rules with regions, buffers, and concurrency: disallow patterns that would lead to data races, ensure that aliasing and lifetime rules are respected when mutation is allowed. Current Implementation Restrictions the compiler implements: Local let mut bindings, including assignment and numeric compound assignment. mut value parameters (fn inc(mut x: int) { x = x + 1; }) as a callee-local mutable binding (no call-site mut marker is required). Borrowed reference parameters of the form &Struct for the current supported struct subset. The two-part mut borrow contract for mutable reference parameters: parameter declared mut (e.g. fn bump(mut p: &Pair)), and call site uses mut <expr> (e.g. bump(mut pair)). Field updates through both: local let mut struct bindings (pair.a = 1, pair.b += 2), and mut borrowed reference parameters (p.a = 1, p.b += 2). Local borrowed references (&Struct) as first-class values: via the borrow operator &expr on borrowable lvalues (e.g. &pair, &obj.field), and via implicit borrow coercions in contexts that expect &T (for example let r: &Pair = pair;). These borrows are checked with conservative lexical lifetime rules (they may not escape the scope of the borrowed stack storage). Local bindings of &Struct values that originate from heap allocation (new) or from calls that return &Struct: these &Struct values are refcounted in Silk, copying a &Struct binding (e.g. let g: &File = f;) creates an alias to the same underlying heap allocation and increments the refcount. Borrow Safety Rules Borrowed references (&T) in Silk are safe-by-default and, for now, use conservative lexical lifetime checks: Borrowed references can be created and stored as local values (see above). The callee can mutate a borrowed reference only when: the parameter is declared mut, and the caller uses mut <expr> at the call site. Mutable borrows must be explicit and must originate from a borrowable lvalue: borrowing a local binding requires a writable base (let mut) or an already-mutable view, and field borrows follow the same rule (the base must be writable). Slice views (T[]) are also call-scoped and safe-by-default: A slice value is a non-owning view (pointer + length) and may alias other slice views into the same underlying storage. Slice range borrows are created via: &a[start..end] &a[..end] &a[start..] A mutable slice view is created via mut &a[...] and is restricted: the base must be a borrowable lvalue (a name or a field-access chain rooted at a name), and the base storage must be writable (let mut for fixed arrays / structs, or an already-mutable view such as a mut borrowed reference parameter), or already a mutable slice view. A function parameter of slice type may be declared mut to allow mutation through the slice view, and requires the caller to pass a mutable slice view using mut <expr>. When a slice value is stored in a struct field (xs: T[]), the stored view\u2019s mutability is tracked: storing &a[...] stores a read-only view, and storing mut &a[...] stores a mutable view. A call-site mut <expr> marker does not upgrade a read-only stored view into a mutable one; passing a field as mut requires that the field already holds a mutable view. Aliasing Restrictions (Per Call) Within a single call expression, the compiler enforces conservative aliasing rules to avoid creating multiple mutable views of the same storage: A given binding may be mutably borrowed at most once in a single call. A binding may not be both mutably and immutably borrowed in the same call. Multiple immutable borrows of the same binding are permitted. For slice parameters (T[]), these same per-call aliasing restrictions apply. Additionally, when both borrows are slice range borrows of the same base with integer-literal bounds, the checker permits multiple mutable borrows in the same call when it can prove the two ranges are disjoint (including when the slices are first bound to locals and then passed by name). When borrowing a range from an existing slice binding (for example s: T[]), the checker interprets &s[start..end] as a subrange of the underlying base (offset by s\u2019s known bounds) for the purposes of overlap checks. This disjointness reasoning is currently limited to integer-literal bounds and to slice bindings whose own bounds are known. For &Struct reference-typed local bindings and slice-typed (T[]) local bindings, the compiler also tracks obvious aliasing introduced by copying and ref \u201cshape casts\u201d: Copying a &Struct binding produces an alias (it refers to the same storage). Copying a slice binding (T[]) produces an alias (it refers to the same underlying storage). Casting &S to &T via as under the shape-cast rules produces an alias (it is a retyped view of the same storage). The per-call aliasing restrictions apply across aliases: within a single call expression, you may not take multiple mutable borrows (or both mutable and immutable borrows) of the same underlying reference, even if they are held under different local names. Example (rejected): fn swap(mut a: &Pair, mut b: &Pair) { // ... } fn main () -> int { let mut p: Pair = Pair{ a: 1, b: 2 }; swap(mut p, mut p); // error: two mutable borrows of p in one call return 0; } Example (allowed, immutable): fn sum2(a: &Pair, b: &Pair) -> int { return a.a + a.b + b.a + b.b; } fn main () -> int { let p: Pair = Pair{ a: 1, b: 2 }; return sum2(p, p); // OK: multiple immutable borrows } ABI Notes (Exported/C Boundaries) At C ABI boundaries (export fn), reference types are supported only for opaque handle types (&Opaque / mut &Opaque). Non-opaque &Struct borrows are not ABI-stable; see the ABI and struct layout docs for the current rules. Memory Model (Stack, Heap, and Moves) This document specifies Silk\u2019s intended memory model: how values are allocated, passed, and how (future) heap-managed values interact with the type system. minimal heap model for new on linux/x8664 and a small lexical move/cleanup model for droppable values: new is supported for allocating non-opaque struct values on the heap and producing an &Struct reference. These heap allocations are managed via reference counting (RC) inserted by the compiler during lowering. Regions and a richer move/borrow model remain design-in-progress. See Regions, Borrow Checking (Static Alias and Lifetime Safety), and the implementation status for current scope. Goals Make allocation behavior explicit and predictable. Prefer stack allocation for most local data. Prevent unsafe implicit lifetime extension (for example implicitly \u201cmoving\u201d stack data into a longer-lived heap allocation). Keep borrow safety a compile-time property (no runtime borrow errors in the safe subset). Stack vs Heap Stack allocation (default) Rule: values created without new are stack values by default. Locals hold their data directly (for example an int or a small POD struct). Passing to functions is by value. For ownership-tracked values, this is a move (the source binding is consumed); for plain scalars it behaves like a copy. Lifetime is lexical (ends when the scope ends). This aligns with the compiler, which is value-oriented and does not implement a general heap allocation model. Heap allocation (new) and boxed values Rule: values created with new live on the heap and are represented as an &Struct reference in user code. The reference value is passed by value (copying the reference representation). The underlying allocation\u2019s lifetime is managed by compiler-inserted reference counting (RC) for values originating from new. Important: this is currently an internal Silk-managed heap for Silk code, not an FFI pointer model. The current implementation does not permit &Struct for non-opaque structs in ext signatures; only &Opaque handles may cross the FFI boundary (see Structs, Impl Blocks, and Memory Layout and External Declarations (ext)). Details new is supported only in function bodies (top-level let initializers cannot contain new in the current implementation). new is supported only when the checker can determine a concrete reference result type of the form &Struct. In the current implementation this happens in two ways: from an expected type context &Struct (for example let x: &Packet = new Packet{ ... }; or as a call argument where the parameter type is &Struct) from the new operand itself when it names a struct type (for example let x = new Packet{ ... }; or let x = new Packet(...);), which allows let bindings to infer &Packet without an explicit annotation Only non-opaque struct types are supported for new. Reference counting is applied only to &Struct values that originate from new (borrowed stack references are not treated as RC-managed values). The silk build CLI supports --noheap to disable heap allocation for the : heap-backed new (outside a with region) is rejected with E2027, async/task/await/yield and capturing closures are rejected with E2027, ext bindings to libc heap primitives (malloc/calloc/realloc/free/etc) are rejected with E2027 in non-stdlib modules, std::runtime::mem::{alloc,realloc,free} traps when called without an active with region (no implicit heap fallback), region-backed new inside with is still permitted. Region-backed allocation (with + region) In Silk, new may also allocate from a region when an active region context is established with with (see Regions). Inside with <region> { ... }, new allocates from the region\u2019s backing bytes instead of calling the heap allocator. On last-release, region-backed new allocations run drop (when defined), but do not free their backing storage (region memory is not reclaimed by RC). Reference counting rules new initializes the allocation\u2019s RC cell to 1. Copying an RC-managed &Struct binding (for example let q: &T = p;) emits an RC retain (increment). Assigning to an RC-managed &Struct binding (for example p = q; where p is a var) releases the previous value; when the RHS is an RC-managed binding, a retain is emitted before the release to keep self-assignment safe. Exiting a scope emits RC releases (decrement) for RC-managed bindings declared in that scope, including on fallthrough, return, break, and continue. Passing new directly as a call argument to a &Struct parameter allocates a temporary and releases it after the call completes. When an RC release decrements the count to 0, the allocation is freed. Destructors (Drop) In Silk, Silk supports deterministic cleanup for resource-owning struct values via std::interfaces::Drop. A struct type is considered \u201cdroppable\u201d when it provides a method with this surface signature (usually via an interface impl): import std::interfaces; impl T as std::interfaces::Drop { public fn drop (mut self: &T) -> void { ... } } Automatic invocation : Scope exit: values are dropped when they go out of scope (including via fallthrough, break, and continue). Return: on return, the compiler drops all in-scope droppable bindings except any value moved into the return result (for example return value; and return Some(value); treat value as moved in Silk). Overwrite: assigning to an existing value drops the old value before the new value is copied in. Heap last-release: for new allocations managed by compiler-inserted RC, drop is called before freeing the backing allocation when the refcount reaches zero. Notes and limitations: drop is resolved statically (no dynamic dispatch). Values that require deterministic cleanup should be treated as ownership-tracked: consuming a binding moves it and suppresses scope-exit cleanup for that binding, using a moved binding is rejected by the checker, explicit ownership transfer may be written as move <name> (see Borrow Checking (Static Alias and Lifetime Safety)). No Implicit Heap Promotion Planned rule: stack values cannot be implicitly promoted to heap-managed storage. Any promotion must be explicit and must perform a copy. This avoids accidental lifetime extension and makes performance characteristics obvious. The precise syntax for \u201cheap-copy this value\u201d is still under design; any proposed surface form must be written down in Formal Grammar Spec before it is implemented. Closure Captures Silk supports capturing closures as a subset of function values. Representation: A function-typed value is a small pair: { funcptr, envptr }. funcptr is a pointer to the closure code. envptr is either 0 (non-capturing) or a pointer to a heap-allocated environment box that stores captured values. Calling convention: When envptr == 0, an indirect call behaves like a normal function-pointer call: funcptr(userargs...). When envptr != 0, the backend passes envptr as a hidden first argument to the closure function: funcptr(envptr, userargs...). Environment allocation and lifetime: Captures are by-value copies of scalar locals/parameters (int, fixed width ints, bool, char, f32, f64, Instant, Duration). The environment box begins with a u64 refcount header, followed by the captured scalar fields in a stable order. Copying a closure value retains the environment (increments refcount) when envptr != 0. Dropping a closure value releases the environment (decrements refcount) when envptr != 0; when the refcount reaches zero the environment box is freed. Limitations: Capturing non-scalar values (including string, structs, arrays/slices, optionals, and Drop types) is rejected in Silk. Captures are immutable snapshots; the does not support capturing by reference or mutating captured state. Relationship to Borrowing and Mutability Borrow checking is intended to be a compile-time property in the safe subset: invalid borrows should be rejected statically. See Mutability for the current implemented borrow rules (call-scoped aliasing checks for &T parameters in Silk). See Borrow Checking (Static Alias and Lifetime Safety) for the broader planned borrow checker. Borrow Checking (Static Alias and Lifetime Safety) This document specifies Silk\u2019s intended borrow-checking model for references. call-scoped alias checks for mutable borrows (including slice range borrows), lexical lifetime checks for slice and reference borrows (no escaping borrows of stack locals), and a small explicit ownership-transfer form (move) used by the checker and lowering to prevent accidental double-drops in the safe subset. Goals Prevent use-after-free and data races in safe code. Make mutation explicit and intentional. Reject invalid borrows at compile time (no runtime borrow errors required for safe code). Keep diagnostics actionable (highlight the borrow origin, conflicting use, and suggest a fix). Details Today, the language subset implemented by the compiler supports only: call-scoped borrow alias checks for: borrowed reference parameters (&T, mut p: &T), and slice parameters (T[], mut s: T[]) and slice range borrows (&base[start..end], mut &base[start..end]). first-class borrowed &Struct values created from borrowable lvalues: &expr (borrow operator) for borrowable lvalues, and implicit borrow coercions in contexts that expect &T (for example let r: &Pair = pair;). Additionally, the subset implements lexical lifetime checks for both slice borrows and borrowed &T values so obvious use-after-scope cases are rejected (for example returning a slice borrowed from a local fixed array, or returning &T borrowed from a local struct binding). Lexical Lifetimes Slices (T[]) are non-owning views. Slice range borrows create slices that point into existing storage: &base[start..end] creates a slice view whose lifetime is tied to base. When borrowing a range from an existing slice binding s: T[], the borrow\u2019s underlying origin is s\u2019s origin (sub-slicing does not extend lifetime). Lexical lifetime rules enforced by the compiler: A slice value that ultimately borrows from a local fixed array binding (T[N]) may not escape that binding\u2019s lexical scope. Returning such a slice from a function is rejected. Assigning such a slice into outer-scope storage is rejected (including via field assignment and via mutable reference parameters). Returning a slice is permitted when the returned slice ultimately borrows from a function parameter (for example returning a sub-slice of a T[] parameter). These rules are intentionally conservative and are expected to be generalized to a richer lifetime model as more borrow forms become first-class. Lexical Reference Lifetimes Borrowed &T values that ultimately reference stack storage may not escape that storage\u2019s lexical scope. This includes: returning a borrowed &T that points to a local struct binding, and assigning such a borrowed reference into outer-scope storage. Returning a reference is permitted when the returned &T ultimately refers to an input reference parameter (that is, storage owned by the caller), and not to stack locals. Ownership Transfer (move) Silk\u2019s safe subset includes a small explicit ownership-transfer form: move <name> This expression: consumes the binding <name> when its type requires ownership tracking (for example values that are dropped on scope exit), and makes <name> unavailable for further use until it is reinitialized (for var) or permanently (for let). This enables moving values into other values (for example as call arguments or as the payload of Some(...)) without accidentally copying a resource-owning value and dropping it twice. In Silk, ownership transfer is intentionally conservative: A binding may not be moved while it has any live borrows (reference or slice views) in scope, including borrows stored in struct fields. A by-value call argument that requires ownership tracking is treated as a move, and is rejected when the same binding is also borrowed in that call. Planned Expansion As the language grows, borrow checking is expected to expand to cover: borrowed references as first-class values (&expr producing &T values), references and borrows in more positions (locals, fields, returns), lifetime/region inference across control flow, explicit disambiguation when multiple input references exist (for example a label syntax like as A to tie a return reference to a specific input), restrictions around suspension points in async/await, and well-defined rules for passing references across FFI boundaries. Any expansion must be specified in Formal Grammar Spec and in this document before implementation lands, and must be reflected in diagnostics (Compiler Diagnostics) and tests. Buffers Buffer(T) is an intrinsic type providing low-level access to a contiguous block of memory. It is intentionally unsafe and used as a foundation for higher-level collections and strings. Key points: Buffer(T) is a \u201cfat pointer\u201d with: a raw pointer to the start of the memory block, a capacity (number of elements that can be stored). Buffer(T) does not track the number of initialized elements (length). The intrinsic API includes operations such as: std::buffer::alloc std::buffer::write std::buffer::read std::buffer::capacity std::buffer::drop std::buffer::view std::buffer::slice The safety model is layered: Layer 1: unsafe Buffer(T) primitive. Layer 2: compile-time safety via the verifier. Layer 3: provable safety via refinement types. Compiler requirements: Treat Buffer(T) as an intrinsic type with special semantics. Ensure the verifier has enough information to reason about buffer safety. Coordinate with the standard library so that safe collections are built on top of Buffer(T). Regions Regions provide a fixed-size, statically allocated block of memory that can be used as an allocation context for new. Regions are represented at runtime as a first-class Region handle value. A Region value may be passed to functions, stored in structs, and exported. Syntax Region handle type Region is a primitive value type representing a region allocation context. Conceptually, a Region value contains: a base pointer to the backing bytes, a pointer to a mutable cursor cell (shared by copies of the handle), and a byte limit used for overflow checking. Copying a Region value copies the handle; copies refer to the same backing store and cursor. Declaring a region A region declaration has the surface form: const region arena: u8[1024]; Rules: const region is a declaration form (it is not a type). A region declaration has no initializer. The type annotation specifies the region backing size and must be a fixed byte array type: u8[N]. The declared name is bound as a Region value. Using a region: with with establishes a region allocation context for the enclosed block. 1) Bind an existing region with <region> { ... } activates a named region binding: struct Packet { x: int } fn main () -> int { const region arena: u8[1024]; with arena { let p: &Packet = new Packet{ x: 1 }; // ... } return 0; } The <region> name may refer to any Region-typed binding, including a region parameter passed to a function: struct Packet { x: int } fn allocin (r: Region) -> int { with r { let p: &Packet = new Packet{ x: 1 }; return p.x; } } 2) Use an anonymous region with an explicit byte budget with <bytes> { ... } (or with(<bytes>) { ... }) creates an anonymous region backed by <bytes> writable bytes and activates it for the block: struct Packet { x: int } fn main () -> int { with 1024 { let p: &Packet = new Packet{ x: 1 }; // ... } return 0; } Rules: <bytes> must be a positive integer literal. 3) Use a slice of an existing region (from) with <bytes> from <region> { ... } creates an anonymous region backed by the first <bytes> bytes of <region>: struct Packet { x: int } fn main () -> int { const region arena: u8[2048]; with 1024 from arena { let p: &Packet = new Packet{ x: 1 }; // ... } return 0; } You may also specify a byte slice of the source region: with 1024 from arena[64..] { // uses bytes 64..(64 + 1024) of arena } with 1024 from arena[64..1088] { // uses bytes 64..1088 of arena } Rules: <bytes> must be a positive integer literal. <region> must name a Region value that has a compile-time-known backing size In Silk (for example a const region declaration). Slice bounds use byte offsets (the region backing store is u8[N]). <start> / <end> must be non-negative integer literals. When an explicit <end> is present, it is exclusive ([start..end]). The from slice must contain at least <bytes> writable bytes: with <bytes> from r { ... } requires <bytes> <= sizeof(r). with <bytes> from r[start..end] { ... } requires <bytes> <= end - start. with <bytes> from r[start..] { ... } requires <bytes> <= sizeof(r) - start. Semantics Region-backed new Within a with <region> { ... } block: any new allocation performed by the compiler\u2019s new lowering uses the active region as its backing store, allocations are 8-byte aligned in the current implementation subset, if the region does not have enough remaining space, the program traps. Outside of a with block, new uses the current heap model described in Memory Model (Stack, Heap, and Moves). Region-backed raw allocation (std::runtime::mem::alloc) Within the dynamic extent of a with <region> { ... } block (including calls performed while the block is active): std::runtime::mem::alloc(n) allocates an n-byte payload from the active region (8-byte aligned) and reserves an additional 8-byte header immediately before the returned pointer (used by the runtime to distinguish region-backed and heap-backed pointers and to record the allocation size), if the region does not have enough remaining space, the program traps. Implication for with <bytes> limits: each alloc(n) consumes at least n + 8 bytes of region capacity (plus any alignment padding from 8-byte alignment). Region-backed raw allocations are bump-allocated. In the current runtime model: std::runtime::mem::free is a no-op for region-backed pointers, std::runtime::mem::realloc reallocates by allocating a new region block and copying bytes (it never calls libc realloc on a region-backed pointer). Nested with Nested with blocks use the innermost active region: with a { with b { // new uses region b here. } } Reclaiming Region Memory Regions are bump allocators: each allocation advances a cursor within the backing byte buffer. Because region-backed new allocations are still RC-managed in the current subset and do not free backing bytes on last-release, reclaiming region memory requires resetting the region cursor so the backing bytes can be reused. Current behavior: with <region> { ... } activates the region but does not reset its cursor. allocations across multiple with <region> blocks accumulate and can eventually overflow and trap. with <bytes> { ... } creates an anonymous region and resets its cursor to 0 on entry so repeated execution of the block starts from an empty region. with <bytes> from <region>[...] { ... } creates an anonymous region backed by a subrange of <region> and resets its cursor to the slice start on entry. Important limitation: The compiler does not yet enforce \u201cregion allocations must not escape the with block\u201d. Because anonymous-region cursors are reset on entry, code must treat pointers/&Struct values allocated inside with <bytes> { ... } and with <bytes> from ... { ... } as block-scoped. Exports Region declarations may be exported and imported like other top-level bindings: export const region globalarena: u8[4096]; Exporting a region exports a Region handle that refers to the same backing bytes and cursor cell. Importing a region binds a Region value that may be used with with like a locally declared region. Concurrency Concurrency in Silk is built around two orthogonal function modifiers: async \u2014 marks a function as pausable/awaitable (concurrency), task \u2014 marks a function as safe to execute on a worker pool (parallelism), plus structured concurrency blocks (async { ... } and task { ... }) intended to provide structured concurrency. The runtime manages a thread pool to execute tasks. The compiler is intended to enforce task-safety rules when values cross task boundaries (Send/Sync-like constraints). Core Keywords: async and task async Marks a function as awaitable (pausable). Primary domain (design): I/O-bound concurrency on an event loop/executor. task Marks a function as task-safe and eligible to be executed as a parallel task on a worker pool. Primary domain (design): CPU-bound parallelism and offloading blocking work. In the intended design, calling a task fn is non-blocking and produces a task handle. await await <expr> is the surface syntax for unwrapping a Promise(T) handle. In Silk: await Promise(T) unwraps the completed promise and yields T. await Promise(Task(T)) yields Task(T) (which can then be consumed via yield / yield ). await Task(T) is rejected; use yield / yield for task values. Task/Promise Handle Ownership In Silk, Task(T) and Promise(T) are single-use handles: A Promise(T) handle may be awaited at most once. await consumes the handle. A Task(T) handle may be drained/joined at most once via yield (and yield on a temporary task expression drains/joins as well). Handles are non-copyable: you may not copy a handle into another binding or use it as a normal value expression. A consumed handle may not be used again (including attempting to await it a second time, or attempting to yield it a second time). Consuming a handle that was created outside the current loop body is rejected In Silk (a loop may iterate multiple times). These rules are enforced at compile time and exist to prevent double-free and use-after-free bugs in the current runtime lowering, where await frees the underlying handle storage after join/unwrap. Handle Lifetime and Cleanup In Silk, Task(T) and Promise(T) handles are stored in heap-allocated handle memory: await unwraps a promise and then frees the promise handle storage. yield drains/joins a task and then frees the task handle storage. If a handle is not consumed (await/yield ), the compiler inserts automatic cleanup when the handle binding is overwritten or goes out of scope: Task(T) cleanup joins the worker thread and then frees the handle storage. Promise(T) cleanup frees the handle storage. Because the current runtime subset uses OS threads (no coroutine transform or event loop), this automatic cleanup can block the current OS thread when it joins a task. yield yield is the task-side counterpart to await. In the intended model for tasks: A task fn ... -> T produces a Task(T) handle when called. Inside the task body, yield <expr>; sends a value (convertible to T) to the task\u2019s receiver and continues execution. return <expr>; sends the final task value (of type T) and terminates the task. Outside the task, yield <taskhandle> blocks until the task produces its next value and yields it. yield <taskhandle> drains all remaining task values and then joins the worker thread for cleanup, yielding a collected T[] in value position. yield <taskhandle>; as a statement forwards all remaining values from the right-hand task to the enclosing task\u2019s receiver and then joins/cleans up the drained task. In Silk: yield is a blocking OS-thread operation (like the rest of the current concurrency runtime). yield is permitted only inside task fn / async task fn bodies and inside task { ... } / task loop { ... } blocks. The statement forms (yield <value>; and yield <taskhandle>; forwarding) require an enclosing task function (task fn / async task fn), since they send values to the task\u2019s receiver. Collected Array Ownership In Silk, yield and await produce a heap-allocated collection of values (T[]) for convenience. This is a current behavior: the compiler inserts deterministic cleanup for these collections when their bindings are overwritten or go out of scope, the returned T[] value must not be copied, and must not escape its defining scope until a stable owning collection type is specified. Structured Concurrency Blocks and Loops async { ... }, task { ... }, async loop { ... }, and task loop { ... } introduce structured regions intended for scheduler-backed concurrency and ensure all work started in the region completes before exit. In Silk, these forms parse and type-check, but they do not yet introduce any runtime scheduling; they currently behave like a normal lexical block. Future Work: Runtime and Safety The long-term design is to provide: a well-defined Task(T) handle type, scheduler-backed lowering of task calls into non-blocking spawns, await that unwraps promises and propagates errors/contracts, yield / yield that receive/drain tasks without blocking the OS thread, structured blocks (async { ... } / task { ... }) that provide well-delimited lifetimes, static rules for data-race prevention and safe sharing across tasks. Formal Silk Formal Silk is Silk\u2019s compile-time formal verification language. It is written using syntax that does not exist at runtime and is discharged at compile time using the Z3 SMT solver. When Formal Silk syntax is present, compilation generates verification conditions (VCs), proves them with Z3, and fails the build if any VC cannot be proven. This behavior applies to: the silk CLI (silk check, silk test, silk build), and the C ABI build entrypoints (silkcompilerbuild, silkcompilerbuildtobytes). Proof requirements are opt-in by syntax Silk requires proofs only when verification syntax is present in the compiled module set: any use of #... directives (#require, #assure, #assert, #invariant, #variant, #monovariant, #const), and/or any use of where predicates (for example refinement-type binders). Note: where predicates are not implemented yet. When they land, they will also be treated as verification syntax. When verification syntax is present, compilation MUST: 1. generate VCs, 2. prove them using Z3, and 3. fail compilation with clear diagnostics if any VC cannot be proven. When verification syntax is not present, compilation does not require proofs. Z3 linkage and overrides On linux/x8664, Silk always links the vendored Z3 static library (vendor/lib/x64-linux/libz3.a) and its headers (vendor/include). To override the Z3 library at runtime (for example to test against a different Z3 build), provide a dynamic library path: CLI: pass --z3-lib <path>, or CLI/ABI: set SILKZ3LIB in the environment. When --z3-lib is provided, it overrides SILKZ3LIB. Debugging proofs with Z3 (--debug) When a verification condition fails, the compiler reports a normal diagnostic at the failing annotation site. When --debug is passed to silk build or silk test, the verifier also emits additional Z3 debugging output to stderr and writes an SMT-LIB2 reproduction script under .silk/z3/ in the current working directory (or $SILKWORKDIR/z3): .silk/z3/silkz3m<module><n>.smt2 You can replay the query with an external Z3 binary: z3 -smt2 .silk/z3/silkz3m00.smt2 Z3 model The current Formal Silk verifier maps Silk constructs directly to Z3: bool \u2192 Z3 Bool. string \u2192 Z3 String (: literals and equality/inequality comparisons). integer primitives \u2192 fixed-width Z3 bitvectors: i8/u8 \u2192 BV8 i16/u16 \u2192 BV16 i32/u32 \u2192 BV32 i64/u64/int \u2192 BV64 Arithmetic is modular 2^N (wraparound). Ordered comparisons and >> use signed semantics for signed integers (i/int) and unsigned semantics for unsigned integers (u). Supported operators in specification expressions: boolean: !, &&, , ==, != string: ==, != integer: unary: -, ~ arithmetic: +, -, , /, % bitwise: &, , ^, <<, >> comparisons: <, <=, >, >=, ==, != size/layout queries: sizeof, alignof, offsetof (type operands and other statically-sized operands in Silk) Other operators and expression forms are currently rejected in verified code (see \u201cImplementation Status\u201d below). The ext boundary External declarations (ext) have no body available to the verifier. Therefore: The verifier cannot generate VCs about the behavior of ext bodies. In the current verifier subset, calls are supported only to functions that have Formal Silk contracts (see \u201cCalls in verified code\u201d below). ext declarations do not have Formal Silk contracts yet, so verified code cannot call ext functions. See External Declarations (ext) for the external-declaration rules. The main constructs are: #const \u2014 formal Silk declarations used inside specifications. #require \u2014 precondition. #assure \u2014 postcondition. #assert \u2014 block-local proof obligation. #invariant \u2014 loop or state invariant. #variant \u2014 well-founded termination measure (ranking function). #monovariant \u2014 monotonic measure (non-decreasing or non-increasing). theory / #theory \u2014 reusable, parameterized proof obligations. Key properties: These annotations appear before the function or loop they describe. They are used by the verifier only and incur no runtime cost. Formal Silk declarations (#const) Formal Silk declarations let you name intermediate values for use in specifications. Syntax: const name = <Expr>; Rules: #const is a statement that may appear inside function bodies (inside blocks). The binding is compile-time-only and is not lowered into runtime code. A #const binding is visible only inside specification expressions: function specs (#require, #assure), loop specs (#invariant, #variant, #monovariant). Using a #const name in a runtime expression (e.g. in while conditions or normal let initializers) is a compile-time error. Use a normal let binding for runtime values, and (optionally) introduce a #const alias for specifications. Example: fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; while i < limit { i = i + 1; } return 0; } Function annotations (initial syntax) For functions, the initial surface syntax is: require <Expr>; require <Expr2>; assure <Expr3>; theory TheoryName(args...); fn name (params) -> ResultType { ... } One or more #require, #assure, and contract-theory attachments (#theory Name(args...);) may appear, in any order, immediately before the fn declaration (and before any export modifier). Each annotation is terminated by a semicolon. The compiler front-end: lexes these annotations as dedicated tokens, parses the annotation expressions using the normal expression grammar, type-checks each annotation expression as bool so obvious mistakes are rejected early (specifications are still compile-time-only metadata), attaches them to the corresponding function in the AST as lists of preconditions, postconditions, and contract theories. Loop specifications (#invariant, #variant, #monovariant) follow a similar pattern for loops. Loop annotations (initial syntax) For while loops, the initial surface syntax is: invariant <Expr>; variant <Expr2>; monovariant <Expr3>; while condition { ... } Rules: One or more #invariant annotations, zero or more #monovariant annotations, and at most one #variant annotation may appear immediately before the while keyword. Each annotation is terminated by a semicolon. The compiler front-end: lexes these annotations as directive tokens, parses the annotation expressions using the normal expression grammar, attaches them to the corresponding loop in the AST as invariants, monovariants, and a (single) variant expression. The verifier will interpret: #invariant expressions (type bool In Silk) as properties that must hold: before entering the loop, after each iteration (assuming the body and condition do not diverge), and at break exits (so proofs after the loop may rely on the invariant). #variant expressions as a well-founded measure that must decrease on each iteration (and be non-negative at the loop head), used for termination proofs. #monovariant expressions as measures that must be monotonic on each iteration (either non-decreasing or non-increasing, proved consistently across all continuation paths). Compiler requirements: Parse and represent these annotations in the AST. Integrate with the verifier to check specifications. Ensure that, if verification fails, compilation fails with clear diagnostics. Block assertions (#assert) Formal Silk also supports block-local proof obligations: assert <Expr>; Rules: #assert is a statement that may appear inside function/test bodies (inside blocks). It is compile-time-only metadata and is not lowered into runtime code. The verifier must prove the assertion holds in the current symbolic state at the #assert site. If it cannot be proven, compilation fails. After a #assert succeeds, the asserted expression is assumed to hold for the remainder of the block (so later proofs may rely on it). Theories (theory / #theory) A theory is a reusable, parameterized block of Formal Silk directives that can be applied at points inside a function body to assert properties about the current symbolic state. Syntax Declaration form (top-level): export theory acustomtheory (x: int, y: int) { #const z = x + y; #invariant x != 0 && y != 0; #invariant z > 1; } An inline theory declaration may also appear as a statement inside a function/test block: fn main (x: int, y: int) -> int { #theory localsumnonzero (x: int, y: int) { #const z = x + y; #assure z != 0; } #theory localsumnonzero(x, y); return 0; } Use form (statement inside a function body, or inside another theory body): fn main (x: int, y: int) -> int { #theory acustomtheory(x, y); return 0; } Theories may apply other theories: export theory nonzero (x: int) { #require x != 0; } export theory nonzerosum (x: int, y: int) { #theory nonzero(x); #theory nonzero(y); #assure (x + y) != 0; } Notes: Top-level theory declarations use the theory keyword. Inline (block) theory declarations and theory use sites share the #theory token; the parser disambiguates by the token that follows the argument/parameter list: { ... } starts an inline theory declaration, ; terminates a theory use. A top-level theory declaration may be exported (export theory ...). Exported theories may be imported from other modules and reused. Inline theory declarations inside a block are not exportable/importable; they exist only in the containing block and may be applied via #theory Name(...); after they are declared. A theory body may contain #theory Name(args); statements. These are compile-time-only theory applications; they are checked by the verifier in the current symbolic state at the point they appear in the theory body. Theory recursion is rejected (direct or indirect cycles). Theories are not runtime functions. They can only be applied via #theory use statements; calling a theory with normal call syntax (Name(...)) is a compile-time error. Prefix #require / #assure on theories For ergonomics, a theory declaration may be preceded by #require and/or assure directives: require x >= 0; export theory ensurenonnegativex (x: int) { #assure x >= 0; } These prefix directives are treated as if they were written at the beginning of the theory body. Theories as function contracts A function may attach one or more theories as part of its Formal Silk contract surface by placing #theory Name(args...); directives in the function-spec prelude: import { boundednonnegadd } from \"./theories.slk\"; theory boundednonnegadd(x, y); export fn add (x: int, y: int) -> int { return x + y; } Contract-theory attachments: are compile-time-only metadata (not runtime statements), contribute additional preconditions/postconditions to the function contract: #require become additional function preconditions, #assure and #invariant become additional function postconditions, are used by the verifier to enable contracted calls in verified code (see \u201cCalls in verified code\u201d above), are not permitted before a top-level theory declaration (only #require / #assure may prefix a theory declaration). Importing theories Exported theories may be imported via JS-style named imports and then applied via #theory use statements. Example: // theories.slk export theory ensurepositivex (x: int) { #assure x > 0; } // main.slk import { ensurepositivex as posx } from \"./theories.slk\"; fn main () -> int { let x: int = 1; #theory posx(x); return 0; } Rules: Only exported theories may be imported. A theory use (#theory Name(args);) resolves Name as either: a local theory declared in the same module, or an imported theory name from import { ... } from \"<specifier>\";. Namespace imports (import ns from \"<specifier>\";) do not currently provide theory access, because theory use sites do not accept qualified names (ns::TheoryName) yet. Semantics (initial subset) When a theory is applied (#theory Name(args);): its parameters are bound to the provided argument expressions (as specification expressions), its #const formal declarations are evaluated and are visible only within the theory during checking, each #require <Expr>;, #invariant <Expr>;, and #assure <Expr>; directive in the theory body is treated as a compile-time proof obligation that must hold in the current symbolic state at the use site, each #variant <Expr>; directive in the theory body is treated as a non-negativity obligation (Expr >= 0) at the use site (the theory form does not model decrease across iterations). Theory bodies are verifier-only: Theory argument expressions and theory directive expressions are Formal Silk specification expressions evaluated by the verifier. In Silk, specification expressions do not support function calls or value construction (for example foo(x), Type{...}, arrays, or new). Such expressions are rejected as unsupported Formal Silk. The theory form is compile-time-only and has no runtime semantics. Generics (Monomorphized) This document specifies Silk\u2019s parameterized type and declaration syntax. parameterized declarations are monomorphized into concrete, fully specified types and functions at build time (there are no runtime type parameters). Note: Option(T) is a special-case surface form that is treated as sugar for T? In Silk (see Optional). This is still accepted in Silk even as general-purpose type-parameter generics are implemented. Overview Silk supports parameterized declarations by allowing a parameter list on struct, interface, enum, impl, and fn declarations. In Silk: Supported: type parameters (T) and const parameters (N: usize) on struct/interface/enum/impl, type application in type positions (Name(args...)), and generic functions using a compile-time parameter section separated by ; in the signature (fn id(T; x: T) -> T) (including generic methods in impl blocks). Declaration syntax Parameter lists The parameter list uses parentheses: struct Vector(T) { // ... } Rules: T is a type parameter. Type parameters may provide a default type argument using =: interface Serialize(S = string) { ... } defaults must be trailing (once a parameter has a default, all subsequent parameters must also have defaults). Const parameters are written with an explicit type annotation: N: usize const parameters are compile-time integer values and may be used in type positions such as array lengths (T[N]) and type applications. The parameter list may be empty (though it is uncommon): struct Foo() { ... }. Supported declaration forms: struct Name(T, ...) { ... } interface Name(T, ...) { ... } enum Name(T, ...) { ... } impl Name(T, ...) { ... } impl Name(T, ...) as InterfaceName(T, ...) { ... } Applying parameters in types Parameterized types are referenced using the same call-like syntax in type positions: Vector(int) Mutex(Account) Result(int, string) Generic enums (tagged unions) Enums may be parameterized and are monomorphized like generic structs. Because applied types are not used directly as expression qualifiers in the current surface syntax, callers typically introduce a local alias for an instantiation and then use that alias to construct and match variants: enum Result(T, E) { Ok(T), Err(E), } type R = Result(int, string); fn main () -> int { let x: R = R::Ok(123); return match x { R::Ok(v) => v, R::Err() => 0, }; } Default type arguments: When a parameterized declaration provides default type arguments, a use site may omit trailing arguments that have defaults. If all parameters have defaults, the type may be referenced as Name or Name() (both are equivalent to applying the defaults). Type arguments may be: types (e.g. int, &Foo, Option(string)). integer literals for const parameters (e.g. Vector(u8, 1024)). Const arguments are compile-time integer literals and participate in monomorphization identity. Interfaces and applied interface types Interfaces may be generic: interface Channel(T) { fn send(value: T) -> bool; fn recv() -> T?; } An impl ... as ... conformance may apply type arguments to the interface: struct QueueU8 { // ... } impl QueueU8 as Channel(u8) { // ... } Rule: when a generic interface is referenced in a concrete impl X as I(...), all interface type arguments must be fully known at that conformance site. The only exception is when the conformance itself is generic (type parameters are in scope), for example: struct Data(T) { / ... / } interface DataInterface(T) { / ... / } impl Data(T) as DataInterface(T) { // ... } Impl blocks for generic structs If a struct is declared with type parameters, its impl blocks must also declare those parameters: struct Data(T) { / ... / } // OK: impl Data(T) { / ... / } // Error: // impl Data { / ... / } This rule keeps method receiver typing unambiguous and makes monomorphization explicit. Functions (initial parsed surface form) Generic functions require a way to declare type/const parameters distinct from value parameters. The initial parsed surface form is: fn getfirst(T, N: usize; v: &T[N]) -> T { // ... } Where the ; separates generic parameters from value parameters inside the function\u2019s parameter list. Alternate (Go-like) function declaration syntax Silk also supports a Go-like generic header form: fn (T, N: usize) getfirst (v: &T[N]) -> T { // ... } This is sugar for the ; form above; the compiler records the same generic parameter list (T, N: usize) either way. Rules: At most one generic parameter list may be provided: either fn name(T; ...), or fn (T) name (...). Call syntax for generic functions Calls mirror the signature split: let x: int = getfirst(int, 4; &xs); Rules: the ; separates compile-time arguments from runtime value arguments, compile-time arguments are a comma-separated list of: type arguments (int, &Foo, Option(string)), and integer literals for const arguments, runtime arguments are ordinary expressions. the compile-time argument list may be empty when defaults supply all generic parameters, for example iddefault(; 1) uses the default type argument for T in fn iddefault(T = int; x: T) -> T. Call-site type inference (omitting ;) When a call does not include the generic separator (;), the compiler may infer type and const arguments from runtime arguments: fn (X, Y) add (x: X, y: Y) -> X { return x + y as X; } let a = add(1.123, 2); // infers X = f64, Y = int Rules: Both type parameters (T) and const parameters (N: usize) may be inferred. Inference is driven by the runtime argument expressions and any types that are known at the call site: literals (123, 1.0, \"hi\", 'a', true), struct literals (Point { ... }), explicit casts (expr as Type), and name expressions (x) when the binding\u2019s type is known (from an annotation like let x: T = ... or from a simple initializer like a literal/struct literal). Const parameters are inferred only from type structure: array lengths (T[N]), and const arguments in applied types (Buffer(T, N)), when the corresponding runtime argument type provides a concrete value. When inference cannot determine a type argument, compilation fails with an actionable diagnostic. Disambiguate by either: inserting as casts on runtime arguments, or using the explicit ; form (add(f64, int; 1.123, 2)). When inference cannot determine a const argument, disambiguate by using the explicit ; form (takebuf(4; buf)). Implementation notes Monomorphization produces a concrete instance for each referenced instantiation Name(args...). Type names share one namespace within a package: struct, interface, enum, error, and type declarations may not reuse the same name. Name conflicts across generic arities are rejected (for example, struct Foo and struct Foo(T) cannot both exist in the same package namespace). Const parameters are currently restricted to integer primitive types; const values are usable in type positions (for example T[N]) but are not yet exposed as runtime values. Refinement Types Refinement types are types annotated with logical predicates that constrain the set of values they may represent. They are a tool for making illegal states unrepresentable and for turning certain classes of bugs into compile-time errors. current compiler subset. Today, Silk provides verification annotations (#require, #assure, #assert, #invariant, #variant, #monovariant) and formal Silk declarations (#const) as compile-time-only metadata; see Formal Silk. Note: in Silk, any use of a where predicate is verification syntax. When where predicates are implemented, their presence will require proof (VC generation + Z3 discharge) for the compiled module set, per Formal Silk. Overview A refinement type consists of: a base type (for example int, string, &T, or a struct), and a predicate that must hold for all values of the refinement type. The predicate is written in Silk\u2019s specification expression language (the same expression grammar used by #require / #assure). Proposed Surface Syntax One intended surface form is a record-like binder with a where clause: type NonEmptyString = { s: string where std::length(s) > 0 }; Notes: type aliases are not implemented yet (this is design work). The binder name (s) is a name for the value being constrained, usable inside the predicate. Checking Model The compiler/verifier discharges refinement predicates using: constant-folding and local reasoning for literals and simple expressions, facts established by control-flow (guards) when the verifier can prove them, facts provided by contracts (#require / #assure) and invariants (#invariant), and, where necessary, explicit evidence via helper constructors or lemmas. When the compiler cannot prove a predicate, the program should fail to compile with a diagnostic that: points to the predicate that could not be proven, and suggests how to provide evidence (guard, constructor, or contract). Relationship to #require / #assure Refinement types and function contracts are meant to compose: A parameter of a refinement type encodes a precondition at the type level. A refinement return type encodes a postcondition at the type level. Example (design-only): type NonZeroInt = { n: int where n != 0 }; fn safedivide(numer: int, denom: NonZeroInt) -> int { return numer / denom; } Implementation Notes In the current implementation: there is no type alias declaration, there is no where clause in types, and there is no verifier that can prove user-defined predicates. The existing verification directives (#require, #assure, #assert, invariant, #variant, #monovariant) are parsed, type-checked as bool where appropriate, and preserved as metadata, but they do not yet affect code generation. Dependent Types (Const Parameters and Type-Level Computation) This document specifies Silk\u2019s intended support for \u201cdependent-type-like\u201d patterns where types mention compile-time values (most notably integers). declaration parameter lists on struct, impl, and fn, type application in type positions (for example VectorN(int, 1024)), but the compiler does not yet implement constraint checking, inference, or monomorphization/code generation for parameterized declarations. In the current compiler subset, generic parameter lists and applied types are rejected during type checking (Compiler Diagnostics, E2016). See Generics (Monomorphized). Const Parameters Const parameters are compile-time values that appear in parameter lists with a type annotation: struct VectorN(T, N: int) { / ... / } Where: T is a type parameter, and N: int is a const parameter whose value must be known at compile time. The initial supported const-argument form in type application is integer literals (for example VectorN(int, 1024)). Type-Level Computation The language intends to allow certain expressions over const parameters in type positions (design-only): fn concat(T, M: int, N: int; a: VectorN(T, M), b: VectorN(T, N)) -> VectorN(T, M + N) { // ... } This requires: a notion of const expressions at the type level, evaluation rules (and overflow behavior) for those expressions, and a compilation strategy (typically monomorphization) that produces concrete layouts and code for each instantiated type. Function Parameter Lists (CT/RT Split) Generic functions use a single parameter list split by a top-level ; inside the parentheses: fn id(T; x: T) -> T { return x; } fn g(T;) -> T { / CT-only, rare / } fn h(x: int) -> int { return x; } // RT-only This split is parsed and preserved by the front-end, but generic functions are rejected by the current checker until monomorphization is implemented (Compiler Diagnostics, E2016). Relationship to Arrays and Collections Const parameters are intended to power: fixed-size arrays (T[N]), dependent-length collections (for example VectorN(T, N)), and compile-time-checked indexing/slicing APIs. These features require additional language and runtime support beyond the current compiler subset. Function Disciplines (pure, task, async) This document specifies Silk\u2019s intended \u201cfunction discipline\u201d system: how functions declare whether they are pure, asynchronous, or safe to run as parallel tasks. Const functions (const fn) are specified separately in Const Functions (const fn). The const modifier is orthogonal to the discipline system described here (a const fn may also be declared pure). pure fn parsing and a strict purity checker. Concurrency disciplines (task / async) are parsed and Task(T) / Promise(T) handles plus yield (task values) and await (promise values) are implemented in Silk (await Task(T) is rejected), but the compiler does not yet implement an async event loop, coroutine lowering, or task-safety (Send/Sync) rules. See Concurrency for the concurrency model and implementation status. Overview The language design distinguishes: fn \u2014 normal function (may perform effects; blocking). pure fn \u2014 function with no observable side effects (referentially transparent). task fn \u2014 function safe to execute on a worker pool as a parallel task. async fn \u2014 function that may suspend at await points (returns an awaitable). async task fn \u2014 async function executed as a separate task (self-contained worker). Intended Call Rules (Design) The checker is expected to enforce: pure code may call only pure code (and cannot perform I/O or mutation outside local, non-escaping temporaries). task code may call task and pure code, and must satisfy task-safety rules for captured/argument data. async code may await other async operations; it may call pure code and may offload blocking work via explicit adapters . Crossing discipline boundaries is intended to be explicit and diagnostic-driven (for example suggesting the correct adapter/intrinsic). Standard Intrinsics The standard library is expected to provide typed adapters to cross boundaries safely (names and exact signatures are design work): lifting sync work onto a task pool, presenting a task as an async operation, running blocking work from async without stalling the event loop, structured spawn/join primitives. These APIs are not yet present in the in-tree std/ implementation. Implementation Notes Today: pure fn is parsed and checked: a pure fn may call only pure functions; ext is treated as impure, the checker also supports purity inference (\u201cauto-pure\u201d) for ordinary fn declarations and impl methods: when an unannotated function/method has an eligible signature and its body satisfies the purity rules, it is treated as pure for call checking, and may be called from pure code, functions/methods with &T parameters are not eligible for inference (explicit pure fn remains supported for &T parameters in the current subset), pure cannot be combined with task or async In Silk, a pure fn may not have mut parameters, a pure fn may not declare mutable locals (var or let mut) and may not perform mutation via assignment, a pure fn may not allocate (new) in Silk, a pure fn may not have a typed-error contract (-> T Error...) and may not contain panic statements. task fn, async fn, and async task fn are parsed and preserved in the AST. Calls across disciplines are now reflected in expression types: calling a task fn yields Task(T), calling an async fn yields Promise(T), calling an async task fn yields Promise(Task(T)), yield sends task values (yield v;) and receives task values (yield t), and yield t drains/collects remaining task values into T[], await unwraps Promise(T) and yields T (await Task(T) is rejected), and await ps unwraps Promise(T)[] into T[]. await <expr> and async { ... } / task { ... } blocks are enforced as async-only constructs: await is only permitted inside async functions (including async task fn), async { ... } / task { ... } blocks are only permitted inside async functions. yield <expr> is enforced as a task-only construct: yield is permitted only inside task functions (task fn / async task fn) and inside task { ... } / task loop { ... } blocks. Lowering/codegen implements task execution using OS threads on linux/x8664 and implements yield/yield for task values plus await for promises. There is not yet a coroutine transformation or event loop; awaiting a Promise(T) currently does not \u201cpark\u201d the OS thread (it is still a synchronous unwrap in Silk). async { ... } / task { ... } blocks are still lexical blocks in the (they do not yet introduce scheduler behavior). Function types are parsed in type positions (notably for ext). Function expressions are implemented as first-class function values: fn (x: int) -> x + 1 (expression body), fn (x: int) -> int { return x + 1; } (block body). Function expressions may not declare &T parameters. Non-capturing function expressions are inferred as pure and are callable from pure code. Capturing closures are supported as a subset: a function expression may reference immutable locals/parameters from an enclosing scope, captures are by-value copies into a heap environment (scalar-only in the ), capturing closures are not pure and are rejected in pure code. Function values (both non-capturing and capturing) are supported end-to-end: they may be passed, returned, stored, and called indirectly. Const Functions (const fn) Summary Silk supports compile-time evaluation of certain expressions to produce compile-time constants. const fn (and const pure fn) declarations opt a function into this compile-time evaluation system so that it can be called from compile-time contexts (for example, a const binding initializer). Syntax const is a function modifier: const fn add (a: int, b: int) -> int { return a + b; } const pure fn add2 (a: int, b: int) -> int { return a + b; } Notes: const pure fn is simply a const fn that also opts into the pure rules (see Function Disciplines (pure, task, async)). const fn is a compile-time-only function: it may be called only from compile-time contexts (for example const initializers and Formal Silk specifications), it is not emitted as a runtime/linkable symbol in executable, object, or library outputs. Compile-Time Values In this document, a \u201ccompile-time value\u201d is a value that the compiler can produce and manipulate during compile-time evaluation. (initial implementation target): scalar primitives: bool fixed-width integers (i8, u8, i16, u16, i32, u32, i64, u64) int f32, f64 char Instant, Duration Planned (not yet supported for const fn In Silk): string values (string literals are supported directly in const bindings), aggregate values (struct/enum/optional/slice/array) as return values, function values as compile-time values (for higher-order const evaluation). Rules The defines a deliberately small \u201cconst-eval VM\u201d surface. A const fn must fit within this surface. Signature rules In Silk, a const fn: must not be task or async, must not declare a typed-error contract (-> T ErrorType...), must have a non-void return type that is a compile-time value type, must have parameters whose types are compile-time value types. Body rules In Silk, a const fn: must not allocate (new) and must not use regions/with, must not contain panic statements, must not declare const local bindings, may call only other const fn declarations, is restricted to a small expression subset over scalar values: literals and local names (parameters and let bindings; no global const reads in Silk), as casts between supported scalar types, unary operators: -, ~, !, binary operators: arithmetic: +, -, (division/modulo are not part of the const-eval subset), bitwise: &, , ^, <<, >>, comparisons: ==, !=, <, <=, >, >=, if expressions (if cond { a } else { b }). assignments to local names: =, +=, -=, =, plus ++/--. Control flow is limited to: if / else statements, while loops with boolean conditions, break / continue, return statements. Calling Const Functions The initial intended compile-time use site is const bindings: const fn add (a: int, b: int) -> int { return a + b; } const answer: int = add(20, 22); fn main () -> int { return answer; } Const functions may also be imported/exported across modules/packages like runtime declarations, but they are still compile-time-only: importing a const fn does not make it callable from runtime code. \u201cNo Static Storage\u201d Rule Const functions do not create new static storage. In particular: compile-time execution may compute scalar values and fold them into constants, compile-time execution must not allocate heap memory, compile-time execution must not synthesize new global read-only data (for example, it cannot build a new string at compile time in Silk). String literals are still backed by read-only static storage, but they are introduced by the literal syntax itself (see String Literals), not by the const fn evaluator. Evaluation Limits Compile-time evaluation must terminate. The current implementation enforces an instruction budget and a call-depth budget when executing const fn bodies at compile time; evaluation that exceeds these budgets is rejected as not compile-time evaluable. Varargs (Variable Arguments) Silk supports declaring functions that accept a variable number of trailing arguments (\u201cvarargs\u201d). This is used heavily by std::io::print / std::io::println for formatted output. Syntax Varargs are declared by prefixing the final parameter with ...: fn log (fmt: string, ...args: std::fmt::Arg) -> void { std::io::println(fmt, args); } Rules: A function may declare at most one varargs parameter. The varargs parameter must be the final parameter in the list. The varargs parameter must have an explicit type annotation. Varargs parameters are not permitted to be mut In Silk. Varargs parameters may not have a default expression (= ...) in the current subset. Call Semantics At call sites: All non-varargs parameters are matched positionally as usual. Any additional arguments are collected into the varargs parameter. Example: std::io::println(\"hello {s} answer={d}\", \"world\", 42); Here \"world\" and 42 become varargs elements. Forwarding Because Silk does not yet have a general \u201cspread\u201d operator for calls, the current implementation supports forwarding a varargs pack when you pass a varargs binding as the final argument. fn log (fmt: string, ...args: std::fmt::Arg) -> void { // args is forwarded as-is to println. std::io::println(fmt, args); } This is primarily intended for building wrappers that preserve the caller\u2019s argument list without repacking. Representation In Silk, a varargs parameter is lowered as a fixed-size pack value with: len: int \u2014 the number of provided varargs arguments. a0 .. a(N-1) \u2014 storage for up to N arguments (implementation-defined, currently N = 128). The pack is passed by value using the same \u201cflattened scalar slot\u201d ABI as other POD structs. Notes: Accessing aK where K >= len is a logic error (the value is unspecified). Calls supplying more than N varargs arguments are rejected. FFI (C Variadics) This document is about Silk varargs. C variadic functions declared via ext (printf-style ...) are a separate concern and are not implemented yet In Silk. Language Spec Conventions This document defines conventions used across this specification. It exists to keep the language specification consistent and easy to navigate for both: first-time readers learning Silk, and returning readers looking up precise rules. See also: Silk Language Guide (Index) for recommended reading paths. Document Structure (Recommended) Concept documents should be structured so readers can answer, quickly: \u201cWhat is this feature for?\u201d \u201cWhat syntax does the compiler accept?\u201d \u201cWhat are the rules and edge cases?\u201d \u201cWhat works in the current compiler today?\u201d Recommended sections: 1. One-paragraph summary 2. Implementation status (if the concept is partially implemented) 3. Surface syntax 4. Semantics (evaluation order, scoping, control-flow behavior) 5. Type checking rules (static requirements and diagnostics) 6. Examples minimal examples (smallest correct usage) realistic examples (how the feature is used in real code) 7. Common pitfalls 8. Related documents 9. Relevant tests (links to the runnable fixtures and the runnable fixtures) Not every concept needs every section, but the goal is that a reader should never have to infer critical rules from examples. \u201cImplementation status\u201d Format When a feature is not fully implemented end-to-end, the concept doc should include an explicit \u201cImplementation status\u201d section near the top. Use concrete statements, not vague language. Prefer describing support in these layers: Parser: which surface forms are accepted. Checker: which typing/validation rules are enforced. Lowering/backends: which forms code-generate end-to-end on supported targets. C ABI / FFI: whether the feature is permitted at exported boundaries. When something is rejected in Silk, include the diagnostic code from Compiler Diagnostics when one exists. Examples Examples in language docs should follow these rules: Use 2-space indentation and spaces only. Prefer complete, runnable snippets when possible: fn main () -> int { return 0; } When an example requires multiple files, label them with comments, e.g.: // app/main.slk package app; When an example is intentionally invalid (to show a rule), label it and mention the expected diagnostic. Terminology These terms are used consistently across the spec: Expression: a construct that produces a value and has a type. Statement: a construct evaluated for its effects and sequencing. Block: { stmt }, a scope boundary and the unit of structured control flow. (Whether blocks are also expressions depends on the concept; docs must be explicit.) Current compiler subset: the set of features that parse, type-check, and code-generate end-to-end in the current implementation. Cross-References When describing a rule, link to the most relevant concept doc rather than restating it everywhere. Common cross-links include: Formal Grammar Spec for the exact accepted syntax, Types for type-system rules and special cases, Mutability for mut and borrowing rules, Compiler Diagnostics for error codes, the implementation status for a high-level implementation snapshot. Operators This document summarizes the operator set and precedence for Silk. Operator Set The language includes the following operators and delimiters: Assignment and compound assignment: =, +=, -=, =, /=. Increment/decrement: ++, -- (prefix and postfix). Arithmetic: +, -, , /, %. In the current implementation: integer operands support +, -, , /, and %, floating-point operands (f32/f64) support +, -, , and / (no %). unary -x is supported for both integer and floating-point operands. time types support a small arithmetic subset: Duration + Duration, Duration - Duration, and unary -Duration, Instant + Duration, Duration + Instant, Instant - Duration, and Instant - Instant (producing a Duration). Bitwise: &, , ^, ~, <<, >>. In the current implementation, bitwise operators are defined for integer operands (int and the fixed-width integer types): &, , ^ perform bitwise AND/OR/XOR on two integer values of the same type and produce a result of that same type. ~x performs bitwise NOT on an integer value and produces a result of that same type. <<, >> shift the left-hand integer operand by an integer shift amount of the same type; >> uses an arithmetic right shift for signed integers (i/int) and a logical right shift for unsigned integers (u). Comparison: ==, !=, <, <=, >, >=. In the current implementation, comparisons are defined for both integer operands and floating-point operands of the same type. In Silk, == and != are also defined for bool operands. In Silk, comparisons are also defined for Duration and Instant when both operands have the same time type. In Silk, == and != are also defined for string operands, comparing the underlying UTF-8 byte sequences for equality (length check + bytewise compare). In Silk, ordered comparisons over string (<, <=, >, >=) are defined as bytewise lexicographic ordering over the underlying UTF-8 byte sequences (unsigned byte comparison, with shorter-prefix ordering when one string is a prefix of the other). In Silk, == and != are also defined for supported optional values (T?, string?, optionals of the supported struct subset, and nested optionals T??): None == None is true, Some(x) == Some(y) compares the payload values for equality (recursively for nested optionals), and != is the logical negation of ==. In the current implementation, None and Some(...) can appear in equality expressions when the other operand has an optional type (for example opt == None and opt == Some(x)), using that other operand\u2019s type to infer the optional payload type. In Silk, == and != are also defined for the supported struct subset (see Structs, Impl Blocks, and Memory Layout), performing slot-wise equality over the lowered scalar slots (including embedded strings, nested structs, and optionals); float slots use IEEE-754 equality semantics. Ordered struct comparisons are not implemented. Float comparisons follow IEEE-754 semantics: NaN compares unequal to everything (including itself), and ordered comparisons (<, <=, >, =) are false when either operand is NaN. Logical: !, &&, . In the current implementation: ! is supported for bool operands. Member and scope: ., ::, ?.. In the current implementation: . and :: are supported, and ?. is supported for optional field access on the supported struct subset (opt?.field yields FieldType?; see Optional). Casts: as and as raw (postfix). Syntax: numeric/shape cast: <expr> as <Type>, raw bit-cast: <expr> as raw <Type>. as is an explicit, potentially lossy conversion operator intended for primitive numeric conversions (see \u201cCasts (as)\u201d below). as raw is an explicit bit reinterpretation operator intended for generic storage/marshalling of scalar values (see \u201cRaw casts (as raw)\u201d below). Typed error propagation: ? (postfix). Syntax: <callexpr>?. This propagates typed errors from an error-producing call to the enclosing function; see Typed Errors (error, panic, and T ErrorType...). Ranges: ..., ..=, ... Other punctuation: ?, ??, ->, =>, ,, ;, (, ), {, }, [, ], , :. In the current implementation, ?? is supported for optionals in the current backend subset (including scalar, string, and the current struct subset, plus nested optionals in the supported payload subset; see Optional). The ? token is used both in type annotations (T?) and as the postfix typed error propagation operator for error-producing calls (call()?; see Typed Errors (error, panic, and T ErrorType...)). The lexer and parser must recognize these tokens exactly as specified, and precedence/associativity must match the formal grammar. Assignment Assignment updates an existing binding (an lvalue). Assignment is \u201cstatement-like\u201d: it is parsed as an expression but has type void and is intended to appear as an expression statement. = x = expr evaluates expr and stores the resulting value into x. Rules: The left-hand side must be an assignable lvalue. In the current implementation, it may be: an identifier that refers to a local let mut binding, or a struct field lvalue name.field where name is either: a local let mut binding of a supported POD struct, or a mut borrowed reference parameter (mut name: &Struct). Identifier lvalues must refer to let mut local bindings. The type of expr must match the binding\u2019s type. The assignment expression has type void. Compound assignment (+=, -=, =, /=) Compound assignments are shorthand for \u201cread-modify-write\u201d: x += y is equivalent to x = x + y (and similarly for -=/=//=), with y evaluated exactly once. Rules: The left-hand side must be an assignable lvalue (as described above for =). In the current implementation, compound assignments are supported only for numeric scalar types (integers and f32/f64), including numeric struct fields. The compound assignment expression has type void. Increment and Decrement (++ / --) ++x, x++, --x, and x-- increment or decrement an existing binding by 1. In Silk, increment/decrement expressions are \u201cstatement-like\u201d: they have type void and are intended to appear only as expression statements. Rules: The operand must be an assignable lvalue (the same lvalue rules as =). The operand type must be an integer scalar type (int, i8, u8, i16, u16, i32, u32, i64, u64, size, usize). (isize is accepted as an alias for size.) Prefix and postfix forms are equivalent in Silk (both update the binding and produce void). Conceptual desugaring: x++ and ++x are equivalent to x += 1; x-- and --x are equivalent to x -= 1; sizeof sizeof <operand> produces the size of a type or value in bytes. Result type: sizeof always returns usize. Evaluation mode: When the operand is a type name (a primitive type, struct/enum name, type alias, or qualified type name), sizeof is a compile-time constant. When the operand is a compile-time constant value (literals and other const-evaluable expressions), sizeof is a compile-time constant. When the operand is a runtime value, sizeof is evaluated at runtime. Sized integration: Planned: for runtime values, if the operand type provides an instance method matching std::interfaces::Sized (fn size(self: &Self) -> usize), sizeof value will lower to a call of that method. For type operands, if the operand type provides a static, pure method pure fn size() -> usize, the compiler may fold sizeof Type to that value when the method body is const-evaluable; otherwise it falls back to the compiler\u2019s built-in size model. Built-in size model : Sizes reflect the current scalar-slot lowering model (Structs, Impl Blocks, and Memory Layout): each lowered scalar occupies one 8-byte slot. A string value occupies two slots ((u64 ptr, i64 len)), so sizeof string is 16 In Silk. A T[] slice value occupies two slots ((u64 ptr, i64 len)), so sizeof T[] is 16 In Silk. A T[N] fixed array occupies N sizeof(T) bytes in Silk, using the element\u2019s scalar-slot size. Parsing note: Because Name[expr] is also indexing syntax, fixed array type operands should be parenthesized: sizeof (u8[4]). Without parentheses, sizeof u8[4] is parsed as an index expression. Because as binds at postfix precedence, sizeof x as T parses as sizeof (x as T). To cast the result of sizeof, write (sizeof x) as T. alignof alignof <operand> produces the alignment of a type or value in bytes. Result type: alignof always returns usize. Evaluation mode: When the operand is a type name (a primitive type, struct/enum name, type alias, or qualified type name), alignof is a compile-time constant. When the operand is a compile-time constant value (literals and other const-evaluable expressions), alignof is a compile-time constant. When the operand is a runtime value, alignof is evaluated at runtime. Built-in alignment model : Alignments reflect the current scalar-slot lowering model (Structs, Impl Blocks, and Memory Layout): values are stored as 8-byte slots. All non-void types currently have alignment 8. alignof void is 1. Parsing notes: As with sizeof, fixed array type operands should be parenthesized: alignof (u8[4]). Without parentheses, alignof u8[4] is parsed as an index expression. Because as binds at postfix precedence, alignof x as T parses as alignof (x as T). To cast the result of alignof, write (alignof x) as T. offsetof offsetof(Type, fieldpath) produces the byte offset of a struct-like field within Type in the current memory layout model. Result type: offsetof always returns usize. Evaluation mode: offsetof is always a compile-time constant. Operands: Type must name a struct or error type (including nested structs). fieldpath is one or more field identifiers separated by . (for example b or inner.header.len). Built-in offset model : Offsets reflect the current scalar-slot lowering model (Structs, Impl Blocks, and Memory Layout): each lowered slot is stored in an 8-byte cell, and composite fields (nested structs, optionals, strings, etc.) are expanded into their slot sequences in source order. offsetof(Type, field) returns the offset of the first slot of that field\u2019s lowered representation, in bytes. When fieldpath traverses an optional T? field, it refers to the payload layout (the path implicitly skips the tag slot). typename typename <expr> and typename(<expr>) produce a string naming the static type of <expr>. Result type: typename always returns string. Evaluation mode: typename is always a compile-time constant string. Operand notes: When the operand is a bare name that does not resolve to an in-scope runtime binding (for example int, User, or std::wasm::Module), the compiler interprets it as a type name and returns that type\u2019s name. Formatting uses the compiler\u2019s normal type formatting (for example T[], &T, and fn (...) -> ...). For monomorphized generic instantiations, the string is the human-readable display name (not an internal silkmono... symbol). is <expr> is <Type> checks whether the static type of <expr> conforms to <Type>. Result type: is always returns bool. Evaluation mode: is is always a compile-time constant boolean. Rules: The right-hand side must be a type (primitive, nominal struct/enum/error, interface, a function type, or a type alias for one of those). If <Type> is a nominal struct type, expr is Type is true when the expression\u2019s static type is exactly Type or a struct that extends Type. If <Type> is an interface, expr is Interface is true when the expression\u2019s static type declares conformance (impl T as Interface) or when the operand is a module declared module Name as Interface. For primitive types, enum/error types, reference types (&T), slice/array types (T[], T[N]), optionals (T?), and function types, is currently checks exact type equality (after resolving type aliases). Notes: is does not perform runtime tagging or value inspection. For runtime discrimination of union/optional values, use match and the relevant pattern forms. Examples: type Adder = fn (x: int, y: int) -> int; fn myadder (x: int, y: int) -> int { return x + y; } if myadder is Adder { / ... / } struct User { id: u64 = 0 } struct Beep extends User { boop: string = \"\" } let beep = Beep{ boop: \"boop\" }; if beep is User { / ... / } let n = 123; if n is int { / ... / } interface Logger { fn log (value: string) -> void; } module mylogger as Logger { export log (value: string) { / ... / } } if mylogger is Logger { / ... / } Wrapping and Overflow The spec notes \u201cArithmetic Wraps\u201d for certain operators. The checker and code generator must: Implement deterministic wrapping behavior for integer arithmetic where required. Clearly separate wrapping operations from checked or saturating variants (if exposed in the standard library). Casts (as) as is a postfix operator that performs an explicit conversion to a target type. Precedence as binds at postfix precedence (like calls, field access, and ?). For example: a + b as int parses as a + (b as int). To cast the result of new, use parentheses so the cast applies to the heap reference: (new Type{ ... }) as &Other. Without parentheses, new Type{ ... } as &Other parses as new (Type{ ... } as &Other). Supported conversions In Silk, as is supported for primitive scalar conversions: Integer \u2192 Integer (including Instant, Duration, and char): The conversion is deterministic and may be lossy. It is performed by canonicalizing the underlying bits to the destination integer type (width truncation + sign/zero extension as appropriate). This matches the behavior of ir.CastInt in the current IR. Float \u2192 Float: f32 \u2194 f64 using standard IEEE-754 conversion and rounding. Integer \u2192 Float: Converts the integer value to the destination float type (IEEE-754), with rounding when the integer cannot be represented exactly. Float \u2192 Integer: Converts by truncating toward zero. If the source value is NaN, the result is 0. If the source value is outside the destination integer\u2019s representable range, the result saturates to the nearest bound (min/max for signed, 0/max for unsigned). Struct \u2192 Struct (safe \u201cshape cast\u201d): A cast from S to T is permitted when both S and T name non-opaque struct types and their fields match positionally: same field count, and for each index i, the field type of S at i is exactly the same type as the field type of T at i (field names may differ). This is intended for \u201cnewtype-like\u201d wrappers and schema evolution where two structs have the same shape but different field names. Semantics: the cast produces a value copy of the underlying struct slots, retyped as T. The operation does not reorder fields. &Struct \u2192 &Struct (safe \u201cshape cast\u201d for references): A cast from &S to &T is permitted when S and T are compatible under the same Struct \u2192 Struct \u201cshape cast\u201d rules above. Semantics: the cast produces a retyped view of the same referenced storage. It does not allocate and does not copy the underlying struct slots. For refcounted heap references created by new, the cast is still a view only: it must not change which drop implementation runs when the refcount reaches zero. The allocation\u2019s concrete type (tracked through the value, not the view type) determines Drop behavior at the last release. This means the two references alias: reading fields through the cast view observes updates made through the original reference (and vice versa). Because the two references alias, the compiler\u2019s per-call mutable-borrow restrictions treat aliases as the same storage: a single call expression may not take multiple mutable borrows (or both mutable and immutable borrows) of the same underlying reference, even if the aliases are held under different local names. See Mutability. This cast is intentionally conservative: it is permitted only when the compiler can prove the two referenced struct layouts are identical at the type level (same field types in the same order). It does not permit arbitrary \u201creinterpret pointer\u201d casts. u64 \u2194 T[] / T[N] (unsafe pointer/slice view cast): Silk\u2019s represents raw addresses as u64. For low-level byte-copy routines and runtime interop, as supports explicit conversions between raw addresses and array/slice views: ptr as T[] constructs a T[] slice view where the pointer component is ptr and the length component is a dedicated unknown-length sentinel (in the current implementation, i64.min). The compiler does not validate the pointer value. Indexing and assignment through an unknown-length slice are permitted but unchecked: the runtime performs no index < len bounds check. Operations that require a known length (iteration, slicing, etc.) trap unless an explicit length is provided. ptr as T[](len) constructs a T[] slice view where the pointer component is ptr and the length component is len (element count). slice as u64 extracts the pointer component of a T[] slice. arr as u64 extracts the address of element 0 of a fixed array T[N] (for N == 0, the result is 0). These casts remain unsafe: the compiler does not validate pointer provenance (whether the address is valid for the claimed element type). In Silk, indexed accesses through arrays/slices trap when: the pointer is 0, the pointer is not 8-byte aligned, the explicit length is negative (when provided), the index is out of bounds (index < len) when the slice/array has a known (non-unknown) length. Serialize(T)-backed casts (explicit conversion via serialize()): When the operand type provides a unique instance method named serialize matching the std::interfaces::Serialize(T) surface (fn serialize(self: &Type) -> T), expr as T is permitted and lowers to a call of that method. The conversion is explicit (it does not introduce implicit coercions). The serialize method must be infallible (no typed errors). Purity rules apply: inside pure fn, the serialize method must be pure. Limitation: the compiler must be able to resolve the receiver\u2019s nominal type at the cast site so it can lower the implicit serialize() call. This includes name expressions, field accesses, calls, and array/slice indexing (arr[i] as T) in the current implementation. Deserialize(S)-backed casts (explicit conversion via deserialize(...)): When the target type provides a unique static method named deserialize matching the std::interfaces::Deserialize(S) surface (fn deserialize(value: S) -> Self), expr as Self is permitted and lowers to Self.deserialize(expr). This rule is checked before struct shape casts: when both a deserialize conversion and a shape cast could apply, the deserialize conversion is used. The conversion is explicit (it does not introduce implicit coercions). The deserialize method must be infallible (no typed errors). Purity rules apply: inside pure fn, the deserialize method must be pure. Examples: struct Data { value: string, } struct User { name: string, } fn main () -> int { let data = Data{ value: \"hello\" }; let user = data as User; assert data.value == user.name; return 0; } struct A { value: string, } struct B { value: string, } fn setvalue (mut b: &B, value: string) -> void { b.value = value; } fn main () -> int { let a: &A = new A{ value: \"hello\" }; var b = a as &B; setvalue(mut b, \"world\"); assert a.value == \"world\"; assert b.value == \"world\"; return 0; } Notes: as does not participate in the implicit call-argument coercion mechanism described in Types (that mechanism is opt-in per destination struct and is used primarily for stdlib ergonomics). Raw casts (as raw) as raw is a postfix operator that reinterprets the raw bits of a scalar value as another scalar type. It is intended for use in generic collections and low-level marshalling where numeric conversion would be incorrect (notably when storing f32/f64 values in integer-backed storage). Syntax: <expr> as raw <Type> Rules: Both the operand and the target type must be scalar numeric types supported by the current backend (i8/u8/i16/u16/i32/u32/i64/u64/int, f32/f64, plus int-like primitives lowered to those scalars such as Duration/Instant and char). as raw is not permitted for string, void, &T, optionals, arrays, maps, function types, or structs/enums. Semantics: The operand\u2019s current canonical scalar bits are reinterpreted as the target type\u2019s canonical scalar bits (bit-level truncation/masking for narrower target widths such as u8/u16/u32 and f32). No numeric conversion is performed. For example, 1.0 as u64 yields 1, while 1.0 as raw u64 yields the IEEE-754 bit pattern. Examples: let bits: u64 = (1.0 as f32) as raw u64; let f: f32 = bits as raw f32; Duration & Instant Duration and Instant are time-related types with special literal and operator support. Key ideas: Duration represents a signed time span. Instant represents a signed point-in-time on a monotonic timeline (an opaque epoch chosen by the runtime). Duration literals represent time spans with unit suffixes and are converted into integral ticks. Operators cover arithmetic, comparisons, and construction from scalars. Representation In Silk: Duration is represented as a signed 64-bit integer count of nanoseconds. Instant is represented as a signed 64-bit integer count of nanoseconds since a monotonic, runtime-defined origin. These are distinct Silk types in the type system, but share the same underlying scalar representation (i64) at the IR and native ABI layers. Operators The current implementation supports the following operator subset: Duration + Duration -> Duration Duration - Duration -> Duration Duration -> Duration Instant + Duration -> Instant Duration + Instant -> Instant Instant - Duration -> Instant Instant - Instant -> Duration Comparisons (==, !=, <, <=, >, >=) are supported for: Duration vs Duration Instant vs Instant Other arithmetic (, /, %) and bitwise operators are not defined for time types in the current implementation. Overflow Arithmetic uses the same deterministic wrapping behavior as the underlying i64 operations in the current back-end subset (two\u2019s complement wraparound). Future Work At maturity, this document will be expanded to fully specify: duration/instant division semantics and rounding rules, checked/saturating variants exposed by the standard library, the precise relationship between Instant and the platform clock APIs, and FFI-safe conversions and APIs in std::temporal. Compiler requirements: Implement type-checking and lowering for the operator subset above. Implement duration literal parsing as specified in Duration Literals. Integrate with std::temporal in the standard library. External Declarations (ext) Silk\u2019s external declaration feature lets Silk code call foreign functions and access foreign variables. The core construct is the ext definition, which declares: external C functions and their Silk function types, or external C variables and their Silk types. The compiler and runtime perform marshalling between Silk\u2019s internal representations and the C ABI, following a documented mapping. Declaring an External Binding Example: ext foo = fn (string) -> void; ext bar = u32; Here: foo is a C function named foo with the given Silk function type. bar is a C variable of type u32. Binding a Different External Symbol Name Sometimes you want the Silk binding name to differ from the linked external symbol name (for example, when writing wrapper modules that want to expose stable public API names without colliding with imported libc names). Syntax: // The binding name is cmalloc, but the linked symbol is malloc. ext cmalloc \"malloc\" = fn (i64) -> u64; ext cfree \"free\" = fn (u64) -> void; Rules: The identifier after ext is the Silk binding name (used for imports and calls from Silk code). The optional string literal is the external symbol name used for linking (native) or as the import name (wasm). If the string literal is omitted, the external symbol name is the same as the binding name. Avoiding Shadowing (Global ::...) If an ext binding is declared in the global namespace (a module with no package ...; or header-form module ...; declaration) and a local declaration shadows it (for example, a wrapper function named malloc), use the global-name prefix to force lookup of the global binding: return ::malloc(bytes); The global-name prefix is not limited to ext: it also applies to type names and enum variant paths in expression and type positions (for example, ::Foo, ::Foo{...}, or ::E::Variant), always forcing resolution in the global (unnamed) package. Verification and ext (Silk rule) External declarations have no body available to the verifier. Therefore: It is a compile-time error to attempt to verify an ext declaration. It is a compile-time error for verified code (code whose compilation requires proofs) to call an ext function or read an ext variable. This intentionally limits verification across the ext boundary. Opaque Struct Handles Opaque structs are intended for representing foreign pointers/handles safely. They strengthen type safety at the language boundary by preventing accidental mixups between different handle types and by disallowing invalid operations in Silk. Declare an opaque handle type with a fieldless struct declaration: // runtime.slk struct StringBuilder; ext sbnew = fn () -> &StringBuilder; ext sbappend = fn (&StringBuilder, string) -> void; ext sbdestroy = fn (&StringBuilder) -> void; Use the handle by importing the type name and the ext functions: import { StringBuilder, sbnew, sbappend, sbdestroy } from \"./runtime.slk\"; fn main () -> int { let sb: &StringBuilder = sbnew(); sbappend(sb, \"hello\"); sbdestroy(sb); // Using sb after destroy is UNDEFINED BEHAVIOR (dangling foreign pointer). return 0; } Rules: The handle type must be used behind & (&StringBuilder), not by value. Opaque structs cannot be instantiated and do not support member access. Safety: You are responsible for managing the lifetime of foreign handles. Most C APIs provide explicit create/destroy functions; always call the destruction function when you are done. Using a handle after destruction is undefined behavior; the compiler does not currently enforce this at compile time. Notes on executable ext calls (current linux/x8664 implementation): When an executable uses ext calls or ext variable reads, the compiler emits a dynamically-linked ELF64 executable (PIE-style ETDYN with PTINTERP, .dynamic, .rela.dyn, and a .got). External symbols are resolved by the platform dynamic loader. Dependencies can be declared via the CLI (silk build --needed <soname> ...) or via the C99 embedding API (silkcompileraddneededlibrary), and runtime search paths can be declared via --runpath / silkcompileraddrunpath. ABI Contract (Overview) The language defines two closely related views of the ABI: A \u201cfat pointer\u201d internal representation for string and regexp: conceptually: struct string { ptr: ptr, len: i64 } where ptr is a UTF\u20118 pointer. conceptually: struct regexp { ptr: ptr, len: i64 } where ptr is an engine-owned bytecode pointer. A C ABI contract (e.g. via silk.h) using an explicit struct: typedef struct { char ptr; int64t len; } SilkString; A mapping to an LLVM type used internally by the compiler: %silk.string = type { i8, i64 } When calling conventional C APIs, the compiler may pass a const char derived from this structure, with the guarantee that the underlying data is null\u2011terminated. This distinction is important: Internal/runtime ABI: operates on { ptr, len } structs (SilkString). Compatibility calls to typical C libraries: may expose const char for parameters declared as string in Silk ext declarations, with the compiler extracting the ptr. Our embedding ABI for libsilk.a will treat SilkString as the canonical C representation; details are further specified in C99 ABI and libsilk.a. Primitive Type Mapping The spec includes a table mapping Silk primitive types to C types, for example: i8, u8 \u2192 int8t, uint8t i16, u16 \u2192 int16t, uint16t i32, u32 \u2192 int32t, uint32t i64, u64 \u2192 int64t, uint64t int \u2192 int64t (current linux/x8664 baseline; do not assume C int) f32 \u2192 float f64 \u2192 double bool \u2192 bool (or Bool) char \u2192 uint32t (UTF\u201132) string \u2192 SilkString ({ char ptr; int64t len; }) regexp \u2192 SilkString ({ char ptr; int64t len; }, opaque bytecode view) void \u2192 void Notes: For FFI with APIs that use a C int (for example many POSIX syscalls), prefer i32/u32 in your ext declarations rather than int. These mappings must be reflected exactly in the C99 ABI. Strings and Passing Convention For strings, the spec makes the following points: Silk\u2019s string is represented internally as a { ptr, len } pair. For ext calls to typical C APIs: the compiler can extract ptr and pass it as a const char , the data is guaranteed to be null\u2011terminated so standard C string functions are safe. For regex bytecode values (regexp): Silk\u2019s regexp is represented internally as a { ptr, len } pair with the same slot layout as string, but the bytes are not text and are not required to be null\u2011terminated. At ABI boundaries, regexp uses the same C shape as SilkString, but C code must treat it as an opaque (ptr, len) byte span (not a C string). For the embedding ABI (libsilk.a): We treat SilkString ({ char ptr; int64t len; }) as the primary C representation of Silk string values. Functions exported by libsilk.a will use SilkString in their signatures wherever strings cross the boundary. This layered design allows: idiomatic FFI to existing C libraries using const char , a precise, length\u2011carrying ABI (SilkString) for embedding the compiler/runtime. Safety & Ownership The external interface rules must ensure: No C code can violate Silk\u2019s invariants about ownership and lifetimes. Any shared data representation (strings, structs, arrays, closures) is documented and stable. Typed Errors and the ext boundary Typed errors (error, panic, and T ErrorType...) must not cross the ext boundary. Rules: ext function types must not use in their return types. Silk-to-C ABI surfaces must not expose in exported function signatures. Shims should convert typed errors into explicit error codes, optionals, or domain-specific error types, or terminate in a platform-appropriate way. The current compiler rejects ext declarations that include , and rejects exporting error-producing functions to C ABI outputs. The spec also includes a \u201cStructs, Arrays, and Closures (Complex Types)\u201d subsection for FFI. As the implementation proceeds, this document must be extended to: describe how user\u2011defined structs map to C structs (respecting the layout rules in Structs, Impl Blocks, and Memory Layout), define how arrays and slices are represented across the boundary, document any stable closure representation, if exposed in the C ABI. Structs (Initial ABI Subset) The full language design includes rich user-defined structs and nested aggregates. The current compiler implementation supports only a small subset of structs in code generation: structs with 0+ fields of supported value types (scalar primitives, string, nested structs, and supported optionals) in function bodies and internal helper calls, on linux/x8664, passing and returning these structs by value at ABI boundaries using a scalar-slot lowering model: a struct value lowers to N scalar \u201ceightbyte\u201d slots in field order, and each slot is classified as INTEGER (integer-like scalars such as int, fixed-width integers, bool, char, Instant, Duration) or SSE (f32/f64), exported function parameters accept these slots as separate parameters; for 1\u20132 slot structs this is ABI-compatible with a by-value C struct parameter for the 8-byte-field subset, while for packed structs with smaller fields ABI compatibility with an equivalent C struct layout is not yet implemented/validated; for 3+ slot structs downstream C callers should declare separate parameters for the slots, exported function returns support 1+ slot structs; 1\u20132 slot results return in rax/rdx and/or xmm0/xmm1 accordingly, while 3+ slot results return indirectly via a hidden sret pointer. This subset is intended as a stepping stone toward fully general struct layout and SysV ABI classification (including packed layout for smaller fields such as f32 and small integers, nested structs, and larger aggregates returned via hidden sret pointers). Optionals (Initial ABI Subset) The full language design includes rich optional patterns (?., match, nested optionals, etc.). The current compiler implementation supports only a limited optional subset in code generation: optionals whose payload type is a supported scalar, string, or a supported ABI-safe struct (i.e. after slot-flattening, all scalar slots are i64/u64/f64), construction via None and Some(value), unwrapping via ?? with short-circuit fallback evaluation, and nested optionals (T??) for the same supported payload subset, including unwrapping T?? to T? via ??. At ABI boundaries in the current linux/x8664 subset, optionals are lowered as a Bool tag followed by the payload scalar slots in order: (tag, payload) for scalar payload optionals, (tag, ptr, len) for string?, (tag, slot0, slot1, ...) for struct? where the payload lowers to N scalar slots. For nested optionals (T??) in this subset, the payload slots are the full inner optional representation (for example int?? lowers as (tag0, tag1, i64 payload)). For exported functions, these slots consume the normal scalar argument and result locations (registers then stack), and 3+ scalar results return via a hidden sret pointer. Compiler requirements: Implement ext declarations as specified. Map Silk types to C types per the ABI document. Enforce the documented passing conventions and ownership rules for external-call strings and other bridged types. Keep this document and C99 ABI and libsilk.a in sync with the actual codegen strategy. Blocks and Statement Composition Blocks group statements, establish lexical scopes, and provide the \u201cbody\u201d form for structured control-flow constructs like if, while, and the match statement used for typed errors. Surface Syntax A block is a sequence of zero or more statements delimited by braces: { stmt0; stmt1; ... } The empty block {} is permitted. Statements the compiler supports these statement forms (see Formal Grammar Spec for exact syntax): Local bindings: const (compile-time constant binding; initializer must be const-evaluable), let and let mut (and var as an alias for let mut). Specification-only declarations: #const (Formal Silk; not usable in runtime expressions). Structured blocks: async { ... } / task { ... } (see Concurrency). Expression statements: limited to calls, assignments, and increment/decrement In Silk (Expression Statements). Flow control: if / else statements, while loops, break, continue, return, assert, panic (typed errors), match statement (typed errors; see Typed Errors (error, panic, and T ErrorType...)). Semantics Sequencing Statements in a block execute in source order. If a statement transfers control out of the current block (return, panic, break/continue inside loops), the remainder of the block is not executed on that path. Scope A block introduces a lexical scope: Names declared by const/let/var are visible only after their declaration within the same block, and within any nested blocks. Inner blocks may shadow outer bindings by reusing a name (this is a normal lexical-shadowing rule; the checker should reject only when a specific feature imposes stricter rules). The special name is a discard binding: let = expr; and let : T = expr; evaluate the initializer but do not introduce a binding into scope. may be used repeatedly in the same scope without conflicts. Any produced runtime value is cleaned up at end-of-statement (not at scope exit). Destructuring let bindings bind multiple locals from a single struct value: Positional (field order): struct User { id: u64, name: string } let (id, name) = User{ id: 123, name: \"alice\" }; Named (by field name, order-independent), with aliasing: struct Record { id: u64, data: string } let { data, id } = Record{ id: 123, data: \"a record\" }; let { data as d, id as i } = Record{ id: 456, data: \"other record\" }; Array destructuring binds multiple locals from a single array/slice value: struct Record { id: u64, data: string } let records: Record[] = [{ id: 123, data: \"a\" }, { id: 456, data: \"b\" }]; let [a, b] = records; Rules: Only flat patterns are supported (no nested destructuring). The initializer is required. The initializer must have a non-opaque struct value type. The pattern must account for every field exactly once: positional patterns must have exactly one binder per declared field (in field order), named patterns must list each field exactly once (in any order), use to discard a field (let (, name) = ...; or let { data as } = ...;). For array/slice destructuring: The initializer must have an array type (T[N]) or slice type (T[]). Each binder is positional (index order). The pattern binds exactly the number of listed binders: fixed arrays require an exact arity match ([a, b] requires T[2]), slices trap at runtime if too short (as if indexing each element). const bindings are compile-time constants: their initializer expression must be compile-time evaluable (otherwise the compiler reports an error), the binding is immutable (there is no const mut), a const binding is a normal runtime value (unlike #const), but its value is computed by the compiler at compile time and does not incur runtime computation cost in Silk. In Silk, compile-time evaluation for runtime const bindings is restricted to: scalar primitive types (bool, integer/float scalars, char, Instant, Duration), and pure scalar expressions composed of: literals, other const bindings, calls to const fn functions where all arguments are themselves compile-time evaluable, and as casts between supported scalar types, and a small operator subset (notably +, -, , bitwise ops, shifts; / and % are currently rejected for const). string bindings whose initializer is either: a string literal (\"...\" or ... ), or another const string binding. Formal Silk declarations (#const) are compile-time-only names intended for specifications (#require, #assure, #assert, #invariant, #variant, #monovariant). They must not be referenced in runtime expressions (see Formal Silk and Compiler Diagnostics, E2014). Blocks as Expressions The broader language design includes expression-oriented flow constructs (for example match expressions today and if expressions). In Silk: a block is not an expression and does not produce a value; it is purely a statement list used as the body of constructs. The if expression form is a special-case expression-oriented construct; it does not make { ... } a general expression form. If/when general block expressions are introduced, the spec will define: which contexts accept them (and how ambiguity with { ... } struct literals is resolved), and how their result values are computed. Examples Nested scope fn main () -> int { let x: int = 1; { let y: int = 2; if x < y { return 0; } } return 1; } Formal Silk declarations for loop specifications fn main () -> int { let limit: int = 3; #const originallimit = limit; let mut i: int = 0; #invariant i >= 0; #invariant i <= originallimit; #variant originallimit - i; while i < limit { i = i + 1; } return 0; } Build Metadata (BUILDKIND, BUILDMODE, BUILDVERSION) Silk exposes a small set of compiler-provided build metadata values to both runtime code and Formal Silk (compile-time verification) so programs can adapt to build configuration and so theories can express \u201cthis code is only valid in test builds\u201d, \u201cthis feature requires a minimum version\u201d, and similar policies. Built-In Constants The compiler provides the following built-in constants in every module: BUILDKIND: string BUILDMODE: string BUILDVERSION: string BUILDVERSIONMAJOR: u64 BUILDVERSIONMINOR: u64 BUILDVERSIONPATCH: u64 These behave like normal const string values: They do not require an import. They may be used anywhere a string expression is allowed. They are compile-time constants (their values are fixed at compile time and are embedded into the output artifact). BUILDKIND The output kind currently being built: \"executable\" \"object\" \"static\" \"shared\" BUILDMODE The build mode currently being built: \"debug\" \"release\" \"test\" Notes: \"test\" is the mode used by silk test. Debug stack traces and debug assertion behavior are controlled separately by std::runtime::build::isdebug() (see std::runtime). BUILDVERSION The semantic version of the current package when building from a manifest. When building from a package manifest (silk.toml), BUILDVERSION is the manifest version. When not building from a manifest, BUILDVERSION is \"0.0.0\". BUILDVERSIONMAJOR / BUILDVERSIONMINOR / BUILDVERSIONPATCH The SemVer core triplet (major.minor.patch) of BUILDVERSION exposed as u64 values for convenient comparisons (especially in Formal Silk). Rules: These parse the major.minor.patch prefix of BUILDVERSION. Any trailing -prerelease or +build suffix is ignored. On parse failure, all three values default to 0. Relationship to std::runtime::build The standard library provides std::runtime::build functions that return the same metadata: std::runtime::build::kind() -> string std::runtime::build::mode() -> string std::runtime::build::version() -> string Use std::runtime::build when you prefer explicit namespacing or when writing code intended to run under alternate stdlib roots. Examples Build-mode gated behavior fn main () -> int { if BUILDMODE == \"test\" { // Test-only behavior. return 0; } return 0; } Version-gated behavior For semver parsing and comparison, use std::semver at runtime or reuse the formal theories provided by std::formal (see Formal Silk). Testing This document specifies the initial language-level testing surface for Silk. The goal is a Zig-like authoring experience (tests live next to the code they exercise) with a simple CLI runner that emits modern TAP output for downstream consumption. test declarations A test declaration is a top-level block of statements that the compiler can compile and execute under silk test. Syntax: test \"name\" { // statements... } The string name is optional: test { // statements... } Rules: test declarations MAY appear: at top level (like fn and let), and nested inside another test block (scoped subtests). A test block introduces its own scope (like a function body). Nested test blocks are executed inline, in source order, as part of the enclosing test\u2019s execution. They may be used for hierarchical grouping and shared setup. test blocks may use let, var, control flow, and call functions/methods using the same expression subset as normal code. return; is allowed inside a test block (equivalent to ending the test early). return <expr>; is not allowed. Doc comments: Doc comments (/ ... / and /// ...) attach to a test declaration the same way they attach to other top-level declarations. Running tests (silk test) The silk test command: loads a module set (like silk check / silk build), discovers all test declarations in the module set, and executes them, emitting TAP output. TAP output The initial runner uses TAP version 13 formatting: TAP version 13 1..N ok <n> - <name> not ok <n> - <name> Assertions inside tests In silk test builds, failed assertions do not abort the process. Instead: A failed assert records a test failure and execution continues. If the assertion has no explicit message, the compiler uses the assertion condition text as the message (e.g. assert value != 123; uses value != 123). The test executable exits non-zero if any failures were recorded so TAP output reflects failures. The current runner still isolates top-level tests in separate processes, but a single test case may now accumulate multiple failures. std::test (standard test helpers) The standard library provides std::test helpers for test-only assertions that record failures without aborting: expect(ok: bool, message: string? = None); expectequal(expected: X, actual: Y) -> bool; expecterror(err: E?) -> bool; See std::test for the detailed API. Note: std::test helpers carry a Formal Silk contract requiring BUILDMODE == \"test\" via std::formal.requirestestmode() so downstream verification can model them as test-only APIs. Arenas Arenas are not part of the language surface. Use regions instead. See Regions. Silkdoc (Documentation Comments) This document specifies Silkdoc, Silk\u2019s documentation-comment format. Silkdoc comments are intended for tools (documentation generators, editors, and the language server). They do not affect program semantics. The goal is a familiar JSdoc feel with Silk/TypeScript-style type annotations. Comment Forms Two doc-comment forms are recognized: Block doc comments: / ... / Line doc comments: one or more consecutive lines starting with /// In both forms, doc comments attach to the next declaration when they appear immediately before it with only whitespace/comments between them. Initial implementation scope: Doc comments attach to top-level declarations (package, module, import, fn, theory, let, struct, ext, interface, impl). Doc comments also attach to: methods inside impl Type { ... } blocks, and method signatures inside interface Name { ... } blocks. For function declarations, doc comments attach even when one or more formal verification annotations (#require / #assure) appear between the doc comment and the fn keyword. Doc comments inside function bodies are treated as ordinary comments (not attached to anything). Attaching doc comments to struct fields, parameters, and locals is future work. Content Model A doc comment contains: free-form text (Markdown-friendly) describing the declaration, and optional tags starting with @. The free-form text is everything before the first tag line. Any non-tag lines that appear after the first tag line are ignored unless they are part of a multi-line tag body (for example @example or @remarks). Leading convention For block doc comments, the conventional leading is ignored: / Hello world / Tools strip the leading (and one following space when present) before parsing. Tags Tags begin at the start of the logical line after stripping comment prefixes. @param Declare a parameter description. Syntax: @param <name>: <Type> <description...> @param <name> <description...> The <Type> uses Silk type syntax as defined in Types. Example: / Appends one byte to the vector, growing as needed. @param self: &std::vector::Vector(u8) The receiver. @param value: u8 The byte to append. / @returns Describe the return value. Syntax: @returns <Type> <description...> @returns <description...> @throws Describe an error/exception-like condition. Syntax: @throws <Type> <description...> @throws <description...> Note: the language does not yet have a stable error type; @throws is documentation-only until Result(T, E) and error conventions are fully implemented. @external Indicate that a declaration is an external FFI binding (its implementation is provided outside Silk). This tag is typically used to document ext function declarations. Syntax: @external @example Provide an example snippet. The tag may optionally declare a language for Markdown fenced code blocks. Syntax: @example <one or more lines of example text> @example silk <one or more lines of code> The example body continues until the next tag line or the end of the doc comment. Other tags The initial toolchain may also recognize: @since <text...> @deprecated <text...> @remarks <text...> (may span multiple lines like @example) @see <text...> (repeatable) Additional tags must be documented here before they are relied on by tooling. Formal Silkdoc tags Silkdoc can document Formal Silk constructs without affecting verification. These tags are documentation-only (they do not prove anything and do not introduce Formal Silk obligations). @requires Document one precondition for a declaration (typically mirroring #require on a function or a theory). Syntax: @requires <Expr...> This tag is repeatable. @assures Document one postcondition for a declaration (typically mirroring #assure on a function or a theory). Syntax: @assures <Expr...> This tag is repeatable. @asserts Document one internal proof obligation (typically mirroring a #assert inside a function or theory body). Syntax: @asserts <Expr...> This tag is repeatable. @theory Document one theory attachment or use (typically mirroring #theory Name(args...);). Syntax: @theory <Name(args...)...> This tag is repeatable. Manpage-oriented tags The toolchain uses a small set of optional doc tags to generate man(7) pages from source comments (silk doc --man and silk man). These tags are documentation-only and do not affect program semantics. @misc Declare a conceptual documentation block intended for man section 7. Syntax: @misc <label> <summary...> @misc <label> Notes: The <label> is an opaque identifier used by tooling for discovery (for example silk man <label>). It should be stable and globally unique within a package (recommendation: use a pkg::topic label). The optional <summary...> provides a one-line description for the manpage NAME section. When omitted, tools may derive a summary from the first line of the free-form description text. @cli Declare that a doc comment describes a command-line interface, intended for man section 1. Syntax: @cli <name> @cli When <name> is omitted, tools derive the command name from context (for example the module name or executable name provided by the build system). @synopsis Provide one or more synopsis lines for a CLI manpage. Syntax: @synopsis <one or more lines of synopsis text> The synopsis body continues until the next tag line or the end of the doc comment. @option Declare a command-line option for a CLI manpage. This tag is repeatable. Syntax: @option <prototype...> @option <prototype...> <description...> Examples: @option -h, --help Show help and exit. @option --out <path> Write output to <path>. @command Declare a subcommand for a CLI manpage. This tag is repeatable. Syntax: @command <name> <description...> Markdown Rendering The documentation generator renders doc comments to Markdown using: the free-form text as the leading description (paragraphs preserved), @param entries as a \u201cParameters\u201d list, @returns as a \u201cReturns\u201d section, @throws as a \u201cThrows\u201d section, @requires, @assures, @asserts, and @theory as dedicated sections (one bullet per tag instance), @example blocks as fenced code blocks. The generator must keep formatting stable (deterministic output) so that documentation diffs are meaningful. Expression Statements Expression statements allow expressions to be used for their side effects. Syntax An expression statement is an expression followed by a semicolon: expr; Semantics The expression is evaluated exactly once. The result value (if any) is discarded. Current implementation restrictions For the compiler, an expression statement is only valid when the expression is either: a call expression (a function call), or an assignment / compound assignment expression. an increment/decrement expression (++x, x++, --x, x--). All other expression statements are rejected. This restriction will be relaxed as more of the expression language is lowered and code-generated. Examples (accepted in Silk): fn main () -> int { std::io::println(\"hello\"); let mut x: int = 0; x = 1; x += 2; x++; return 0; } Examples (rejected in Silk): fn main () -> int { 1 + 2; // rejected: non-call/non-assignment expression statement (E2002) return 0; } Guidance If you computed a value and you want to keep it, bind it: fn main () -> int { let x: int = 1 + 2; return x; } If you want a value for control flow, prefer an expression form that produces a value (for example match expressions; see match Expression). Compiler requirements The compiler must: Distinguish between expressions that can appear as statements and those that cannot (if the spec imposes restrictions). Preserve evaluation order consistent with the language\u2019s semantics. for Loop The for loop iterates over a range or iterable and executes a block once per element. start..=end), array/slice iteration (for x in xs { ... } for T[N] and T[]), iterator iteration (for x in it { ... } when it.next() -> T?), and C-style for (init; condition; step) { ... } loops. Goals Provide a readable, structured loop construct for iteration. Avoid \u201coff-by-one\u201d patterns by making range boundaries explicit. Integrate with break / continue. Integrate with future iteration protocols (interfaces/generics) without introducing hidden allocation. Surface Syntax Supported surface forms: for <pattern> in <iterable> { ... } for (<init>; <condition>; <step>) { ... } Notes: <pattern> is intended to be a pattern binder. In early implementations it is restricted to a single identifier (and ). It will be expanded alongside pattern matching. <iterable> is an expression. <init> is a local binding (let / var / const) with an initializer. <condition> is a boolean expression. <step> is a statement-like expression (the same restricted subset as expression statements; see Expression Statements). Semantics General rules: The iterable expression is evaluated once to produce an iteration source. The loop body executes once per produced element. break exits the loop; continue advances to the next element. Range iteration When the iterable is a range expression (for example start..end or start..=end), the loop iterates over integer values. Design intent: start..end iterates start, start+1, ..., end-1 (end-exclusive). start..=end iterates start, start+1, ..., end (end-inclusive). Notes: The range bounds are evaluated once, left-to-right (start then end). If the start bound is greater than or equal to the end bound (start >= end) for an end-exclusive range, the loop executes zero times. If the start bound is greater than the end bound (start > end) for an end-inclusive range, the loop executes zero times. continue advances to the next element (it performs the increment step, then re-checks the range condition). The loop binder is in scope only inside the loop body block. The binder is immutable in Silk (it behaves like a let binding that is updated by the loop machinery; user code cannot assign to it). Type checking: Both range bounds must have integer type (int, i8/u8, i16/u16, i32/u32, i64/u64). The two bound types must match, except that an integer literal bound may be coerced to the other bound\u2019s integer type (for example for i in 0..nu32). The loop binder (when not ) has the bound\u2019s integer type. Example: fn main () -> int { let mut sum: int = 0; for i in 0..3 { // i takes values 0, 1, 2 sum += i; } // 0 + 1 + 2 = 3 return sum; } Array and slice iteration In Silk, for also supports iterating over builtin array and slice types: fixed arrays T[N], slices T[]. Semantics: The iterable expression is evaluated once. The loop executes in increasing index order, starting at index 0. The loop binder (when not ) is bound to the element value (a copy) for the current iteration. The binder is in scope only inside the loop body block. break exits the loop; continue advances to the next element. Limitations: Element types are limited to the currently-supported array/slice element subset (types that lower to a fixed scalar slot sequence in the current back-end, such as primitive scalars, string, and supported non-opaque structs). Iteration is by value; to mutate an element, use indexing (xs[i] = ...). Example: fn main () -> int { let xs: int[3] = [1, 2, 3]; let mut sum: int = 0; for x in xs { sum += x; } return sum; } Iterator protocol In addition to builtin arrays and slices, for supports iterating over a stateful iterator value. An expression it is treated as an iterator when it has a next() -> T? instance method (typically by implementing std::interfaces::Iterator(T)). Semantics: The iterable expression is evaluated once to produce the iterator value. The loop repeatedly calls (mut it).next(). When the result is None, the loop exits. When the result is Some(value), the binder (when not ) is bound to value (a copy) for that iteration and the body executes. continue advances by calling next() again; break exits the loop. C-style for loops Silk also supports the traditional \u201cC-style\u201d for loop: fn main () -> int { let len: int = 10; let mut sum: int = 0; for (let i = 0; i < len; ++i) { sum += i; } return sum; } Semantics: <init> executes exactly once before the first condition check. <condition> is checked before each iteration; if it is false, the loop exits. The loop body executes once per iteration when <condition> is true. After the body executes normally, <step> executes, then the loop re-checks <condition>. continue; skips the remainder of the loop body and jumps to <step> (then re-checks <condition>). break; exits the loop immediately without executing <step> for that iteration. The init binding\u2019s name is in scope within the entire loop (condition, step, and body) but is not visible after the loop. Init binding mutability: For ergonomics, for (let i = 0; ...; ++i) is accepted and the init binding is treated as mutable (equivalent to var) within the loop. const init bindings remain immutable. Guidance In Silk, for supports integer ranges and builtin array/slice iteration. To write other loops today, use while: fn main () -> int { let mut i: int = 0; while i < 3 { std::io::println(\"i = {}\", i); i += 1; } return 0; } Compiler Requirements Recognize for loop syntax. Resolve iteration targets (ranges, collections) according to the language\u2019s iteration model. Lower for into explicit control flow, with correct semantics for break and continue. Compiler requirements: Recognize for loop syntax. Resolve iteration targets (ranges, collections) according to the language\u2019s iteration model. loop Loop The loop statement executes a block repeatedly until it is terminated by a break or return. task loop { ... }. Surface Syntax loop { // ... } async loop { // ... } task loop { // ... } Notes: async loop and task loop are still loop statements: they do not end with ;. In Silk, async loop / task loop follow the same async-context restriction as async { ... } / task { ... }: they are only allowed inside functions declared with async (Compiler Diagnostics, E2031). Semantics The body block executes repeatedly. break; exits the nearest enclosing loop and continues execution at the statement immediately following the loop (break). continue; skips the remainder of the current iteration\u2019s body and begins the next iteration (continue). return; exits the current function (return). Type Checking Rules The loop body is checked in a loop context so break / continue are valid. break; outside a loop is rejected (Compiler Diagnostics, E2007). continue; outside a loop is rejected (Compiler Diagnostics, E2008). Type Unions (T1 T2 ...) Silk supports type unions in type annotations. A union type represents a value that is exactly one of several member types. This feature exists to model small, explicit \u201cone-of-these-types\u201d outcomes without requiring a dedicated nominal enum declaration for every case. See also: Typed Errors (error, panic, and T ErrorType...) (unparenthesized in function signatures is reserved for typed-error contracts), enum Types (general tagged unions with named variants), match Expression (match over union values). Surface Syntax Union types use between member types: let x: Foo Bar; struct S { v: u8 bool } type U = Foo Bar Baz; Return types (important disambiguation) In function declarations, unparenthesized after -> is reserved for typed errors (SuccessType ErrorType...). To write a union as a function\u2019s return type, the union must be parenthesized: fn f () -> (Foo Bar); fn g () -> (Foo Bar) SomeTypedError; This disambiguation is required so the parser and checker can treat typed-error contracts as authoritative. Rules The initial implementation intentionally supports only unions whose member types have a safe, well-defined representation in the current compiler/backend subset. A union type T1 T2 ... Tn is permitted when all member types are in the supported union-member set: Primitive scalar types in { bool, char, i8, u8, i16, u16, i32, u32, i64, u64, int, usize, size, Instant, Duration } (isize is accepted as an alias for size), and/or Nominal POD structs (including error types) that lower to a scalar-slot representation in Silk (no opaque structs; no enums). Unions may freely mix primitive and nominal members in this subset. For primitive members, the current native backend requires that each member type be distinguishable at injection sites. In practice, that means a union may not contain two primitive types that lower to the same backend scalar representation (for example int i64, usize u64, char u32, Duration i64). This restriction is specific to the backend and may be relaxed once union injection uses full type identity rather than a backend-scalar heuristic. Notes: Nested unions are flattened: (A B) C is the same union as A B C. Duplicate member types are rejected. Semantics A value of a union type is a tagged value: It stores a runtime tag identifying which member type is active. It stores the payload value in a uniform representation compatible with all members in Silk. Representation In the current native backend subset, unions are lowered as: (u64 tag, u64 payload0, ..., u64 payload(N-1)) where N is the maximum scalar-slot count across the union\u2019s member types (primitive members contribute 1). Member payload values are stored/loaded via raw-bit casts (castraw) to and from the u64 payload slots. Unused payload slots are zero-filled on injection and on widening coercions. Union-to-union coercions (supersets) When a context expects a union type Usup, a value of a union type Usub may be used if Usub\u2019s member set is a subset of Usup\u2019s member set. The compiler remaps the runtime tag to the destination union\u2019s tag numbering when needed so pattern matches on the destination union remain correct. If Usup\u2019s payload is larger than Usub\u2019s payload (because Usup contains a member with a larger scalar-slot representation), the payload is widened by copying existing payload slots and zero-filling the newly-added slots. Construction (injection) When a context expects a union type, a value whose type is one of the union\u2019s member types may be used directly and is injected into the union. Examples: struct A { x: int } struct B { x: int } type U = A B; fn main () -> int { let a: A = A{ x: 1 }; let u: U = a; // inject A into U return 0; } Matching (match) Union values are consumed via match expressions using typed binder patterns: type U = A B; let out: int = match u { a: A => a.x, b: B => b.x, }; Rules: The scrutinee must have a union type. Patterns are restricted to name: Type (or : Type) where Type is one of the union member types. Matches must be exhaustive: exactly one arm per member type (order does not matter). using (Aliases and Method Reuse) using introduces a local alias to an existing symbol, and (in interface / impl bodies) can import method signatures/implementations under a new name. This feature is intended to make large module trees ergonomic (short local names) and to enable explicit, audited method reuse across types. Syntax At any supported scope, using has two surface forms: using Alias = QualifiedName; using QualifiedName; using QualifiedName as Alias; Where QualifiedName uses the normal ::-separated name syntax (including the global-prefix form ::name). Module / Package Scope At module scope, using introduces a local alias for an in-scope symbol: types (struct / enum / error / interface / type aliases), functions (fn and ext function bindings), Formal Silk theories (theory). The alias is transparent: using Alias is equivalent to using the target symbol directly. Name conflicts are errors, except when the alias already refers to the same symbol as the target (a redundant alias). In that case the using declaration is accepted as a no-op. interface Scope Inside an interface { ... } body, using may import method signatures from another interface: interface Read { fn read() -> u8; } interface ReadAndPeek { using Read::read; fn peek() -> u8; } using Other::name; is equivalent to copying the corresponding fn name(...); signature from Other. using Other::name as alias; imports it under the new name alias. Name conflicts (including conflicts with inherited extends members) are errors. Note: interface method signatures omit the receiver parameter. The receiver is introduced only in impl method declarations (see Interfaces). impl Scope Inside an impl Type { ... } body, using may import a method implementation from another impl: impl Foo { fn id(self: &Foo) -> int { return 1; } } impl Bar { using Foo::id; } This makes the imported method available as if it were declared in the target impl, including as a candidate for interface conformance checking. Visibility Imported methods inherit the source method\u2019s visibility: importing a public fn method produces a public method in the target impl, importing a private method produces a private method in the target impl. Since using does not accept visibility modifiers in Silk, this inheritance rule is the only way to control whether an imported method is callable outside the target impl { ... } block. Self and Layout Compatibility When the imported method\u2019s signature depends on Self (for example self: &Self, parameters of type Self, or returning Self), importing it across distinct struct types requires that the underlying layouts are compatible. In Silk, a pair of non-opaque, non-error structs are considered compatible when they have the same number of fields and the same field types in the same order (field names do not matter). If the source and target struct layouts are not compatible, the using declaration is rejected. Limitations using does not accept public / private modifiers yet (imported methods inherit the source method\u2019s visibility). Imported methods whose Self-dependent parameters require a mutable borrow (mut &Self) are rejected in Silk. Constructor reuse (constructor) via using is not supported yet. Compiler Diagnostics This document specifies the human-readable diagnostic format emitted by the Silk toolchain, including: the silk CLI (silk check, silk build), the embedding ABI (libsilk.a via silkcompilerlasterror / silkerrorformat), and tooling that reuses the front-end (for example silk-lsp). The goal is to provide diagnostics that are: precise (file + line + column + source span), stable (consistent wording and stable error codes for known error kinds), consumable by humans (caret snippets, notes/help where appropriate), easy to test (deterministic formatting; the canonical text contains no ANSI escapes). Terminology Source span: a byte range in the UTF\u20118 source buffer (offset, length). Displayed line and column numbers are 1-based. Columns are measured in UTF\u20118 bytes (matching the lexer\u2019s current Token.column behavior). Primary label: the main span where the error is reported (single span in the initial implementation). Note / Help: supplemental lines that explain context or suggest a fix. Text Format (CLI and ABI) The standard human-readable diagnostic format is: error[E<code>]: <message> <path>:<line>:<column> <line> <source line text> <caret underline> = note: <note text> (optional, repeatable) = help: <help text> (optional, repeatable) Rules: The error[...] line always appears for known error kinds; <code> is stable for that error kind. For diagnostics with no usable location, the --> ... and snippet block may be omitted. The snippet block uses the 1-based line number and includes the full line text as it appears in the source. The caret underline is placed under the primary span: for a zero-length span, print a single ^, otherwise print ^ repeated for the span length, clipped to the line end if needed. The canonical text format contains no ANSI color escapes. Manifest and Config Errors The CLI uses the same caret diagnostic format for errors in tooling/config inputs, including the package manifest silk.toml and build-script-generated manifests. These diagnostics may not yet have stable error codes. Example (missing = in silk.toml): error: invalid TOML in package manifest silk.toml:2:6 2 name \"app\" ^ expected = ANSI Color (CLI) The silk CLI may decorate the canonical diagnostic format with ANSI SGR escape codes when writing to a terminal. The visible text (after stripping ANSI escapes) must still match the canonical format. Color is enabled only when: stderr is a TTY that supports ANSI escapes, NOCOLOR is not set, TERM is not dumb. Color is never used for the embedding ABI (silkerrorformat / silkcompilerlasterror), and is not used when stderr is not a TTY (for example when piping diagnostics to a file). Suggestions and Help Text Diagnostics may include one or more = help: lines that suggest concrete fixes. These are heuristic and may be omitted when the compiler cannot compute a safe suggestion. Examples of help/suggestion content the compiler may emit: for unknown imports, a \"did you mean ...?\" suggestion based on nearby names, for file imports, a note about the resolved import path, reminders about enabling or configuring the standard library (--nostd, std-root, SILKSTDROOT) when importing std::..., guidance to include additional modules in the build/module set when an import refers to a package or file that is not present. Error Codes (Initial Set) The compiler assigns a stable code to each currently supported error kind. Parsing E0001 \u2014 unexpected token / invalid top-level ordering. Import and Package Resolution E1001 \u2014 unknown imported package. E1002 \u2014 cyclic package imports. E1003 \u2014 unknown imported file. E1004 \u2014 cyclic file imports. E1005 \u2014 duplicate exported symbol within a package. E1006 \u2014 file imports require a module file path. Type Checking E2001 \u2014 type mismatch. E2002 \u2014 unsupported construct in Silk (the diagnostic detail may identify the rejected statement/expression form). E2003 \u2014 unknown imported name. E2004 \u2014 duplicate imported name. E2005 \u2014 invalid assignment. E2006 \u2014 invalid borrow. E2007 \u2014 invalid break. E2008 \u2014 invalid continue. E2009 \u2014 invalid return. E2010 \u2014 missing return. E2011 \u2014 opaque struct used by value. E2012 \u2014 cannot instantiate opaque struct. E2013 \u2014 cannot access fields on opaque struct. E2014 \u2014 formal Silk declaration used in runtime expression. E2015 \u2014 let requires an initializer. E2016 \u2014 unsupported generic form in Silk (for example const parameters / const type arguments). E2017 \u2014 builtin map(K, V) type form was removed (use std::map::{HashMap, TreeMap} instead). E2018 \u2014 namespace import is not callable. E2019 \u2014 duplicate default export in a module. E2020 \u2014 invalid panic statement. E2021 \u2014 unknown error type. E2022 \u2014 error not declared in function signature. E2023 \u2014 error-producing call must be handled with match. E2024 \u2014 match scrutinee is not an error-producing call. E2025 \u2014 match is missing an arm. E2026 \u2014 typed error-handling match arm must end with a terminal statement. E2027 \u2014 heap allocation is disabled (--noheap) and heap-backed allocation is rejected (new outside with, libc allocator ext, concurrency keywords, capturing closures). E2028 \u2014 unknown name. E2029 \u2014 ambiguous implicit coercion. E2030 \u2014 await requires an async function. E2031 \u2014 async { ... } / task { ... } requires an async function. E2032 \u2014 ambiguous constructor call. E2033 \u2014 await requires a Promise operand. E2034 \u2014 cannot copy a Task/Promise handle. E2035 \u2014 Task/Promise handle used after await/yield . E2036 \u2014 cannot consume an outer Task/Promise handle inside a loop. E2037 \u2014 task fn uses a non-task-safe type at a task boundary. E2038 \u2014 ? requires an error contract (-> T ErrorType...). E2039 \u2014 ? requires a fallible call operand. E2040 \u2014 propagated error is not declared in the function signature. E2041 \u2014 const initializer is not compile-time evaluable. E2042 \u2014 pure fn may not have a typed-error contract ( in return type). E2043 \u2014 pure fn may not contain panic statements. E2044 \u2014 pure fn may not have mut parameters. E2045 \u2014 pure fn may not declare mutable locals (var or let mut). E2046 \u2014 pure fn may not perform mutation via assignment. E2047 \u2014 pure fn may not allocate (new). E2048 \u2014 pure fn may not call impure functions. E2049 \u2014 pure fn may not be combined with task or async. E2050 \u2014 theories are not callable as runtime functions (use #theory Name(...);). E2051 \u2014 module does not satisfy the declared interface (missing exported function). E2052 \u2014 module does not satisfy the declared interface (signature mismatch). E2053 \u2014 unknown re-export name. E2054 \u2014 duplicate exported name. E2056 \u2014 function expression may not have &T parameters. E2057 \u2014 duplicate type alias name. E2058 \u2014 type alias cycle. E2059 \u2014 type alias kind mismatch. E2060 \u2014 unknown extends base. E2061 \u2014 invalid extends base. E2062 \u2014 cyclic extends chain. E2063 \u2014 derived struct redeclares an inherited field name. E2064 \u2014 derived interface redeclares an inherited method name. E2065 \u2014 opaque structs may not use extends. E2067 \u2014 capturing closure is not allowed in pure code. E2068 \u2014 capturing closure capture type is not supported in Silk. E2069 \u2014 capturing closure may not capture a mutable binding in Silk. E2070 \u2014 yield requires a task context. E2071 \u2014 yield in value position requires a Task operand. E2072 \u2014 yield requires a Task operand. E2073 \u2014 yield as a statement requires an enclosing task function. E2074 \u2014 await requires a Promise-array operand. E2075 \u2014 duplicate type name. E2076 \u2014 generic type arguments must be fully specified at the use site (missing a required, non-default type argument). E2077 \u2014 invalid region declaration. E2078 \u2014 with requires a region binding. E2079 \u2014 invalid with ... from region slice. E2080 \u2014 reserved (previously: indexing a slice cast from u64 required an explicit length). E2081 \u2014 slice-length cast suffix requires a u64 pointer operand. E2082 \u2014 const fn may not be task or async. E2083 \u2014 const fn may not have a typed-error contract ( in return type). E2084 \u2014 const fn parameter types must be compile-time value types. E2085 \u2014 const fn result type must be a compile-time value type. E2086 \u2014 const fn may not allocate (new). E2087 \u2014 const fn may not call a non-const fn. E2088 \u2014 const fn may not contain panic statements. E2089 \u2014 unsupported construct in a const fn body (outside the current const-eval subset). E2090 \u2014 const fn may be called only from compile-time contexts. E2091 \u2014 generic function call type arguments could not be inferred at the call site. E2092 \u2014 use of moved value. E2093 \u2014 move requires a local binding name. E2094 \u2014 slice borrow escapes its lexical scope. E2095 \u2014 reference borrow escapes its lexical scope. E2096 \u2014 unknown using target. E2097 \u2014 using alias conflicts with an existing name. E2098 \u2014 using target is ambiguous. E2099 \u2014 using cannot import constructor In Silk. E2100 \u2014 using may not import methods that require mutable Self borrows in Silk. E2101 \u2014 using method reuse requires compatible struct layouts. E2102 \u2014 cannot move value while it is borrowed. E2103 \u2014 invalid regexp flags (unknown or duplicate). E2104 \u2014 invalid regexp literal (pattern compile failed). E2105 \u2014 method is private to its impl block (not visible from the call site). E2106 \u2014 interface-required methods may not be declared private. E2107 \u2014 destructuring requires a non-opaque struct value. E2108 \u2014 cannot destructure opaque struct. E2109 \u2014 destructuring pattern does not match the struct type (wrong arity, unknown field, or duplicate binder/field). E2110 \u2014 array destructuring requires an array/slice value. E2111 \u2014 array destructuring pattern does not match the array type (wrong arity for fixed arrays, or duplicate binder). Formal Silk Verification E3001 \u2014 loop invariant may not hold. E3002 \u2014 loop variant may be negative. E3003 \u2014 loop variant may not decrease. E3004 \u2014 postcondition may not hold. E3005 \u2014 Formal Silk verification failed to initialize or encountered an unsupported construct. E3006 \u2014 assertion may not hold (#assert and theory assertions). E3007 \u2014 call precondition may not hold. E3008 \u2014 loop monovariant may not be monotonic. Notes: When silk build --debug or silk test --debug is used, failed Formal Silk checks emit additional Z3 debug output and write an SMT-LIB2 reproduction script under .silk/z3/ in the current working directory (or $SILKWORKDIR/z3). Code Generation / Backend Lowering E4001 \u2014 unsupported construct in Silk. E4002 \u2014 code generation failed in the backend (unexpected backend error). Notes: This error is reported when a program successfully parses and type-checks, but IR lowering or native code generation cannot yet handle a construct. The diagnostic detail names the rejected construct kind (statement / expression / function) and its surface form tag when available. Tooling Integration Notes silk-lsp should map the compiler\u2019s primary source span to the LSP diagnostic range directly. When the compiler grows multi-span diagnostics (labels and secondary spans), the LSP implementation must be updated to surface them. C99 ABI and libsilk.a This document defines the C99 ABI and the interface of the libsilk.a static library. Goals Provide a stable C ABI for embedders. Mirror the external-declaration semantics described in External Declarations (ext). Keep the ABI small, explicit, and well-documented. Library & Headers Static library: libsilk.a. Primary header: include/silk.h. Linking on linux/x8664 (vendored Z3) On linux/x8664, libsilk.a vendors Z3 (via vendor/lib/x64-linux/libz3.a) to support Formal Silk verification. The vendored Z3 static library is built as C++, so downstream embedders linking against libsilk.a MUST also link the system C++ runtime and any required system libraries: cc -std=c99 -Wall -Wextra \\ I/path/to/include yourapp.c \\ L/path/to/lib -lsilk \\ lstdc++ -lpthread -lm The silk cc wrapper adds these flags automatically when linking on linux/x8664. The header must define: Core bridged types (e.g. SilkString, and any other structs or enums used by the ABI). Opaque handle types (SilkCompiler, SilkModule, SilkError) and their lifetime rules. Entry points for: initializing and shutting down compiler/runtime state, configuring compilation (target triple, stdlib name, optimization level), adding source buffers, compiling Silk source to executables, libraries, or object files, interacting with diagnostics and error reporting. Initial C Header Shape (include/silk.h) The initial C header provided in this repository defines: SilkString mirroring the internal Silk string layout: Note: SilkString is also the C ABI shape for Silk regexp values (bytecode-backed { ptr, len }), but the bytes are opaque and not required to be null-terminated. typedef struct SilkString { char ptr; int64t len; } SilkString; SilkBytes for owned binary buffers returned by in-memory build APIs: typedef struct SilkBytes { uint8t ptr; int64t len; } SilkBytes; Opaque handles: typedef struct SilkCompiler SilkCompiler; typedef struct SilkModule SilkModule; typedef struct SilkError SilkError; An output-kind enum: typedef enum SilkOutputKind { SILKOUTPUTEXECUTABLE = 0, SILKOUTPUTSTATICLIBRARY = 1, SILKOUTPUTSHAREDLIBRARY = 2, SILKOUTPUTOBJECT = 3, } SilkOutputKind; ABI version query: void silkabigetversion(int outmajor, int outminor, int outpatch); Compiler lifecycle: SilkCompiler silkcompilercreate(void); void silkcompilerdestroy(SilkCompiler compiler); Configuration: bool silkcompilersetstdlib(SilkCompiler compiler, SilkString stdlibname); bool silkcompilersetstdroot(SilkCompiler compiler, SilkString stdroot); bool silkcompilersetnostd(SilkCompiler compiler, bool nostd); bool silkcompilersetdebug(SilkCompiler compiler, bool debug); bool silkcompilersetnoheap(SilkCompiler compiler, bool noheap); bool silkcompilersettarget(SilkCompiler compiler, SilkString targettriple); bool silkcompilersetz3lib(SilkCompiler compiler, SilkString path); bool silkcompilersetstdarchive(SilkCompiler compiler, SilkString path); bool silkcompileraddneededlibrary(SilkCompiler compiler, SilkString soname); bool silkcompileraddrunpath(SilkCompiler compiler, SilkString path); bool silkcompilersetsoname(SilkCompiler compiler, SilkString soname); bool silkcompilersetoptimizationlevel(SilkCompiler compiler, int level); bool silkcompilersetcheader(SilkCompiler compiler, SilkString path); silkcompilersetstdroot configures the filesystem stdlib root directory used to auto-load std::... packages when modules contain import std::...;. The stdroot string is copied. When set, it overrides SILKSTDROOT and the working-directory/default search behavior described below. silkcompilersetnostd disables this stdlib auto-loading behavior when set to true. When nostd is enabled, import std::...; declarations must be satisfied by explicitly adding the corresponding std sources as modules (for example via silkcompileraddsourcebuffer); the compiler will not consult SILKSTDROOT or the filesystem std root search paths. silkcompilersetdebug enables the same debug build mode as the CLI (silk --debug): debug-mode lowering for supported native outputs, and additional Z3 debug output plus .smt2 reproduction scripts on failing Formal Silk obligations (written under .silk/z3/ or $SILKWORKDIR/z3). silkcompilersetnoheap enables the same no-heap mode as the CLI (silk --noheap): heap-backed allocation is disabled for the supported subset. --noheap is currently incompatible with --debug; the ABI rejects configurations that enable both. silkcompilersettarget selects the code generation target. The targettriple string is copied. The initial implementation recognizes: linux-x8664 (default), and common x8664--linux- triples such as x8664-linux-gnu and x8664-unknown-linux-gnu, wasm32-unknown-unknown, wasm32-wasi (and other wasm32 triples containing wasi). For wasm32 targets, only SILKOUTPUTEXECUTABLE is supported. The output bytes are a final WebAssembly module (.wasm) produced by the IR-backed wasm backend (the implementation), with a smaller constant-only fallback for programs that fit the constant subset. The wasm backend is still early-stage, but it is no longer limited to single-module constant programs: Multi-module builds (packages + file imports) are supported. ext foo = fn (...) -> ...; declarations become imported functions under env.foo for wasm32-unknown-unknown, analogous to extern symbols in C. String and other constant data are emitted into wasm data segments. Entrypoint conventions: wasm32-unknown-unknown: when a valid executable main exists, it is exported as main for embedder use, when no main exists, an export-only module is emitted that exports each supported export fn from the root package. wasm32-wasi: requires fn main () -> int (the main(argc, argv) form is not supported yet for WASI), emits an exported start () -> void wrapper that calls main and then imports/calls WASI procexit, export-only modules are supported for embedding (export-only modules do not include start). silkcompileraddneededlibrary records a dynamic loader dependency for executable and shared library outputs (emitted as DTNEEDED). The soname string is copied; the function may be called multiple times (duplicates are ignored). For static library and object outputs, the value is ignored. DTNEEDED entries starting with libsilkrt are rejected: bundled runtime helpers are linked statically from libsilkrt.a / libsilkrtnoheap.a and must not become runtime loader dependencies. On linux/x8664 with the glibc dynamic loader (ld-linux), when an executable or shared library imports any external symbols, the compiler automatically adds libc.so.6 as a DTNEEDED dependency (so embedders do not need to manually add libc when using hosted std:: modules like std::io and std::fs). Additional non-libc dependencies must still be declared via silkcompileraddneededlibrary. silkcompileraddrunpath records a dynamic loader search path element for executable and shared library outputs (emitted as DTRUNPATH). The path string is copied; the function may be called multiple times (duplicates are ignored) and the final DTRUNPATH string is formed by joining all entries with ':'. silkcompilersetsoname configures the shared library soname recorded as DTSONAME for shared library outputs. The soname string is copied; passing an empty string clears the configured soname (no DTSONAME entry). For executable, static library, and object outputs, the value is ignored. silkcompilersetz3lib configures a Z3 dynamic library override for Formal Silk verification (equivalent to the CLI --z3-lib <path>). Passing an empty string clears the override and returns to the normal Z3 selection rules (including honoring SILKZ3LIB). silkcompilersetstdarchive configures a stdlib archive override (equivalent to the CLI --std-lib <path>). Passing an empty string clears the override and returns to the normal stdlib archive selection rules (including honoring SILKSTDLIB). silkcompilersetcheader configures C header generation for non-executable outputs (equivalent to the CLI --c-header <path>). The header is written when silkcompilerbuild succeeds for SILKOUTPUTOBJECT, SILKOUTPUTSTATICLIBRARY, or SILKOUTPUTSHAREDLIBRARY. C header generation is not supported for silkcompilerbuildtobytes. Source management: SilkModule silkcompileraddsourcebuffer(SilkCompiler compiler, SilkString name, SilkString contents); Building artifacts: bool silkcompilerbuild(SilkCompiler compiler, SilkOutputKind kind, SilkString outputpath); For embedders that need filesystem-free compilation (for example sandboxed hosts or WASM-like environments), the ABI also provides an in-memory build API that returns an owned byte buffer: bool silkcompilerbuildtobytes(SilkCompiler compiler, SilkOutputKind kind, SilkBytes outbytes); void silkbytesfree(SilkBytes bytes); The returned bytes are target-specific: for example an ELF64 binary on linux-x8664, or a .wasm module on wasm32 targets. Ownership rules: On success, silkcompilerbuildtobytes fills outbytes with a pointer and length describing the produced artifact, and returns true. The returned outbytes->ptr is owned by libsilk.a and must be freed by calling silkbytesfree(&bytes). Callers must not free the pointer with free() (or any other allocator). silkbytesfree is a no-op when passed NULL or when bytes->ptr is NULL; it always clears the struct to { NULL, 0 }. Note: the compiler may still consult the filesystem to auto-load std::... modules unless silkcompilersetnostd(compiler, true) has been set. At the current stage of implementation: silkcompilerbuild always performs full front\u2011end validation for all modules added via silkcompileraddsourcebuffer: it lexes and parses each module into an internal representation, it then type\u2011checks the set of modules as a unit, taking into account package/import relationships and exported constants, according to the language grammar and semantics documented under this specification, if Formal Silk syntax is present (for example #require, #assure, #assert, #invariant, #variant, #monovariant, #const), it also runs the Z3-backed verifier and fails the build if verification fails (E3001..E3008), the verifier is currently skipped for stdlib modules (std::...), on linux/x8664, Z3 is linked from the vendored static archive vendor/lib/x64-linux/libz3.a, the verifier honors SILKZ3LIB (environment variable) to override the Z3 dynamic library at runtime, it fails fast on the first front\u2011end error. when packages/imports are present: import declarations must refer to packages that exist in the current module set (otherwise a resolver error is reported, such as \"unknown imported package\"), exported let bindings with explicit type annotations in an imported package are treated as ordinary, unqualified names in the importing modules for type\u2011checking purposes (for example, import util; and export let answer: int = 42; in util allows let x: int = answer; in app), imported exported functions (export fn) are callable across packages for the current scalar subset (both unqualified foo() and qualified pkg::foo() call forms are accepted initially), and functions in the same package share a call namespace across modules in the same module set, duplicate exported names within a single package are reported as a resolver error (\"duplicate exported symbol\"). standard library import resolution (first slice): when a module contains import std::...;, the compiler will attempt to auto-load the referenced std::... package modules from a configured stdlib root so embedders do not need to provide std sources explicitly in the common case, the stdlib root is selected via: silkcompilersetstdroot when set, otherwise SILKSTDROOT (environment variable) when set, otherwise a std/ directory in the current working directory (development default), otherwise ../share/silk/std relative to the current executable (installed default). package-to-path mapping is deterministic: std::foo::bar resolves to the file <stdroot>/foo/bar.slk, if the embedder explicitly provides a std::... module via silkcompileraddsourcebuffer, that module is treated as authoritative for its package (auto-loading does not replace already-provided packages). standard library archive linking (linux/x8664, current archive layout): the toolchain can build a target-specific stdlib static archive (libsilkstd.a) containing one ELF object per std module (for example via make stdlib), for supported executable builds, the compiler treats auto-loaded std::... modules as external during code generation and resolves their exported functions from the archive when available (while still type-checking the std sources as part of the module set), archive discovery (in order): SILKSTDLIB when set, otherwise zig-out/lib/libsilkstd.a when using the in-repo std/ root, otherwise ../lib/libsilkstd.a relative to the current executable, otherwise common installed-layout heuristics derived from the selected stdlib root, walk up from the current working directory to find libsilkstd.a or lib/libsilkstd.a, when no suitable archive is found (or on unsupported targets), the compiler falls back to compiling the reachable std sources into the build as part of module-set code generation. When a front\u2011end error occurs (e.g. parse error, type mismatch, invalid control\u2011flow such as break/continue/return in the wrong context, or other semantic violations), the call returns false and silkcompilerlasterror/silkerrorformat provide a human\u2011readable description (such as \"unexpected token while parsing module\", \"type mismatch\", \"invalid break statement\", \"invalid return statement\", \"missing return statement\", etc.). For executable outputs (kind == SILKOUTPUTEXECUTABLE), the compiler also enforces an entrypoint precondition on the front\u2011end: there MUST be exactly one top\u2011level function fn main() -> int { ... } with no parameters and a declared result type of int, otherwise silkcompilerbuild fails with an error message such as \"no valid main function for executable output\" or \"multiple main functions for executable output\". When all modules pass front\u2011end validation (including the executable entrypoint requirement, where applicable), code generation behavior depends on kind: for non-executable outputs (SILKOUTPUTOBJECT, SILKOUTPUTSTATICLIBRARY, SILKOUTPUTSHAREDLIBRARY): main is optional, but when more than one valid executable main exists in the module set, silkcompilerbuild fails with \"multiple main functions for non-executable output\", when multiple packages are present in the module set, only exports from the root package (the package of the first module added to the compiler via silkcompileraddsourcebuffer) are emitted as globally-visible symbols for that output; other packages are compiled as dependencies and their export declarations are treated as internal for that output. within the current linux/x8664 IR subset, string and regexp values are supported at ABI boundaries in a C-friendly SilkString { ptr, len } layout: string/regexp parameters lower to two integer-like scalars in order (u64 pointer, then i64 byte length) and consume the normal integer argument locations (registers then stack), string/regexp results return as two integer-like scalars in rax/rdx, within function bodies, the compiler supports a small string/regexp expression subset: string: string literals, let bindings of string, return of a string value, direct calls to string-returning helpers, and ==/!=/</<=/>/>= comparisons over string values (producing bool), regexp: regex literals (/pattern/flags), let bindings of regexp, return of a regexp value, and direct calls between helpers that accept/return regexp, other string operations (concatenation, indexing, etc.) are not implemented yet; higher-level regex matching lives in std::regex and is routed through ext calls. within the current linux/x8664 IR subset, a limited struct subset is supported at ABI boundaries: within function bodies and internal helper calls, struct declarations with 0+ fields of supported value types are supported (scalar primitives, string, nested structs, and supported optionals), at ABI boundaries for exported/FFI functions, only ABI-safe structs are currently supported: after slot-flattening, all scalar slots must be i64/u64/f64 (until packed ABI mapping for smaller fields is implemented), at the C ABI surface, exported function parameters support 1+ slot ABI-safe structs by lowering the struct to its scalar slots in order; downstream C callers should declare separate parameters for 3+ slot structs (by-value C struct parameters are ABI-compatible only for the 1\u20132 slot cases), while exported function returns support 1+ slot ABI-safe structs (3+ slot returns use the native backend\u2019s sret return path and are ABI-compatible with returning an equivalent C struct by value), in all cases, the compiler lowers a struct value into N scalar slots in field order and assigns argument/result locations according to System V AMD64 integer/SSE classification for those slots. within the current linux/x8664 IR subset, optionals (T?) are supported at ABI boundaries for the supported payload subset (scalar payloads, string?, and optionals of ABI-safe structs): an optional lowers to a Bool tag followed by the payload scalar slots: (tag, payload0, payload1, ...) with tag=0 for None and tag=1 for Some(...), nested optionals (T??) lower by treating the payload slots as the full inner optional representation (for example int?? lowers as (tag0, tag1, i64 payload)), optional parameters are passed as these scalar slots in order (so downstream C callers should declare separate parameters, treating tag as an integer-like 0/1 value), optional results return as the same scalar slots (1\u20132 slots in registers; 3+ slots via a hidden sret pointer as described above). for object outputs (SILKOUTPUTOBJECT): on linux/x8664, the compiler can emit an ELF64 relocatable object (ETREL) for the supported IR subset, emitting supported functions (scalar-returning, void-returning, and a limited string subset) and supported exported constants (export let/export const; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit : string when the initializer is a string literal), and marking export fn declarations, supported exported constants, and a valid executable main (when present) as global symbols, when the module set contains no supported globally-visible symbols (no supported export fn, no supported export let constants, and no valid executable main), silkcompilerbuild still succeeds and writes a valid relocatable object with no globally-visible symbols, for programs outside that subset (or on unsupported targets), silkcompilerbuild returns false with an E4001 / E4002 formatted diagnostic (via silkcompilerlasterror / silkerrorformat) and does not write an output file. for static library outputs (SILKOUTPUTSTATICLIBRARY): on linux/x8664, the compiler can emit a static library archive (.a) containing an object file for the supported IR subset, emitting supported functions (scalar-returning, void-returning, and a limited string subset) and supported exported constants (export let/export const; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit : string when the initializer is a string literal), and marking export fn declarations, supported exported constants, and a valid executable main (when present) as global symbols, when the module set contains no supported globally-visible symbols (no supported export fn, no supported export let constants, and no valid executable main), silkcompilerbuild still succeeds and writes a valid archive containing an object file with no globally-visible symbols, for programs outside that subset (or on unsupported targets), silkcompilerbuild returns false with an E4001 / E4002 formatted diagnostic (via silkcompilerlasterror / silkerrorformat) and does not write an output file. for shared library outputs (SILKOUTPUTSHAREDLIBRARY): on linux/x8664, the compiler can emit an ELF64 shared library (ETDYN, typically with a .so filename) for the supported IR subset, emitting supported functions (scalar-returning, void-returning, and a limited string subset) and supported exported constants (export let/export const; scalar exports require an explicit type annotation and a literal initializer, and string exports may omit : string when the initializer is a string literal), and marking export fn declarations, supported exported constants, and a valid executable main (when present) as dynamic global symbols, when the module set contains no supported globally-visible symbols (no supported export fn, no supported export let constants, and no valid executable main), silkcompilerbuild still succeeds and writes a valid shared library with an empty export set, for programs outside that subset (or on unsupported targets), silkcompilerbuild returns false with an E4001 / E4002 formatted diagnostic (via silkcompilerlasterror / silkerrorformat) and does not write an output file. for executable outputs (SILKOUTPUTEXECUTABLE): the implementation supports a minimal constant\u2011expression backend: the program must satisfy the entrypoint rule above, the body of main must be one of the following shapes: zero or more let statements whose initializers are constant integer expressions, followed by exactly one return statement that returns a constant integer expression built only from: integer literals, the arithmetic operators +, -, , /, and %, and references to immutable let bindings (top\u2011level or local to main, or imported exported scalar constants from imported packages) whose initializers are themselves constant integer expressions in this same sense (no side\u2011effecting operations); imported exported constants must be declared as export let or export const with the shape export <binding> name: <scalar> = <literal>; (explicit scalar type and literal initializer), on linux/x8664, direct calls to simple helper functions of the form fn helper (x, y) -> int { [let ...;] return <expr>; } where: parameters may be annotated as scalar types (defaulting to int when unannotated), arguments at each call site are drawn from the same scalar expression subset as <expr> (including bool, char, Instant, Duration, fixed-width integers, and f32/f64 on linux/x8664), with optionals (T?) supported for scalar payloads, string?, and optionals of the POD struct subset via None / Some(...) and ?? coalescing, and in module-set builds, helper calls may target: functions defined in the same package (across multiple modules), and imported exported functions (export fn) from any packages imported by the module that contains main (both foo() and pkg::foo() call forms are accepted initially for imported exports), the helper body either: consists only of scalar let bindings and a final return, or ends in a simple if / else of the form: if <cond> { [let ...;] return <expr>; } else { [let ...;] return <expr>; } where <cond> is a boolean expression built from comparisons over scalar expressions and boolean literals, and both branches end in return; such calls are lowered to IR Call instructions and compiled to native code together with main, using the System V AMD64 scalar calling convention on linux/x8664 (integer-like scalars in rdi..r9, f32/f64 in xmm0..xmm7, with additional arguments spilled to the stack); helpers may have more than six integer parameters, and this path is exercised in both Zig tests and C tests (see the C ABI test harness), or a final if statement whose condition is a boolean expression: for the purely constant subset, the condition is a compile\u2011time boolean literal (true or false) and each branch body itself satisfies the same \u201cconstant lets + return constant integer expression\u201d rule, and on linux/x8664, a slightly richer branching main shape is also supported in which the body is exactly: fn main () -> int { if <cond> { [let ...;] return <expr>; } else { [let ...;] return <expr>; } } where <cond> is built from integer comparisons (==, !=, <, <=, >, >=) over integer expressions from the same constant subset; this shape is lowered to IR using BrCond and compiled to native code by the IR\u2192ELF backend so that the condition is evaluated at runtime, or one or more trivial constant while loops that appear before the final return, each of which has: a condition that is a compile\u2011time boolean literal (true or false), for while false { ... }, a body that is ignored by the constant backend, and for while true { ... }, a body consisting of zero or more constant let statements followed by a break;, with no other control\u2011flow; loop invariants (#invariant) and variants (#variant) may be present but are treated as metadata and do not affect constant evaluation, examples of supported forms include: fn main() -> int { return 0; } fn main() -> int { return 1; } fn main() -> int { return 1 + 2 3; } let answer: int = 21 2; fn main() -> int { return answer; } // Two-module imported constant example (module-set builds only): // // util.slk package util; export let answer: int = 42; // // app.slk package app; import util; fn main () -> int { return answer; } // Two-module imported function example (module-set builds only): // // util.slk package util; export fn add (x: int, y: int) -> int { return x + y; } // // app.slk package app; import util; fn main () -> int { return add(40, 2); } fn main () -> int { let a: int = 21; let b: int = a 2; return b; } fn main () -> int { if true { return 0; } else { return 1; } } fn main () -> int { while true { break; } return 0; } when these conditions hold and outputpath names a valid path, silkcompilerbuild: evaluates the constant integer expression in the body of main, emits a tiny native executable image directly using a Silk\u2011owned backend (no C stub, no external C compiler), currently this backend writes a minimal ELF64 executable for linux/x8664 whose entrypoint immediately performs a sysexit(value) system call, returns true on success with no last error recorded. when the program is front\u2011end valid but outside this subset (e.g. main contains non\u2011constant expressions, references to non\u2011constant values, or calls that fall outside the simple helper\u2011call subset described above), or when the backend cannot produce an executable for the current platform or output path, the call returns false and records either an E4001 / E4002 diagnostic (for unsupported constructs or backend failures) or a descriptive string for I/O/argument errors as the last error. Error reporting: SilkError silkcompilerlasterror(SilkCompiler compiler); sizet silkerrorformat(const SilkError error, char buffer, sizet bufferlen); silkerrorformat returns a human-readable diagnostic message. When the compiler can associate the error with a source span, the formatted message includes the module name/path plus line/column and a caret snippet. The text format and initial stable error code set are specified in Compiler Diagnostics. Embedders should treat the formatted message as user-facing text (not a stable machine-readable protocol). Ownership, lifetime, and thread-safety guarantees for these APIs must be clearly documented and kept in sync with the implementation. ABI rules: All exposed functions must be C99-compatible. Data layouts must be stable and match the Silk side. Ownership and lifetime of any pointers passed across the boundary must be explicitly documented. In addition, the embedding ABI must clearly distinguish: functions that consume Silk\u2011owned values (e.g. SilkString whose storage is owned by the runtime) versus functions that take ownership of data supplied by the embedder (and are responsible for freeing it via documented APIs). Any deviation from the mappings documented in External Declarations (ext) must be justified here and reflected in tests. See Also libsilk (7) \u2014 C99 ABI manpage for embedders. silk.h` \u2014 public C header shipped with the library."
    }
  ]
}
